<div class="post__text post__text-html js-mediator-article">  The C ++ 20 standard will appear soon, in which, most likely, they will add the concept of intervals ( <i>ranges</i> ), but few know what they are and what they eat.  I couldn’t find the Russian-speaking sources available to a wide audience about this beast, so in this article I would like to tell you more about it based on the lecture by Arno Schödl <a href="https://www.youtube.com/watch%3Fv%3DvrCtS6FDay8">“From Iterators to Ranges: The Upcoming Evolution Of the STL”</a> from Meeting C ++ 2015- th year.  I will try to make this article as clear as possible for those who first come across this concept, and at the same time I will talk about all sorts of chips like interval adapters for those who are already familiar with this concept and want to learn more. <br><br><h2>  Libraries with ranges </h2><br>  At the time of this writing, there are three main libraries that implement the intervals: <br><br><ul><li>  <a href="https://www.boost.org/doc/libs/1_67_0/libs/range/doc/html/index.html">Boost.Range</a> </li><li>  <a href="https://github.com/ericniebler/range-v3">Range v3</a> </li><li>  <a href="https://github.com/think-cell/range">think-cell public library</a> </li></ul><br>  The first library, in fact, is the progenitor of this concept (which is not surprising, after all, what is missing in the <a href="https://www.boost.org/">Boost</a> library collection :)).  The second is the Eric Niebler Library, which will be discussed later.  And finally, the latest library, as you might guess, was written by the company think-cell, which can be said to have developed and improved Boost.Range. <br><a name="habracut"></a><br><h2>  Why are intervals our future? </h2><br>  For those who are not familiar with the concept of interval, we define this non-trivial concept as something that has a beginning and an end (a <u>pair of iterators</u> ). <br><br>  Let's now consider the following problem: there is a vector, it is necessary to remove from it all repeating elements.  Under the current standard, we would solve it like this: <br><br><pre><code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; vec=...; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort( vec.begin(), vec.end() ); vec.erase( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique( vec.begin(), vec.end() ), vec.end() );</code> </pre> <br>  In this case, we specify the name of the vector as much as <b>6</b> times!  However, using the concept of intervals (by combining iterators at the beginning and end of a vector into one object), you can write many times simpler by specifying the desired vector only <b>once</b> : <br><br><pre> <code class="cpp hljs">tc::unique_inplace( tc::sort(vec) );</code> </pre> <br><h2>  What is the interval at the moment within the current standard? </h2><br>  In the C ++ 11 standard, a range-based for loop and universal access to the beginning / end of containers was added, and in the last C ++ 17 standard, nothing new was added at intervals. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp; i : &lt;range_expression&gt; ) { ... }</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::begin/end(&lt;range_expression&gt;)</code> </pre> <br><h2>  Future intervals </h2><br>  Let us now dwell on the previously mentioned library Range V3.  Erik Nibler, her creator, created the <i>Range's Technical Specification</i> as his home project, modifying the <i>algorithm</i> library to support the intervals.  It looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> ranges { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Rng, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> What &gt; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>) find( Rng &amp;&amp; rng, What <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; what ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::find( ranges::begin(rng), ranges::end(rng), what ); } }</code> </pre> <br>  On his website there is some kind of preview of what he wants to standardize, this is the <i>Range V3</i> . <br><br><h2>  What, after all, can range be considered? </h2><br>  First of all, <i>containers</i> (vector, string, list, etc.), because they have a beginning and an end.  It is clear that containers own their elements, that is, when we turn to containers, we turn to all their elements.  Similarly, when copying and declaring permanent (deep copying and constancy).  <i>Secondarily</i> , <i>views</i> can also be considered as intervals.  Views is just a pair of iterators pointing to the beginning and the end, respectively.  Here is their simplest implementation: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> It&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator_range</span></span></span><span class="hljs-class"> {</span></span> It m_itBegin; It m_itEnd; <span class="hljs-function"><span class="hljs-function">It </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">begin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_itBegin; } <span class="hljs-function"><span class="hljs-function">It </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_itEnd; } };</code> </pre> <br>  Views, in turn, only refer to the elements, so copying and constancy are lazy (this does not affect the elements). <br><br><h2>  Interval adapters </h2><br>  At this, the inventors of the intervals did not dwell, because otherwise this concept would be quite useless.  Therefore, they introduced such a thing as range adapters. <br><br><h3>  Transformer adapter </h3><br>  Consider the following problem: Let the vector <i>int</i> 's be given, in which you need to find the first element equal to 4: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = ranges::find(v, <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre><br>  Now let's imagine that the type of the vector is not int, but some kind of complex self-written structure, but in which there is an int, and the task is still the same: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> data; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;A&gt; v={...}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = ranges::find_if( v, [](A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; a) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.id == <span class="hljs-number"><span class="hljs-number">4</span></span>; } );</code> </pre> <br>  It is clear that these two codes are similar in semantics, however, they differ significantly in syntax, because in the latter case we had to manually write a function that runs through the <i>int</i> field.  But if you use a transforming adapter ( <i>transform adapter</i> ), then everything looks much more succinctly: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> data; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;A&gt; v={...}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = ranges::find( tc::transform(v, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mem_fn(&amp;A::id)), <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre><br>  In fact, the transforming adapter “transforms” our structure by creating a wrapper class around the int field.  It is clear that the pointer points to the <i>id</i> field, but if we wanted it to point to the whole structure, then we need to add <i>.base ()</i> at the end.  This command encapsulates a field, which is why the pointer can run through the entire structure: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = ranges::find( tc::transform(v, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mem_fn(&amp;A::id)), <span class="hljs-number"><span class="hljs-number">4</span></span>).base();</code> </pre><br>  Here is an example implementation of a transforming adapter (it consists of iterators, each of which has its own functor): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">transform_range</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Func m_func; <span class="hljs-comment"><span class="hljs-comment">// в каждом итераторе decltype( tc::begin(std::declval&lt;Base&amp;&gt;()) ) m_it; public: decltype(auto) operator*() const { return m_func(*m_it); } decltype(auto) base() const { return (m_it); } ... }; };</span></span></code> </pre><br><h3>  Filter adapter </h3><br>  And if in the last task we needed to find not the first such element, but to “filter” the <b>entire</b> field of <i>int</i> 's for the presence of such elements?  In this case, we would use a filter adapter: <br><br><pre> <code class="cpp hljs">tc::filter( v, [](A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; a) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> == a.id; } );</code> </pre><br>  Note that the filter is performed lazily during iterations. <br><br>  But its naive implementation (something like this is implemented in Boost.Range): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">filter_range</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Func m_func; <span class="hljs-comment"><span class="hljs-comment">// функтор и ДВА итератора decltype( ranges::begin(std::declval&lt;Base&amp;&gt;()) ) m_it; decltype( ranges::begin(std::declval&lt;Base&amp;&gt;()) ) m_itEnd; public: iterator&amp; operator++() { ++m_it; while( m_it != m_itEnd &amp;&amp; !static_cast&lt;bool&gt;(m_func(*m_it)) ) ++m_it; return *this; } ... }; };</span></span></code> </pre><br>  As we can see, it already requires two iterators instead of one, as it was in the transforming adapter.  The second iterator is necessary in order not to accidentally overstep the bounds of the container during iterations. <br><br><h2>  Some optimizations </h2><br>  Well, what does the iterator from <b>tc :: filter (tc :: filter (tc :: filter (...)))</b> look like? <br><br><h3>  Boost.Range </h3><br>  As part of the implementation above, it looks like this: <br><br><div class="spoiler">  <b class="spoiler_title">Not to look nervous!</b> <div class="spoiler_text"> <code>m_func3 <br> m_it3 <br> m_func2 <br> m_it2 <br> m_func1 <br> m_it1; <br> m_itEnd1; <br> m_itEnd2 <br> m_func1 <br> m_it1; <br> m_itEnd1; <br> m_itEnd3 <br> m_func2 <br> m_it2 <br> m_func1 <br> m_it1; <br> m_itEnd1; <br> m_itEnd2 <br> m_func1 <br> m_it1; <br> m_itEnd1; <br></code> <br></div></div><br>  Obviously, it is <u>terribly</u> inefficient. <br><br><h3>  Range v3 </h3><br>  Let's think about how to optimize this adapter.  The idea of ​​Eric Nibler was that we should put general information (a functor and a pointer to the end) into an adapter object, and then we can store a link to this adapter object and the desired iterator <br> <code>*m_rng <br> m_it <br></code> <br>  Then, as part of this implementation, the triple filter will look something like this: <br><br><div class="spoiler">  <b class="spoiler_title">Tyk</b> <div class="spoiler_text"> <code>m_rng3 <br> m_it3 <br> m_rng2 <br> m_it2 <br> m_rng1 <br> m_it1 <br></code> <br></div></div><br>  This is still not perfect, although at times faster than the previous implementation. <br><br><h3>  think-cell index concept </h3><br>  Now consider the solution of the company think-cell.  They introduced the so-called concept of indexes ( <i>index concept</i> ) to solve this problem.  An index is an iterator that performs all the same operations as a regular iterator, but does so by referring to intervals. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">index_range</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Index = ...; <span class="hljs-function"><span class="hljs-function">Index </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">begin_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Index </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Index&amp; idx )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decrement_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Index&amp; idx )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">reference </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dereference</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Index&amp; idx )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; ... };</code> </pre><br>  We show how you can combine an index with a regular iterator. <br><br>  It is clear that a regular iterator can also be considered an index.  In the opposite direction, compatibility can be implemented for example: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> IndexRng&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator_for_index</span></span></span><span class="hljs-class"> {</span></span> IndexRng* m_rng; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> IndexRng::Index m_idx; iterator&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>++() { m_rng.increment_index(m_idx); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } ... };</code> </pre><br>  Then the triple filter will be implemented super-efficiently: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">filter_range</span></span></span><span class="hljs-class"> {</span></span> Func m_func; Base&amp; m_base; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Index = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base::Index; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Index&amp; idx )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { m_base.increment_index(idx); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( idx != m_base.end_index() &amp;&amp; !m_func(m_base.dereference_index(idx)) ); } };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> IndexRng&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator_for_index</span></span></span><span class="hljs-class"> {</span></span> IndexRng* m_rng; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> IndexRng::Index m_idx; ... };</code> </pre><br>  As part of this implementation, the algorithm will work quickly regardless of the depth of the filter. <br><br><h2>  Intervals with lvalue and rvalue containers </h2><br>  Now let's see how the intervals work with lvalue and rvalue containers: <br><br><h3>  lvalue </h3><br>  Range V3 and think-cell behave the same with lvalue.  Suppose we have this code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> rng = view::filter(vec, pred1); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = ranges::any_of(rng, pred2);</code> </pre><br>  Here we have a pre-declared vector that lies in memory (lvalue), and we need to create an interval and then somehow work with it.  We create a view using <i>view :: filter</i> or <i>tc :: filter</i> and become happy, there are no errors, and we can use this view, for example, in any_of. <br><br><h3>  Range V3 and rvalue </h3><br>  However, if our vector had not yet been remembered (for example, if we only created it), and we would have the same task, then we would try to write and faced with an error: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> rng = view::filter(create_vector(), pred1); <span class="hljs-comment"><span class="hljs-comment">// не скомпилируется bool b = ranges::any_of(rng, pred2);</span></span></code> </pre><br>  Why did it arise?  View will be a hanging link to rvalue due to the fact that we create a vector and directly put in the filter, that is, the filter will have an rvalue link, which will then point to something unknown when the compiler goes to the next line and an error occurs.  In order to solve this problem, in Range V3 came up with an <i>action</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> rng = action::filter(create_vector(), pred1); <span class="hljs-comment"><span class="hljs-comment">// теперь скомпилируется bool b = ranges::any_of(rng, pred2);</span></span></code> </pre> <br>  Action does everything at once, that is, it simply takes a vector, filters it by predicate and puts it in the interval.  However, the disadvantage is that it is no longer lazy, and think-cell tried to correct this minus. <br><br><h3>  think-cell and rvalue </h3><br>  Think-cell made it so that instead of view a container is created there: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> rng = tc::filter(creates_vector(), pred1); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = ranges::any_of(rng, pred2);</code> </pre><br>  As a result, we do not encounter a similar error, because in their implementation the filter collects the rvalue container instead of the link, so this happens lazily.  In Range V3, they didn’t want to do that, because they were afraid that there would be errors due to the fact that the filter behaves either as a view or as a container, but the think-cell is convinced that programmers understand how the filter behaves, and most of the errors arise precisely because of this "laziness." <br><br><h2>  Generator intervals </h2><br>  Let us generalize the concept of intervals.  In fact, there are intervals without iterators.  They are called <i>generator ranges</i> .  Suppose we have a GUI widget (interface element), and we call the move widget.  We have a window that asks to move its widget, we also have a button in the <i>list box</i> , and another window should also flip through its widgets, that is, we call <i>traverse_widgets</i> , which connects the elements to the functor ( <i>you can say, there is an enumeration function where you connect the functor, and the function lists in this functor all the elements that it has</i> ). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traverse_widgets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Func func )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (window1) { window1-&gt;traverse_widgets(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ref(func)); } func(button1); func(listbox1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (window2) { window2-&gt;traverse_widgets(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ref(func)); } }</code> </pre><br>  This is somewhat similar to the interval of widgets, but there are no iterators here.  Writing them directly would be inefficient and, above all, very difficult.  In this case, we can say that such constructions are also considered as intervals.  Then for such cases the use of useful interval methods takes place, such as <i>any_of</i> : <br><br><pre> <code class="cpp hljs">mouse_hit_any_widget=tc::any_of( [] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> func) { traverse_widgets(func); }, [] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; widget) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> widget.mouse_hit(); } );</code> </pre><br>  think-cell tries to implement the methods so that they have the same interface for all types of intervals: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> tc { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Rng &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any_of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Rng </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; rng )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> bResult = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; tc::enumerate( rng, [&amp;](bool_context b) { bResult = bResult || b; } ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bResult; } }</code> </pre><br>  Using <i>tc :: enumerate</i> , the difference between the intervals is hidden, since such an implementation adheres to the concept of <i>internal iteration</i> (what the concepts of <i>external</i> and <i>internal iteration</i> are described in more detail in the lecture), however, such an implementation has its drawbacks, namely <i>std :: any_of</i> stops as soon as <i>true</i> is encountered.  They try to solve this problem, for example, by adding exceptions (the so-called <i>interrupted generator intervals</i> ). <br><br><h2>  Conclusion </h2><br>  I hate the range-based for loop, because it motivates people to write it wherever it is needed and where it is not needed, because of which the brevity of the code often worsens, for example, people write this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n : rng) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( is_prime(n) ) { b = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre><br>  instead of this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = tc::any_of( rng, is_prime );</code> </pre> </div>