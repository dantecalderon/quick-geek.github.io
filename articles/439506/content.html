<div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/986/ab5/0b3/986ab50b34cc8a3453a622333411cc46.png" alt="image"><br><br><h3>  What is it and why? </h3><br>  When designing, a developer may encounter a problem: creatures and objects may have different abilities in different combinations.  Frogs jump and swim, ducks swim and fly, but not with a weight, and frogs can fly with a branch and ducks.  Therefore, it is convenient to move from inheritance to composition and add capabilities dynamically.  The need to animate the flying frogs led to an unjustified abandonment of the ability methods and bringing their code to the teams in one of the implementations.  Here she is: <a name="habracut"></a><br><br><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CastSpellCommand</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Command</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span> (source, target, spell) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.source = source; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.target = target; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.spell = spell; } execute () { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> spellAbility = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.source.getAbility(SpellCastAbility); <span class="hljs-comment"><span class="hljs-comment">// может быть много совершенно разных if (!cond) return error if (spellAbility == null) { throw new Error('NoSpellCastAbility'); } this.addChildren(new PayManaCommand(this.source, this.spell.manaCost)); this.addChildren(this.spell.getCommands(this.source, this.target)); // из другой команды: healthAbility.health = Math.max( 0, resultHealth ); } } // отрисовка: async onMeleeHit (meleeHitCommand) { await view.drawMeleeHit( meleeHitCommand.source, meleeHitCommand.target ); } async onDealDamage (dealDamageCommand) { await view.showDamageNumbers( dealDamageCommand.target, dealDamageCommand.damage ); }</span></span></code> </pre> <br><h3>  What can be done? </h3><br>  Consider several approaches of different nature: <br><br><h4>  Observer </h4><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Executor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Observer</span></span></span><span class="hljs-class"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animator</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Observer</span></span></span><span class="hljs-class"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>}</code> </pre><br>  The classic, well-known solution for programmers.  You only need to change it as little as possible to check the values ​​returned by observers: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listeners.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result, listener</span></span></span><span class="hljs-function">) =&gt;</span></span> result &amp;&amp; listener(action), <span class="hljs-literal"><span class="hljs-literal">true</span></span>)</code> </pre> <br>  Disadvantage: Observers must subscribe to events in the correct order. <br><br>  If you do error handling, the animator will also be able to show animations of failed actions.  You can pass the previous value to the observers, conceptually the solution remains the same.  Whether observer methods or callback functions are called, whether a normal cycle is used instead of convolution - the details are not so significant. <br><br><h4>  Leave as is </h4><br>  And in fact.  The current approach has both disadvantages and advantages: <br><br><ol><li>  Verifying the ability to execute a command requires the execution of a command </li><li>  Arguments in varying order, conditions, method prefixes are hard-wired. </li><li>  Cyclic dependencies (command &lt;spell &lt;command) </li><li>  Additional entities for each action (method replaced by method, class and its constructor) </li><li>  Excessive knowledge and actions of a separate team: from game mechanics to timing errors and direct manipulation of other people's properties </li><li>  The interface is misleading (execute not only causes, but also adds commands via addChildren; which obviously does the opposite) </li><li>  Dubious need and implementation of recursive commands as such </li><li>  The dispatcher class, if any, does not perform its functions. </li><li>  [+] Allegedly, the only way to animate in practice, if the animation needs complete data (indicated as the main reason) </li><li>  [+] Probably other reasons. </li></ol><br>  Some of the shortcomings can be dealt with separately, but the rest require more fundamental changes. <br><br><h4>  ad hoc </h4><br><ul><li>  The conditions for the execution of the team, especially the game mechanics, must be removed from the teams and drawn up separately.  Conditions can change in runtime, and the selection of inactive buttons in gray is encountered in practice long before the work on the animation begins, not to mention the logic.  To avoid copying, it may make sense to store general conditions in prototype abilities. </li><li>  Return methods, in combination with the previous item, there is no need for such checks: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> spellAbility = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.source.getAbility(SpellCastAbility); <span class="hljs-comment"><span class="hljs-comment">// может быть много совершенно разных if (!cond) return error if (spellAbility == null) { throw new Error('NoSpellCastAbility'); }</span></span></code> </pre> <br>  The Javascript engine itself will show the correct TypeError when an error method is called. </li><li>  The team also does not need such knowledge: <br><br><pre> <code class="javascript hljs">healthAbility.health = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.max( <span class="hljs-number"><span class="hljs-number">0</span></span>, resultHealth );</code> </pre> </li><li>  To solve the problem of arguments that change places, they can be passed to the object. </li><li>  Although the calling code is not available for study, it seems that most of the drawbacks are due to the non-optimal way of invoking game actions.  For example, button handlers refer to some specific entities.  Therefore, replacing them in the handlers with specific commands seems quite natural.  If there is a dispatcher, it is much simpler to call animation after the action; you can transfer the same information to it, so there will be no lack of data. </li></ul><br><h4>  Turn </h4><br>  To show the animation of the action after the execution of the action, it is enough to add them to the queue and run something like in solution 1. <br><br><pre> <code class="javascript hljs">[ [ walkRequirements, walkAction, walkAnimation ], [ castRequirements, castAction, castAnimation ], <span class="hljs-comment"><span class="hljs-comment">// ... ]</span></span></code> </pre> <br>  It does not matter which entities lie in the array: functions booted with the necessary parameters, instances of user-defined classes or ordinary objects. <br>  The value of such a decision is simplicity and transparency; it is easy to make a sliding window for viewing the last N commands. <br><br>  Good for prototyping and debugging. <br><br><h4>  Doubler class </h4><br>  Making an animation class for ability. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MovementAbility</span></span></span><span class="hljs-class"> </span></span>{ walk (...args) { <span class="hljs-comment"><span class="hljs-comment">// action } } class AnimatedMovementAbility { walk (...args) { // animation } }</span></span></code> </pre><br>  If you cannot make changes to the calling class, inherit from it or decorate the desired method so that it invokes an animation.  Or we transfer animation instead of ability, they have the same interface. <br><br>  Well suited when you actually need the same set of methods, you can automatically check and test them. <br><br><h4>  Combinations of methods </h4><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AnimatedMovementAbility = combinedClass(MovementAbility, { [<span class="hljs-string"><span class="hljs-string">'*:before'</span></span>] (method, ...args) { <span class="hljs-comment"><span class="hljs-comment">// call requirements }, ['*:after'] (method, ...args) { // call animations } })</span></span></code> </pre> <br>  It would be an interesting opportunity with native language support. <br>  It is good to use if this option turns out more productive, although a proxy is actually needed. <br><br><h4>  Proxy </h4><br>  Wrapping abilities in proxies, catching methods in the getter. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Proxy</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MovementAbility, {<span class="hljs-comment"><span class="hljs-comment">/* handler */</span></span>})</code> </pre> <br>  Disadvantage: many times slower than normal calls, which is not so significant for animation.  On a server processing millions of objects, a slowdown would be noticeable, but no animation is needed on the server. <br><br><h4>  Promise </h4><br>  You can construct chains from Promise, but there is another option (ES2018): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> action <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> actionDispatcher.getActions()) { <span class="hljs-comment"><span class="hljs-comment">// }</span></span></code> </pre> <br>  getActions returns an asynchronous iterator over an action.  The next iterator method returns the Deferred Promise of the next action.  After processing the events from the user and the server, call resolve (), create a new promise. <br><br><h4>  Better team </h4><br>  Create objects like this: <br><br><pre> <code class="javascript hljs">{actor, ability, method, options}</code> </pre> <br>  The code comes down to checking and calling the ability method with parameters.  The easiest and most productive option. <br><br><h4>  Note </h4><br><ul><li>  <a href="https://habr.com/ru/post/438510/">Sample command source</a> </li></ul></div>