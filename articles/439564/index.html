<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Practical application of transformation of AST-trees on the example of Putout</title>
  <meta name="description" content="Introduction 


 Every day when working on the code, on the way to implementing useful functionality for the user, there are forced (inevitable, or si...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Practical application of transformation of AST-trees on the example of Putout</h1><div class="post__text post__text-html js-mediator-article"><h2 id="vvedenie">  Introduction </h2><br><p>  Every day when working on the code, on the way to implementing useful functionality for the user, there are forced (inevitable, or simply desirable) changes to the code.  This may be refactoring, updating a library or framework to a new major version, updating JavaScript syntax (which is not uncommon recently).  Even if the library is part of a working draft - changes are inevitable.  Most of these changes are routine.  There is nothing interesting for the developer on the one hand, on the other it does not bring anything to the business, and on the third, in the update process, you need to be very careful not to break the wood and break the functionality.  Thus, we come to the conclusion that it is better to shift such a routine onto the shoulders of the programs, what would they all do themselves, and the person, in turn, would control whether everything was properly done.  That is what this article is about. </p><a name="habracut"></a><br><h2 id="ast">  AST </h2><br><p>  For programmatic processing of the code, it is necessary to translate it into a special presentation with which it would be convenient for the programs to work.  Such a representation exists, it is called <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25B1%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2581%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B0%25D0%25BA%25D1%2581%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">Abstract Syntax Tree</a> (AST). <br>  In order to get it, use parsers.  The resulting AST can be transformed as you like, and then to save the result you need a code generator.  Let us consider in more detail each of the steps.  Let's start with the parser. </p><br><h3 id="parser">  Parser </h3><br><p>  And so we have the code: </p><br><pre><code class="javascript hljs">a + b</code> </pre> <br><p>  Usually parsers are divided into two parts: </p><br><ul><li>  Lexical analysis </li></ul><br><p>  Splits the code into tokens, each of which describes a part of the code: </p><br><pre> <code class="json hljs">[{ <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"Identifier"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">"a"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"Punctuator"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">"+"</span></span>, }, { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"Identifier"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">"b"</span></span> }]</code> </pre> <br><ul><li>  Syntax analysis. </li></ul><br><p>  Builds a syntax tree of tokens: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"BinaryExpression"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"left"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"Identifier"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"a"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"operator"</span></span>: <span class="hljs-string"><span class="hljs-string">"+"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"right"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"Identifier"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"b"</span></span> } }</code> </pre> <br><p>  And here we already have the very idea with which you can work programmatically.  It should be clarified that there are a large number of <code>JavaScript</code> parsers, here are some of them: </p><br><ul><li>  <a href="https://babeljs.io/docs/en/babel-parser">babel-parser</a> - a parser that uses <code>babel</code> ; </li><li>  <a href="https://github.com/eslint/espree">espree</a> - a parser that uses <code>eslint</code> ; </li><li>  <a href="https://github.com/acornjs/acorn">acorn</a> is the parser on which the previous two are based; </li><li>  <a href="https://github.com/jquery/esprima">esprima</a> is a popular parser that supports JavaScript up to EcmaScript 2017; </li><li>  <a href="https://github.com/cherow/cherow">cherow</a> is a new player among JavaScript parsers, claiming to be the fastest; </li></ul><br><p>  There is a standard JavaScript parsers, it is called <a href="https://github.com/estree/estree">ESTree</a> and determines which nodes should parse as it should. <br>  For a more detailed analysis of the implementation process of the parser (as well as the transformer and generator), you can read <a href="https://github.com/jamiebuilds/the-super-tiny-compiler">super-tiny-compiler</a> . </p><br><h3 id="transformator">  Transformer </h3><br><p>  In order to convert an AST tree, you can use the <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D1%2581%25D0%25B5%25D1%2582%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">Visitor</a> pattern, for example, using the <a href="https://babeljs.io/docs/en/babel-traverse">@ babel / traverse</a> library.  The following code will output the names of all the JavaScript code identifiers from the <code>code</code> variable. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> parser <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@babel/parser"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> traverse <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@babel/traverse"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> code = <span class="hljs-string"><span class="hljs-string">`function square(n) { return n * n; }`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ast = parser.parse(code); traverse(ast, { Identifier(path) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(path.node.name); } });</code> </pre> <br><h3 id="generator">  Generator </h3><br><p>  You can generate code, for example, using <a href="https://babeljs.io/docs/en/babel-generator">@ babel / generator</a> , thus: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {parse} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@babel/parser'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> generate <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@babel/generator'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> code = <span class="hljs-string"><span class="hljs-string">'class Example {}'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ast = parse(code); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> output = generate(ast, code);</code> </pre> <br><p>  And so, at this stage, the reader had to get a basic idea of ‚Äã‚Äãwhat is needed to transform JavaScript code, and with what tools this is implemented. </p><br><p>  It is <a href="https://astexplorer.net/">necessary to</a> add such an online tool as <a href="https://astexplorer.net/">astexplorer</a> , it combines a large number of parsers, transformers and generators. </p><br><h2 id="putout">  Putout </h2><br><p>  <a href="https://github.com/coderaiser/putout">Putout</a> is a code transformer with plug-in support.  In fact, it is a cross between <a href="https://eslint.org/">eslint</a> and <a href="https://babeljs.io/">babel</a> , combining the advantages of both tools. </p><br><p>  As <code>eslint</code> <code>putout</code> shows problem areas in the code, but unlike <code>eslint</code> <code>putout</code> changes the behavior of the code, that is, it is able to correct all errors that it can find. </p><br><p>  Like <code>babel</code> <code>putout</code> transforms the code, but tries to change it as little as possible, so it can be used to work with code that is stored in the repository. </p><br><p>  Another <a href="https://prettier.io/">thing</a> worth mentioning is the <a href="https://prettier.io/">prettier</a> , it is a formatting tool, and it differs radically. </p><br><p>  <a href="https://github.com/facebook/jscodeshift">Jscodeshift</a> is not very far from <code>putout</code> , but it does not support plugins, does not show error messages, and also uses <a href="https://github.com/benjamn/ast-types">ast-types</a> instead of <a href="https://babeljs.io/docs/en/babel-types">@ babel / types</a> . </p><br><h3 id="istoriya-poyavleniya">  Appearance history </h3><br><p>  In the process of work, <code>eslint</code> helps me a lot with my hints.  But sometimes you want more from him.  For example, what would he <a href="https://github.com/eslint/eslint/issues/10242">remove the debugger</a> , <a href="https://github.com/atabel/eslint-plugin-tape/pull/3">fix test.only</a> , and also delete unused variables.  The last point formed the basis of <code>putout</code> , in the development process, it became clear that this is not very simple and many other transformations are much easier to implement.  Thus, <code>putout</code> smoothly evolved from one function to a plugin system.  Removing unused variables is still the most difficult process, but it doesn‚Äôt interfere with the development and maintenance of many other equally useful transformations. </p><br><h3 id="kak-putout-ustroen-iznutri">  How Putout Works from the Inside </h3><br><p>  Work <code>putout</code> can be divided into two parts: the engine and plugins.  This architecture allows you to not be distracted by the transformation when working with the engine, and when working on plug-ins you will focus on their purpose. </p><br><h4 id="vstroennye-plaginy">  Built-in plugins </h4><br><p>  The work <code>putout</code> is built on the plugin system.  Each plugin represents one rule.  Using the built-in rules, you can do the following: </p><br><ul><li><p>  Find and remove: </p><br><ul><li>  unused variables </li><li> <code>debugger</code> </li> <li>  call <code>test.only</code> </li><li>  call <code>test.skip</code> </li><li>  call <code>console.log</code> </li><li>  call <code>process.exit</code> </li><li>  empty blocks </li><li>  empty patterns </li></ul><br></li><li><p>  Find and split variable declarations: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// –±—ã–ª–æ var one, two; // —Å—Ç–∞–Ω–µ—Ç var one; var two;</span></span></code> </pre> <br></li><li><p>  Convert <code>esm</code> to <code>commonjs</code> : </p><br></li></ul><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">// –±—ã–ª–æ import one from 'one'; // —Å—Ç–∞–Ω–µ—Ç const one = require('one');</span></span></code> </pre> <br><ul><li>  Apply destructuring: </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// –±—ã–ª–æ const name = user.name; // —Å—Ç–∞–Ω–µ—Ç const {name} = user;</span></span></code> </pre> <br><ol><li>  Combine unstructure properties: </li></ol><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// –±—ã–ª–æ const {name} = user; const {password} = user; // —Å—Ç–∞–Ω–µ—Ç const { name, password } = user;</span></span></code> </pre> <br><p>  Each plug-in is built according to the <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B8%25D0%25BB%25D0%25BE%25D1%2581%25D0%25BE%25D1%2584%25D0%25B8%25D1%258F_Unix">Unix Philosophy</a> , that is, they are as simple as possible, each performs one action, making them easy to combine, because they, in essence, are filters. </p><br><p>  For example, having the following code: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> name = user.name; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> password = user.password;</code> </pre> <br><p>  It is first converted into the following using <a href="https://github.com/coderaiser/putout/tree/master/packages/plugin-apply-destructuring">apply-destructuring</a> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {name} = user; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {password} = user;</code> </pre> <br><p>  After that, using <a href="https://github.com/coderaiser/putout/tree/master/packages/plugin-merge-destructuring-properties">merge-destructuring-properties is</a> converted to: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { name, password } = user;</code> </pre> <br><p>  Thus, plug-ins can work both separately and together.  When creating your own plugins, it is recommended to adhere to this rule, and implement a plug-in with minimal functionality that does only what you need, and the plug-in and user plug-ins take care of the rest. </p><br><h4 id="primer-ispolzovaniya">  Usage example </h4><br><p>  After we have familiarized ourselves with the built-in rules, we can consider an example of using <code>putout</code> . <br>  Create an <code>example.js</code> file with the following contents: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>, y = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> name = user.name; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> password = user.password; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name, password);</code> </pre> <br><p>  Now, run <code>putout</code> , passing <code>example.js</code> as an argument: </p><br><pre> <code class="plaintext hljs">coderaiser@cloudcmd:~/example$ putout example.js /home/coderaiser/example/example.js 1:6 error "x" is defined but never used remove-unused-variables 1:13 error "y" is defined but never used remove-unused-variables 6:0 error Unexpected "console" call remove-console 1:0 error variables should be declared separately split-variable-declarations 3:6 error Object destructuring should be used apply-destructuring 4:6 error Object destructuring should be used apply-destructuring 6 errors in 1 files fixable with the `--fix` option</code> </pre> <br><p>  We will receive information containing 6 errors, discussed in more detail above, now we will correct them, and see what happened: </p><br><pre> <code class="plaintext hljs">coderaiser@cloudcmd:~/example$ putout example.js --fix coderaiser@cloudcmd:~/example$ cat example.js const { name, password } = user;</code> </pre> <br><p>  As a result of the correction, unused variables and <code>console.log</code> calls were removed, and destructuring was also applied. </p><br><h4 id="nastroyki">  Settings </h4><br><p>  The default settings may not always be suitable for everyone, therefore <code>putout</code> supports the configuration file <code>.putout.json</code> , it consists of the following sections: </p><br><ul><li>  Rules </li><li>  Ignore </li><li>  Match </li><li>  Plugins </li></ul><br><h5 id="rules">  Rules </h5><br><p>  The <code>rules</code> section contains a rule system.  The rules, by default, are set as follows: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"rules"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"remove-unused-variables"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"remove-debugger"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"remove-only"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"remove-skip"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"remove-process-exit"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">"remove-console"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"split-variable-declarations"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"remove-empty"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"remove-empty-pattern"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"convert-esm-to-commonjs"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">"apply-destructuring"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"merge-destructuring-properties"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> </pre> <br><p>  In order to enable <code>remove-process-exit</code> enough to set it to <code>true</code> in the <code>.putout.json</code> file: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"rules"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"remove-process-exit"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> </pre> <br><p>  This will be enough to report all the <code>process.exit</code> calls found in the code, and remove them if the <code>--fix</code> parameter is <code>--fix</code> . </p><br><h5 id="ignore">  Ignore </h5><br><p>  If you need to add some folders to the list of exceptions, just add the <code>ignore</code> section: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"ignore"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"test/fixture"</span></span> ] }</code> </pre> <br><h5 id="match">  Match </h5><br><p>  In case of need of an extensive system of rules, for example, enable <code>process.exit</code> for the <code>bin</code> directory, just use the <code>match</code> section: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"match"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"bin"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"remove-process-exit"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, } } }</code> </pre> <br><h5 id="plugins">  Plugins </h5><br><p>  In the case of using plugins that are not embedded and have the <code>putout-plugin-</code> , they must be included in the <code>plugins</code> section before being activated in the <code>rules</code> section.  For example, to connect the <code>putout-plugin-add-hello-world</code> and enable the <code>add-hello-world</code> rule, it‚Äôs enough to specify: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"rules"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"add-hello-world"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"plugins"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"add-hello-world"</span></span> ] }</code> </pre> <br><h4 id="dvizhok-putout">  Putout engine </h4><br><p>  The <code>putout</code> engine is a command line tool that reads the settings, parses the files, loads and launches the plugins, and then writes the result of the plugins. </p><br><p>  It uses the <a href="https://github.com/benjamn/recast">recast</a> library, which helps to accomplish a very important task: after parsing and transformation, collect the code in a state as close as possible to the previous one. </p><br><p>  For parsing, <code>ESTree</code> compatible parser (currently <code>babel</code> with an <code>estree</code> plugin, but changes are possible in the future), and for transformation, <code>babel</code> tools.  Why exactly <code>babel</code> ?  It's simple.  The fact is that this is a very popular product, much more popular than other similar tools, and it develops much more rapidly.  <a href="https://github.com/babel/proposals">Each new proposal in the standard EcmaScript can not do without a babel-plugin</a> .  <a href="">Babel also</a> has a <a href="">Babel Handbook</a> book in which all the features and tools for circumventing and transforming an AST tree are described very well. </p><br><h4 id="svoy-plagin-dlya-putout">  Own plugin for Putout </h4><br><p>  The <code>putout</code> plugin system is quite simple, and very similar to the <a href="https://eslint.org/docs/developer-guide/working-with-rules">eslint plugins</a> , as well as the <a href="">babel plugins</a> .  True, instead of a single function, the <code>putout</code> plugin should export 3. This is done to increase the reuse of the code, because duplicating the functionality in 3 functions is not very convenient, it is much easier to put it into separate functions and just call it in the right places. </p><br><h5 id="struktura-plagina">  Plugin structure </h5><br><p>  So <code>Putout</code> plugin consists of 3 functions: </p><br><ul><li>  <code>report</code> - returns the message; </li><li>  <code>find</code> - looks for places with errors and returns them; </li><li>  <code>fix</code> - fix these places; </li></ul><br><p>  The main point to remember when creating a plugin for <code>putout</code> is its name, it must begin with <code>putout-plugin-</code> .  Next can be the name of the operation that the plugin performs, for example, the plug-in <code>remove-wrong</code> should be called like this: <code>putout-plugin-remove-wrong</code> . </p><br><p>  You should also add the words: <code>putout</code> and <code>putout-plugin</code> in <code>package.json</code> , in the <code>keywords</code> section, and specify <code>"putout": "&gt;=3.10"</code> in <code>peerDependencies</code> <code>"putout": "&gt;=3.10"</code> , or the version that will be the last one at the time of writing the plugin. </p><br><h5 id="primer-plagina-dlya-putout">  Example plugin for Putout </h5><br><p>  Let's write, for example, a plugin that will remove the word <code>debugger</code> from the code.  Such a plugin is already there, it is <a href="https://github.com/coderaiser/putout/tree/master/packages/plugin-remove-debugger">@ putout / plugin-remove-debugger</a> and it is simple enough to consider it now. </p><br><p>  It looks like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—à–∏–±–∫—É —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â—É—é –∫–∞–∂–¥–æ–º—É –∏–∑ –Ω–∞–π–¥–µ–Ω—ã—Ö —É–∑–ª–æ–≤ module.exports.report = () =&gt; 'Unexpected "debugger" statement'; // –≤ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –∏—â–µ–º —É–∑–ª—ã, —Å–æ–¥–µ—Ä–∂–∞—â–∏–µ–π debugger —Å –ø–æ–º–æ—â—å—é –ø–∞—Ç—Ç–µ—Ä–Ω–∞ Visitor module.exports.find = (ast, {traverse}) =&gt; { const places = []; traverse(ast, { DebuggerStatement(path) { places.push(path); } }); return places; }; // —É–¥–∞–ª—è–µ–º –∫–æ–¥, –Ω–∞–π–¥–µ–Ω–Ω—ã–π –≤ –ø—Ä–µ–¥—ã–¥—É—â–µ–º —à–∞–≥–µ module.exports.fix = (path) =&gt; { path.remove(); };</span></span></code> </pre> <br><p>  If a <code>remove-debugger</code> rule is included in <code>.putout.json</code> , the <code>@putout/plugin-remove-debugger</code> will be loaded.  First, the <code>find</code> function is called which, using the <code>traverse</code> function, <code>traverse</code> nodes of the AST tree and saves all the necessary places. </p><br><p>  The next step <code>putout</code> will turn to <code>report</code> for the desired message. </p><br><p>  If the <code>--fix</code> flag is used, the plug-in <code>fix</code> function will be called and the transformation will be performed, in this case, the node is deleted. </p><br><h5 id="primer-testa-plagina">  Sample plugin test </h5><br><p>  In order to simplify the testing of plugins, the <a href="https://github.com/coderaiser/putout/tree/master/packages/test">@ putout / test</a> tool was written.  At its core, this is nothing more than a wrapper over a <a href="https://github.com/substack/tape">tape</a> , with several methods for convenience and ease of testing. </p><br><p>  The test for the <code>remove-debugger</code> plugin can look like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> removeDebugger = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'..'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> test = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'@putout/test'</span></span>)(__dirname, { <span class="hljs-string"><span class="hljs-string">'remove-debugger'</span></span>: removeDebugger, }); <span class="hljs-comment"><span class="hljs-comment">// –ø—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –±—ã —Å–æ–æ–±—â–µ–Ω–∏–µ –±—ã–ª–æ –∏–º–µ–Ω–Ω–æ —Ç–∞–∫–∏–º test('remove debugger: report', (t) =&gt; { t.reportCode('debugger', 'Unexpected "debugger" statement'); t.end(); }); // –ø—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ test('remove debugger: transformCode', (t) =&gt; { t.transformCode('debugger', ''); t.end(); });</span></span></code> </pre> <br><h5 id="codemods">  Codemods </h5><br><p>  Not any transformation needs to be used every day, for one-time transformations, it is enough to do everything the same, only instead of publishing to <code>npm</code> place it in the <code>~/.putout</code> .  When launching, <code>putout</code> will look in this folder, pick up and start transformations. </p><br><p>  Here is an example of a transformation that replaces the <code>tape</code> connection and <a href="https://github.com/coderaiser/try-to-tape">try-to-tape</a> <a href="https://github.com/coderaiser/supertape">connection with a supertape</a> call: <a href="https://github.com/coderaiser/putout/tree/master/codemods/convert-tape-to-supertape">convert-tape-to-supertape</a> . </p><br><h3 id="eslint-plugin-putout">  eslint-plugin-putout </h3><br><p>  Finally, it‚Äôs worth adding one thing: <code>putout</code> tries to change the code minimally, but if it happens to a friend that some formatting rules break, eslint --fix is ‚Äã‚Äãalways ready to <code>eslint --fix</code> , and for this purpose there is a special plugin <a href="https://github.com/coderaiser/putout/tree/master/packages/eslint-plugin-putout">eslint-plugin-putout</a> .  It can brighten up many formatting errors, and of course it can be configured in accordance with the preferences of developers on a particular project.  Connect it easily: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"extends"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"plugin:putout/recommended"</span></span>, ], <span class="hljs-attr"><span class="hljs-attr">"plugins"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"putout"</span></span> ] }</code> </pre> <br><p>  So far there is only one rule in it: <code>one-line-destructuring</code> , it does the following: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// –±—ã–ª–æ const { one } = hello; // —Å—Ç–∞–Ω–µ—Ç const {one} = hello;</span></span></code> </pre> <br><p>  There are still many included <code>eslint</code> rules that you can read in <a href="https://github.com/coderaiser/putout/tree/master/packages/eslint-config">more detail</a> . </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  I want to thank the reader for paying attention to this text.  I sincerely hope that the topic of AST transformations will become more popular, and articles about this fascinating process will appear more often.  I would be very grateful for any comments and suggestions related to the future direction of <code>putout</code> development.  <a href="https://github.com/coderaiser/putout/issues/new">Create an issue</a> , <a href="https://github.com/coderaiser/putout/compare">send a pool of requests</a> , test, write what rules you would like to see, and how to transform your code programmatically, we will work together to improve the AST transformation tool. </p></div><p>Source: <a href="https://habr.com/ru/post/439564/">https://habr.com/ru/post/439564/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>