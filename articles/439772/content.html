<div class="post__text post__text-html js-mediator-article">  Today I want to quickly tell you how to test asynchronous code. <br>  Imagine the situation that you need to download data from the Internet and check whether everything is working fine, or some other task that is being performed asynchronously.  And how to test it?  What if you try just like regular synchronous code ?! <br><pre><code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testAscynFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { someAsyncFunction() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someAsyncFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bg = <span class="hljs-type"><span class="hljs-type">DispatchQueue</span></span>.global(qos: .background) bg.asyncAfter(deadline: .now() + <span class="hljs-number"><span class="hljs-number">5</span></span>) { <span class="hljs-type"><span class="hljs-type">XCTAssert</span></span>(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"Something went wrong"</span></span>) } }</code> </pre> <br><br>  Such a test will return us a positive result, since the method will not wait for all our asynchronous tasks. <br><br>  To solve this problem in tests there is one wonderful thing: <a name="habracut"></a>  XCTestExpectation <br>  XCTestExpectation sets how many times the asynchronous method should be executed and only after all these executions the test will end and tell if there were any errors.  Here is an example: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestAsyncTests</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XCTestCase</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// 1) объявляем expectation var expectation: XCTestExpectation! func testWithExpectationExample() { //2) Инициализируем его expectation = expectation(description: "Testing Async") //3) задаем то количество раз, сколько должен исполниться метод expectation.fulfill() expectation.expectedFulfillmentCount = 5 for index in 0...5 { someAsyncFunctionWithExpectation(at: index) } //5) Ожидаем пока исполнится нужное количество expectation.fulfill() // в противном же случае по истечении 60 сек метод сам выдаст ошибку, так как не дождался waitForExpectations(timeout: 60) { (error) in if let error = error { XCTFail("WaitForExpectationsWithTimeout errored: \(error)") } } } func someAsyncFunctionWithExpectation(at index: Int) { let bg = DispatchQueue.global(qos: .background) bg.asyncAfter(deadline: .now() + 5) { [weak self ] in XCTAssert(false, "Something went wrong at index \(index)") //4) Именно его исполнение и подсчитывает expectation.expectedFulfillmentCount self?.expectation.fulfill() } } }</span></span></code> </pre><br><br>  I hope someone will be useful this note. </div>