<div class="post__text post__text-html js-mediator-article">  Hello again! <br><br>  Colleagues, on the last day of January we launch the course <a href="https://otus.pw/SNQ6/">“MS SQL Server Developer”</a> , in connection with which we had a thematic open lesson.  On it, we talked about how MS SQL Server performs a SELECT query, discussed the order in which and what is being analyzed, and also slightly dived into reading the query plan. <br><br>  The instructor is <a href="https://otus.pw/m4Q8/">Kristina Kucherova</a> , data model architect at Sberbank of Russia. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/H9oS-eLSX_8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>  <b>Goals and route of the webinar</b> <br><br>  At the beginning of the webinar were set the following goals: <br><br><ol><li>  See how the server performs the request, and why it happens that way. </li><li>  Learn to read the query plan. </li></ol><br>  To achieve them, the teacher has prepared a simple but effective route: <br><br><img src="https://habrastorage.org/webt/fq/kj/nr/fqkjnrypzokv5wpzw1phclft3xa.jpeg"><br><br>  <b>Why do you need a query plan?</b> <br><br>  The query plan is a very useful tool that, unfortunately, many developers do not use.  At first glance, it may seem that it is not necessary to know the mechanics of the query.  However, if you understand what is happening inside SQL Server, you can write a more efficient query.  And it will greatly help, for example, with optimization. <br><br>  <b>How do we see the SELECT query?</b> <br><br>  Let's see what a SELECT query looks like: <br><br><table><tbody><tr><td>  SELECT [field1], [field2] ... <br></td><td>  Which fields do we choose? <br></td></tr><tr><td>  FROM [table] <br></td><td>  From where <br></td></tr><tr><td>  WHERE [conditions] <br></td><td>  Where conditions are such <br></td></tr><tr><td>  GROUP BY [field1] <br></td><td>  Group by field <br></td></tr><tr><td>  HAVING [conditions] <br></td><td>  Having such and such conditions <br></td></tr><tr><td>  ORDER BY [field1] <br></td><td>  Order (sort) <br></td></tr></tbody></table><br>  <b>How to figure out where to go for the data?</b> <br><br>  The first thing the server tries to understand when a request comes in is where to go for the data.  The FROM command answers this question, since it is here that we will have a list of tables (or the name of a single table). <br><br>  For clarity, let's imagine that our server is a kind of butler, whom we order to collect us on vacation.  Accordingly, the butler begins to think, and in what closet are the necessary things (in which table do you need to take data)?  And so that our butler can easily complete his task, we use FROM. <br><br><img src="https://habrastorage.org/webt/ig/wo/uy/igwouy4la8vroshisd8pk5sqcx8.jpeg"><br><br>  <b>How to understand what data to take?</b> <br><br>  Suppose the butler found the closet he needed and opened it.  But what things to take?  Maybe we are going to a ski resort?  Or maybe on a hot sunny beach?  In order for our things to match the weather, we need the WHERE command, which defines the conditions, that is, allows us to filter the data.  If it's hot, we take slates, T-shirts and swimsuits, if it's cold - mittens, knitted socks, sweaters)). <br><br>  The next stage is to put this data into groups, which is done with the help of GROUP BY (T-shirts separately, socks separately).  According to the results of grouping, you can impose one more condition using HAVING (for example, weed out unpaired things).  In the end, we add everything with the help of ORDER BY, resulting in a ready-made bag of things, or rather, an ordered data block. <br><br><img src="https://habrastorage.org/webt/vd/lt/4b/vdlt4bg1o5ebpaxz1di_vhl__tm.jpeg"><br><br>  By the way, there is a nuance, but it lies in the fact that there is a difference, which conditions should be prescribed in WHERE, and which in HAVING.  But this is better to look at the video. <br><br>  We continue.  The path of the request is saved <b>in the form of a query plan</b> in the cache, that is, our butler writes everything down, because he is a good butler - what if you want to repeat your order next year?  And such plans, in principle, can be many. <br><br>  <b>Connection types in terms of query</b> <br><br>  There are three connections that you may encounter in the query plan: <br><br><ol><li>  Nested Loop. </li><li>  Merge join. </li><li>  Hash join. </li></ol><br>  Before dwelling on each of them in more detail, let's summarize, why should we even read the request plan.  In fact, it is very useful, as you will learn: <br><br><ul><li>  which index is used; </li><li>  in what order join is done; </li><li>  what is selected from the buffer; </li><li>  how much the server spends resource on the operation; </li><li>  what is the difference between a hypothetical and a real plan. </li></ul><br>  <b>Nested loop</b> <br><br>  Suppose we need to connect data from different tables.  Let's present these tables in the form of ... a small amount of Skittles candy and full M &amp; M's packaging. <br><br><img src="https://habrastorage.org/webt/4k/-s/uh/4k-suhjbpvptu8kjhe77rx8posm.jpeg"><br><br>  When connecting the type of Nested Loop, we take the candy Skittles, and then we blindly get the candy from the M &amp; M's package.  If we don’t come across a candy of the same color (this is our condition), we get the next one, that is, a normal search occurs.  As a result, we can say that the Nested Loop connection is more suitable for small amounts of data.  Obviously, if there is a lot of data, busting is not the best option. <br><br><img src="https://habrastorage.org/webt/fu/0d/mv/fu0dmvprjve1i1mgbn5v3nou3ow.jpeg"><br><br>  Let's see how it looks in the SQL panel: <br><br><pre><code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--drop table skittles --drop table mms --запрос для окна слева create table mms (id int identity(1,1), color varchar(25), taste varchar(15)) insert into mms (color, taste) values ('yellow', 'chocolate') insert into mms (color, taste) values ('red', 'nuts') create clustered index IX_mms_color ON mms(color); create table skittles (id int identity(1,1), color varchar(25), taste varchar(15)) create index IX_skittles_id ON skittles(id); create clustered index IX_skittles_color ON skittles(color); insert into skittles (color, taste) values ('red', 'cherry') insert into skittles (color, taste) values ('blue', 'strange') insert into skittles (color, taste) values ('yellow', 'lemon') insert into skittles (color, taste) values ('green', 'apple') insert into skittles (color, taste) values ('orange', 'orange') --запрос для правого окна select mms.* from mms join skittles on mms.color = skittles.color select * from mms join skittles on mms.color = skittles.color</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/gx/vj/ed/gxvjedgxwzjcdv2kbzreqmmofwi.jpeg"><br><br>  <b>Merge join</b> <br><br>  Connection is used for large amounts of data.  When you have a merge join, both tables have an index by which they can be joined.  In the case of candies, it is as if they are arranged in advance in colors. <br><br>  It looks like this: <br><br><img src="https://habrastorage.org/webt/j2/cy/ld/j2cyldmem4_ytym2ssj3wpyco1q.jpeg"><br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--2 tables 50000 rows, only clustered index by color, color is not unique select COUNT(*) from mms_big join skittles_big on mms_big.color = skittles_big.color</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/xv/vm/mf/xvvmmf1ozq_lt7f2rrcnqsvz1cs.jpeg"><br><br>  Merge join is good in the following cases: <br><br><ul><li>  large data sets; </li><li>  identical fields of connection of the same type; </li><li>  there are indexes on the connection fields. </li></ul><br>  <b>Hash join</b> <br><br>  Hash join is used for unsorted large amounts of data.  To join the tables in this case, you need to build something that simulates an index. <br><br>  Hash join example: <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--drop table skittles --drop table mms --запрос для окна слева create table mms (id int identity(1,1), color varchar(25), taste varchar(15)) insert into mms (color, taste) values ('yellow', 'chocolate') insert into mms (color, taste) values ('red', 'nuts') insert into mms (color, taste) values ('blue', 'strange') insert into mms (color, taste) values ('green', 'chocolate') insert into mms (color, taste) values ('orange', 'chocolate') create table skittles (id int identity(1,1), color varchar(25), taste varchar(15)) insert into skittles (color, taste) values ('red', 'cherry') insert into skittles (color, taste) values ('blue', 'strange') insert into skittles (color, taste) values ('yellow', 'lemon') insert into skittles (color, taste) values ('green', 'apple') insert into skittles (color, taste) values ('orange', 'orange') --запрос для правого окна select * from mms join skittles on mms.color = skittles.color</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/0g/vr/xd/0gvrxdfdoc55bwpdkv5ghkwnq-w.jpeg"><br><br>  For clarity, recall our candy: <br><br><img src="https://habrastorage.org/webt/xg/2l/cn/xg2lcndw5mzxm5msx6l_0kq_4wc.jpeg"><br><br>  Using Hash join involves 2 phases of actions: <br><br><ol><li>  Build - builds a hash table using the smallest table.  For each value in the table number 1 is a hash.  The value is stored in a hash table, and the calculated hash is used as a key. </li><li>  Probe.  For each row from table No. 2, the hash value is calculated by the fields that are specified in the join (operator =).  Look for a hash in the hash table, check the field values. </li></ol><br><img src="https://habrastorage.org/webt/nr/nn/q2/nrnnq2ahbh57a28x3szylahyjue.jpeg"><br><br><img src="https://habrastorage.org/webt/fu/e3/bg/fue3bgxwsesvzgwjgzzva6isnpu.jpeg"><br><br><img src="https://habrastorage.org/webt/dd/fx/mn/ddfxmnjwgneqpqmzxeseavjpkhy.jpeg"><br><br>  When Hash join is good: <br><br><ul><li>  large data set; </li><li>  no margin in the margin. </li></ul><br>  An important point: if there is not enough memory, the recording will go to tempdb - to disk. <br><br>  Friends, besides the above, in the open lesson included other interesting points that are best seen, watching the video.  We suggest visiting the <a href="https://otus.pw/SNQ6/">Open Day of the course</a> “MS SQL Server Developer” where you can ask the teacher all your questions. <br><br>  PS Teacher <a href="https://otus.pw/m4Q8/">Kristina Kucherova</a> expresses appreciation to Jes Schultz Borland for her <a href="http://magicpass.pass.org/Portals/96/downloads/Execution%2520Plans%2520the%2520Secret%2520to%2520Query%2520Tuning%2520Success.pdf">presentation</a> with PASS Summitt Execution Plans, which was used during the preparation of the open lesson. </div>