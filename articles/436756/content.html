<div class="post__text post__text-html js-mediator-article"><p>  "Isomorphism" is one of the basic concepts of modern mathematics.  With specific examples in Haskell and C #, I not only explain the theory for non-mathematicians (without using any obscure mathematical symbols and terms), but also show how this can be used in everyday practice. </p><a name="habracut"></a><br><p>  The problem is that strict equality (for example, 2 + 2 = 4) is often overly strict.  Here is an example: </p><br><div class="spoiler">  <b class="spoiler_title">Haskell</b> <div class="spoiler_text"><pre><code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">add</span></span> :: (a, a) -&gt; a add (x, y) = x + y</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">C #</b> <div class="spoiler_text"><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">int</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Add</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Tuple</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">int</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">int</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">pair</span></span>) { return pair.Item1 + pair.Item2; }</code> </pre> </div></div><br><p>  However, there is one more - more cunning and in many situations much more practical - a way to define <b>in some sense</b> the same function: </p><br><div class="spoiler">  <b class="spoiler_title">Haskell</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">add'</span></span> :: a -&gt; a -&gt; a add' x = \y -&gt; x + y</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">C #</b> <div class="spoiler_text"><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">int</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">int</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">Add_</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">int</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span>) { return y =&gt; x + y; }</code> </pre> </div></div><br><p>  Contrary to the obvious fact that for any two <i>x, y,</i> both functions always return the same result, they do not satisfy strict equality: </p><br><ul><li>  the first function immediately returns the amount (i.e., performs the calculation at the time of export) </li><li>  while the second function returns another function (which ultimately returns the sum — if someone calls it, of course, otherwise no calculation will be performed: this is an example of deferred calculation and here too there is an isomorphism to which I will return a little later). </li></ul><br><p>  And this is "being too strict." </p><br><p>  Isomorphism is “quite strict”;  it does not require full, all-embracing equality, but is limited to equality "in a certain sense," which is always conditioned by a specific context. </p><br><p>  As we guessed, both definitions above are isomorphic.  This means exactly the following: if only one of them is given to me, then both of them are given to me <em>implicitly</em> : all thanks to <b>isomorphism — a two-way converter from one to the other</b> .  Having a little generalized types: </p><br><div class="spoiler">  <b class="spoiler_title">Haskell</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">curry</span></span> :: ((a, b) → c) → a → b → c curry fxy = f (x, y), uncurry :: (a → b → c) → (a, b) → c uncurry f (x, y) = fxy</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">C #</b> <div class="spoiler_text"><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg1</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg2</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span>&gt;&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">Curry</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">Tuple</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg1</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg2</span></span>&gt;, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uncurried</span></span>) { return arg1 =&gt; arg2 =&gt; uncurried(Tuple.Create(arg1, arg2)); } <span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">Tuple</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg1</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg2</span></span>&gt;, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">Uncurry</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg1</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg2</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span>&gt;&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">curried</span></span>) { return pair =&gt; curried(pair.Item1)(pair.Item2); }</code> </pre> </div></div><br><p>  ... and now for any <em>x, y</em> : </p><br><div class="spoiler">  <b class="spoiler_title">Haskell</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">curry</span></span> add $ x, y = uncurry add' $ (x, y)</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">C #</b> <div class="spoiler_text"><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Curry</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Add</span></span>)(<span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span>)(<span class="hljs-selector-tag"><span class="hljs-selector-tag">y</span></span>) = <span class="hljs-selector-tag"><span class="hljs-selector-tag">Uncurry</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Add_</span></span>)(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Tuple</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Create</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">y</span></span>))</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">A little more math for particularly inquisitive.</b> <div class="spoiler_text"><p>  In fact, it should look like this: </p><br><div class="spoiler">  <b class="spoiler_title">Haskell</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">curry</span></span> . uncurry = id uncurry . curry = id id x = x</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">C #</b> <div class="spoiler_text"><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Compose</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Curry</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Uncurry</span></span>) = <span class="hljs-selector-tag"><span class="hljs-selector-tag">Id</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Compose</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Uncurry</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Curry</span></span>) = <span class="hljs-selector-tag"><span class="hljs-selector-tag">Id</span></span>, где: <span class="hljs-selector-tag"><span class="hljs-selector-tag">T</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Id</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">T</span></span>&gt;(<span class="hljs-selector-tag"><span class="hljs-selector-tag">T</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">arg</span></span>) =&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">arg</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TFinalRes</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">Compose</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TFinalRes</span></span>&gt;( <span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">first</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TFinalRes</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">second</span></span>) { return arg =&gt; second(first(arg)); } ...или как <span class="hljs-selector-tag"><span class="hljs-selector-tag">extension-</span></span>метод (определение функции <span class="hljs-selector-tag"><span class="hljs-selector-tag">Id</span></span> остается таким же): <span class="hljs-selector-tag"><span class="hljs-selector-tag">Curry</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Compose</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Uncurry</span></span>) = <span class="hljs-selector-tag"><span class="hljs-selector-tag">Id</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Uncurry</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Compose</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Curry</span></span>) = <span class="hljs-selector-tag"><span class="hljs-selector-tag">Id</span></span>, где: <span class="hljs-selector-tag"><span class="hljs-selector-tag">public</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">static</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TFinalRes</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">Compose</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TFinalRes</span></span>&gt;( <span class="hljs-selector-tag"><span class="hljs-selector-tag">this</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TArg</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">first</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TFinalRes</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">second</span></span>) { return arg =&gt; second(first(arg)); }</code> </pre> </div></div><br><p>  Id should be understood as "nothing happened."  Since an isomorphism is a two-way converter by definition, you can always 1) take one thing, 2) convert it to another, and 3) convert it back to the first.  Only two such operations can be done: because at the first stage (No. 1), the choice is only of two options.  And in both cases, the operation should lead to exactly the same result, as if nothing happened at all (it is for this reason that strict equality is involved - because nothing has changed <strong>at</strong> all, and not “something” has not changed). </p><br><p>  In addition to this, there is a theorem that the id element is always unique.  Note that the Id function is generic, polymorphic and therefore truly unique with respect to each specific type. </p></div></div><br><p>  Isomorphism turns out to be very, very useful precisely because it is strict, but not too.  It retains certain important properties (in the example above - the same result with the same arguments), while allowing you to freely transform the data structures themselves (carriers of isomorphic behavior and properties).  And it is absolutely safe - because isomorphism always works in both directions, which means you can always go back without losing those very "important properties".  Let me give you another example, which is so useful in practice that it even forms the basis of many "advanced" programming languages ​​such as Haskell: </p><br><div class="spoiler">  <b class="spoiler_title">Haskell</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">toLazy</span></span> :: a -&gt; () -&gt; a toLazy x = \_ -&gt; a fromLazy :: (() -&gt; a) -&gt; a fromLazy f = f ()</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">C #</b> <div class="spoiler_text"><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">Lazy</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">res</span></span>) { return () =&gt; res; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Lazy</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Func</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">TRes</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">lazy</span></span>) { return lazy(); }</code> </pre> </div></div><br><p>  This isomorphism preserves the result of the delayed calculation itself - this is the "important property", while the data structures are different. </p><br><p>  Conclusion?  The PLO, especially strictly typed, (forcedly) works at the level of "strict equality".  And therefore - in the wake of the examples cited - it is often too strict.  When you get used to thinking "too strictly" (and this happens imperceptibly - it gradually leaks into the programmer, especially if he is not looking for inspiration in mathematics), your decisions unwittingly lose the desired (or, at least, objectively possible) flexibility.  Understanding isomorphism - in collaboration with a conscious attempt to be more attentive to his <br>  and to someone else's code - it helps to define more clearly the circle of “important properties”, abstracting from unnecessary details: namely, from specific data structures on which these “important properties” are captured (they are also “implementation details”, for that matter).  First of all, it is a way of thinking and only then - more successful (micro) architectural solutions and, as a natural consequence, an altered approach to testing. </p><br><p>  PS If I see that the article has benefited, then I will return to the topics of "more successful (micro) architectural solutions" and "alter the approach to testing." </p></div>