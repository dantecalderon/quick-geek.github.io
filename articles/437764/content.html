<div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="image"><br><h1>  Introduction </h1><br>  We have already said that the osg :: Camera class manages its associated OpenGL graphics context.  The graphic context encapsulates information about how and where objects are drawn and which state attributes apply to them.  A context is a graphical window, or rather its client area, or an OpenGL pixel buffer that stores pixel data without transferring it to the frame buffer. <br><br>  OSG uses the osg :: GraphicsContext class to represent the abstract graphics context, and the osg :: GraphicsWindow class to represent the abstract graphics window.  The latter has a getEventQueue () method for managing events from GUI elements.  Generally speaking, graphical context is a platform-specific concept, so most of the work on creating a window and associating its context with the OpenGL context, OSG takes over.  When you call the createGraphicsContext () method of the osg :: GraphicsContext () class, the required code (and not a little, believe me!) Will be generated by the preprocessor automatically, depending on the platform.  All we have to do is pass an osg :: GraphicsContex :: Traits argument to this method, containing a description of which window we want to receive. <br><a name="habracut"></a><br><h1>  1. Class osg :: DisplaySettings </h1><br>  OSG allows the developer to control the global display settings, on the basis of which cameras, viewers and scene elements are rendered.  For this purpose, the singleton pattern is used, that is, a unique object containing these settings, implemented as an osg :: DisplaySettings class, which can be accessed from anywhere in the program.  Therefore, from our application, we can change these settings at any time. <br><br><pre><code class="cpp hljs">osg::DisplaySettings *ds = osg::DisplaySettings::instance();</code> </pre> <br>  Singleton osg :: DisplaySettings contains settings that are applied to newly created rendering devices, the OpenGL context of the graphics window.  You can vary the following parameters: <br><br><ol><li>  setDoubleBuffer () - enable / disable double buffering.  Enabled by default. <br></li><li>  setDepthBuffer () - enable / disable depth buffer.  By default enabled. <br></li><li>  Set the alpha buffer (alpha buffer), stencil buffer (stencil buffer), accumulation buffer by using methods of the type setMinimumNumAlphaBits ().  By default, all parameters are 0. <br></li><li>  Allowing to use anti-aliasing and its depth using the setNumMultiSamples () method.  The default is 0. <br></li><li>  Enable stereo mode.  Off by default. <br></li></ol><br>  Consider the use of this singleton on the example of smoothing <br><br><div class="spoiler">  <b class="spoiler_title">Singleton osg :: DisplaySettings example</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::DisplaySettings::instance()-&gt;setNumMultiSamples(6); osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; model = osgDB::readNodeFile("../data/cessna.osg"); osgViewer::Viewer viewer; viewer.setSceneData(model.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Only one challenge is important here. <br><br><pre> <code class="cpp hljs">osg::DisplaySettings::instance()-&gt;setNumMultiSamples(<span class="hljs-number"><span class="hljs-number">6</span></span>);</code> </pre><br>  - setting the smoothing parameter, which can take the values ​​2, 4 and 6, depending on the graphics device used.  Notice how the blade of the screw of the cessna looks without smoothing. <br><br><img src="https://habrastorage.org/webt/4y/nr/1p/4ynr1p8ia9knpagauohb6_fe2-g.png"><br><br>  and after applying it <br><br><img src="https://habrastorage.org/webt/yq/4b/og/yq4bog1qdmngwxpsij7ujponxzk.png"><br><br><h1>  2. Switch to windowed mode </h1><br>  The class osgViewer :: Viewer can be very quickly reconfigured for display in windowed mode.  As you noticed, all our previous examples were displayed in full screen.  To switch the viewer to windowed mode, there is the setUpViewInWindow () method, which takes as its parameters the coordinates of the upper left corner of the window, its width and height in pixels <br><br><pre> <code class="cpp hljs">viewer.setUpViewInWindow(<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">800</span></span>, <span class="hljs-number"><span class="hljs-number">600</span></span>);</code> </pre><br>  Optionally, this method takes the fifth parameter - the number of the screen to which the window should be displayed, in case you have more than one monitor.  Surely working with multiple monitors in Windows, you have observed that the scene is spreading to all monitors in full screen mode (this is not observed in Linux). <br><br>  In addition, in the project settings, you can set the OSG_WINDOW environment variable in this way <br><br><img src="https://habrastorage.org/webt/-5/yg/ge/-5yggeqzivtjkymngxq3xk318qm.png"><br><br>  which will be equivalent to calling setUpViewInWindow (), which in this case can not be executed. <br><br><img src="https://habrastorage.org/webt/2z/z_/px/2zz_pxckvywsn1c3hpebbwwj77e.png"><br><br>  To explicitly specify the screen on which the viewer should be displayed in full screen mode, you can use the setUpViewOnSingleScreen () method by specifying the screen number as a parameter (default is 0). <br><br>  OSG also supports demo spherical displays.  You can use the setUpViewFor3DSphericalDisplay () method to customize the display on this display. <br><br><h1>  3. Composite Viewer </h1><br>  The osgViewer :: Viewer class manages one view that displays one scene graph.  Besides it, there is a class osgViewer :: CompositeViewer which supports several views and several scenes.  It has the same run (), frame () and done () methods to control the rendering process, but it allows you to add and remove independent views using the addView () and removeView () methods, as well as getting views from their index using the getView method ()  The view object is described by the osgViewer :: View class. <br><br>  The osgViewer :: View class is the base class for the osgViewer :: Viewer class.  It allows you to add a root node with the scene data, a camera manipulator and event handlers.  The main difference between this class (view) and the viewer class is that it does not allow rendering the scene with run () or frame () calls.  A typical script for adding a view looks like this. <br><br><pre> <code class="cpp hljs">osgViewer::CompositeViewer multiviewer; multiviewer.addView( view );</code> </pre><br>  Composite viewer allows you to display one scene in different angles, displaying these angles in different windows.  It also allows you to display independent scenes in different windows.  Let's write a simple example of using a composite viewer. <br><br><div class="spoiler">  <b class="spoiler_title">Composite example</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgDB/ReadFile&gt; #include &lt;osgViewer/CompositeViewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osgViewer::View *createView(int x, int y, int w, int h, osg::Node *scene) { osg::ref_ptr&lt;osgViewer::View&gt; view = new osgViewer::View; view-&gt;setSceneData(scene); view-&gt;setUpViewInWindow(x, y, w, h); return view.release(); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Node&gt; model1 = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::Node&gt; model2 = osgDB::readNodeFile("../data/cow.osg"); osg::ref_ptr&lt;osg::Node&gt; model3 = osgDB::readNodeFile("../data/glider.osg"); osgViewer::View *view1 = createView(50, 50, 320, 240, model1); osgViewer::View *view2 = createView(380, 50, 320, 240, model2); osgViewer::View *view3 = createView(185, 330, 320, 240, model3); osgViewer::CompositeViewer viewer; viewer.addView(view1); viewer.addView(view2); viewer.addView(view3); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Creating a separate view is placed in a function that takes as parameters the position and size of the window, as well as the scene as a pointer to its root node. <br><br><pre> <code class="cpp hljs">osgViewer::<span class="hljs-function"><span class="hljs-function">View *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> w, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> h, osg::Node *scene)</span></span></span><span class="hljs-function"> </span></span>{ osg::ref_ptr&lt;osgViewer::View&gt; view = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osgViewer::View; view-&gt;setSceneData(scene); view-&gt;setUpViewInWindow(x, y, w, h); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> view.release(); }</code> </pre><br>  Here we create a view managed by a smart pointer to the object osgViewer :: View <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osgViewer::View&gt; view = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osgViewer::View;</code> </pre><br>  set the data of the displayed scene and the windowed display mode in the window with the specified position and size <br><br><pre> <code class="cpp hljs">view-&gt;setSceneData(scene); view-&gt;setUpViewInWindow(x, y, w, h);</code> </pre><br>  The view is returned from the function according to the rules for returning smart pointers. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> view.release();</code> </pre><br>  Now in the main program we load three different models. <br><br><pre> <code class="cpp hljs">osgViewer::View *view1 = createView(<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">320</span></span>, <span class="hljs-number"><span class="hljs-number">240</span></span>, model1); osgViewer::View *view2 = createView(<span class="hljs-number"><span class="hljs-number">380</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">320</span></span>, <span class="hljs-number"><span class="hljs-number">240</span></span>, model2); osgViewer::View *view3 = createView(<span class="hljs-number"><span class="hljs-number">185</span></span>, <span class="hljs-number"><span class="hljs-number">330</span></span>, <span class="hljs-number"><span class="hljs-number">320</span></span>, <span class="hljs-number"><span class="hljs-number">240</span></span>, model3);</code> </pre><br>  we create three different types <br><br><pre> <code class="cpp hljs">osgViewer::View *view1 = createView(<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">320</span></span>, <span class="hljs-number"><span class="hljs-number">240</span></span>, model1); osgViewer::View *view2 = createView(<span class="hljs-number"><span class="hljs-number">380</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">320</span></span>, <span class="hljs-number"><span class="hljs-number">240</span></span>, model2); osgViewer::View *view3 = createView(<span class="hljs-number"><span class="hljs-number">185</span></span>, <span class="hljs-number"><span class="hljs-number">330</span></span>, <span class="hljs-number"><span class="hljs-number">320</span></span>, <span class="hljs-number"><span class="hljs-number">240</span></span>, model3);</code> </pre><br>  create a composite viewer and add previously created views to it <br><br><pre> <code class="cpp hljs">osgViewer::CompositeViewer viewer; viewer.addView(view1); viewer.addView(view2); viewer.addView(view3);</code> </pre><br>  and we start rendering in exactly the same way as we did in the case of a single scene. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewer.run();</code> </pre><br>  Everything!  When you run the program, we get three different windows.  The contents of each window can be managed independently.  Any of the windows can be closed in the standard way, and exit the entire application by pressing Esc. <br><br><img src="https://habrastorage.org/webt/dh/na/kl/dhnaklox5z-apbaynehnea_okss.png"><br><br><h1>  3. Class osg :: GraphicsContext :: Traits </h1><br>  The word "traits" in English means "features."  So, the above class describes the features of the future window, and contains all the properties for describing the graphic context.  It differs from the osg :: DisplaySettings class, which controls the characteristics of all graphics contexts for newly created cameras.  The main public properties of this class are listed in the table below. <br><br><table><thead><tr><th>  Class attribute </th><th>  Type of </th><th>  Default value </th><th>  Description </th></tr></thead><tbody><tr><td>  x </td><td>  int </td><td>  0 </td><td>  Initial horizontal position of the window </td></tr><tr><td>  y </td><td>  int </td><td>  0 </td><td>  Initial vertical position of the window </td></tr><tr><td>  width </td><td>  int </td><td>  0 </td><td>  Window width </td></tr><tr><td>  height </td><td>  int </td><td>  0 </td><td>  Window height </td></tr><tr><td>  windowName </td><td>  std :: string </td><td>  "" </td><td>  Window title </td></tr><tr><td>  windowDecoration </td><td>  bool </td><td>  false </td><td>  Window title display flag </td></tr><tr><td>  red </td><td>  unsigned int </td><td>  eight </td><td>  The number of bits of red in the OpenGL color buffer </td></tr><tr><td>  green </td><td>  unsigned int </td><td>  eight </td><td>  The number of bits of green in the OpenGL color buffer </td></tr><tr><td>  blue </td><td>  unsigned int </td><td>  eight </td><td>  The number of bits of blue in the OpenGL color buffer </td></tr><tr><td>  alpha </td><td>  unsigned int </td><td>  eight </td><td>  The number of bits in the OpenGL alpha buffer </td></tr><tr><td>  depth </td><td>  unsigned int </td><td>  24 </td><td>  The number of bits in the OpenGL depth buffer </td></tr><tr><td>  stencil </td><td>  unsigned int </td><td>  0 </td><td>  The number of bits in the OpenGL stencil buffer </td></tr><tr><td>  doubleBuffer </td><td>  bool </td><td>  false </td><td>  Use double buffer </td></tr><tr><td>  samples </td><td>  unsigned int </td><td>  0 </td><td>  The number of primitive smoothing </td></tr><tr><td>  quadBufferStereo </td><td>  bool </td><td>  false </td><td>  Use quad stereo buffer (for NVidia hardware) </td></tr><tr><td>  inheritedWindowData </td><td>  osg :: ref_ptr </td><td>  Null </td><td>  The data descriptor associated with the window </td></tr></tbody></table><br>  To initialize the object Traits, you must run the following code <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::GraphicsContext::Traits&gt; traits = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::GraphicsContext::Traits; traits-&gt;x = <span class="hljs-number"><span class="hljs-number">50</span></span>; traits-&gt;y = <span class="hljs-number"><span class="hljs-number">100</span></span>; ...</code> </pre><br><h1>  4. Configure the OSG application window </h1><br>  To create a window with the specified characteristics, you need to do the following steps: <br><br><ol><li>  Configure an object of type osg :: GraphicsContext :: Traits <br></li><li>  Create graphic window context <br></li><li>  Associate this graphic context with the camera. <br></li><li>  Make the camera main for the viewer <br></li></ol><br><div class="spoiler">  <b class="spoiler_title">Traits example</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/GraphicsContext&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::GraphicsContext::Traits&gt; traits = new osg::GraphicsContext::Traits; traits-&gt;x = 50; traits-&gt;y = 50; traits-&gt;width = 800; traits-&gt;height = 600; traits-&gt;windowName = "OSG application"; traits-&gt;windowDecoration = true; traits-&gt;doubleBuffer = true; traits-&gt;samples = 4; osg::ref_ptr&lt;osg::GraphicsContext&gt; gc = osg::GraphicsContext::createGraphicsContext(traits.get()); osg::ref_ptr&lt;osg::Camera&gt; camera = new osg::Camera; camera-&gt;setGraphicsContext(gc); camera-&gt;setViewport( new osg::Viewport(0, 0, traits-&gt;width, traits-&gt;height) ); camera-&gt;setClearMask(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT); camera-&gt;setClearColor( osg::Vec4(0.2f, 0.2f, 0.4f, 1.0f) ); double aspect = static_cast&lt;double&gt;(traits-&gt;width) / static_cast&lt;double&gt;(traits-&gt;height); camera-&gt;setProjectionMatrixAsPerspective(30.0, aspect, 1.0, 1000.0); camera-&gt;getOrCreateStateSet()-&gt;setMode(GL_DEPTH_TEST, osg::StateAttribute::ON); osg::ref_ptr&lt;osg::Node&gt; root = osgDB::readNodeFile("../data/cessna.osg"); osgViewer::Viewer viewer; viewer.setCamera(camera.get()); viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  To set the window settings, create an instance of the osg :: GraphicsContext :: Traits class and initialize it with the parameters we need <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::GraphicsContext::Traits&gt; traits = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::GraphicsContext::Traits; traits-&gt;x = <span class="hljs-number"><span class="hljs-number">50</span></span>; traits-&gt;y = <span class="hljs-number"><span class="hljs-number">50</span></span>; traits-&gt;width = <span class="hljs-number"><span class="hljs-number">800</span></span>; traits-&gt;height = <span class="hljs-number"><span class="hljs-number">600</span></span>; traits-&gt;windowName = <span class="hljs-string"><span class="hljs-string">"OSG application"</span></span>; traits-&gt;windowDecoration = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; traits-&gt;doubleBuffer = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; traits-&gt;samples = <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre><br>  After that we create a graphics context, passing as a pointer to the traits <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::GraphicsContext&gt; gc = osg::GraphicsContext::createGraphicsContext(traits.get());</code> </pre><br>  Create a camera <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Camera&gt; camera = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Camera;</code> </pre><br>  Associate a camera with the created graphics context. <br><br><pre> <code class="cpp hljs">camera-&gt;setGraphicsContext(gc);</code> </pre><br>  Adjust the viewport, set the buffer cleaning mask, set the cleaning color <br><br><pre> <code class="cpp hljs">camera-&gt;setViewport( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Viewport(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, traits-&gt;width, traits-&gt;height) ); camera-&gt;setClearMask(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT); camera-&gt;setClearColor( osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.2f</span></span>, <span class="hljs-number"><span class="hljs-number">0.2f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) );</code> </pre><br>  Customize the perspective projection matrix <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> aspect = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(traits-&gt;width) / <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(traits-&gt;height); camera-&gt;setProjectionMatrixAsPerspective(<span class="hljs-number"><span class="hljs-number">30.0</span></span>, aspect, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1000.0</span></span>);</code> </pre><br>  Do not forget to turn on the depth test, for correct display of faces <br><br><pre> <code class="cpp hljs">camera-&gt;getOrCreateStateSet()-&gt;setMode(GL_DEPTH_TEST, osg::StateAttribute::ON);</code> </pre><br>  Load model aircraft <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; root = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg"</span></span>);</code> </pre><br>  Configure and launch the viewer, indicating the camera we configured as the main camera <br><br><pre> <code class="cpp hljs">osgViewer::Viewer viewer; viewer.setCamera(camera.get()); viewer.setSceneData(root.get()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewer.run();</code> </pre><br>  At the exit we have a window with the required parameters. <br><br><img src="https://habrastorage.org/webt/rs/av/d-/rsavd-z8aawrwpykioblv1kxsni.png"><br><br>  The title of the window is not displayed because in the settings of my window manager this feature is disabled.  If you run the example in Windows or Linux with different settings, the title will be in place. <br><br>  <i><a href="https://habr.com/ru/post/438218/">To be continued...</a></i> </div>