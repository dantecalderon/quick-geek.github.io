<div class="post__text post__text-html js-mediator-article">  The author of the material, the translation of which we are publishing today, says that there are many things in JavaScript objects that one could not even suspect about the existence of using them in their daily work.  Objects in JavaScript are very easy to create, it is convenient to work with them, they seem to be understandable and flexible entities, and many programmers simply do not think that objects are actually arranged is not so simple. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/438794/"><img src="https://habrastorage.org/webt/o8/ga/z0/o8gaz0tewtkdqmryqsar9vdswfc.png"></a> <br><blockquote>  <b>NB:</b> Information from the publication in practice should be applied very carefully and under the supervision of more experienced colleagues. </blockquote><a name="habracut"></a><br>  Here we will talk about what is hidden in the depths of objects and discuss the subtleties of working with them. <br>  Having mastered this material, you will know the answers to the following questions: <br><br><ul><li>  How to make a property of the object to be deleted? </li><li>  What are the properties with access methods and what are their features? </li><li>  How to make a property immutable or hidden? </li><li> Why are some properties not visible in <code>for-in</code> loops or in the results of the <code>Object.keys()</code> method, and some are visible? </li><li>  How to “protect” an object from modification? </li><li>  How to understand a code snippet similar to the following: </li></ul><br><pre> <code class="javascript hljs">obj.id = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj.id) <span class="hljs-comment"><span class="hljs-comment">// =&gt; '101' (5 в двоичной системе счисления)</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Types of properties of objects</font> </h2><br><h3>  <font color="#3AC1EF">▍Properties that store data</font> </h3><br>  You have probably created countless objects resembling this one: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Arfat'</span></span>, <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span> } obj.name <span class="hljs-comment"><span class="hljs-comment">// =&gt; 'Arfat'</span></span></code> </pre> <br>  The <code>name</code> and <code>id</code> properties of the <code>obj</code> object are called data <code>obj</code> properties, or “data properties” (Data Properties).  These are familiar properties that are constantly found in JavaScript code.  What other kinds of properties can objects have? <br><br><h3>  <font color="#3AC1EF">▍Properties with access methods</font> </h3><br>  Such properties are also known as getters and setters, they are found in other programming languages ​​like C # or Python.  A property with access methods (Accessor Property) is a combination of two functions, <code>get</code> and <code>set</code> . <br><br>  When declaring such properties instead of using the traditional construction of the form <code>ключ: значение</code> , the following syntax is used: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> accessorObj = { get name() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Arfat'</span></span>; } }; accessorObj.name; <span class="hljs-comment"><span class="hljs-comment">// =&gt; 'Arfat' const dataObj = { name: 'Arfat', }; dataObj.name; // =&gt; 'Arfat'</span></span></code> </pre> <br>  Take a look at the <code>accesorObj</code> object and compare it with the <code>dataObj</code> object.  As you can see, they are now showing the same behavior.  In describing the first object, we used the <code>get</code> keyword, followed by the function declaration.  In order to access such a property, although it is represented by a function, it is not necessary to put parentheses after the name of the property to call this function.  That is a construction like <code>accessorObj.name();</code>  is incorrect. <br><br>  When you try to access the <code>accessorObj.name</code> property, that is, when you try to read it, the corresponding function is executed and the value returned to it becomes the value of the <code>name</code> property. <br><br>  The <code>get</code> functions are called getters, they are responsible for getting values.  If we continue our example and try to change the value of the <code>name</code> property of the <code>accessorObj</code> object, say, by running the command <code>accessorObj.name = 'New Person';</code>  then it turns out that nothing will happen.  The point here is that the setter function is not associated with the <code>name</code> key.  Such functions allow you to customize the order in which new values ​​are assigned to properties of objects, access to which is organized using getters. <br><br>  Here’s what an object declaration with a getter and setter looks like: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> accessorObj = { <span class="hljs-attr"><span class="hljs-attr">_name</span></span>: <span class="hljs-string"><span class="hljs-string">'Arfat'</span></span>, get name() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._name; }, set name(value) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._name = value; } };</code> </pre> <br>  The setter function gets what it is trying to assign to the property of the object, as a parameter.  Now you can save something in the object property.  In this case, we create a “private” property of the <code>_name</code> object.  The first symbol of the name of such a property is an underscore, which is nothing more than a hint for the programmer, indicating that this property is intended for the internal needs of the object.  Next, we work with it when accessing the property of the <code>name</code> object, access to which is regulated by a getter and a setter. <br><br>  In the getter function, before returning the value of the <code>_name</code> property, we can modify it. <br><br>  Here is what it might look like: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { get name() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._name.toUpperCase(); }, set name(value) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._name = value; }, get id() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._id.toString(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Преобразуем десятичное число в его двоичное представление }, set id(value) {   this._id = value; } } obj.name = 'Arfat'; obj.name; // =&gt; 'ARFAT' obj.id = 5; obj.id; // =&gt; '101</span></span></code> </pre> <br>  This program, by the way, contains an answer to one of the questions given at the beginning of the article, which concerns the analysis of a code that is incomprehensible at first glance. <br><br>  Why would anyone need properties with access methods if you can safely work with ordinary properties?  For example, they may be needed in order to log information about property read operations, or to keep a history of changes in property values.  Properties with access methods give us all the possibilities of data processing with the help of functions and the simplicity characteristic of working with ordinary properties.  More information about the use of such properties can be found <a href="https://stackoverflow.com/questions/1568091/why-use-getters-and-setters-accessors">here</a> . <br><br>  How does JavaScript distinguish regular properties that store data from properties with accessors?  Let's figure it out. <br><br><h2>  <font color="#3AC1EF">Object Property Descriptors</font> </h2><br>  At first glance it may seem that there is a direct correspondence between the keys and the values ​​stored in the objects.  However, this is not quite true. <br><br><h3>  <font color="#3AC1EF">Свойств Property Attributes</font> </h3><br>  Associated with each object key is a set of attributes that define the characteristics of the value associated with a given key.  These attributes can also be viewed as metadata describing a <code>ключ: значение</code> pair. <br><br>  Attributes are used to set and describe the state of object properties.  The set of property attributes is called a descriptor.  There are six attributes of properties: <br><br><ul><li> <code>[[Value]]</code> </li> <li> <code>[[Get]]</code> </li> <li> <code>[[Set]]</code> </li> <li> <code>[[Writable]]</code> </li> <li> <code>[[Enumerable]]</code> </li> <li> <code>[[Configurable]]</code> </li> </ul><br>  Why are the property attribute names in this list enclosed in <code>[[]]</code> ?  Double parentheses indicate that these are entities used by the internal mechanisms of the language.  The JS programmer cannot access these properties directly.  In order to influence them, appropriate methods are used. <br><br>  Consider the following image taken <a href="https://mathiasbynens.be/notes/shapes-ics">from here</a> , where you can see the object and the attributes of its properties. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/613/e59/d25/613e59d25aa164d3fb5dc1acbe49e25f.png"></div><br>  <i><font color="#999999">Object and attributes of its properties</font></i> <br><br>  Our object has 2 keys - <code>x</code> and <code>y</code> .  In addition, each of them is associated with a set of attributes. <br><br>  How can JavaScript get object information similar to those shown in the previous figure?  You can use the <code>Object.getOwnPropertyDescriptor()</code> function to do this.  It takes an object and the name of its property, and then returns an object containing the attributes of this property.  Here is an example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptor(object, <span class="hljs-string"><span class="hljs-string">'x'</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* { value: 5, writable: true, enumerable: true, configurable: true } */</span></span></code> </pre> <br>  It should be noted that the composition of the attributes of a particular property depends on its type.  All six attributes of the same property are not found. <br><br><ul><li>  If we are talking about properties with data, then they will only have the attributes <code>[[Value]]</code> , <code>[[Writable]]</code> , <code>[[Enumerable]]</code> and <code>[[Configurable]]</code> . </li><li>  Properties with access methods, instead of the <code>[[Value]]</code> and <code>[[Writable]]</code> attributes, have the <code>[[Get]]</code> and <code>[[Set]]</code> attributes. </li></ul><br><h3>  <font color="#3AC1EF">▍ [[Value]]</font> </h3><br>  This attribute stores what is issued when trying to get the value of an object property.  That is, if in the previous example we use a construct of the <code>object.x</code> type, we get what is stored in the <code>[[Value]]</code> attribute.  The same thing will happen when trying to read the properties of an object using square brackets. <br><br><h3>  <font color="#3AC1EF">▍ [[Get]]</font> </h3><br>  This attribute stores a reference to a function that is a getter property.  This function is called without arguments when trying to read the value of a property. <br><br><h3>  <font color="#3AC1EF">▍ [[Set]]</font> </h3><br>  Here is a reference to the function declared when creating a setter property.  It is called with an argument representing the value that the property was attempted to assign, that is, it is called with each assignment operation to the property of a new value. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { set x(val) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(val)   <span class="hljs-comment"><span class="hljs-comment">// =&gt; 23 } } obj.x = 23;</span></span></code> </pre> <br>  In this example, the right-hand side of the expression is passed as the argument <code>val</code> to the setter function.  <a href="https://gist.github.com/ArfatSalman/07f8663adfd78ddc4af8ebea152cdbae">Here is the</a> code that demonstrates the use of setters and getters. <br><br><h3>  <font color="#3AC1EF">▍ [[Writable]]</font> </h3><br>  This attribute stores a boolean value.  It indicates whether the value of the property can be rewritten or not.  If <code>false</code> is stored here, then attempts to change the value of the property will not succeed. <br><br><h3>  <font color="#3AC1EF">▍ [[Enumerable]]</font> </h3><br>  Logical value is also stored here.  This attribute governs the output of a property in <code>for-in</code> loops.  If it is set to <code>true</code> , then the property will be able to work using such cycles. <br><br><h3>  <font color="#3AC1EF">▍ [[Configurable]]</font> </h3><br>  This attribute is also represented by a logical value.  This is what happens if it holds <code>false</code> : <br><br><ul><li>  The property cannot be deleted. </li><li>  It will not be possible to convert properties that store data into properties with access methods, and vice versa.  Attempts to perform such transformations will not lead to anything. </li><li>  It will be forbidden to change property attribute values.  That is, the current values ​​of the <code>[[Enumerable]]</code> , <code>[[Configurable]]</code> , <code>[[Get]]</code> and <code>[[Set]]</code> attributes will be immutable. </li></ul><br>  The effect of setting this attribute to <code>false</code> also depends on the type of property.  This attribute, in addition to the above effects on the properties, acts on them and so: <br><br><ul><li>  If we have a property that stores data, then the <code>[[Writable]]</code> attribute can only be changed from <code>true</code> to <code>false</code> . </li><li>  As long as the <code>[[Writable]]</code> attribute is not set to <code>false</code> , the <code>[[Value]]</code> attribute can be changed.  But after the <code>[[Writable]]</code> and <code>[[Configurable]]</code> attributes are set to <code>false</code> , the property will be non-writable, undeletable, and immutable. </li></ul><br><h2>  <font color="#3AC1EF">Work with descriptors</font> </h2><br>  Now that we are familiar with the attributes, we will ask ourselves how we can influence them.  In JavaScript, there are special functions designed to work with property descriptors.  Let's talk about them. <br><br><h3>  <font color="#3AC1EF">Object Method Object.getOwnPropertyDescriptor ()</font> </h3><br>  We have already met with this method.  He, accepting object and a name of its property, returns either <code>undefined</code> , or object with a property descriptor. <br><br><h3>  <font color="#3AC1EF">Object Method Object.defineProperty ()</font> </h3><br>  This is a static <code>Object</code> method that allows you to add properties to objects or change existing properties.  It takes three arguments — an object, a property name, and an object with a handle.  This method returns a modified object.  Consider an example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {}; <span class="hljs-comment"><span class="hljs-comment">// #1 Object.defineProperty(obj, 'id', { value: 42 }); // #2 console.log(obj); // =&gt; { } // #3 console.log(obj.id); // =&gt; 42 // #4 Object.defineProperty(obj, 'name', { value: 'Arfat', writable: false, enumerable: true, configurable: true }); // #5 console.log(obj.name); // =&gt; 'Arfat' // #6 obj.name = 'Arfat Salman' // #7 console.log(obj.name); // =&gt; 'Arfat' // (а не 'Arfat Salman') Object.defineProperty(obj, 'lastName', { value: 'Salman', enumerable: false, }); console.log(Object.keys(obj)); // =&gt; [ 'name' ] // #8 delete obj.id; // #9 console.log(obj.id); // =&gt; 42 //#10 Object.defineProperties(obj, { property1: {   value: 42,   writable: true }, property2: {} }); console.log(obj.property1) // =&gt; 42</span></span></code> </pre> <br>  It can be run in the Node.js environment.  The code is quite large, but, in fact, it is quite simple.  Let us analyze it, focusing on the comments of the form <code>// #n</code> . <br><br>  In fragment <code>#1</code> we use the <code>defineProperty</code> function, passing it an <code>obj</code> object, the name of the <code>id</code> property and a descriptor object that contains only the <code>value</code> property, indicating that the value [ <code>42</code> <code>[[Value]]</code> will be written to the <code>[[Value]]</code> attribute.  Remember that if you do not pass values ​​for attributes like <code>[[Enumerable]]</code> or <code>[[Configurable]]</code> in this object, they will be set to <code>false</code> by default.  In this case, the <code>[[Writable]]</code> , <code>[[Enumerable]]</code> and <code>[[Configurable]]</code> attributes of <code>id</code> set to <code>false</code> . <br><br>  In the place marked as <code>#2</code> , we are trying to output a string representation of the object to the console.  Since its <code>id</code> property is not enumerable, it will not be displayed.  At the same time, the property exists, which proves its successful output by command <code>#3</code> . <br><br>  Creating an object (fragment <code>#4</code> ), we set the complete list of attributes.  In particular, we set <code>[[Writable]]</code> to <code>false</code> . <br><br>  With commands <code>#5</code> and <code>#7</code> we display the value of the <code>name</code> property.  But between them (fragment <code>#6</code> ) we tried to change this value.  This operation did not change the value of a property, because its <code>[[Writable]]</code> attribute is set to <code>false</code> .  As a result, both commands output the same to the console. <br><br>  Command <code>#8</code> is an attempt to delete the <code>id</code> property.  Recall that its <code>[[Configurable]]</code> attribute is set to <code>false</code> , which means that you cannot delete it.  This is proved by team <code>#9</code> . <br><br>  Slice <code>#10</code> shows the use of the <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties">Object.defineProperties ()</a> function.  It works in the same way as the <code>defineProperty()</code> function, but allows, in one call, to affect several properties of an object, while <code>defineProperty()</code> works with only one property of an object. <br><br><h2>  <font color="#3AC1EF">Protection of objects</font> </h2><br>  Periodically, the developer needs to protect objects from outside interference.  For example, given the flexibility of JavaScript, it is very easy to mistakenly change the properties of an object, which should not change.  There are three main ways to protect objects. <br><br><h3>  <font color="#3AC1EF">Object Method Object.preventExtensions ()</font> </h3><br>  The <code>Object.preventExtensions()</code> method prevents the object from expanding, that is, adding new properties to it.  It takes an object and makes it non-expandable.  Note that you can delete properties from such an object.  Consider an example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.preventExtensions(obj); obj.name = <span class="hljs-string"><span class="hljs-string">'Arfat'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj); <span class="hljs-comment"><span class="hljs-comment">// =&gt; { id: 42 }</span></span></code> </pre> <br>  To find out if an object is non-extensible, you can use the <code>Object.isExtensible()</code> method.  If it returns <code>true</code> , then new properties can be added to the object. <br><br><h3>  <font color="#3AC1EF">Object Method Object.seal ()</font> </h3><br>  The <code>seal()</code> method “seals” objects.  This is what it is about: <br><br><ul><li>  Its use prevents new properties from being added to the object (in this it is similar to <code>Object.preventExtensions()</code> ). </li><li>  It makes all existing properties of the object non-configurable. </li><li>  Values ​​of existing properties, if their <code>[[Writable]]</code> attribute is not set to <code>false</code> , can be changed. </li></ul><br>  As a result, it turns out that this method prevents the addition of new properties to the object and the deletion of existing properties in it. <br><br>  Consider an example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.seal(obj); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> obj.id <span class="hljs-comment"><span class="hljs-comment">// (не работает) obj.name = 'Arfat'; // (не работает) console.log(obj); // =&gt; { id: 42 } Object.isExtensible(obj); // =&gt; false Object.isSealed(obj); //=&gt; true</span></span></code> </pre> <br>  To check whether an object is “sealed” or not, you can use the <code>Object.isSealed()</code> method. <br><br><h3>  <font color="#3AC1EF">Object Method Object.freeze ()</font> </h3><br>  The <code>freeze()</code> method allows you to “freeze” objects, equipping them with the maximum possible JavaScript level of protection.  Here is how it works: <br><br><ul><li>  “Seals” an object using <code>Object.seal()</code> . </li><li>  Completely prohibits the modification of any existing properties of the object. </li><li>  Forbids modification of property descriptors. </li></ul><br>  Here is an example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.freeze(obj); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> obj.id <span class="hljs-comment"><span class="hljs-comment">// (не работает) obj.name = 'Arfat'; // (не работает) console.log(obj); // =&gt; { id: 42 } Object.isExtensible(obj); // =&gt; false Object.isSealed(obj); //=&gt; true Object.isFrozen(obj); // =&gt; true</span></span></code> </pre> <br>  You can check whether an object is “frozen” by using the <code>Object.isFrozen()</code> method. <br><br><h3>  <font color="#3AC1EF">▍ Overview of methods used to protect objects</font> </h3><br>  It is important to note that the methods described above, used to protect objects, affect only their properties, which are not objects. <br><br>  Here is a summary table on the considered methods of protection of objects, which is taken <a href="https://github.com/piecioshka/test-freeze-vs-seal-vs-preventExtensions">from here</a> . <br><table><tbody><tr><td></td><td>  Property creation <br></td><td>  Reading property <br></td><td>  Property rewrite <br></td><td>  Property removal <br></td></tr><tr><td> <code>Object.freeze()</code> <br> </td><td>  - </td><td>  + <br></td><td>  - </td><td>  - </td></tr><tr><td> <code>Object.seal()</code> <br> </td><td>  - </td><td>  + <br></td><td>  + <br></td><td>  - </td></tr><tr><td> <code>Object.preventExtensions()</code> <br> </td><td>  - </td><td>  + <br></td><td>  + <br></td><td>  + <br></td></tr></tbody></table><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  Considering how often objects are used in JavaScript code, it is important for each developer to know how they work.  We hope that what you have learned by reading this material will be useful to you.  In addition, now you know the answers to the questions listed at the beginning of the article. <br><br>  <b>Dear readers!</b>  How do you protect JavaScript objects? <br><br><div style="text-align:center;"> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div>