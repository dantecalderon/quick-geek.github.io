<div class="post__text post__text-html js-mediator-article">  Stones of ancient temples can talk, but few listen to them.  The universe is filled with sounds that we humans do not hear;  colors that we don’t see: sometimes it’s about the objective limitations of the body and spirit, but there are also subjective reasons - lack of knowledge and skills or the inability to use them in everyday practice.  A vivid example of the second in the world of programming is function signatures.  At best, children of an OO world think in interfaces — this is close, but “not quite that,” and the more attentive you become, the more it turns into “not at all”.  And function signatures also know how to talk. <br><a name="habracut"></a><br>  Honestly, I would like to start from truly high-level abstractions, but my previous experience shows that even the simplest mathematical truths in non-mathematical language “do not sound”.  Only incidentally I will note that everything that I am talking about is born of mathematical thought - and, accordingly, can be strictly formalized. <br>  And now - specifics.  Probably, all more or less “rummaging” have bothered to read the epoch-making work of GoF at least once;  Probably, even the “non-aging” ones know that there is such a pattern - the iterator.  And certainly everyone uses it every day.  So (holding on to conditional C #): <br><br><pre><code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">MoveNext</span></span>(); <span class="hljs-selector-tag"><span class="hljs-selector-tag">T</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Current</span></span> { get; }</code> </pre> <br>  ... and now the same thing, but without syntactic noise (it is significant that in fact "without syntactic noise" means on Haskell'e): <br><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">MoveNext</span></span> :: () -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> <span class="hljs-type"><span class="hljs-type">Current</span></span> :: () -&gt; t</code> </pre><br>  ... forgetting for a while about the types and focusing on the arrow itself (-&gt;), one involuntarily comes to the question of what will happen if it is “reversed”?  Then it will turn out: <br><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">MoveNext'</span></span> :: <span class="hljs-type"><span class="hljs-type">Bool</span></span> -&gt; () <span class="hljs-type"><span class="hljs-type">Current'</span></span> :: t -&gt; ()</code> </pre><br>  A slight sensation of disharmony, yes?  If there are no problems with <i>t -&gt; ()</i> , then <i>Bool -&gt; ()</i> looks more than suspicious.  And really - this flag was used to signal the end of the sequence, right?  In the inverted form, the case of <i>True -&gt; ()</i> has no useful meaning - only <i>False -&gt; ()</i> is sufficient.  The binary uncertainty that the Bool type provides is lost - and therefore it should look like this: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">completed</span></span> :: () -&gt; () next :: t -&gt; ()</code> </pre><br>  Nothing like?  How about <a href="https://docs.microsoft.com/en-us/dotnet/api/system.iobserver-1%3Fview%3Dnetframework-4.7.2">reactive extensions</a> ? <br>  Wow!  The signature (well, more precisely, signatures, but the approach itself works on an individual level) the functions of one (almost) classy (mini) framework told us about another not less steep one, yes?  You just need to be attentive and hear. <br><br><div class="spoiler">  <b class="spoiler_title">Good news to the world from category theory</b> <div class="spoiler_text">  Who in the subject, of course, knows that the example with IEnumerator &lt;-&gt; IObserver is not new. <br>  It is surprising that rarely anyone is aware that this is not the only example (although we must pay tribute, specifically this one is very bright). <br><br>  Curious can take the remaining GoF patterns and look at their duals.  Quite often, sheer nonsense will be obtained - this is normal: the “duality” itself is higher than the earthly world and does not consider itself obliged to reckon with practical benefits: but then the Sun does not need anything from people to shine. <br></div></div><br>  Why, then, "almost cool"?  Yes, because of the disharmony, which entailed the need for additional grinding and polishing.  Strictly speaking, turning the arrows back, it turned out something not quite useful, which can be interpreted as a disadvantage of the original signature.  Looking ahead, I can say that this very signature can be redefined in such a way that disharmony disappears and it will be enough just to turn to its dual.  But I won't bother with this ... at least not in this note. <br><br>  Better to sum up, based entirely on my experience: <br><br><ol><li>  Function signatures can talk, but programmers often remain deaf. </li><li>  Every time you meet a well-designed function, ask yourself what its dual is and if it could be useful for any tasks. </li><li>  If a dual exists, but requires a “light modification” as in the example above, then most likely the original signature has some implicit defects;  maybe it makes sense to redefine it so that there is no such problem? </li></ol></div>