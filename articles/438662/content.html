<div class="post__text post__text-html js-mediator-article">  In 2007, I wrote a <a href="https://github.com/skeeto/binitools">couple of</a> modding <a href="https://github.com/skeeto/binitools">tools</a> for the <a href="https://en.wikipedia.org/wiki/Freelancer_(video_game)">Freelancer</a> space simulator.  Game resources are stored in “binary INI” or “BINI” format.  Probably, the binary format was chosen for the sake of performance: such files are faster to download and read than arbitrary text in the INI format. <br><br>  Most of the game content can be edited directly from these files, changing the names, prices of goods, statistics of space ships, or even adding new ships.  Binary files are difficult to modify directly, so the natural approach is to convert them to text INI, make changes in a text editor, then convert back to BINI format and replace the files in the game directory. <br><a name="habracut"></a><br>  I have not analyzed the BINI format, and I am not the first to learn how to edit them.  But I did not like the existing tools, and I had my own vision of how they should work.  I prefer the Unix-style interface, although the game itself runs under Windows. <br><br>  At that time, I was just introduced to the <a href="http://pubs.opengroup.org/onlinepubs/9699919799/utilities/yacc.html">yacc</a> (actually <a href="https://www.gnu.org/software/bison/">Bison</a> ) and <a href="http://pubs.opengroup.org/onlinepubs/9699919799/utilities/lex.html">lex</a> (actually <a href="https://github.com/westes/flex">flex</a> ) tools, as well as Autoconf, so I used them.  It was interesting to try out these utilities in action, although I slavishly imitated other open source projects, not understanding why everything was done in such a way.  Due to the use of yacc / lex and the creation of configuration scripts, a full-fledged Unix-like system was required.  This is all seen in the <a href="https://github.com/skeeto/binitools/tree/original">original version of the programs</a> . <br><br>  The project turned out to be quite successful: I myself successfully used these tools, and they appeared in various collections for Freelancer modding. <br><br><h1>  Refactoring </h1><br>  In mid-2018, I returned to this project.  Have you ever looked at your old code with the thought: what did you even think about?  My INI format turned out to be much tougher and more rigorous than necessary, the recording of the binaries was dubious, and the build did not even work properly. <br><br>  Thanks to ten years of extra experience, I knew for sure that now I will write these tools much better.  And I did it in a few days, rewriting them from scratch.  In the master branch on Github now lies this new code. <br><br>  <a href="https://nullprogram.com/blog/2017/03/30/">I like to do everything as easy as possible</a> , so I got rid of autoconf in favor of a <a href="https://nullprogram.com/blog/2017/08/20/">simpler and portable Makefile</a> .  There is no longer any yacc or lex, and the parser is written by hand.  Only the appropriate, portable C is used. The result is so simple that I put together a project with one short command <a href="https://nullprogram.com/blog/2016/06/13/">from Visual Studio</a> , so the Makefile is not so necessary.  If you replace <code>stdint.h</code> with <code>typedef</code> , you can even <a href="https://nullprogram.com/blog/2018/04/13/">build and run binitools under DOS</a> . <br><br>  The new version is faster, more compact, cleaner and simpler.  It is much more flexible in terms of INI input, so it is easier to use.  But is it more correct? <br><br><h1>  Fuzzing </h1><br>  I have been interested in <a href="https://labs.mwrinfosecurity.com/blog/what-the-fuzz/">fuzzing for</a> many years, especially <a href="http://lcamtuf.coredump.cx/afl/">afl</a> (american fuzzy lop).  But he did not master it, although he tested some tools that I regularly use.  But fuzzing didn't find anything remarkable, at least before I gave up.  I tested my JSON library and for some reason also did not find anything.  It's clear that my JSON parser could not be <i>so</i> reliable, right?  But fuzzing showed nothing.  (As it turned out, my JSON library is still pretty reliable, thanks in large part to the efforts of the community!) <br><br>  But now I have a relatively new INI parser.  Although he can successfully analyze and correctly assemble the initial set of BINI files in the game, his functionality <i>has</i> not <i>really</i> been tested.  Surely here fuzzing will find something.  In addition, to run afl on this code, you do not need to write a single line.  The default tools work with standard input, which is ideal. <br><br>  Assuming you have the necessary tools installed (make, gcc, afl), here’s how easy the fuzzing binitools run: <br><br><pre> <code class="bash hljs">$ make CC=afl-gcc $ mkdir <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> out $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'[x]'</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>/empty $ afl-fuzz -i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> -o out -- ./bini</code> </pre> <br>  The <code>bini</code> utility accepts INI input and issues a BINI, so it is much more interesting to check it than the reverse <code>unbini</code> procedure.  Since <code>unbini</code> analyzes relatively simple binary data, (probably) the fuzzer has nothing to look for.  However, I just checked anyway. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/483/089/6dc/4830896dc68da2e5559c899429235f95.png"><br><br>  In this example, I changed the default compiler to the GCC shell for afl ( <code>CC=afl-gcc</code> ).  Here, afl calls GCC in the background, but adds its own toolkit to the binary.  With fuzzing, <code>afl-fuzz</code> uses this tool to monitor the program execution path.  <a href="http://lcamtuf.coredump.cx/afl/technical_details.txt">The afl documentation</a> explains the technical details. <br><br>  I also created input and output directories, putting a minimum working example in the input directory that gives afl a starting point.  At startup, it mutates the input queue and monitors changes during program execution.  The output directory contains the results and, more importantly, the corpus of input data that cause unique execution paths.  In other words, a lot of inputs are processed at the output of a fuzzer, testing many different border scenarios. <br><br>  The most interesting and terrible result - a complete failure of the program.  When I first launched fuzzer for binitools, <code>bini</code> found <i>many</i> such failures.  Within a few minutes, afl discovered a number of subtle and interesting bugs in my program, which was incredibly useful.  Phazzer found even an unlikely <a href="https://github.com/skeeto/binitools/commit/b695aec7d0021299cbd83c8c6983055f16d11507">bug of an obsolete pointer</a> , checking the different order of different allocations of memory.  This particular bug was a turning point that made me realize the value of fuzzing. <br><br>  Not all errors found led to crashes.  I also examined the issue and looked at which inputs yielded a successful result, and which did not, and watched as the program handled various extreme cases.  She rejected some input that I thought she would handle.  Conversely, she processed some data that I considered to be incorrect, and interpreted some data in an unexpected way.  So even after fixing bugs with program crashes, I still changed the parser settings to fix each of these unpleasant incidents. <br><br><h1>  Creating a test suite </h1><br>  As soon as I corrected all the errors detected by the fuzzer and set up the work of the parser in all border situations, I made a set of tests from the fuzzer data case - although not directly. <br><br>  First, I ran a fuzzer in parallel — this process is explained in the afl documentation — so I got a lot of redundant input data.  By redundancy, I mean that the input data is different, but have the same execution path.  Fortunately, afl has a tool to deal with this: <code>afl-cmin</code> , a body minimization tool.  It eliminates the extra inputs. <br><br>  Secondly, many of these inputs were longer than necessary to call their unique execution path.  Here helped <code>afl-tmin</code> , a minimizer of test cases, which reduced the test case. <br><br>  I separated valid and invalid input - and checked it in the repository.  Take a look at all these stupid entrances <a href="https://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html">invented by the fuzzer</a> , based on a single minimum entry: <br><br><ul><li>  <a href="https://github.com/skeeto/binitools/tree/master/tests/valid">valid input</a> <br></li><li>  <a href="https://github.com/skeeto/binitools/tree/master/tests/invalid">invalid input</a> </li></ul><br>  In fact, here the parser is frozen in one state, and the test suite ensures that a particular build behaves in a <i>very</i> specific way.  This is especially useful for ensuring that builds made by other compilers on other platforms really behave the same to their output.  My test suite even revealed an error in the dietlibc library because binitools did not pass the tests after binding to it.  If it were necessary to make non-trivial changes to the parser, then in fact I would have to abandon the current test suite and start all over again, so that afl generates a whole new package for the new parser. <br><br>  Of course, fuzzing has proven itself as a powerful technique.  He found a number of errors that I could never discover on my own.  Since then, I have become more competent to use it for testing other programs - not just my own - and have found many new bugs.  Now, fuzzer has taken a permanent place among the tools in my developer kit. </div>