<div class="post__text post__text-html js-mediator-article">  No one will deny that Composer is quite a handy tool, and that there are free or cheap hosting services that do not provide any console or built-in tool for working with Composer.  That's exactly the kind of stack I encountered.  Well, as the Jedi bequeathed, <b>vendor is</b> immediately added to <b>.gitignore</b> so as not to clutter up the repository and not to drive libraries to and from there. <br><br>  The first thing that came to mind was to make the script available from the Web, which can be pulled at the right time and it will update the dependencies or install them. <br><a name="habracut"></a><br>  For this we need to carry out some manipulations. <br><br>  1. To install the composer locally, we <a href="">need to download <b>composer.phar</b></a> . <br><br>  2. Create a folder where it will be unpacked (let it be <b>var</b> ). <br><br>  3. Create <b>composer.json</b> (well, I think about this you already know if you worked with composer). <br><br>  4. Well, create the script itself to work with the composer from the Web (let it be <b>composer.php</b> ). <br><br>  So we have the structure of our future site: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/484/127/544/484127544170fe43a28a9e3b4dde854b.png" alt="Site structure"><br><br>  <b>Composer.phar itself</b> will be as follows: <br><br><pre><code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Composer</span></span>\<span class="hljs-title"><span class="hljs-title">Console</span></span>\<span class="hljs-title"><span class="hljs-title">Application</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Symfony</span></span>\<span class="hljs-title"><span class="hljs-title">Component</span></span>\<span class="hljs-title"><span class="hljs-title">Console</span></span>\<span class="hljs-title"><span class="hljs-title">Input</span></span>\<span class="hljs-title"><span class="hljs-title">ArrayInput</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Symfony</span></span>\<span class="hljs-title"><span class="hljs-title">Component</span></span>\<span class="hljs-title"><span class="hljs-title">Console</span></span>\<span class="hljs-title"><span class="hljs-title">Output</span></span>\<span class="hljs-title"><span class="hljs-title">StreamOutput</span></span>; <span class="hljs-comment"><span class="hljs-comment">//Уберём лимиты, чтоб скрипт не отвалился раньше времени ini_set("memory_limit", -1); ini_set("max_execution_time", 0); //Корень проекта $root = __DIR__ . "/../"; //Папка для разархивирования $dir = "{$root}/var"; //Смотрим если Phar архив еще не распакован, то распакуем его if (file_exists("{$dir}/vendor/autoload.php") === false) { $composerPhar = new Phar("{$root}/composer.phar"); $composerPhar-&gt;extractTo($dir); } //Подключим автолоадер для использования классов композера require_once("{$dir}/vendor/autoload.php" . ''); //Обьявим переменную окружения чтоб обозначить где хранится сам композер putenv("COMPOSER_HOME={$dir}/bin/composer"); //Изменим папку на корень чтоб vendor хранился на том же уровне что и WebRoot chdir($root); //Подготавливаем комманду установки $input = new ArrayInput(['command' =&gt; 'install']); //Создаем вывод в стрим $stream = fopen('php://temp', 'w+'); $output = new StreamOutput($stream); //Запускаем "консольное" приложение $application = new Application(); $application-&gt;setAutoExit(false); $application-&gt;run($input, $output); //А тут должен быть вывод echo stream_get_contents($stream);</span></span></code> </pre> <br><br>  And if you are a thrill.  Then after calling the script, it will expand the <b>vendor</b> folder. <br><br>  But I didn’t <b>turn</b> out to be this way) The first thing that broke my plans was setting <b>phar.readonly = On</b> in <b>php.ini</b> , and you guessed it on free hosting, you usually don’t edit it.  Then I started looking for workarounds. <br><br>  The first thing I tried was to create a <b>user.ini</b> which would override the settings in <b>php.ini</b> , on the local machine worked) But on the hosting this functionality was stabbed. <br><br>  Then I tried to use another trick.  Rename <b>composer.phar</b> to just <b>composer</b> , the result is the same.  On LAN worked, on the hosting - no. <br><br>  Then I had to unpack the <b>var</b> files locally instead of the script and upload them to the server. <br><br>  Also it is necessary to close the script by authorization, so that any person will not call it.  Also in the final version of the script I added the choice of the command through the parameters. <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Composer</span></span>\<span class="hljs-title"><span class="hljs-title">Console</span></span>\<span class="hljs-title"><span class="hljs-title">Application</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Symfony</span></span>\<span class="hljs-title"><span class="hljs-title">Component</span></span>\<span class="hljs-title"><span class="hljs-title">Console</span></span>\<span class="hljs-title"><span class="hljs-title">Input</span></span>\<span class="hljs-title"><span class="hljs-title">ArrayInput</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Symfony</span></span>\<span class="hljs-title"><span class="hljs-title">Component</span></span>\<span class="hljs-title"><span class="hljs-title">Console</span></span>\<span class="hljs-title"><span class="hljs-title">Output</span></span>\<span class="hljs-title"><span class="hljs-title">BufferedOutput</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Symfony</span></span>\<span class="hljs-title"><span class="hljs-title">Component</span></span>\<span class="hljs-title"><span class="hljs-title">Console</span></span>\<span class="hljs-title"><span class="hljs-title">Output</span></span>\<span class="hljs-title"><span class="hljs-title">OutputInterface</span></span>; <span class="hljs-comment"><span class="hljs-comment">//Уберём лимиты, чтоб скрипт не отвалился раньше времени ini_set("memory_limit", -1); ini_set("max_execution_time", 0); //Негоже в Web хранить скрипты не закрытые паролем, чтоб кто-то посторонний мог их вызвать if (isset($_SERVER['HTTP_AUTHORIZATION']) AND !empty($_SERVER['HTTP_AUTHORIZATION'])) { list($_SERVER['PHP_AUTH_USER'], $_SERVER['PHP_AUTH_PW']) = explode(':', base64_decode(substr($_SERVER['HTTP_AUTHORIZATION'], 6)), 2); } elseif (isset($_SERVER['REDIRECT_HTTP_AUTHORIZATION']) AND !empty($_SERVER['REDIRECT_HTTP_AUTHORIZATION'])) { list($_SERVER['PHP_AUTH_USER'], $_SERVER['PHP_AUTH_PW']) = explode(':', base64_decode(substr($_SERVER['REDIRECT_HTTP_AUTHORIZATION'], 6)), 2); } //Детали для авторизации, не забудьте поменять на что-то более секьюрное $config = [ 'user' =&gt; 'admin', 'password' =&gt; 'admin', ]; //Пускаем или не пускаем пользователя дальше if ((isset($_SERVER['PHP_AUTH_USER']) &amp;&amp; $_SERVER['PHP_AUTH_USER'] == $config['user'] &amp;&amp; isset($_SERVER['PHP_AUTH_PW']) &amp;&amp; $_SERVER['PHP_AUTH_PW'] == $config['password'])) { unset($_SERVER['PHP_AUTH_USER']); unset($_SERVER['PHP_AUTH_PW']); } else { $uniqueID = uniqid(); header("WWW-Authenticate: Basic realm='{$uniqueID}'"); header('HTTP/1.0 401 Unauthorized'); exit(); } //Корень проекта $root = realpath(__DIR__ . "/../"); //Папка для разархивирования $dir = "{$root}/var"; //Смотрим если Phar архив еще не распакован, то распакуем его if (file_exists("{$dir}/vendor/autoload.php") === false) { $composerPhar = new Phar("{$root}/composer.phar"); $composerPhar-&gt;extractTo($dir); } //Подключим автолоадер для использования классов композера require_once("{$dir}/vendor/autoload.php" . ''); //Обьявим переменную окружения чтоб обозначить где хранится сам композер putenv("COMPOSER_HOME={$dir}/bin/composer"); //Изменим папку на корень чтоб vendor хранился на том же уровне что и WebRoot chdir($root); //Не очень то хорошо, но будем надеятся что пароль знает только человек который знает что он делает, и делает это во имя добра) //По умолчанию composer update, так как он используется чаще чем ?command=install $params = !empty($_GET) ? $_GET : ['command' =&gt; 'update']; //Подготавливаем комманду установки. $input = new ArrayInput($params); //Создаем вывод в стрим $output = new BufferedOutput( OutputInterface::VERBOSITY_NORMAL //true ); //Запускаем "консольное" приложение $application = new Application(); $application-&gt;setAutoExit(false); $application-&gt;run($input, $output); $content = $output-&gt;fetch(); echo "&lt;pre&gt;"; //А тут должен быть вывод echo $content; echo "&lt;br&gt;"; echo (file_exists("{$root}/vendor/autoload.php")) ? 'Autoload &lt;b&gt;installed&lt;/b&gt;' : 'Autoload &lt;b&gt;Missing&lt;/b&gt;';</span></span></code> </pre> <br>  It also does not hurt to add a rule to <b>.htaccess</b> for forwarding an authorization header (in the case of CGI) and a redirect to HTTPS, since the authorization goes in clear text. <br><br><pre> <code class="apache hljs"><span class="hljs-attribute"><span class="hljs-nomarkup"><span class="hljs-attribute"><span class="hljs-nomarkup">RewriteEngine</span></span></span></span> <span class="hljs-literal"><span class="hljs-literal">On</span></span> #Если у вас CGI, то заголовок авторизации потеряется, поэтому нужно его принудительно добавить RewriteRule .* -<span class="hljs-meta"><span class="hljs-meta"> [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}] #Переадресация на HTTPS, так как авторизация уходит в незашифрованном виде RewriteCond %{HTTPS} off RewriteCond %{HTTP:SSL} !=1 [NC] RewriteRule .* https://%{HTTP_HOST}%{REQUEST_URI} [R=302,L]</span></span></code> </pre> </div>