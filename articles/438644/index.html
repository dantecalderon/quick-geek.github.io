<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Security of machine learning algorithms. Protect and test models using Python</title>
  <meta name="description" content="In the previous article, we talked about such a machine learning problem as Adversarial examples and some types of attacks that allow them to be gener...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Security of machine learning algorithms. Protect and test models using Python</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/wo/o_/u2/woo_u2i8ll_fqrqvt3o-typrlue.jpeg" alt="image"></p><br><p>  <a href="https://habr.com/ru/company/dsec/blog/437092/">In the previous article,</a> we talked about such a machine learning problem as Adversarial examples and some types of attacks that allow them to be generated.  This article will discuss algorithms for protection against this kind of effect and recommendations for testing models. </p><a name="habracut"></a><br><h2 id="zaschita">  Protection </h2><br><p>  First of all, let us immediately explain one thing - it is impossible to fully defend oneself against such an effect, and this is quite natural.  After all, if we solved the problem of Adversarial examples completely, then we would simultaneously solve the problem of constructing an ideal hyperplane, which, naturally, cannot be done without having a general body of data. </p><br><p>  To protect the model of the machine can be in two stages: </p><br><p>  <strong>Training</strong> - we train our algorithm to respond correctly to Adversarial examples. </p><br><p>  <strong>Operation</strong> - we are trying to detect an Adversarial example during the operation phase of the model. </p><br><p>  Immediately it should be said that you can work with the protection methods presented in this article using the <a href="https://github.com/IBM/adversarial-robustness-toolbox">Adversarial Robustness Toolbox</a> from IBM. </p><br><h3 id="adversarial-training">  Adversarial Training </h3><br><p><img src="https://habrastorage.org/webt/4w/t_/lm/4wt_lmm-cbcdye9rabryki0jj70.png" alt="image"></p><br><p>  If you ask a person who has just become familiar with the problem of Adversarial examples, the question: "How can you protect yourself from this effect?", Then certainly 9 out of 10 people will say: "Let's add the generated objects to the training set."  This approach was immediately proposed in the article <a href="https://arxiv.org/pdf/1312.6199.pdf">Intriguing properties of neural networks</a> as early as 2013.  It is in this article that this problem was first described and the L-BFGS attack, which allows to get Adversarial examples. </p><br><p>  This method is very simple.  We generate Adversarial examples using various kinds of attacks and add them to the training sample at each iteration, thereby increasing the "resistance" of the Adversarial model to examples. </p><br><p>  The disadvantage of this method is quite obvious: at each iteration of training, for each example we can generate a very large number of examples, respectively, and the time for training the model increases many times. </p><br><p>  You can apply this method using the ART-IBM library as follows. </p><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> art.defences.adversarial_trainer <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> AdversarialTrainer trainer = AdversarialTrainer(model, attacks) trainer.fit(x_train, y_train)</code> </pre> <br><h3 id="gaussian-data-augmentation">  Gaussian Data Augmentation </h3><br><p><img src="https://habrastorage.org/webt/jf/9d/ko/jf9dkoia9fom1rtqkvgwe-7aulo.png" alt="image"></p><br><p>  The following method, described in the article <a href="https://arxiv.org/pdf/1707.06728.pdf">Efficient Defenses Against Adversarial Attacks</a> , uses similar logic: he also suggests adding additional objects to the training set, but unlike Adversarial Training these objects are not Adversarial examples, but slightly noisy objects of the training set (Gaussian noise, hence the name of the method).  And, indeed, it seems very logical, because the main problem of the models is precisely the poor resistance to noise. </p><br><p>  This method shows results similar to Adversarial Training, while spending much less time generating objects for training. </p><br><p>  You can apply this method using the GaussianAugmentation class in ART-IBM. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> art.defences.gaussian_augmentation <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> GaussianAugmentation GDA = GaussianAugmentation() new_x = GDA(x_train)</code> </pre> <br><h3 id="label-smoothing">  Label Smoothing </h3><br><p>  The Label Smoothing method is very simple to implement, but nonetheless carries a lot of probabilistic meaning.  We will not go into details of the probabilistic interpretation of this method; you can find it in the original article <a href="https://arxiv.org/pdf/1512.00567.pdf">Rethinking the Inception Architecture for Computer Vision</a> .  But, to say briefly about this, Label Smoothing is an additional type of regularization of the model in the classification problem, which makes it more resistant to noise. </p><br><p>  In fact, this method smoothes class labels.  Making them, say, not 1, but 0.9.  Thus, when training, models are penalized for a very large "confidence" in the label for a particular object. </p><br><p>  The application of this method in Python can be seen below. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> art.defences.label_smoothing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> LabelSmoothing LS = LabelSmoothing() new_x, new_y = LS(train_x, train_y)</code> </pre> <br><h3 id="bounded-relu">  Bounded relu </h3><br><p><img src="https://habrastorage.org/webt/dw/mw/sz/dwmwszowk1t9l6byacxcscvmvh4.png" alt="image"></p><br><p>  When we talked about attacks, many may have noticed that some attacks (JSMA, OnePixel) depend on how strong the gradient is at one point or another in the input image.  With this task, the Bounded ReLU method is trying to fight the simple and ‚Äúcheap‚Äù (in terms of computational and time costs). </p><br><p>  The essence of the method is as follows.  Let's replace the activation function of the ReLU in the neural network with the same, but limited not only from below, but also from above, thus we smooth the gradient maps, and at specific points it will not be possible to get a splash, which will not allow changing the one pixel of the image to deceive the algorithm. </p><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot; />" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="0" height="0.25ex" viewBox="0 -53.9 0 107.7" role="img" focusable="false" style="vertical-align: -0.125ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"></script></p><br>  \ begin {equation *} f (x) = <br>  \ begin {cases} <br>  0, x &lt;0 <br>  \\ <br>  x, 0 \ leq x \ leq t <br>  \\ <br>  t, x&gt; t <br>  \ end {cases} <br>  \ end {equation *} <p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot; />" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="0" height="0.25ex" viewBox="0 -53.9 0 107.7" role="img" focusable="false" style="vertical-align: -0.125ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-2"></script></p><br><p>  This method was also described in the article <a href="https://arxiv.org/pdf/1707.06728.pdf">Efficient Defenses Against Adversarial Attacks</a> </p><br><h3 id="postroenie-ansambley-modeley">  Building Model Ensembles </h3><br><p><img src="https://habrastorage.org/webt/cq/2i/pg/cq2ipgeru_vavdrnk-usoydtlxw.png" alt="image"><br>  It is not difficult to deceive one trained model.  It is even more difficult to deceive two models at the same time with one object.  And if such models N?  This is the basis of the model ensemble method.  We simply build N different models and aggregate their output into a single answer.  If the models are also represented by different algorithms, then it is extremely possible to deceive such a system, but it is extremely difficult! </p><br><p>  It is quite natural that the implementation of model ensembles is a purely architectural approach that asks many questions (What are the basic models to take? How to aggregate the outputs of the basic models? Is there a relationship between the models? And so on.).  It is for this reason that this approach is not implemented in ART-IBM. </p><br><h3 id="feature-squeezing">  Feature squeezing </h3><br><p><img src="https://habrastorage.org/webt/sn/wy/wp/snwywpuqqae7pun4njrlmluseeg.png" alt="image"><br>  This method, described in the article <a href="https://arxiv.org/pdf/1704.01155.pdf">Feature Squeezing: Detecting Adversarial Examples in Deep Neural Networks</a> , works during the model operation phase.  It allows to detect Adversarial examples. </p><br><p>  The idea behind this method is as follows: if we train n models on the same data, but with different degrees of compression, then the results of their work will still be similar.  At the same time, the Adversarial example that works on the source network is likely to fail on additional networks.  Thereby, considering the pairwise difference of the outputs of the original neural network and additional ones, choosing the maximum from them and comparing it with a pre-selected threshold, we will be able to assert that the input object is either Adversarial or absolutely valid. </p><br><p>  Below is a method to get compressed objects using ART-IBM. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> art.defences.feature_squeezing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> FeatureSqueezing FS = FeatureSqueezing() new_x = FS(train_x)</code> </pre> <br><p>  This concludes the protection methods.  But it would be wrong not to understand one important point.  If an attacker does not have access to the input and output of the model, he will not understand how the raw data is processed inside your system before entering the model.  Then and only then all his attacks will be reduced to a random search of input values, which of course is unlikely to lead to the desired result. </p><br><h2 id="testirovanie">  Testing </h2><br><p>  Now let's talk about testing algorithms to counter Adversarial examples.  Here, first of all, it is necessary to understand how we will test our model.  If we assume that in some way an attacker can get full access to the entire model, then our model should be tested using WhiteBox attacks. <br><img src="https://habrastorage.org/webt/vj/pm/-w/vjpm-wuwle8c5sngov5ksw5iahq.png" alt="image"></p><br><p>  In another case, we assume that the attacker will never get access to the ‚Äúinsides‚Äù of our model, however, he will be able, though indirectly, to influence the input data and see the result of the model‚Äôs work.  Then you should use the methods of BlackBox attacks. <br><img src="https://habrastorage.org/webt/xc/h9/wo/xch9wo0pweqhlf33pzgrgdiihqm.png" alt="image"></p><br><p>  The general testing algorithm can be described by the following example: </p><br><p><img src="https://habrastorage.org/webt/1d/p_/lx/1dp_lxdocm0zkd2ssmbg_fmnvba.jpeg" alt="image"></p><br><p>  Let there be a trained neural network written in TensorFlow (TF NN).  We expertly argue that our network can fall into the hands of an attacker by entering the system where the model is located.  In this case, we need to conduct WhiteBox attacks.  To do this, we define a pool of attacks and frameworks (FoolBox - FB, CleverHans - CH, Adversarial robustness toolbox - ART), which allow these attacks to be implemented.  After that, considering how many attacks were successful, we calculate the succes rate (SR).  If SR suits us, we end the testing, otherwise we use one of the protection methods, for example, those implemented in ART-IBM.  Then again we carry out attacks and we consider SR.  We do this operation cyclically, as long as SR does not suit us. </p><br><h2 id="vyvody">  findings </h2><br><p>  At this point, I would like to finish with general information about attacks, defenses, and testing machine learning models.  Summarizing the two articles, we can conclude the following: </p><br><ol><li>  You should not believe in machine learning as a kind of miracle that can solve all your problems. </li><li>  Applying machine learning algorithms in your tasks, think about how this algorithm is resistant to such a threat as Adversarial examples. </li><li>  The algorithm can be protected both from the side of machine learning and from the side of the system in which this model is operated. </li><li>  Test your models, especially in cases where the result of the model directly affects the decision </li><li>  Libraries like FoolBox, CleverHans, ART-IBM provide a convenient interface for attacking and protecting machine learning models. </li></ol><br><p>  Also in this article I would like to summarize the work with the FoolBox, CleverHans and ART-IBM libraries: </p><br><p>  FoolBox is a simple and clear library for the use of attacks on neural networks, supporting many different frameworks. </p><br><p>  CleverHans is a library that allows you to conduct attacks by changing the set of parameters of the attack, a little more complicated than FoolBox, it supports fewer frameworks. </p><br><p>  ART-IBM is the only library described above that allows you to work with protection methods, so far only supports TensorFlow and Keras, but it is developing faster than others. </p><br><p>  Here it is worth saying that there is another <a href="https://github.com/baidu/AdvBox">library</a> for working with Adversarial examples from Baidu, but, unfortunately, it is suitable only for people who speak Chinese. </p><br><p>  In the next article on this topic, we will examine part of the task that was proposed to be solved in the course of ZeroNights HackQuest 2018 by deceiving a typical neural network using the FoolBox library. </p></div><p>Source: <a href="https://habr.com/ru/post/438644/">https://habr.com/ru/post/438644/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>