<div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/bj/xy/0n/bjxy0nr4vpbelnmkveqbap8ttz8.jpeg"><br><br>  In the room where the child plays, I installed an additional light in the form of LED tape.  Initially, I planned that I would control the brightness of the tape, it is convenient to adjust the night light.  I already had a Z-Wave 220V dimmer, so it was cheaper to buy a dimmable 12V transformer for 1000r than a special RGBW controller from Fibaro for 5500r. <br><br>  This solution works, but there are downsides: <br><br><ul><li>  Dimming delay </li><li>  You cannot set a very small level of brightness. </li></ul><br>  After a year of use, I decided to make my Z-Wave LED controller, but with an encoder and in the case of a dimmer, for installation in a power socket. <br><br>  The circuit diagram of the device is elementary, the encoder is directly connected to the Z-Uno with 3 pins: pin A, pin B and a button.  Mosfet connects to PWM pinu. <br><br><img src="https://habrastorage.org/webt/19/qo/ud/19qoudd6-mdxnr2wjlgoiyc3to8.png"><br><a name="habracut"></a><br>  Materials and prices: <br><table><tbody><tr><td>  No </td><td>  Material </td><td>  A photo </td><td>  Price </td></tr><tr><td>  one </td><td>  <a href="http://z-uno.z-wave.me/">Z-Wave Z-Uno board</a> </td><td><img src="https://habrastorage.org/webt/rs/tf/ot/rstfotet4fdlx7hykgzzt4lfvz8.png"></td><td>  3500 r </td></tr><tr><td>  2 </td><td>  <a href="http://pdf1.alldatasheet.net/datasheet-pdf/view/311711/IRF/IRLR8729PBF/%2B21QJ3_VGP.aITxUDDvhZlP%2B/datasheet.pdf">MOSFET IRLR8729</a> </td><td><img src="https://habrastorage.org/webt/pc/at/98/pcat98rzamov6dre40fu61uyotu.jpeg"></td><td>  27 r </td></tr><tr><td>  3 </td><td>  <a href="http://mypractic.ru/downloads/pdf/EC11.pdf">Encoder EC11</a> </td><td><img src="https://habrastorage.org/webt/yc/qn/gu/ycqnguemeh31olsprczpbrvdodw.jpeg"></td><td>  50 r </td></tr></tbody></table><br>  The Z-Wave Z-Uno board is programmed in the Arduino environment, the sketch for processing signals from the encoder and controlling mosfets takes only 143 lines of code with comments.  The sketch works as follows: <br><br>  <i>Every 128 microsec, by interruption from the timer, we check which way the wheel is turned; we protect ourselves from bounce by a 4-fold state check.</i>  <i>In the loop, we check the button press, with each press we turn off the tape or turn it on to the previous level of brightness.</i>  <i>Brightness can be set either from the encoder or from a telephone or another Z-Wave switch.</i> <br><br><img src="https://habrastorage.org/webt/uk/sz/nz/uksznzqhs7x7ibrcfuiqbh65mfy.png"><br><br><div class="spoiler">  <b class="spoiler_title">Rotary Dimmer LED Control Code</b> <div class="spoiler_text"><pre><code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PUSH_BUTTON 23 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ENCODER_CHA_PIN 19 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ENCODER_CHB_PIN 20 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LEV_SHIFT 8 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ENCODER_DEBONCE 4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STATE_IDLE 0xFF #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STATE_SKIP 0xFE ZUNO_SETUP_ISR_GPTIMER(gpt_handler); ZUNO_SETUP_CHANNELS(ZUNO_SWITCH_MULTILEVEL(getter, setter)); byte level = 0; byte last_reported_level = 0; byte g_state = STATE_IDLE; byte g_pins = 0; byte g_debounce_time = 0; byte last_push_button_state = HIGH; byte stored_level = 0; dword last_level_changed_time = 0; // Runs every 128 μs void gpt_handler() { byte pins = 0; pins = !digitalRead(ENCODER_CHA_PIN); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(!digitalRead(ENCODER_CHB_PIN)) pins |= 2; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(g_pins == pins) { // Is the state stable? g_debounce_time++; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(g_debounce_time&gt;ENCODER_DEBONCE) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(g_state == STATE_IDLE) { g_state = pins; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(g_state == STATE_SKIP) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(pins == 0) g_state = 0; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">((g_state == 0 &amp;&amp; pins == 1) || (g_state == 1 &amp;&amp; pins == 3) || (g_state == 3 &amp;&amp; pins == 2) || (g_state == 2 &amp;&amp; pins == 0) ) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (level &lt; 39) { level++; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((level + LEV_SHIFT) &lt;= 255) { level += LEV_SHIFT; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((level + LEV_SHIFT) &gt; 255){ level = 255; } } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">((g_state == 0 &amp;&amp; pins == 2) || (g_state == 2 &amp;&amp; pins == 3) || (g_state == 3 &amp;&amp; pins == 1) || (g_state == 1 &amp;&amp; pins == 0) ) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (level &lt;= 39 &amp;&amp; level !=0) { level--; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (level &gt;= LEV_SHIFT) { level -= LEV_SHIFT; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (level &lt; 0) { level = 0; } } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(g_state != pins) g_state = STATE_SKIP; } g_debounce_time = 0; } } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { g_debounce_time = 0; } g_pins = pins; } void setup() { Serial.begin(); pinMode(PUSH_BUTTON, INPUT_PULLUP); pinMode(ENCODER_CHA_PIN, INPUT); pinMode(ENCODER_CHB_PIN, INPUT_PULLUP); zunoGPTInit(ZUNO_GPT_SCALE1024|ZUNO_GPT_CYCLIC); // 32 MHz/1024 = 31.25 kHz (tick is 32 μs) zunoGPTSet(4); // 32 μs * 4 = 128 μs zunoGPTEnable(1); } void loop() { // Do we need to report the level? </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(last_reported_level != level) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (level &gt; 0) { stored_level = level; } last_reported_level = level; analogWrite(PWM1, level); last_level_changed_time = millis(); Serial.print("Level: "); Serial.println(level); } // Button handler byte current_push_button_state = digitalRead(PUSH_BUTTON); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (current_push_button_state != last_push_button_state) { last_push_button_state = current_push_button_state; // </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> button pressed </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (last_push_button_state == LOW) { // </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> LED turned ON, turn OFF </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (level &gt; 0) { analogWrite(PWM1, 0); level = 0; } // Restore last level </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { analogWrite(PWM1, stored_level); level = stored_level; } } } // Send report </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> 2 seconds level not changed </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (last_level_changed_time &amp;&amp; millis() &gt; last_level_changed_time + 2000) { last_level_changed_time = 0; zunoSendReport(1); } } void setter(byte value) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (value &gt; 99) { value = 99; } level = (long)value * 255 / 99; analogWrite(PWM1, level); } byte getter(void) { return last_reported_level * 99 / 255; }</span></span></code> </pre> <br></div></div><br>  To change the brightness of the tape using a dimmer, which I used to use, it was necessary to hold the key up or down, this is not very convenient, it is difficult to adjust the desired level of brightness.  And the dimmer looks like an ordinary switch, and not like a classic dimmer with a wheel to which many are accustomed. <br><br><img src="https://habrastorage.org/webt/ex/9w/dj/ex9wdjv3-zvyb0yeys9sqa3seli.png"><br><br>  For the new Z-Wave LED controller, I modified the dimmer housing - I drilled a hole for the encoder and slightly changed the frame attachment to use the frame from another switch.  For design, do not kick, made from scrap materials.  You can use the finished body from the usual dimmer to look aesthetically pleasing. <br><br><img src="https://habrastorage.org/webt/o4/fy/ho/o4fyhoqcs_pgkuuevonqwnphaqa.jpeg"><br><br>  LUT decides!  For the manufacture of a single copy of the board, I don’t know the technology better than LUT, so I made 2 boards that fit perfectly in the case of the old dimmer.  In the lower part there is a Z-Uno, mosfet and a power supply and tape connector, by the way, the mosfets are designed for voltages up to 30V, so the tape can be used as 12V and 24V, without a radiator, it is better not to exceed 5A. <br><br><img src="https://habrastorage.org/webt/oy/re/nh/oyrenh3ut8pkyyblfo2bfzl1gpe.png"><br><br>  In the upper part is located only the encoder. <br><br><img src="https://habrastorage.org/webt/ys/qp/vf/ysqpvfdjhdjkanifun0tnxvfgb0.png"><br><br>  Combining a sandwich from the boards and placing it in the case, we have a Z-Wave LED controller. <br><br><img src="https://habrastorage.org/webt/oq/ze/ia/oqzeia3boantqez9q1zoptlgmn0.png"><br><br>  At the moment, the Z-Wave LED controller is not installed in the plug-in and lies on the TV cabinet.  Some time I will still test the work. <br><br><img src="https://habrastorage.org/webt/ko/jy/iy/kojyiy3sckvg_sn63m5ah8znneo.jpeg"><br><br>  But now the convenience of controlling the LED ribbon has greatly increased; when controlled from the wheel or the bedside switch, the brightness changes instantly.  In Z-Wave, the dimming scale is in the range from 0 to 99, with the help of the wheel you can select the brightness level from 0 to 255. When rotating by 1 division after 0, the LEDs light up a little, at night it will not wake anyone, but will help not to step on the accidentally forgotten LEGO cube on the floor. <br><br>  It took 3 evenings to make the device, 1 evening - writing the firmware, 1 evening LUT, 1 evening work with a file. <br><br>  UPDATED 1/21/2018 <br>  There are several ideas for finalizing the design, I would like to receive comments. <br>  Idea 1. I’ll order a nice beautiful dimmer with a glass panel on alik and replace the stuffing, I can handle it. <br>  Idea 2. To use a twirl with a display like the climate control in a car, the display will show the current brightness level.  The problem is that I can not find a spinner with a display separately from the climate control. <br><br>  UPDATED 01/23/2018 <br>  In the mounting plate Schneider Electric Odace (80 r in Electrical installation) assembled the LED circuit of the controller. <br><br><img src="https://habrastorage.org/webt/xp/co/pf/xpcopfrsidb2tpxcnc5jhr78vme.jpeg"><br><br>  Frame Odace 90 p stands (which is not in the photo), but the twirl is not sold separately, but I had it in stock.  Any additional case is not planned, the device is completely ready. <br><br><img src="https://habrastorage.org/webt/ls/s7/z1/lss7z1kq9gfqasixvj4beg9tmu4.jpeg"></div>