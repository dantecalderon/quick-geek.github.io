<div class="post__text post__text-html js-mediator-article">  Hi, Habr!  I present to your attention the translation of the article " <a href="https://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/">Java 8 Stream Tutorial</a> ". <br><br>  This tutorial, based on code examples, provides a comprehensive overview of streams in Java 8. When I first met the Stream API, I was puzzled by the name, since it is very consonant with the InputStream and OutputStream from the java.io package;  However, threads in Java 8 are completely different. <a name="habracut"></a>  Threads are <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25BE%25D0%25BD%25D0%25B0%25D0%25B4%25D0%25B0_(%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">monads</a> that play an important role in the development of functional programming in Java. <br><blockquote>  In functional programming, a monad is a structure that represents a calculation in a chain of successive steps.  The type and structure of a monad determine the chain of operations; in our case, a sequence of methods with built-in functions of a given type. </blockquote>  This tutorial will teach you how to work with streams and show you how to handle the various methods available in the Stream API.  We will analyze the order of operations and trace how the sequence of methods in the chain affects performance.  Let's <code>flatMap</code> acquainted with the powerful methods of the Stream API, such as <code>reduce</code> , <code>collect</code> and <code>flatMap</code> .  At the end of the manual we will pay attention to parallel work with threads. <br><br>  If you do not feel free to work with lambda expressions, functional interfaces and reference methods, it will be useful for you to familiarize yourself with <a href="https://winterbe.com/posts/2014/03/16/java-8-tutorial/">my guide to innovations in Java 8</a> ( <a href="https://habr.com/ru/post/216431/">translation</a> to Habré), and then return to learning threads. <br><br><h3>  How threads work </h3><br>  The stream represents a sequence of elements and provides various methods for performing calculations on these elements: <br><br><pre> <code class="java hljs">List&lt;String&gt; myList = Arrays.asList(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"c2"</span></span>, <span class="hljs-string"><span class="hljs-string">"c1"</span></span>); myList .stream() .filter(s -&gt; s.startsWith(<span class="hljs-string"><span class="hljs-string">"c"</span></span>)) .map(String::toUpperCase) .sorted() .forEach(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// C1 // C2</span></span></code> </pre> <br>  Thread methods are <i>intermediate</i> (intermediate) and <i>terminal</i> (terminal).  Intermediate methods return a thread, which allows you to consistently call many such methods.  Terminal methods either do not return a value (void) or return a result of a type other than a stream.  In the above example, the <code>filter</code> , <code>map</code> and <code>sorted</code> are intermediate, and <code>forEach</code> is terminal.  For a complete list of available stream methods, refer to the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">documentation</a> .  Such a chain of streaming operations is also known as an operation pipeline. <br><br>  Most of the methods from the Stream API take as parameters lambda expressions, a functional interface, describing the specific behavior of the method.  Most of them must simultaneously be non-interfering and stateless.  What does this mean? <br><br>  The method is non-interfering if it does not change the source data underlying the stream.  For example, in the example above, no lambda expressions make changes to the list array myList. <br><br>  The method is a stateless (non-memorized) state if the order of the operation is determined.  For example, none of the lambda expressions in the example are dependent on variable variables or external space states that could change at run time. <br><br><h3>  Different types of threads </h3><br>  Streams can be created from various source data, mainly from collections.  Lists and Sets support new <code>stream()</code> and <code>parllelStream()</code> methods for creating sequential and parallel streams.  Parallel threads are able to work in multi-thread mode (on multiple threads) and will be discussed at the end of the tutorial.  For now, consider sequential streams: <br><br><pre> <code class="java hljs">Arrays.asList(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a3"</span></span>) .stream() .findFirst() .ifPresent(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// a1</span></span></code> </pre><br>  Here the call to the <code>stream()</code> method for the list returns a normal stream object. <br>  However, to work with a stream, it is not necessary to create a collection: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a3"</span></span>) .findFirst() .ifPresent(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// a1</span></span></code> </pre><br>  Just use <code>Stream.of()</code> to create a stream from multiple object references. <br><br>  In addition to the usual object streams, Java 8 has special types of threads for working with primitive types: int, long, double.  As you might guess, this is <code>IntStream</code> , <code>LongStream</code> , <code>DoubleStream</code> . <br><br>  IntStream streams can replace regular for (;;) <code>IntStream.range()</code> using <code>IntStream.range()</code> : <br><br><pre> <code class="java hljs">IntStream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) .forEach(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// 1 // 2 // 3</span></span></code> </pre><br>  All of these streams for working with primitive types work in the same way as regular object streams except for the following: <br><br><ul><li>  Primitive streams use special lambda expressions.  For example, IntFunction instead of Function, or IntPredicate instead of Predicate. </li><li>  Primitive streams support additional terminal methods: <code>sum()</code> and <code>average()</code> <br><br><pre> <code class="java hljs">Arrays.stream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}) .map(n -&gt; <span class="hljs-number"><span class="hljs-number">2</span></span> * n + <span class="hljs-number"><span class="hljs-number">1</span></span>) .average() .ifPresent(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// 5.0</span></span></code> </pre><br></li></ul><br>  Sometimes it is useful to turn a stream of objects into a stream of primitives or vice versa.  For this purpose, object streams support special methods: <code>mapToInt()</code> , <code>mapToLong()</code> , <code>mapToDouble()</code> : <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a3"</span></span>) .map(s -&gt; s.substring(<span class="hljs-number"><span class="hljs-number">1</span></span>)) .mapToInt(Integer::parseInt) .max() .ifPresent(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// 3</span></span></code> </pre><br>  Primitive streams can be converted to object streams by calling <code>mapToObj()</code> : <br><br><pre> <code class="java hljs">IntStream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) .mapToObj(i -&gt; <span class="hljs-string"><span class="hljs-string">"a"</span></span> + i) .forEach(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// a1 // a2 // a3</span></span></code> </pre><br>  In the following example, a stream of floating point numbers is mapped to a stream of integer numbers and then mapped to a stream of objects: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span>) .mapToInt(Double::intValue) .mapToObj(i -&gt; <span class="hljs-string"><span class="hljs-string">"a"</span></span> + i) .forEach(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// a1 // a2 // a3</span></span></code> </pre><br><h3>  Execution order </h3><br>  Now that we have learned how to create different streams and how to work with them, we dive deeper and consider how streaming operations look under the hood. <br><br>  An important characteristic of intermediate methods is their <i>laziness</i> .  In this example, there is no terminal method: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; });</code> </pre><br>  When this code fragment is executed, nothing will be output to the console.  And all because intermediate methods are performed only if there is a terminal method.  Let's extend the example by adding a terminal <code>forEach</code> method: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }) .forEach(s -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"forEach: "</span></span> + s));</code> </pre><br>  Executing this code snippet results in the following output to the console: <br><br><pre> <code class="java hljs">filter: d2 forEach: d2 filter: a2 forEach: a2 filter: b1 forEach: b1 filter: b3 forEach: b3 filter: c forEach: c</code> </pre><br>  The order in which the results are located may surprise.  It can be naive to expect that the methods will be executed “horizontally”: one after another for all elements of the stream.  However, instead, the element moves “vertically” along the chain.  First, the first line “d2” passes through the <code>filter</code> method and then through <code>forEach</code> and only then, after the first element passes through the entire chain of methods, the next element begins to be processed. <br><br>  Given this behavior, you can reduce the actual number of operations: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .map(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"map: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .anyMatch(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"anyMatch: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.startsWith(<span class="hljs-string"><span class="hljs-string">"A"</span></span>); }); <span class="hljs-comment"><span class="hljs-comment">// map: d2 // anyMatch: D2 // map: a2 // anyMatch: A2</span></span></code> </pre><br>  The <code>anyMatch</code> method returns <i>true</i> as soon as the predicate is applied to the input element.  In this case, this is the second element of the sequence - “A2”.  Accordingly, thanks to the “vertical” execution of the thread chain, the <code>map</code> will only be called twice.  Thus, instead of displaying all the elements of the stream, the <code>map</code> will be called the minimum possible number of times. <br><br><h3>  Why sequence matters </h3><br>  The following example consists of two intermediate methods <code>map</code> and <code>filter</code> and terminal method <code>forEach</code> .  Consider how these methods are performed: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .map(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"map: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.startsWith(<span class="hljs-string"><span class="hljs-string">"A"</span></span>); }) .forEach(s -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"forEach: "</span></span> + s)); <span class="hljs-comment"><span class="hljs-comment">// map: d2 // filter: D2 // map: a2 // filter: A2 // forEach: A2 // map: b1 // filter: B1 // map: b3 // filter: B3 // map: c // filter: C</span></span></code> </pre> <br>  It is not hard to guess that both the <code>map</code> and <code>filter</code> methods are called 5 times during the execution time — once for each element of the original collection, while <code>forEach</code> is called only once — for the element that passed the filter. <br><br>  You can significantly reduce the number of operations if you change the order of method calls by placing the <code>filter</code> in the first place: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.startsWith(<span class="hljs-string"><span class="hljs-string">"a"</span></span>); }) .map(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"map: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .forEach(s -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"forEach: "</span></span> + s)); <span class="hljs-comment"><span class="hljs-comment">// filter: d2 // filter: a2 // map: a2 // forEach: A2 // filter: b1 // filter: b3 // filter: c</span></span></code> </pre><br>  Now the map is called only once.  With a large number of incoming elements we will observe a tangible increase in performance.  Keep this in mind when composing complex chains of methods. <br><br>  Expand the example above by adding an additional sorting operation — the sorted method: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .sorted((s1, s2) -&gt; { System.out.printf(<span class="hljs-string"><span class="hljs-string">"sort: %s; %s\n"</span></span>, s1, s2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s1.compareTo(s2); }) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.startsWith(<span class="hljs-string"><span class="hljs-string">"a"</span></span>); }) .map(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"map: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .forEach(s -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"forEach: "</span></span> + s));</code> </pre><br>  Sorting is a special kind of intermediate operations.  This is the so-called stateful operation, since to sort the collection, it is necessary to take into account its states throughout the operation. <br><br>  As a result of the execution of this code, we get the following output to the console: <br><br><pre> <code class="java hljs">sort: a2; d2 sort: b1; a2 sort: b1; d2 sort: b1; a2 sort: b3; b1 sort: b3; d2 sort: c; b3 sort: c; d2 filter: a2 map: a2 forEach: A2 filter: b1 filter: b3 filter: c filter: d2</code> </pre><br>  First, the entire collection is sorted.  In other words, the <code>sorted</code> method runs horizontally.  In this case, <code>sorted</code> is called 8 times for several combinations of the elements of the incoming collection. <br><br>  Once again, we optimize the execution of this code by changing the order of method calls in the chain: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.startsWith(<span class="hljs-string"><span class="hljs-string">"a"</span></span>); }) .sorted((s1, s2) -&gt; { System.out.printf(<span class="hljs-string"><span class="hljs-string">"sort: %s; %s\n"</span></span>, s1, s2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s1.compareTo(s2); }) .map(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"map: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .forEach(s -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"forEach: "</span></span> + s)); <span class="hljs-comment"><span class="hljs-comment">// filter: d2 // filter: a2 // filter: b1 // filter: b3 // filter: c // map: a2 // forEach: A2</span></span></code> </pre><br>  In this example, <code>sorted</code> is not called at all.  <code>filter</code> reduces the input collection to one element.  In the case of large input data, performance will benefit significantly. <br><br><h3>  Reuse streams </h3><br>  In Java 8, threads cannot be reused.  After calling any terminal method, the thread ends: <br><br><pre> <code class="java hljs">Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; s.startsWith(<span class="hljs-string"><span class="hljs-string">"a"</span></span>)); stream.anyMatch(s -&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ok stream.noneMatch(s -&gt; true); // exception</span></span></code> </pre><br>  Calling <code>noneMatch</code> after <code>anyMatch</code> in one thread results in the following exception: <br><br><pre> <code class="java hljs">java.lang.IllegalStateException: stream has already been operated upon or closed at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:<span class="hljs-number"><span class="hljs-number">229</span></span>) at java.util.stream.ReferencePipeline.noneMatch(ReferencePipeline.java:<span class="hljs-number"><span class="hljs-number">459</span></span>) at com.winterbe.java8.Streams5.test7(Streams5.java:<span class="hljs-number"><span class="hljs-number">38</span></span>) at com.winterbe.java8.Streams5.main(Streams5.java:<span class="hljs-number"><span class="hljs-number">28</span></span>)</code> </pre><br>  To overcome this limitation, create a new thread for each terminal method. <br><br>  For example, you can create a <i>supplier</i> for the constructor of a new flow in which all intermediate methods will be installed: <br><br><pre> <code class="java hljs">Supplier&lt;Stream&lt;String&gt;&gt; streamSupplier = () -&gt; Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; s.startsWith(<span class="hljs-string"><span class="hljs-string">"a"</span></span>)); streamSupplier.get().anyMatch(s -&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ok streamSupplier.get().noneMatch(s -&gt; true); // ok</span></span></code> </pre><br>  Each <code>get</code> method call creates a new thread in which you can safely call the desired terminal method. <br><br><h3>  Advanced methods </h3><br>  Streams support a large number of different methods.  We have already become familiar with the most important methods.  To get acquainted with the rest, refer to the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">documentation</a> .  Now <code>flatMap</code> deeper into more complex methods: <code>collect</code> , <code>flatMap</code> and <code>reduce</code> . <br><br>  Most of the code examples in this section refer to the following code snippet to demonstrate the work: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ String name; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> age; Person(String name, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> age) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.age = age; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; } } List&lt;Person&gt; persons = Arrays.asList( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Max"</span></span>, <span class="hljs-number"><span class="hljs-number">18</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Peter"</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Pamela"</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"David"</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>));</code> </pre><br><h4>  Collect </h4><br>  <code>Collect</code> very useful terminal method that serves to convert stream elements into a result of another type, for example, List, Set or Map. <br><br>  <code>Collect</code> accepts <code>Collector</code> , which contains four different methods: supplier (supplier).  battery (accumulator), combiner, finisher (finisher).  At first glance, this looks very difficult, but Java 8 supports various built-in collectors through the <code>Collectors</code> class, where the most used methods are implemented. <br><br>  Popular case: <br><br><pre> <code class="java hljs">List&lt;Person&gt; filtered = persons .stream() .filter(p -&gt; p.name.startsWith(<span class="hljs-string"><span class="hljs-string">"P"</span></span>)) .collect(Collectors.toList()); System.out.println(filtered); <span class="hljs-comment"><span class="hljs-comment">// [Peter, Pamela]</span></span></code> </pre> <br>  As you can see, creating a list of stream items is easy.  Need not a list but a lot?  Use <code>Collectors.toSet()</code> . <br><br>  In the following example, people are grouped by age: <br><br><pre> <code class="java hljs">Map&lt;Integer, List&lt;Person&gt;&gt; personsByAge = persons .stream() .collect(Collectors.groupingBy(p -&gt; p.age)); personsByAge .forEach((age, p) -&gt; System.out.format(<span class="hljs-string"><span class="hljs-string">"age %s: %s\n"</span></span>, age, p)); <span class="hljs-comment"><span class="hljs-comment">// age 18: [Max] // age 23: [Peter, Pamela] // age 12: [David]</span></span></code> </pre><br>  The collectors are incredibly diverse.  You can also aggregate the elements of a collection, for example, determine the average age: <br><br><pre> <code class="java hljs">Double averageAge = persons .stream() .collect(Collectors.averagingInt(p -&gt; p.age)); System.out.println(averageAge); <span class="hljs-comment"><span class="hljs-comment">// 19.0</span></span></code> </pre><br>  For more comprehensive statistics, we use the summarizing collector, which returns a special object with information: minimum, maximum and average values, the sum of values ​​and the number of elements: <br><br><pre> <code class="java hljs">IntSummaryStatistics ageSummary = persons .stream() .collect(Collectors.summarizingInt(p -&gt; p.age)); System.out.println(ageSummary); <span class="hljs-comment"><span class="hljs-comment">// IntSummaryStatistics{count=4, sum=76, min=12, average=19.000000, max=23}</span></span></code> </pre><br>  The following example merges all names into a single line: <br><br><pre> <code class="java hljs">String phrase = persons .stream() .filter(p -&gt; p.age &gt;= <span class="hljs-number"><span class="hljs-number">18</span></span>) .map(p -&gt; p.name) .collect(Collectors.joining(<span class="hljs-string"><span class="hljs-string">" and "</span></span>, <span class="hljs-string"><span class="hljs-string">"In Germany "</span></span>, <span class="hljs-string"><span class="hljs-string">" are of legal age."</span></span>)); System.out.println(phrase); <span class="hljs-comment"><span class="hljs-comment">// In Germany Max and Peter and Pamela are of legal age.</span></span></code> </pre><br>  The connecting collector accepts a separator as well as an optional prefix and suffix. <br><br>  To convert stream elements to a display, you must determine how keys and values ​​should be displayed.  Remember that the keys in the display must be unique.  Otherwise, we get an <code>IllegalStateException</code> .  You can optionally add a merge function to bypass the exception: <br><br><pre> <code class="java hljs">Map&lt;Integer, String&gt; map = persons .stream() .collect(Collectors.toMap( p -&gt; p.age, p -&gt; p.name, (name1, name2) -&gt; name1 + <span class="hljs-string"><span class="hljs-string">";"</span></span> + name2)); System.out.println(map); <span class="hljs-comment"><span class="hljs-comment">// {18=Max, 23=Peter;Pamela, 12=David}</span></span></code> </pre><br>  So, we’ve seen some of the most powerful inline collectors.  Let's try to build your own.  We want to convert all the elements of the stream into a single string, which consists of uppercase names, separated by a vertical bar |.  To do this, create a new collector using <code>Collector.of()</code> .  We need four components of our collector: supplier, battery, connector, finisher. <br><br><pre> <code class="java hljs">Collector&lt;Person, StringJoiner, String&gt; personNameCollector = Collector.of( () -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringJoiner(<span class="hljs-string"><span class="hljs-string">" | "</span></span>), <span class="hljs-comment"><span class="hljs-comment">// supplier (j, p) -&gt; j.add(p.name.toUpperCase()), // accumulator (j1, j2) -&gt; j1.merge(j2), // combiner StringJoiner::toString); // finisher String names = persons .stream() .collect(personNameCollector); System.out.println(names); // MAX | PETER | PAMELA | DAVID</span></span></code> </pre> <br>  Since strings in Java are immutable, we need a helper class of type <code>StringJoiner</code> that allows the collector to build a string for us.  In the first stage, the provider constructs a <code>StringJoiner</code> with an assigned delimiter.  The battery is used to add each name to the <code>StringJoiner</code> . <br><br>  The connector knows how to connect two <code>StringJoiner</code> to one.  And at the end of the finisher constructs the desired string from <code>StringJoiner</code> s. <br><br><h4>  Flatmap </h4><br>  So, we learned how to turn stream objects into other types of objects using the <code>map</code> method.  <code>Map</code> is a kind of limited method, since each object can be mapped to just one other object.  But what if you want to map one object to many others, or not to display it at all?  This is where the <code>flatMap</code> method <code>flatMap</code> .  <code>FlatMap</code> turns each stream object into a stream of other objects.  The contents of these streams are then packed into the return stream of the <code>flatMap</code> method. <br><br>  In order to look at <code>flatMap</code> in action, we build a suitable type hierarchy for an example: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ String name; List&lt;Bar&gt; bars = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); Foo(String name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ String name; Bar(String name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } }</code> </pre><br>  Create several objects: <br><br><pre> <code class="java hljs">List&lt;Foo&gt; foos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-comment"><span class="hljs-comment">// create foos IntStream .range(1, 4) .forEach(i -&gt; foos.add(new Foo("Foo" + i))); // create bars foos.forEach(f -&gt; IntStream .range(1, 4) .forEach(i -&gt; f.bars.add(new Bar("Bar" + i + " &lt;- " + f.name))));</span></span></code> </pre><br>  Now we have a list of three <i>foo</i> , each of which contains three <i>bar</i> . <br><br>  <code>FlatMap</code> accepts a function that should return a stream of objects.  Thus, to access the <i>bar</i> objects of each <i>foo</i> , we just need to select the appropriate function: <br><br><pre> <code class="java hljs">foos.stream() .flatMap(f -&gt; f.bars.stream()) .forEach(b -&gt; System.out.println(b.name)); <span class="hljs-comment"><span class="hljs-comment">// Bar1 &lt;- Foo1 // Bar2 &lt;- Foo1 // Bar3 &lt;- Foo1 // Bar1 &lt;- Foo2 // Bar2 &lt;- Foo2 // Bar3 &lt;- Foo2 // Bar1 &lt;- Foo3 // Bar2 &lt;- Foo3 // Bar3 &lt;- Foo3</span></span></code> </pre><br>  So, we have successfully turned the stream from three <i>foo</i> objects into a stream from 9 <i>bar</i> objects. <br><br>  Finally, all of the above code can be reduced to a simple pipeline of operations: <br><br><pre> <code class="java hljs">IntStream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) .mapToObj(i -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(<span class="hljs-string"><span class="hljs-string">"Foo"</span></span> + i)) .peek(f -&gt; IntStream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) .mapToObj(i -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-string"><span class="hljs-string">"Bar"</span></span> + i + <span class="hljs-string"><span class="hljs-string">" &lt;- "</span></span> f.name)) .forEach(f.bars::add)) .flatMap(f -&gt; f.bars.stream()) .forEach(b -&gt; System.out.println(b.name));</code> </pre><br>  <code>FlatMap</code> also available in the <code>Optional</code> class, introduced in Java 8. The <code>FlatMap</code> from the <code>Optional</code> class returns an optional object of another class.  This can be used to avoid cluttering up <code>null</code> checks. <br><br>  Imagine a hierarchical structure like this: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ Nested nested; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Nested</span></span></span><span class="hljs-class"> </span></span>{ Inner inner; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inner</span></span></span><span class="hljs-class"> </span></span>{ String foo; }</code> </pre><br>  To get the nested string <i>foo</i> from an external object, you must add multiple <code>null</code> checks to avoid a <code>NullPointException</code> : <br><br><pre> <code class="java hljs">Outer outer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Outer(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (outer != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; outer.nested != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; outer.nested.inner != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { System.out.println(outer.nested.inner.foo); }</code> </pre><br>  The same can be achieved using the FlatMap class of the Optional class: <br><br><pre> <code class="java hljs">Optional.of(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Outer()) .flatMap(o -&gt; Optional.ofNullable(o.nested)) .flatMap(n -&gt; Optional.ofNullable(n.inner)) .flatMap(i -&gt; Optional.ofNullable(i.foo)) .ifPresent(System.out::println);</code> </pre><br>  Each <code>flatMap</code> call returns an <code>Optional</code> wrapper for the desired object, if present, or for <code>null</code> if there is no object. <br><br><h4>  Reduce </h4><br>  The simplify operation combines all the elements of a stream into one result.  Java 8 supports three different types of the reduce method. <br><br>  The first reduces the flow of elements to a single stream element.  We use this method to determine the element with the highest age: <br><br><pre> <code class="java hljs">persons .stream() .reduce((p1, p2) -&gt; p1.age &gt; p2.age ? p1 : p2) .ifPresent(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// Pamela</span></span></code> </pre> <br>  The <code>reduce</code> method takes an accumulating function with a <i>binary operator</i> (BinaryOperator).  Here <code>reduce</code> is a <i>bi-function</i> (BiFunction), where both arguments belong to the same type.  In our case, to type <i>Person</i> .  The bi-function is practically the same as the <code>функция</code> (Function), however, it takes 2 arguments.  In our example, the function compares the age of two people and returns the item with a greater age. <br><br>  The following form of the <code>reduce</code> method takes both the initial value and the accumulator with the binary operator.  This method can be used to create a new item.  We have a <i>Person</i> with a name and age, consisting of the addition of all the names and the sum of past years: <br><br><pre> <code class="java hljs">Person result = persons .stream() .reduce(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), (p1, p2) -&gt; { p1.age += p2.age; p1.name += p2.name; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p1; }); System.out.format(<span class="hljs-string"><span class="hljs-string">"name=%s; age=%s"</span></span>, result.name, result.age); <span class="hljs-comment"><span class="hljs-comment">// name=MaxPeterPamelaDavid; age=76</span></span></code> </pre><br>  The third <code>reduce</code> method takes three parameters: the initial value, the accumulator with the bi-function, and the unifying function of the type of the binary operator.  Since the initial value of the type is not limited to the type of Person, a reduction can be used to determine the sum of the living years of each person: <br><br><pre> <code class="java hljs">Integer ageSum = persons .stream() .reduce(<span class="hljs-number"><span class="hljs-number">0</span></span>, (sum, p) -&gt; sum += p.age, (sum1, sum2) -&gt; sum1 + sum2); System.out.println(ageSum); <span class="hljs-comment"><span class="hljs-comment">// 76</span></span></code> </pre><br>  As you can see, we got the result of 76, but what really happens under the hood? <br><br>  Expand the above code snippet with the debug text output: <br><br><pre> <code class="java hljs">Integer ageSum = persons .stream() .reduce(<span class="hljs-number"><span class="hljs-number">0</span></span>, (sum, p) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"accumulator: sum=%s; person=%s\n"</span></span>, sum, p); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum += p.age; }, (sum1, sum2) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"combiner: sum1=%s; sum2=%s\n"</span></span>, sum1, sum2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum1 + sum2; }); <span class="hljs-comment"><span class="hljs-comment">// accumulator: sum=0; person=Max // accumulator: sum=18; person=Peter // accumulator: sum=41; person=Pamela // accumulator: sum=64; person=David</span></span></code> </pre><br>  As you can see, all the work is performed by the accumulating function.  It is first called with the initial value of 0 and the first person is Max.  In the next three steps, the sum constantly increases by the person’s age from the last step until it reaches the total age of 76. <br><br>  So, what is next?  Is the combiner never called?  Consider parallel execution of this thread: <br><br><pre> <code class="java hljs">Integer ageSum = persons .parallelStream() .reduce(<span class="hljs-number"><span class="hljs-number">0</span></span>, (sum, p) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"accumulator: sum=%s; person=%s\n"</span></span>, sum, p); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum += p.age; }, (sum1, sum2) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"combiner: sum1=%s; sum2=%s\n"</span></span>, sum1, sum2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum1 + sum2; }); <span class="hljs-comment"><span class="hljs-comment">// accumulator: sum=0; person=Pamela // accumulator: sum=0; person=David // accumulator: sum=0; person=Max // accumulator: sum=0; person=Peter // combiner: sum1=18; sum2=23 // combiner: sum1=23; sum2=12 // combiner: sum1=41; sum2=35</span></span></code> </pre><br>  With parallel execution, we get a completely different console output.  Now the unifier is actually called.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the battery was called in parallel, the combiner had to sum the values ​​stored separately. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the next chapter we will examine in more detail the parallel execution of threads.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parallel streams </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Streams can run in parallel to improve performance when working with large numbers of incoming items. </font><font style="vertical-align: inherit;">Parallel threads use the usual </font></font><code>ForkJoinPool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">accessible via static method call </font></font><code>ForkJoinPool.commonPool()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The size of the main thread pool can reach 5 threads of execution - the exact number depends on the number of available physical processor cores.</font></font><br><br><pre> <code class="java hljs">ForkJoinPool commonPool = ForkJoinPool.commonPool(); System.out.println(commonPool.getParallelism()); <span class="hljs-comment"><span class="hljs-comment">// 3</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On my computer, the default thread pool is initialized with paralleling to 3 threads by default. </font><font style="vertical-align: inherit;">This value can be increased or decreased by setting the following JVM parameter:</font></font><br><br><pre> <code class="bash hljs">-Djava.util.concurrent.ForkJoinPool.common.parallelism=5</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Collections support a method </font></font><code>parallelStream()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for creating parallel data streams. </font><font style="vertical-align: inherit;">You can also call an intermediate method </font></font><code>parallel()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to turn a serial stream into a parallel stream. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To understand the behavior of a thread in parallel execution, the following example prints information about each current thread (thread) into </font></font><code>System.out</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="java hljs">Arrays.asList(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"c2"</span></span>, <span class="hljs-string"><span class="hljs-string">"c1"</span></span>) .parallelStream() .filter(s -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"filter: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }) .map(s -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"map: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .forEach(s -&gt; System.out.format(<span class="hljs-string"><span class="hljs-string">"forEach: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()));</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Consider the conclusions with debug entries to better understand which thread is used to perform specific stream methods: </font></font><br><br><pre> <code class="java hljs">filter: b1 [main] filter: a2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] map: a2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] filter: c2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] map: c2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] filter: c1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] map: c1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] forEach: C2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] forEach: A2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] map: b1 [main] forEach: B1 [main] filter: a1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] map: a1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] forEach: A1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] forEach: C1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>]</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, in parallel execution of a data stream, all available threads of the current are used </font></font><code>ForkJoinPool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The output sequence may differ, since the execution sequence of each specific thread is not defined (thread). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's extend the example by adding a method </font></font><code>sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="java hljs">Arrays.asList(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"c2"</span></span>, <span class="hljs-string"><span class="hljs-string">"c1"</span></span>) .parallelStream() .filter(s -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"filter: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }) .map(s -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"map: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .sorted((s1, s2) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"sort: %s &lt;&gt; %s [%s]\n"</span></span>, s1, s2, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s1.compareTo(s2); }) .forEach(s -&gt; System.out.format(<span class="hljs-string"><span class="hljs-string">"forEach: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()));</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> At first glance, the result may seem strange: </font></font><br><br><pre> <code class="java hljs">filter: c2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] filter: c1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] map: c1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] filter: a2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] map: a2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] filter: b1 [main] map: b1 [main] filter: a1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] map: a1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] map: c2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] sort: A2 &lt;&gt; A1 [main] sort: B1 &lt;&gt; A2 [main] sort: C2 &lt;&gt; B1 [main] sort: C1 &lt;&gt; C2 [main] sort: C1 &lt;&gt; B1 [main] sort: C1 &lt;&gt; C2 [main] forEach: A1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] forEach: C2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] forEach: B1 [main] forEach: A2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] forEach: C1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It seems to be </font></font><code>sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">executed sequentially and only in the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> stream </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In fact, when running a stream in parallel under the hood of a method </font></font><code>sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from the Stream API </font></font><code>Arrays</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a </font><font style="vertical-align: inherit;">class sorting method </font><font style="vertical-align: inherit;">added in Java 8 is </font><font style="vertical-align: inherit;">hidden </font></font><code>Arrays.parallelSort()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">As stated in the documentation, this method, based on the length of the incoming collection, determines how exactly - the sorting will be performed in parallel or sequentially:</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If the length of a particular array is less than the minimum “grain”, sorting is performed by executing the Arrays.sort method. </font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's return to the example with the method </font></font><code>reduce</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from the previous chapter. </font><font style="vertical-align: inherit;">We have already found out that the unifying function is called only when working in parallel with the thread. </font><font style="vertical-align: inherit;">Consider which threads are involved:</font></font><br><br><pre> <code class="java hljs">List&lt;Person&gt; persons = Arrays.asList( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Max"</span></span>, <span class="hljs-number"><span class="hljs-number">18</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Peter"</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Pamela"</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"David"</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>)); persons .parallelStream() .reduce(<span class="hljs-number"><span class="hljs-number">0</span></span>, (sum, p) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"accumulator: sum=%s; person=%s [%s]\n"</span></span>, sum, p, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum += p.age; }, (sum1, sum2) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"combiner: sum1=%s; sum2=%s [%s]\n"</span></span>, sum1, sum2, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum1 + sum2; });</code> </pre><br> Консольный вывод показывает, что обе функции: аккумулирующая и объединяющая, выполняются параллельно, используя все возможные потоки: <br><br><pre> <code class="java hljs">accumulator: sum=<span class="hljs-number"><span class="hljs-number">0</span></span>; person=Pamela; [main] accumulator: sum=<span class="hljs-number"><span class="hljs-number">0</span></span>; person=Max; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] accumulator: sum=<span class="hljs-number"><span class="hljs-number">0</span></span>; person=David; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] accumulator: sum=<span class="hljs-number"><span class="hljs-number">0</span></span>; person=Peter; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] combiner: sum1=<span class="hljs-number"><span class="hljs-number">18</span></span>; sum2=<span class="hljs-number"><span class="hljs-number">23</span></span>; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] combiner: sum1=<span class="hljs-number"><span class="hljs-number">23</span></span>; sum2=<span class="hljs-number"><span class="hljs-number">12</span></span>; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] combiner: sum1=<span class="hljs-number"><span class="hljs-number">41</span></span>; sum2=<span class="hljs-number"><span class="hljs-number">35</span></span>; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>]</code> </pre><br> Можно утверждать, что параллельное выполнение потока способствует значительному повышению эффективности при работе с большими количествами входящих элементов. Однако следует помнить, что некоторые методы при параллельном выполнении требуют дополнительных расчетов (объединительных операций), которые не требуются при последовательном выполнении. <br><br> Кроме того, для параллельного выполнения потока используется все тот же <code>ForkJoinPool</code> , так широко используемый в JVM. Так что применение медленных блокирующих методов потока может негативно отразиться на производительности всей программы, за счет блокирования потоков (threads), используемых для обработки в других задачах. <br><br><h3> Вот и все </h3><br> Мое руководство по использованию потоков в Java 8 окончено. Для более подробного изучения работы с потоками можно обратиться к <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">документации</a> . Если вы хотите углубиться и больше узнать про механизмы, лежащие в основе работы потоков, вам может быть интересно прочитать статью Мартина Фаулера (Martin Fowler) <a href="http://martinfowler.com/articles/collection-pipeline/">Collection Pipelines</a> . <br><br> Если вам так же интересен JavaScript, вы можете захотеть взглянуть на <a href="https://github.com/winterbe/streamjs">Stream.js</a> — JavaScript реализацию Java 8 Streams API. Возможно, вы также захотите прочитать мои статьи <a href="https://winterbe.com/posts/2014/03/16/java-8-tutorial/">Java 8 Tutorial</a> ( <a href="https://habr.com/ru/post/216431/">русский перевод</a> на Хабре) и <a href="https://winterbe.com/posts/2014/04/05/java8-nashorn-tutorial/">Java 8 Nashorn Tutorial</a> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I hope this tutorial was useful and interesting for you, and you enjoyed the process of reading. </font><font style="vertical-align: inherit;">The full code </font></font><a href="https://github.com/winterbe/java8-tutorial"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is stored in GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Feel free to create a branch in the repository.</font></font></div>