<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to programming: a simple 3D shooter from scratch over the weekend, part 2</title>
  <meta name="description" content="We continue to talk about the 3D shooter over the weekend. If anything, I remind you that this is the second half: 



- Part one: drawing the walls 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Introduction to programming: a simple 3D shooter from scratch over the weekend, part 2</h1><div class="post__text post__text-html js-mediator-article">  We continue to talk about the 3D shooter over the weekend.  If anything, I remind you that this is the second half: <br><br><ul><li>  <a href="https://habr.com/ru/post/439698/">Part one: drawing the walls</a> </li><li>  <b>Part two: we inhabit our world + window interface</b> </li></ul><br>  As I said, I strongly support the desire in the students to do something with their own hands.  In particular, when I read a course of lectures on introduction to programming, then as practical classes I leave them almost complete freedom.  There are only two limitations: a programming language (C ++) and a project theme; this should be a video game.  Here is an example of one of the hundreds of games that my freshman students have done: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Ekomnk1eNFU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Unfortunately, most students choose simple games like 2D platformers.  I am writing this article in order to show that creating the illusion of a three-dimensional world is no more difficult than cloning Mario Broz. <br><a name="habracut"></a><br>  I remind you that we stopped at the stage that allows you to texture the walls: <br><br><img src="https://raw.githubusercontent.com/ssloy/tinyraycaster/master/doc/012.gif"><br><br><hr><br><h1>  Stage 13: draw monsters on the map </h1><br>  What is a monster in our game?  These are its coordinates and texture number: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sprite</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x, y; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> tex_id; }; [..] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Sprite&gt; sprites{ {<span class="hljs-number"><span class="hljs-number">1.834</span></span>, <span class="hljs-number"><span class="hljs-number">8.765</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-number"><span class="hljs-number">5.323</span></span>, <span class="hljs-number"><span class="hljs-number">5.365</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}, {<span class="hljs-number"><span class="hljs-number">4.123</span></span>, <span class="hljs-number"><span class="hljs-number">10.265</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>} };</code> </pre> <br>  Having identified several monsters, to begin with, simply draw them on the map: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/60f/15a/824/60f15a824cec0e8a93ff42f4d7a2722b.png"><br><br>  Changes <a href="https://github.com/ssloy/tinyraycaster/commit/323e3f7c24e220260ef651ecf039b1ffce1d0cda">you can see here</a> . <br> <a href="&amp;xid=17259,15700021,15700186,15700191,15700248&amp;usg=ALkJrhiG7rtLbwCSkNMjU1fhbWv2F7KpbQ#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Open in gitpod"></a> <br><br><hr><br><h1>  Stage 14: black squares instead of monsters in 3D </h1><br>  Now we will draw the sprites in the 3D window.  To do this, we need to determine two things: the position of the sprite on the screen and its size.  Here is the function that draws a black square in place of each sprite: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw_sprite</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sprite &amp;sprite, FrameBuffer &amp;fb, Player &amp;player, Texture &amp;tex_sprites)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// absolute direction from the player to the sprite (in radians) float sprite_dir = atan2(sprite.y - player.y, sprite.x - player.x); // remove unnecessary periods from the relative direction while (sprite_dir - player.a &gt; M_PI) sprite_dir -= 2*M_PI; while (sprite_dir - player.a &lt; -M_PI) sprite_dir += 2*M_PI; // distance from the player to the sprite float sprite_dist = std::sqrt(pow(player.x - sprite.x, 2) + pow(player.y - sprite.y, 2)); size_t sprite_screen_size = std::min(2000, static_cast&lt;int&gt;(fb.h/sprite_dist)); // do not forget the 3D view takes only a half of the framebuffer, thus fb.w/2 for the screen width int h_offset = (sprite_dir - player.a)*(fb.w/2)/(player.fov) + (fb.w/2)/2 - sprite_screen_size/2; int v_offset = fb.h/2 - sprite_screen_size/2; for (size_t i=0; i&lt;sprite_screen_size; i++) { if (h_offset+int(i)&lt;0 || h_offset+i&gt;=fb.w/2) continue; for (size_t j=0; j&lt;sprite_screen_size; j++) { if (v_offset+int(j)&lt;0 || v_offset+j&gt;=fb.h) continue; fb.set_pixel(fb.w/2 + h_offset+i, v_offset+j, pack_color(0,0,0)); } } }</span></span></code> </pre><br>  Let's understand how it works.  Here is the diagram: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/472/062/e0d/472062e0d02a32186987ee94f7364cdd.png"><br><br>  In the first line we consider the absolute angle sprite_dir (the angle between the direction from the player to the sprite and the x-axis).  The relative angle between the sprite and the direction of gaze is obviously obtained by simply subtracting two absolute angles: sprite_dir - player.a.  The distance from the player to the sprite is trivial to count, and the size of the sprite is a simple division of the screen size by distance.  Well, just in case, I cut off two thousand from above, so as not to get giant squares (by the way, this code can easily be divided by zero).  h_offset and v_offset give the coordinates of the upper left corner of the sprite on the screen;  then a simple double loop fills our square with black.  Check with a pen and a piece of paper for the correctness of the calculations of h_offset and v_offset, in my commit (non-critical) error, to believe the code in the article :) Well, the more recent code in the repository is also already fixed. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/03a/795/77c/03a79577c9c0781121b529494b1dafe1.png"><br><br>  Changes <a href="https://github.com/ssloy/tinyraycaster/commit/3d99cf0bb63a5a95a9868dbc1c1f011ace665c15">you can see here</a> . <br><br> <a href="&amp;xid=17259,15700021,15700186,15700191,15700248&amp;usg=ALkJrhiG7rtLbwCSkNMjU1fhbWv2F7KpbQ#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Open in gitpod"></a> <br><br><hr><br><h1>  Stage 15: Depth Map </h1><br>  Our squares are a miracle, but only one problem: the distant monster looks around the corner, and the square is drawn entirely.  How to be?  Very simple.  We draw sprites <b>after</b> the walls have been painted.  Therefore, for each column of our screen, we know the distance to the nearest wall.  Let's save these distances to an array of 512 values, and pass an array of the sprite drawing function.  Sprites are also drawn column by column, so for each column of the sprite we will compare the distance to it with the value from our depth array. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec8/1c3/71f/ec81c371f35f7ddff4086a8e1a51268b.png"><br>  Changes <a href="https://github.com/ssloy/tinyraycaster/commit/ea577d67088656918a85911448b9539421a8f3e1">you can see here</a> . <br><br> <a href="&amp;xid=17259,15700021,15700186,15700191,15700248&amp;usg=ALkJrhiG7rtLbwCSkNMjU1fhbWv2F7KpbQ#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Open in gitpod"></a> <br><br><hr><br><h1>  Step 16: Sprites Problem </h1><br>  Excellent turned out monsters, is not it?  But at this stage I will not add any functionality, on the contrary I‚Äôll break everything by adding one more monster: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/28f/5a8/9b8/28f5a89b8ea84373d9812c3e3a66d61d.png"><br>  Changes <a href="https://github.com/ssloy/tinyraycaster/commit/f2db6b113af0151c06b65460d892531a3739a579">you can see here</a> . <br><br> <a href="&amp;xid=17259,15700021,15700186,15700191,15700248&amp;usg=ALkJrhiG7rtLbwCSkNMjU1fhbWv2F7KpbQ#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Open in gitpod"></a> <br><br><hr><br><h1>  Step 17: Sorting Sprites </h1><br>  What was the problem?  The problem is that I can have an arbitrary order of rendering sprites, and for each of them I compare its distance with the walls, but not with other sprites, so the distant creature came out on top of the nearest one.  Is it possible to adapt a solution with a depth map for drawing sprites? <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text">  The correct answer is ‚Äúcan.‚Äù  That's how?  Write in the comments. <br></div></div><br>  I will go another way, solving the problem stupidly in the forehead.  I'll just draw all the sprites from the farthest to the nearest.  That is, I will sort the sprites in descending order of distance, and draw them in that order. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/73c/820/c20/73c820c20c220093733774e6a1553a50.png"><br>  Changes <a href="https://github.com/ssloy/tinyraycaster/commit/63f1a5639a0f895da1c60e3698105f740f3aa319">you can see here</a> . <br><br> <a href="&amp;xid=17259,15700021,15700186,15700191,15700248&amp;usg=ALkJrhiG7rtLbwCSkNMjU1fhbWv2F7KpbQ#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Open in gitpod"></a> <br><br><hr><br><h1>  Stage 18: SDL Time </h1><br>  It's time to SDL.  Cross-platform window libraries are very many different, and I don‚Äôt understand them at all.  Personally, I like <a href="https://github.com/ocornut/imgui">imgui</a> , but for some reason my students prefer SDL, so I link with it.  The task for this stage is very simple: create a window and display an image of it from the previous stage: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ce/63a/9b5/7ce63a9b5ea3ca1c608fcdcf207d482e.png"><br><br>  Changes <a href="https://github.com/ssloy/tinyraycaster/commit/152b4778206c6931d2d75a81fae59bc6c82189a9">you can see here</a> .  I do not give a link to the guitar pod anymore, because  SDL in the browser has not yet learned to run :( <br><br>  <b>Update: LEARNED!</b>  <b>You can run the code in one click in the browser!</b> <br><br> <a href="&amp;xid=17259,15700021,15700186,15700191,15700248&amp;usg=ALkJrhiG7rtLbwCSkNMjU1fhbWv2F7KpbQ#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Open in gitpod"></a> <br><br><h1>  Step 19: Event Processing and Purge </h1><br>  Add a response to keystrokes is not even funny, I will not describe.  When adding SDL, I removed the dependency on stb_image.h.  It is beautiful, but it takes a long time to compile. <br><br>  For those who do not understand, the source code of the nineteenth stage <a href="https://github.com/ssloy/tinyraycaster">lies here</a> .  Well, here is what a typical performance looks like: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/zPIVTqVilCM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1>  Conclusion </h1><br>  My code at the moment contains only 486 lines, and at the same time I did not save them at all: <br><br><pre> <code class="bash hljs">haqreu@daffodil:~/tinyraycaster$ cat *.cpp *.h | wc -l 486</code> </pre><br>  I did not lick my code, deliberately dumping dirty laundry.  Yes, I write like that (and I'm not the only one).  One Saturday morning I just sat down and wrote this :) <br><br>  I did not make a complete game, my task is only to give an initial impulse for the flight of your fantasy.  Write your own code, it will certainly be better than mine.  Share your code, share your ideas, send pull requests. </div><p>Source: <a href="https://habr.com/ru/post/439720/">https://habr.com/ru/post/439720/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>