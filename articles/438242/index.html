<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Compress the list of IP-addresses in the best way</title>
  <meta name="description" content="Once I read an article on Habr√© about setting up BGP on a router. Instructions from there can be used to configure a home router so that traffic to sp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Compress the list of IP-addresses in the best way</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/xb/cm/03/xbcm03j6a2yijqkxhzatkxq6xbw.jpeg"><br><br>  Once I read <a href="https://habr.com/ru/post/354282/">an article</a> on Habr√© about setting up BGP on a router.  Instructions from there can be used to configure a home router so that traffic to specific IP addresses goes through another channel.  However, there is a problem: the list of IP addresses can be very large. <br><br>  In addition to networks from the list, the graph also contains the largest common subnets of neighboring networks.  Read more about why this is needed. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/fh/pf/er/fhpfer-kqivtgto-agnozn9wpos.png"><br>  <i>It looked like a tree of networks from Roskomnadzor in May 2018.</i> <br><br>  At first I tried to add the entire list via / ip route add to my MikroTik hAP ac lite - the disk ran out of space on the router.  Then, through BGP, I loaded all the addresses into memory - the router worked a little and hung up.  It became obvious that the list should be cut. <br><br>  The <a href="https://habr.com/ru/post/354282/">article</a> mentions the network-list-parser <a href="https://github.com/unsacrificed/network-list-parser">utility</a> from the Unsacrificed <a href="https://habr.com/ru/users/unsacrificed/" class="user_link">habraiser</a> .  She does what I need, but I saw her after I started reinventing my bicycle.  Then I completed it out of interest, because what I got, works better, albeit much slower. <br><br>  So, setting the problem: you need to write a script that takes as input a list of IP addresses and networks and shortens it to the specified size.  At the same time, the new list should cover all addresses from the old one, and the number of new addresses added to it should be minimal. <br><br>  Let's start with the construction of the graph of all source networks (what is in the picture above).  The root node is the network 0.0.0.0/0.  When adding a new subnet A, we find a subnet B in the tree so that A and B are on subnet C and at the same time the size of subnet C is minimal (maximum mask).  In other words, the number of common bits of subnets A and B should be maximum.  We add this common subnet to the tree, and inward we transfer subnets A and B. Probably, this can be called a binary tree. <br><br>  For example, let's build a tree of two subnets (192.168.0.1/32 and 192.168.33.0/24): <br><br><img src="https://habrastorage.org/webt/5d/ts/tx/5dtstx3shvofo6npuytk5n0kcto.png"><br><br>  Get the tree: <br><br><img src="https://habrastorage.org/webt/la/5b/ej/la5bejewneridokbs_-fkahmz1y.png"><br><br>  If we add, say, the network 192.168.150.150/32, then the tree will look like this: <br><br><img src="https://habrastorage.org/webt/-r/yp/om/-rypomiatbn-l5hlfq86wzcgal8.png"><br><br>  Orange here marked common subnet, added when building a tree.  It is these common subnets that we will ‚Äúcollapse‚Äù to reduce the size of the list.  For example, if you collapse the node 192.168.0.0/16, then we will reduce the size of the list of networks by 2 (there were 3 networks from the original list, became 1), but at the same time we will cover 65536-1-1-256 = 65278 IP addresses, which not included in our source list. <br><br>  It is convenient for each node to calculate the "coefficient of benefits from collapsing", showing the number of IP addresses that will be added to each of the records removed from the list: <br><br><pre><code class="plaintext hljs">weight_reversed = net_extra_ip_volume / (in_list_records_count - 1)</code> </pre> <br>  We will use weight = 1 / weight_reversed, because  it is more comfortable.  It is curious that the weight can be equal to infinity, if, for example, there are two networks / 32 in the list, which together make up one large network / 31. <br><br>  Thus, the greater the weight, the more profitable such a network is to collapse. <br><br>  Now you can calculate the weight for all nodes in the network, sort the nodes by weight and collapse the subnets until we get the size of the list we need.  However, there is a difficulty: at the moment when we collapse a network, the weights of all parent networks change. <br><br>  For example, we have a tree with calculated weights: <br><br><img src="https://habrastorage.org/webt/mn/wd/60/mnwd60e30yeamoqjg3veobslqcc.png"><br><br>  We will collapse the subnet 192.168.0.0/30: <br><br><img src="https://habrastorage.org/webt/3q/zf/tm/3qzftmtvi-ctpw9_ebniki7cvkm.png"><br><br>  The weight of the parent node has decreased.  If there are nodes in the tree with a weight greater than 0.166, then the next one should collapse them already. <br><br>  As a result, the list has to be compressed recursively.  Algorithm like this: <br><br><ol><li>  We calculate the weight for all nodes. </li><li>  For each node we store the maximum weight of the child node (Wmax). </li><li>  It turns out that Wmax of the root node is the maximum weight of the node in the entire tree (there can be several nodes with a weight equal to Wmax). </li><li>  Recursively compress all networks with a weight equal to Wmax of the root node.  In this case, recalculate the weight.  We return to the root node. </li><li>  Wmax of the root node has decreased - we perform step 4 until we get the required size of the list of networks. </li></ol><br>  The most interesting thing is to watch the algorithm in motion.  Here is an example for a list of networks: <br><br> <code>192.168.0.1 <br> 192.168.0.2 <br> 192.168.0.8/29 <br> 192.168.150.1 <br> 192.168.150.2 <br> 192.168.150.8/29 <br> 192.168.20.1 <br> 192.168.20.2 <br> 192.168.20.3 <br> 192.168.20.4 <br> 192.168.20.5 <br> 192.168.20.6 <br> 192.168.20.7</code> <br> <br>  Here the subnets 192.168.0.0/24 and 192.168.150.0/24, which are the same in structure, can be better seen, as during compression, the algorithm jumps from one branch to another.  Subnet 192.168.20.0/24 added in order to show that sometimes it is more profitable to compress the parent network than the child network.  Note the subnet 192.168.20.0/30: after filling the tree, its weight is less than that of the parent subnet. <br><br>  Tree Filling: <br><br><img src="https://habrastorage.org/webt/db/7y/od/db7yodt6w5mvgq_rvxxoe5k4lq8.gif"><br><br>  Here the black font is the real networks from the original list.  Yellow - added networks.  Blue is the weight of the node.  Red is the current network.  Pink - a collapsed network. <br><br>  Compression: <br><br><img src="https://habrastorage.org/webt/wp/wr/0j/wpwr0j57ms67jp4xdpmhzjkpnpy.gif"><br><br>  It was thought to speed up the algorithm of collapsing networks: to do this, it is not necessary to collapse only networks with maximum weight at each iteration.  You can pre-select the value of weight, which will give us a list of the desired size.  You can choose a binary search, i.e.  compress with a certain weight and see what the size of the list is obtained at the output.  True, for this you need two times more memory and rewrite the code - I simply did not get around. <br><br>  It now remains to compare with the <a href="https://github.com/unsacrificed/network-list-parser">network-list-parser</a> from the BGP article. <br><br>  Pluses of my script: <br><br><ol><li>  It is more convenient to set up: just specify the required size of the list of networks, and the output will be a list of exactly that size.  The network-list-parser has a lot of pens, and you need to find a combination of them. </li><li>  The degree of compression is adapted to the original list.  If we remove some networks from the list, we will get fewer additional addresses, if we add more.  At the same time, the size of the resulting list will be constant.  You can choose the maximum size that the router can handle and not worry about the list becoming too large at some point. </li><li>  The resulting list contains the minimum possible number of additional networks.  On the test list from GitHub, my algorithm gave 718479 additional IP addresses, and the network-list-parser gave 798761. <b>The difference is only 10%</b> . <br><br><div class="spoiler">  <b class="spoiler_title">How did I calculate this?</b>  <b class="spoiler_title">We look</b> <div class="spoiler_text">  1. Run <br><br><pre> <code class="plaintext hljs"> ./network-list-parser-darwin-386-1.2.bin -src-file real_net_list_example.txt -dst-file parsed.txt -aggregation-max-fake-ips 0 -intensive-aggregation-min-prefix 31 2&gt;&amp;1</code> </pre> <br>  and we get a cleared list without garbage and partially reduced.  I will compare the quality of compression parsed.txt.  (without this step, there were problems with estimating how many fake IPs the network-list-parser adds). <br><br>  2. Run <br><br><pre> <code class="plaintext hljs">./network-list-parser-darwin-386-1.2.bin -src-file parsed.txt -dst-file parsed1.txt 2&gt;&amp;1</code> </pre> <br>  and we get a compressed list, we look at the output, there is a line ‚ÄúAdd 7.3% IPs coverage (798761).‚Äù <br><br>  In the file parsed1.txt 16649 records. <br><br>  3. Run <br><br>  python3 minimize_net_list.py parsed.txt 16649. <br>  We see the line ### not real ips: 718479. <br></div></div><br></li></ol><br>  I see only one drawback of the resulting script: it takes a long time and requires a lot of memory.  On my MacBook list, it takes 5 seconds.  On Raspberry - <b>one and a half minutes</b> .  With RyRy3 on Mac faster, I could not deliver on Raspberry PyPy3.  Network-list-parser flies both there and there. <br><br>  In general, this scheme makes sense to use only perfectionists, because  all the rest will spend so much computing resources for the sake of 10% of the saved networks are unlikely.  Well, a little more convenient, yes. <br><br>  <a href="https://github.com/phoenix-mstu/net_list_minimizer">Link to the project in GitHub</a> <br><br>  Run like this: <br><br><pre> <code class="plaintext hljs">python3 minimize_net_list.py real_net_list_example.txt 30000 | grep -v ### &gt; result.txt</code> </pre> <br>  That's all. <br><br>  <b>UPD</b> <br>  <a href="https://habr.com/ru/users/pochemuk/" class="user_link">Pochemuk</a> in the comments indicated an error in calculating the weight, I corrected it and now, when compressing the same list from the example with the same settings, 624925 IP addresses are added that are not included in the original list.  This is already <b>22% better</b> than when processing network-list-parser <br>  New code in untested branch <a href="https://github.com/phoenix-mstu/net_list_minimizer/tree/untested">github.com/phoenix-mstu/net_list_minimizer/tree/untested</a> </div><p>Source: <a href="https://habr.com/ru/post/438242/">https://habr.com/ru/post/438242/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>