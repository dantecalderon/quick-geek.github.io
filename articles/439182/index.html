<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How do we distribute orders between drivers in Yandex.Taxi</title>
  <meta name="description" content="One of the main tasks in Yandex.Taxi is how to make sure that a car comes quickly to the user, while the driver has reduced the ‚Äúidle run‚Äù time (that ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>How do we distribute orders between drivers in Yandex.Taxi</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/5h/l9/th/5hl9thxhtitxpaufvidq23vkycy.png" alt="image"><br><br>  One of the main tasks in Yandex.Taxi is how to make sure that a car comes quickly to the user, while the driver has reduced the ‚Äúidle run‚Äù time (that is, the time when he is on the line without a passenger).  It would seem that everything is simple: the user chooses a tariff, indicates additional wishes (a child seat, for example).  It remains to filter the drivers on the line according to these criteria, select the closest one and offer him an order.  However, everything is so simple only at first glance. <br><br>  Today I will tell the Habr community about how we choose the most suitable driver and how this process has evolved over time.  You will learn about two approaches to solving the problem. <br><a name="habracut"></a><br><h3>  General search architecture </h3><br>  When the user clicks the "Call a taxi" button, an order object is created in the back end and its processing begins in accordance with the state machine.  In order for the order to go from the ‚ÄúWaiting‚Äù state to ‚ÄúDriver assigned‚Äù, you need to find the driver, offer him the order and wait for confirmation that the order has been accepted. <br><br><img src="https://habrastorage.org/webt/fn/bq/bp/fnbqbplbhy626m7u_kxujya0zho.png" alt="image"><br><br><h3>  Greedy Approach </h3><br>  For a very long time, a <a href="https://ru.wikipedia.org/wiki/%25D0%2596%25D0%25B0%25D0%25B4%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B0%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC">greedy</a> approach worked in Yandex. <a href="https://ru.wikipedia.org/wiki/%25D0%2596%25D0%25B0%25D0%25B4%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B0%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC">Taxi</a> .  With this approach, at the stage of searching for an executor, a request is made to Microservice Tracker, which is responsible for drivers.  Tracker knows everything about cars: from color and branding to the <a href="https://events.yandex.ru/lib/talks/6453/">current location</a> .  In Tracker, there is a local geo-index for drivers and connectors to routing services (routers) for building routes from point A to point B (and even through points C, D, D).  Therefore, when a request to search for a driver is received, Tracker first determines the nearest cars in the local geo-index by the direct radius taking into account ‚Äúhard‚Äù ordering restrictions (car class, requirements - child seat, yellow numbers).  Then, the time and length of the car‚Äôs delivery route is specified and, taking into account this information, the best option is chosen. <br><br>  Later, this logic evolved: for each driver they began to count his ‚Äúscoring‚Äù to order - a function of the time the car was delivered.  And the drivers were ranked according to the scoring value.  The function takes into account not only the time of filing, but also many other factors: from the level of demand at points A and B to the driver‚Äôs ‚Äúexperience‚Äù.  This greedy appointment is called bonus. <br><br><h3>  Buffer (beam) approach </h3><br>  However, with the greedy approach the nearest driver will receive the one who first ordered a taxi.  However, some users may even be left without a car. <br><br><img src="https://habrastorage.org/webt/k-/gr/df/k-grdfddnk6lgvkpxylphlkcv2e.png" alt="image"><br><br><img src="https://habrastorage.org/webt/6b/9x/iz/6b9xizmxnoqytx90py50-8utc00.png" alt="image"><br><br>  With increased demand, when competition begins for performers, the greedy approach is no good.  To best meet the demand even in the most loaded hours, we use a variety of approaches and algorithms.  One of them is the buffer (beam) assignment of drivers to orders.  It is based on the well-known combinatorial optimization <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25B4%25D0%25B0%25D1%2587%25D0%25B0_%25D0%25BE_%25D0%25BD%25D0%25B0%25D0%25B7%25D0%25BD%25D0%25B0%25D1%2587%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F%25D1%2585">problem</a> ‚Äî <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25B4%25D0%25B0%25D1%2587%25D0%25B0_%25D0%25BE_%25D0%25BD%25D0%25B0%25D0%25B7%25D0%25BD%25D0%25B0%25D1%2587%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F%25D1%2585">the assignment problem</a> .  Briefly, its essence: let us have N jobs and M performers, any employee can perform any task during p (i, j) [0 &lt;= i &lt;N, 0 &lt;= j &lt;M].  It is necessary to assign such a performer to each task in order to reduce the total time to complete all the work (at that, one performer can undertake only one work). <br><br><img src="https://habrastorage.org/webt/fc/-k/sh/fc-kshacpkn4hy0nuwqeo1mmzik.png" alt="image"><img src="https://habrastorage.org/webt/fp/en/ot/fpenotm7jopgnz5ndaj3fal_jie.png" alt="image"><br><br>  When solving such an assignment problem, our ‚Äúcost‚Äù of performing the work (order) by the executor (taxi driver and driver) is the value of the scoring function from the time the car was delivered to the user.  The task can be described in terms of bipartite graphs: on the one hand, orders, on the other - performers.  Between orders and performers there are weighted edges (scoring).  Thus, one of our goals is to minimize the total time for car delivery, maximizing the number of completed orders (maximum matching).  One of the most well-known ways to solve this problem is the <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B5%25D0%25BD%25D0%25B3%25D0%25B5%25D1%2580%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D0%25B0%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC">Hungarian algorithm</a> . <br><table><tbody><tr><td><img src="https://habrastorage.org/webt/vd/en/lr/vdenlrgpxfigisllopvwogmqk0k.png" alt="image"></td><td><img src="https://habrastorage.org/webt/jd/5q/sy/jd5qsysg54yoo-n99eipmfuky1m.png" alt="image"></td></tr></tbody></table><br>  Obviously, with a buffer assignment, we cannot give the driver upon request, as with the greedy approach.  First you need to put the order in the queue, then play, and then report the found driver.  This did not at all fit into the state machine for order processing, and it had to be slightly improved.  To test and create a new solution without affecting our colleagues, we immediately agreed that we would do everything in a separate DriverDispatcher microservice.  He will take orders, put himself in a queue, find drivers and save the results of the draws. <br><br>  First of all, we had to prepare Tracker for a new load profile.  If, with a greedy approach, requests for drivers were simply individually placed on the Tracker balancer and redirected to its instances with load distribution, then in the buffer assignment all requests were from the same machine: individual requests would simply fill the connection pool.  Therefore, we have added to the tracker the possibility of batch processing requests that were processed in parallel within the tracker.  Along the way, we also had to solve the problem of a reasonable number of requests for batch processing.  On the client side (DriverDispatcher), we broke a large batch into several small ones and sent them to different Tracker instances. <br><br><img src="https://habrastorage.org/webt/gf/kw/xb/gfkwxba9mefbr-advegu6vg4uv4.png" alt="image"><br><br>  So, the tracker is prepared, scoring is considered both in Tracker'e (greedy assignment), and in the new service (DriverDispatcher'e), the algorithm for solving the assignment problem is debugged and works correctly.  There was a question how to integrate all this into a state machine for order processing.  We added sending and deleting order information in DriverDispatcher when the order is transferred from state to state.  And it almost worked.  Almost - because the iterations of the search artist to order not controlled from the outside.  We could just replace the hike to the tracker for the driver to hike to our service and give the driver when he was found, and before that just give 404. But this is bad because we need to offer the order to the driver as soon as we found the order, and even a few seconds delay here play a role: the driver can simply turn in the wrong direction, and the order will become irrelevant.  To do this, we made it possible to trigger the process of searching for the executor, without affecting the scheduled tasks.  So we saved the search logic (with re-queries) and added the ability to call it outside the scheduler. <br><br>  Thus, we were able to combine the main state machine for order processing with the state machine for processing in the buffer control without affecting the working logic and without races between states.  You can run the first experiments on live users. <br><br>  This is all very cool, but how about searching for an artist, you ask.  If the search does not take place immediately after the receipt of the order, then the search time increases and is eventually compensated by a faster submission?  This is not quite true: with the help of various techniques (including using machine learning), we were able to isolate cases when waiting makes sense, while in other cases the waiting time does not change. <br><br><h3>  Prank draw </h3><br>  Another way to find an artist faster is to start looking for him BEFORE creating an order.  When a new <a href="https://habr.com/ru/company/yandex/blog/429226/">pin</a> appears (that is, the user only enters order data into the application), <a href="https://vc.ru/yandex.taxi/50668-mashinnoe-obuchenie-molodec">the</a> machine learning <a href="https://vc.ru/yandex.taxi/50668-mashinnoe-obuchenie-molodec">algorithms</a> estimate the probability that the order will follow and decide whether to take it into account when searching for drivers in a buffer.  We can find the car in advance, and when the user clicks the order button - immediately make an offer to the right driver. <br><br><h3>  Conclusion </h3><br>  Matching orders and drivers is not an easy task, it requires taking into account many factors.  One of them is the context of driver movements when selecting candidates for an order.  We will tell about it in the following posts. <br><br><h3>  Other posts about Taxi technology </h3><br><ul><li>  <a href="https://habr.com/ru/company/yandex/blog/429226/">Dynamic pricing, or How Yandex.Taxi predicts high demand</a> </li><li>  <a href="https://habr.com/ru/company/yandex/blog/433386/">How using computer vision to assess the condition of the car.</a>  <a href="https://habr.com/ru/company/yandex/blog/433386/">Experience Yandex.Taxi</a> </li><li>  <a href="https://habr.com/ru/company/yandex/blog/431196/">How Yandex.Taxi predicts the time of filing a car using machine learning</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/439182/">https://habr.com/ru/post/439182/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>