<div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a6/15a/4f2/6a615a4f2323c53913f33aca999fd661.png" alt="image"></div><br>  All of us often have to deal with static tables, they can be the settings of our application, authorization screens, screens “about us” and many others.  But often, novice developers do not apply any design patterns for such tables and write an all-in-one non-scalable, inflexible system. <br><br>  How I solve the given problem - under a cat. <br><a name="habracut"></a><br><h4>  What is it about? </h4><br>  Before solving the problem of static tables - it is worth understanding what it is.  Static tables are tables where you already know the number of rows and the content that is in them.  Examples of such tables are below. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/635/327/f7c/635327f7cf51ff06df260af777dba8eb.png" alt="image"><br><br><h4>  Problem </h4><br>  First of all, it's worth defining the problem: why can't we just create a ViewController, which will be a UITableViewDelegate and a UITableViewDatasource and just describe all the necessary cells?  At a minimum, there are 5 problems with our table: <br><br><ol><li>  Hard to scale </li><li>  Depends on indexes </li><li>  Not flexible </li><li>  No reuse </li><li>  Requires a lot of code to initialize. </li></ol><br><h4>  Decision </h4><br>  The problem solving method is based on the following foundation: <br><br><ol><li>  Taking out the responsibility of the table configuration to a separate class ( <b>Constructor</b> ) </li><li>  Its wrapper over the <b>UITableViewDelegate</b> and <b>UITableViewDataSource</b> </li><li>  Connecting cells to custom protocols for reuse </li><li>  Creating your own data models for each table </li></ol><br>  First I want to show how it is used in practice - then I will show how it is all implemented under the hood. <br><br><h4>  Implementation </h4><br>  The task is to create a table with two text cells and one empty between them. <br><br>  First of all, I created an ordinary <b>TextTableViewCell</b> with a <b>UILabel</b> . <br>  Next, for each UIViewController with a static table, you need your own Constructor, let's create it: <br><br><pre><code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ViewControllerConstructor: StaticConstructorContainer { typealias ModelType = &lt;<span class="hljs-meta"><span class="hljs-meta">#type#&gt; }</span></span></code> </pre> <br>  When we inherit it from <b>StaticConstructorContainer</b> , the first thing Generic protocol requires us is a model type ( <b>ModelType</b> ) - this is the type of cell model that we also need to create, let's do it. <br><br>  I use enum for this, since it is more suitable for our tasks and here the most interesting begins.  We will fill our table with content using protocols such as: <i>Titled, Subtitled, Colored, Fonted,</i> and so on.  As you can guess, these protocols are responsible for displaying text.  Suppose the Titled protocol requires <b>title: String?</b>  , and if our cell supports <b>title</b> mappings, it will fill it.  Let's see what it looks like: <br><br><pre> <code class="objectivec hljs">protocol Fonted { var font: <span class="hljs-built_in"><span class="hljs-built_in">UIFont</span></span>? { get } } protocol FontedConfigurable { func configure(by model: Fonted) } protocol Titled { var title: String? { get } } protocol TitledConfigurable { func configure(by model: Titled) } protocol Subtitled { var subtitle: String? { get } } protocol SubtitledConfigurable { func configure(by model: Subtitled) } protocol Imaged { var image: <span class="hljs-built_in"><span class="hljs-built_in">UIImage</span></span>? { get } } protocol ImagedConfigurable { func configure(by model: Imaged) }</code> </pre><br>  Correspondingly, only a small part of such protocols is presented here, you can create it yourself, as you see - it is very simple.  I remind you that we create them once for one goal and then forget them and calmly use them. <br><br>  Our cell ( <i>with text</i> ) basically supports the following things: The text font, the text itself, the text color, the cell background color and in general any things that come to your mind. <br><br>  We need only the <b>title for now</b> .  Therefore, we inherit our model from Titled.  Inside the model in case, we indicate what types of cells we will have. <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> CellModel: Titled { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> firstText <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> emptyMiddle <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> secondText var title: String? { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .firstText: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Я - первый"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .secondText: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Я - второй"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } } }</code> </pre><br>  Since there is no label in the middle (empty cell), you can return nil. <br>  With the cell finished and you can insert it into our constructor. <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ViewControllerConstructor: StaticConstructorContainer { typealias ModelType = CellModel var models: [CellModel] <span class="hljs-comment"><span class="hljs-comment">// Здесь мы должны выставить порядок и количество ячеек, отображаемых в коде func cellType(for model: CellModel) -&gt; Self.StaticTableViewCellClass.Type { // здесь мы должны вернуть тип ячейки, которая принадлежит модели } func configure(cell: UITableViewCell, by model: CellModel) { // Здесь мы можем конфигурировать ячейку вручную, если это необходимо, но можно оставить это пустым } func itemSelected(item: CellModel) { // аналог didSelect, не завязанный на индексах } }</span></span></code> </pre> <br>  And as a matter of fact, it is all our code.  We can say that our table is ready.  Let's fill in the data and see what happens. <br><br>  Oh yeah, I almost forgot.  We need to inherit our cell from the TitledConfigurable protocol so that it can insert the title into itself.  The cells support dynamic height too. <br><br><pre> <code class="objectivec hljs">extension TextTableViewCell: TitledConfigurable { func configure(by model: Titled) { label.text = model.title } }</code> </pre><br>  How the filled constructor looks like: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ViewControllerConstructor: StaticConstructorContainer { typealias ModelType = CellModel var models: [CellModel] = [.firstText, .emptyMiddle, .secondText] func cellType(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> model: CellModel) -&gt; StaticTableViewCellClass.Type { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> model { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .emptyMiddle: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EmptyTableViewCell.self <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .firstText, .secondText: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TextTableViewCell.self } } func configure(cell: <span class="hljs-built_in"><span class="hljs-built_in">UITableViewCell</span></span>, by model: CellModel) { cell.selectionStyle = .none } func itemSelected(item: CellModel) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> item { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .emptyMiddle: print(<span class="hljs-string"><span class="hljs-string">"Нажата средняя ячейка"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Нажата другая ячейка..."</span></span>) } } }</code> </pre><br>  Looks pretty compact, right? <br><br>  Actually, the last thing left for us to do is connect it all to the ViewController: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ViewController: <span class="hljs-built_in"><span class="hljs-built_in">UIViewController</span></span> { private let tableView: <span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span> = { let tableView = <span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tableView }() private let constructor = ViewControllerConstructor() private lazy var delegateDataSource = constructor.delegateDataSource() override func viewDidLoad() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() constructor.setup(at: tableView, dataSource: delegateDataSource) } }</code> </pre> <br>  Everything is ready, we must render <b>delegateDataSource</b> as a separate property to our class so that the weak link does not break inside some function. <br><br>  We can run and test: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5f7/3e8/905/5f73e890597d805b3a341ee2a26f53d8.png" alt="image"><br><br>  As you can see, everything works. <br><br>  Now let's summarize and understand what we have achieved: <br><br><ol><li>  If we create a new cell and want to replace the current cell with it, then we do this by changing one variable.  We have a very flexible table system. </li><li>  We reuse all cells.  The more cells you tie to this table, the easier and easier it is to work with.  Great for large projects. </li><li>  We have reduced the amount of code to create the table.  And we have to write it even less when we have a lot of protocols and static cells in the project. </li><li>  We learned <b>how</b> to build static tables from the <b>UIViewController</b> in the <b>Constructor</b> </li><li>  We have ceased to depend on indices, we can safely swap cells in the array and the logic does not break. </li></ol><br>  The code for the test project at the end of the article. <br><br><h4>  How does it work from the inside? </h4><br>  How the protocols work, we have already discussed.  Now we need to understand how the whole constructor and its associated classes work. <br><br>  Let's start with the constructor: <br><pre> <code class="objectivec hljs">protocol StaticConstructorContainer { associatedtype ModelType var models: [ModelType] { get } func cellType(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> model: ModelType) -&gt; StaticTableViewCellClass.Type func configure(cell: <span class="hljs-built_in"><span class="hljs-built_in">UITableViewCell</span></span>, by model: ModelType) func itemSelected(item: ModelType) }</code> </pre> <br>  This is a common protocol that requires functions already familiar to us. <br><br>  More interesting is its <b>extension</b> : <br><br><pre> <code class="objectivec hljs">extension StaticConstructorContainer { typealias StaticTableViewCellClass = StaticCell &amp; NibLoadable func delegateDataSource() -&gt; StaticDataSourceDelegate&lt;Self&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StaticDataSourceDelegate&lt;Self&gt;.init(container: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) } func setup&lt;T: StaticConstructorContainer&gt;(at tableView: <span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span>, dataSource: StaticDataSourceDelegate&lt;T&gt;) { models.forEach { (model) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> let type = cellType(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: model) tableView.register(type.nib, forCellReuseIdentifier: type.name) } tableView.delegate = dataSource tableView.dataSource = dataSource dataSource.tableView = tableView } }</code> </pre> <br>  The <i>setup</i> function that we called in our ViewController registers all cells for us and delegates the <b>dataSource</b> and <b>delegate</b> . <br><br>  And <i><b>delegateDataSource ()</b></i> creates a wrapper for us <b>UITableViewDataSource</b> and <b>UITableViewDelegate</b> .  Let's look at it: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> StaticDataSourceDelegate&lt;Container: StaticConstructorContainer&gt;: <span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">UITableViewDelegate</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">UITableViewDataSource</span></span> { private let container: Container <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> var tableView: <span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span>? init(container: Container) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.container = container } func reload() { tableView?.reloadData() } func tableView(_ tableView: <span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span>, estimatedHeightForRowAt indexPath: IndexPath) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span> { let type = container.cellType(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: container.models[indexPath.row]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type.estimatedHeight ?? type.height } func tableView(_ tableView: <span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span>, heightForRowAt indexPath: IndexPath) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span> { let type = container.cellType(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: container.models[indexPath.row]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type.height } func tableView(_ tableView: <span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span>, numberOfRowsInSection section: Int) -&gt; Int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> container.models.count } func tableView(_ tableView: <span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span>, cellForRowAt indexPath: IndexPath) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">UITableViewCell</span></span> { let model = container.models[indexPath.row] let type = container.cellType(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: model) let cell = tableView.dequeueReusableCell(withIdentifier: type.name, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: indexPath) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let typedCell = cell as? TitledConfigurable, let titled = model as? Titled { typedCell.configure(by: titled) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let typedCell = cell as? SubtitledConfigurable, let subtitle = model as? Subtitled { typedCell.configure(by: subtitle) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let typedCell = cell as? ImagedConfigurable, let imaged = model as? Imaged { typedCell.configure(by: imaged) } container.configure(cell: cell, by: model) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell } func tableView(_ tableView: <span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span>, didSelectRowAt indexPath: IndexPath) { let model = container.models[indexPath.row] container.itemSelected(item: model) } }</code> </pre> <br>  I think there are no questions to the functions <b>heightForRowAt</b> , <b>numberOfRowsInSection</b> , <b>didSelectRowAt</b> , they just implement an understandable functionality.  The most interesting method here is <b>cellForRowAt</b> . <br><br>  In it we implement not the most beautiful logic.  We have to prescribe each new protocol to the cells here, but we do it once - so this is not so scary.  If the model complies with the protocol, like our cell, then configure it.  If someone has ideas on how to automate it, I will be glad to hear in the comments. <br><br>  This logic ends.  I did not touch third-party utilitarian classes in this system; <a href="https://github.com/Hadevs/static-generic-tableview">you can familiarize yourself with the code in full with the link</a> . <br><br>  Thanks for attention! </div>