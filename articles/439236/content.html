<div class="post__text post__text-html js-mediator-article"><p>  Hello! </p><br><p>  I would like to tell you a little about the project I have been working on for the past six months.  I do the project in my spare time, but the motivation for its creation came from observations made at the main work. </p><br><p>  On the working draft, we use the microservice architecture, and one of the main problems that has manifested itself over time and with the increased number of these same services is testing.  When a service depends on five to seven other services, plus some other database (or even a few) in addition, it is very inconvenient to test it in a “live” form, so to speak.  It is necessary to be surrounded by mocks from all sides so tightly that the test itself cannot be seen.  Well, or somehow organize the test environment, where all the dependencies could actually be running. </p><a name="habracut"></a><br><p>  Actually to facilitate the second option, I just sat down to write <a href="https://github.com/syhpoon/xenvman">xenvman</a> .  In a nutshell, it is something like a hybrid of docker-compose and <a href="https://www.testcontainers.org/">test containers</a> , only without binding to Java (or any other language) and with the ability to dynamically create and configure environments via the HTTP API. </p><br><p> <code>xenvman</code> written on Go and is implemented as a simple HTTP server, which allows you to use all the available functionality from any language that can speak this protocol. </p><br><p>  The main thing that xenvman can do is: </p><br><ul><li>  Flexible description of the contents of the environment using simple JavaScript scripts </li><li>  Create images on the fly </li><li>  Create the required number of containers and combine them into a single isolated network </li><li>  Forwarding the internal ports of the environment to the outside, so that tests can reach the necessary services even from other hosts </li><li>  Dynamically change the composition of the environment (stop, start and add new containers) on the go, without stopping the working environment. </li></ul><br><h2 id="okruzheniya">  Environments </h2><br><p>  The main protagonist in xenvman is the environment.  This is such an isolated bubble in which all the necessary dependencies (packed in Docker containers) of your service are launched. </p><br><p><img src="https://habrastorage.org/webt/z5/ot/ju/z5otjuqar0vsscxnoqpawyf6vxe.png"></p><br><p>  The figure above shows the xenvman server and active environments where various services and databases are running.  Each environment was created directly from the integration test code, and will be deleted upon completion. </p><br><h2 id="shablony">  Templates </h2><br><p>  What is directly included in the environment is determined by the templates (templates), which are small scripts in JS.  xenvman has a built-in interpreter for this language, and when it receives a request to create a new environment, it simply executes the specified templates, each of which adds one or more containers to the list for execution. </p><br><p>  JavaScript was chosen to allow dynamically change / add templates without having to rebuild the server.  In addition, as a rule, only basic features and data types of the language are used in the templates (good old ES5, no DOM, React and other magic), so working with templates should not cause any particular difficulties even for those who do not know JS. </p><br><p>  Templates are parameterizable, that is, we can completely control the template logic by passing certain parameters in our HTTP request. </p><br><h2 id="sozdanie-obrazov-na-letu">  Creating images on the fly </h2><br><p>  One of the most convenient features of xenvman, in my opinion, is the creation of Docker images right along with the configuration of the environment.  Why it may be necessary? <br>  Well, for example, we have on a project to get an image of a service, we need to commit changes into a separate branch, push and wait while Gitlab CI collects and floods the image. <br>  If only one service has changed, then it can take 3-5 minutes. </p><br><p>  And if we are actively sawing new features in our service, or are trying to understand why it does not work by adding the good old <code>fmt.Printf</code> to and fro, or changing the code some other way, even a delay of 5 minutes will be great to put out the performance ( ours, as code writers).  Instead, we can simply add all the necessary debugging to the code, compile it locally, and then simply attach the finished binary to the HTTP request. </p><br><p>  Having received such good, the template will take this binar and on the move will create a temporary image from which we can already launch the container as if nothing had happened. </p><br><p>  On our project, in the main template for services, for example, we check if the binary is present in the parameters, and if so, then collect the image on the go, otherwise just download the <code>latest</code> version of the <code>dev</code> branch.  The following code for creating containers is identical for both options. </p><br><h2 id="nebolshoy-primer">  Small example </h2><br><p>  For clarity, let's look at the micro-sample. </p><br><p>  Let's say we write some kind of miracle server (let's call it <code>wut</code> ), which needs a database to store everything there.  Well, as a base, we chose MongoDB.  So for full testing, we need a working Mongo server.  You can, of course, install and run it locally, but for simplicity and clarity of the example, we assume that for some reason this is difficult to do (with other, more complex configurations in real systems, this will be more like the truth). </p><br><p>  So we will try to use xenvman to create an environment with Mongo running and our <code>wut</code> server. </p><br><p>  First we need to create a <a href="https://github.com/syhpoon/xenvman">base directory</a> in which all templates will be stored: </p><br><p> <code>$ mkdir xenv-templates &amp;&amp; cd xenv-templates</code> </p> <br><p>  Next, create two templates, one for Mongo, the other for our server: </p><br><p> <code>$ touch mongo.tpl.js wut.tpl.js</code> </p> <br><h3 id="mongotpljs">  mongo.tpl.js </h3><br><p>  Open <code>mongo.tpl.js</code> and write the following there: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tpl, params</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> img = tpl.FetchImage(fmt(<span class="hljs-string"><span class="hljs-string">"mongo:%s"</span></span>, params.tag)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cont = img.NewContainer(<span class="hljs-string"><span class="hljs-string">"mongo"</span></span>); cont.SetLabel(<span class="hljs-string"><span class="hljs-string">"mongo"</span></span>, <span class="hljs-string"><span class="hljs-string">"true"</span></span>); cont.SetPorts(<span class="hljs-number"><span class="hljs-number">27017</span></span>); cont.AddReadinessCheck(<span class="hljs-string"><span class="hljs-string">"net"</span></span>, { <span class="hljs-string"><span class="hljs-string">"protocol"</span></span>: <span class="hljs-string"><span class="hljs-string">"tcp"</span></span>, <span class="hljs-string"><span class="hljs-string">"address"</span></span>: <span class="hljs-string"><span class="hljs-string">'{{.ExternalAddress}}:{{.Self.ExposedPort 27017}}'</span></span> }); }</code> </pre> <br><p>  The <em>execute ()</em> function with two parameters must be present in the template. <br>  The first is the tpl instance of the object through which the environment is configured.  The second argument (params) is just a JSON object, with which we will parameterize our template. </p><br><p>  In line </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> img = tpl.FetchImage(fmt(<span class="hljs-string"><span class="hljs-string">"mongo:%s"</span></span>, params.tag));</code> </pre> <br><p>  we ask xenvman to download the docker <code>mongo:&lt;tag&gt;</code> image <code>mongo:&lt;tag&gt;</code> , where <code>&lt;tag&gt;</code> is the version of the image we want to use.  In principle, this line is equivalent to the <code>docker pull mongo:&lt;tag&gt;</code> , with the only difference that all the functions of the <code>tpl</code> object are essentially declarative, that is, the image will actually be downloaded only after xenvman executes all the templates specified in the environment configuration. </p><br><p>  Once we have an image, we can create a container: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cont = img.NewContainer(<span class="hljs-string"><span class="hljs-string">"mongo"</span></span>);</code> </pre> <br><p>  Again, the container will not be instantly created in this place, we simply declare the intention to create it, so to speak. </p><br><p>  Next, we label our container: </p><br><pre> <code class="javascript hljs">cont.SetLabel(<span class="hljs-string"><span class="hljs-string">"mongo"</span></span>, <span class="hljs-string"><span class="hljs-string">"true"</span></span>);</code> </pre> <br><p>  Labels are used so that containers can find each other in the environment, for example, to enter the IP address or host name in the configuration file. </p><br><p>  Now we need to hang the inner Mongo port (27017) out.  This is easily done like this: </p><br><pre> <code class="javascript hljs"> cont.SetPorts(<span class="hljs-number"><span class="hljs-number">27017</span></span>);</code> </pre> <br><p>  Before xenvman reports on the successful creation of the environment, it would be great to make sure that all services are not just running, but already ready to accept requests.  Xenvman has <a href="https://github.com/syhpoon/xenvman">readiness checks</a> for this. <br>  Add one for our mongo container: </p><br><pre> <code class="javascript hljs"> cont.AddReadinessCheck(<span class="hljs-string"><span class="hljs-string">"net"</span></span>, { <span class="hljs-string"><span class="hljs-string">"protocol"</span></span>: <span class="hljs-string"><span class="hljs-string">"tcp"</span></span>, <span class="hljs-string"><span class="hljs-string">"address"</span></span>: <span class="hljs-string"><span class="hljs-string">'{{.ExternalAddress}}:{{.Self.ExposedPort 27017}}'</span></span> });</code> </pre> <br><p>  As we can see, here in the address bar there are stubs into which the necessary values ​​will be dynamically substituted just before launching the containers. </p><br><p>  Instead of <code>{{.ExternalAddress}}</code> external address of the host on which xenvman is running will be substituted, and instead of <code>{{.Self.ExposedPort 27017}}</code> an external port will be substituted, which was forwarded to the internal 27017. </p><br><p>  Read more about interpolation <a href="https://github.com/syhpoon/xenvman">here</a> . </p><br><p>  As a result of all this, we will be able to connect to Mongo, running in the environment, right outside, for example, from the host on which we run our test. </p><br><h3 id="wuttpljs">  wut.tpl.js </h3><br><p>  So-c, having understood Monga, we will write another template for our <code>wut</code> server. <br>  Since we want to build the image on the go, the pattern will be slightly different: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tpl, params</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> img = tpl.BuildImage(<span class="hljs-string"><span class="hljs-string">"wut-image"</span></span>); img.CopyDataToWorkspace(<span class="hljs-string"><span class="hljs-string">"Dockerfile"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Extract server binary var bin = type.FromBase64("binary", params.binary); img.AddFileToWorkspace("wut", bin, 0755); // Create container var cont = img.NewContainer("wut"); cont.MountData("config.toml", "/config.toml", {"interpolate": true}); cont.SetPorts(params.port); cont.AddReadinessCheck("http", { "url": fmt('http://{{.ExternalAddress}}:{{.Self.ExposedPort %v}}/', params.port), "codes": [200] }); }</span></span></code> </pre> <br><p>  Since we are <code>BuildImage()</code> image here, we use <code>BuildImage()</code> instead of <code>FetchImage()</code> : </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> img = tpl.BuildImage(<span class="hljs-string"><span class="hljs-string">"wut-image"</span></span>);</code> </pre> <br><p>  In order to build an image, we will need several files: <br>  Dockerfile - the actual instruction how to build the image <br>  config.toml - configuration file for our <code>wut</code> server </p><br><p>  Using the <code>img.CopyDataToWorkspace("Dockerfile");</code> method <code>img.CopyDataToWorkspace("Dockerfile");</code>  we copy the Dockerfile from <a href="https://github.com/syhpoon/xenvman">the template data directory</a> to a <a href="https://github.com/syhpoon/xenvman">temporary working directory</a> . </p><br><p>  The data directory is the directory in which we can store all the files our template needs in the work. </p><br><p>  In the temporary working directory, we copy the files (using img.CopyDataToWorkspace ()), which will fall into the image. </p><br><p>  Then follows this: </p><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">// Extract server binary var bin = type.FromBase64("binary", params.binary); img.AddFileToWorkspace("wut", bin, 0755);</span></span></code> </pre> <br><p>  We pass our server's binary directly in the parameters, encoded (base64).  And in the template we simply decode it, and save the resulting string to the working directory as a file under the name <code>wut</code> . </p><br><p>  Then we create a container and mount the configuration file into it: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cont = img.NewContainer(<span class="hljs-string"><span class="hljs-string">"wut"</span></span>); cont.MountData(<span class="hljs-string"><span class="hljs-string">"config.toml"</span></span>, <span class="hljs-string"><span class="hljs-string">"/config.toml"</span></span>, {<span class="hljs-string"><span class="hljs-string">"interpolate"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>});</code> </pre> <br><p>  A call to <code>MountData()</code> means that the <code>config.toml</code> file from the data directory will be mounted inside the container as <code>/config.toml</code> .  The <code>interpolate</code> flag instructs the xenvman server to replace all existing stubs before mounting the file. </p><br><p>  Here is what the config might look like: </p><br><pre> <code class="plaintext hljs">{{with .ContainerWithLabel "mongo" "" -}} mongo = "{{.Hostname}}/wut" {{- end}}</code> </pre> <br><p>  Here we are looking for a container labeled <code>mongo</code> , and substitute the name of its host, whatever it is in this environment. </p><br><p>  After substitution, the file may look like: </p><br><pre> <code class="plaintext hljs">mongo = “mongo.0.mongo.xenv/wut”</code> </pre> <br><p>  Then we post the port again and start the readiness check, this time HTTP: </p><br><pre> <code class="javascript hljs">cont.SetPorts(params.port); cont.AddReadinessCheck(<span class="hljs-string"><span class="hljs-string">"http"</span></span>, { <span class="hljs-string"><span class="hljs-string">"url"</span></span>: fmt(<span class="hljs-string"><span class="hljs-string">'http://{{.ExternalAddress}}:{{.Self.ExposedPort %v}}/'</span></span>, params.port), <span class="hljs-string"><span class="hljs-string">"codes"</span></span>: [<span class="hljs-number"><span class="hljs-number">200</span></span>] });</code> </pre> <br><p>  On this, our templates are ready, and we can use them in the code of integration tests: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/syhpoon/xenvman/pkg/client"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/syhpoon/xenvman/pkg/def"</span></span> <span class="hljs-comment"><span class="hljs-comment">// Создаём xenvman клиент cl := client.New(client.Params{}) // Требуем создать для нас окружение env := cl.MustCreateEnv(&amp;def.InputEnv{ Name: "wut-test", Description: "Testing Wut", // Указываем, какие шаблоны добавить в окружение Templates: []*def.Tpl{ { Tpl: "wut", Parameters: def.TplParams{ "binary": client.FileToBase64("wut"), "port": 5555, }, }, { Tpl: "mongo", Parameters: def.TplParams{"tag": “latest”}, }, }, }) // Завершить окружение после окончания теста defer env.Terminate() // Получаем данные по нашему wut контейнеру wutCont, err := env.GetContainer("wut", 0, "wut") require.Nil(t, err) // Тоже самое для монго контейнера mongoCont, err := env.GetContainer("mongo", 0, "mongo") require.Nil(t, err) // Теперь формируем адреса wutUrl := fmt.Sprintf("http://%s:%d/v1/wut/", env.ExternalAddress, wutCont.Ports[“5555”]) mongoUrl := fmt.Sprintf("%s:%d/wut", env.ExternalAddress, mongoCont.Ports["27017"]) // Всё! Теперь мы можем использовать эти адреса, что подключиться к данным сервисам из нашего теста и делать с ними, что захочется</span></span></code> </pre> <br><p>  It may seem that writing templates will take too much time. <br>  However, with the right design, this is a one-time task, and then the same templates can be re-used again and again (and even for different languages!) Simply by fine-tuning them by passing certain parameters.  As you can see in the example above, the test code itself is very simple, due to the fact that all the husks for setting up the environment we have taken out in the templates. </p><br><p>  In this small example, not all the features of xenvman are shown, a more detailed step-by-step tutorial is available <a href="http://syhpoon.ca/posts/xenvman-tutorial/">here.</a> </p><br><h2 id="klienty">  Customers </h2><br><p>  At the moment there are clients for two languages: </p><br><p>  <a href="https://godoc.org/github.com/syhpoon/xenvman/pkg/client">Go</a> <br>  <a href="https://github.com/syhpoon/xenvman-python">Python</a> </p><br><p>  But adding new ones is not difficult, since the provided API is very, very simple. </p><br><h2 id="veb-interfeys">  Web interface </h2><br><p>  In version 2.0.0, a simple web interface was added, with which you can manage environments and view available templates. </p><br><p><img src="https://habrastorage.org/webt/mh/cp/bw/mhcpbw3wxz9rlsyk0nsonsid8_8.png"><br><img src="https://habrastorage.org/webt/7w/_w/wv/7w_wwvi6bq_tsr81bxafvb9vzo4.png"><br><img src="https://habrastorage.org/webt/cw/yr/wi/cwyrwiotyxbnrewwvp0gujta0j0.png"></p><br><h2 id="chem-xenvman-otlichaetsya-ot-docker-compose">  How is xenvman different from docker-compose? </h2><br><p>  Of course, there are many similarities, but xenvman seems to me a bit more flexible and dynamic approach, compared to the static configuration in the file. <br>  Here are the main distinguishing features, in my opinion: </p><br><ul><li>  Absolutely everything is managed through the HTTP API, therefore we can create environments from code of any language that understands HTTP. </li><li>  Since xenvman can be run on a different host, we can use all its capabilities even from a host on which docker is not installed. </li><li>  The ability to dynamically create images on the fly </li><li>  The possibility of changing the composition of the environment (adding / stopping containers) in the process of its work </li><li>  Reducing the boilerplate code, improving the composition and the possibility of reuse of the configuration code due to the use of parameterizable patterns </li></ul><br><h2 id="ssylki">  Links </h2><br><p>  <a href="https://github.com/syhpoon/xenvman">Github project page</a> <br>  <a href="http://syhpoon.ca/posts/xenvman-tutorial">Detailed step by step example, in English.</a> </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  That's all.  In the near future I plan to add the opportunity <br>  call templates from templates and thus allow to combine them with greater efficiency. </p><br><p>  I will try to answer any questions, and I will be glad if this project turns out to be useful to anyone else. </p></div>