<div class="post__text post__text-html js-mediator-article"><p>  Most recently, I discovered <a href="https://flutter.io/">Flutter</a> - a new framework from Google for developing cross-platform mobile applications - and even had the opportunity to show the basics of Flutter to a person who had never programmed before.  Flutter itself is written in Dart, a language that was born in the Chrome browser and escaped into the console world - and this made me think "hmm, and Flutter could well have been written on Go!". </p><br><p>  Why not?  Both Go and Dart are created by Google, both typed compiled languages ​​- turn some events a little differently, Go would be a great candidate for a large-scale project like Flutter.  Someone will say - there are no classes, generics and exceptions in Go, so it does not fit. </p><br><p>  So let's imagine that Flutter is already written on Go.  How will the code look and in general, will it work out? </p><br><p><img src="https://habrastorage.org/webt/9r/4y/cv/9r4ycvikoillhjboi5olwnta4nm.png"></p><a name="habracut"></a><br><h1 id="chto-ne-tak-s-dart">  What is wrong with dart? </h1><br><p>  I have been following this language since its inception as an alternative to JavaScript in browsers.  Dart was built into the Chrome browser for a while and the hope was that it would force out JS.  It was really sad to read in March 2015 that <a href="https://news.dartlang.org/2015/03/dart-for-entire-web.html">Dart support was removed from Chrome</a> . </p><br><p>  Dart himself is great!  Well, basically, after JavaScript, any language is great, but after, say, Go, Dart is not so beautiful.  but quite ok.  It has all imaginable and unimaginable features - classes, generics, exceptions, futures, async-await, event loop, JIT / AOT, garbage collection, function overload - name any known feature from the theory of programming languages ​​and in Dart it will be with a high proportion probabilities.  Dart has a special syntax for almost any piece - a special syntax for getters / setters, a special syntax for abbreviated constructors, a special syntax for special syntax, and much more. </p><br><p>  This makes Dart right at a glance familiar to people who have already programmed in any programming language before, and that’s great.  But trying to explain all this abundance of special features in the simple "Hello, world" example, I found that this, on the contrary, makes it difficult to master. </p><br><ul><li>  <strong>all the "special" features of the language were confused</strong> - "a special method called constructor", "a special syntax for automatic initialization", "a special syntax for named parameters", etc. </li><li>  <strong>all the "hidden" confused</strong> - "from what import is this function? is it hidden, looking at the code you can't find out", "why is there a constructor in this class, but is there no? he is there, but he is hidden" and so on </li><li>  <strong>all the “ambiguous” confused</strong> - “so here to create function parameters with or without names?”, “should there be const or final?”, “use normal function syntax here or“ abbreviated with arrow ”and so on. </li></ul><br><p>  In principle, this trinity - “special”, “hidden” and “ambiguous” - not bad captures the essence of what people call “magic” in programming languages.  These are features created to simplify the writing of code, but in fact complicating its reading and understanding. </p><br><p>  And this is exactly the area where Go takes a fundamentally different position from other languages, and fiercely holds its defense.  Go is a language practically without magic - the amount of "hidden", "special" and "ambiguous" in it is reduced to a minimum.  But Go has its drawbacks. </p><br><h1 id="chto-ne-tak-s-go">  What is wrong with Go? </h1><br><p>  Since we are talking about Flutter, and this is a UI framework, let's consider Go as a tool for describing and working with UI.  In general, UI frameworks are a colossal task and almost always require specialized solutions.  One of the most frequent approaches in the UI is the creation of <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D0%25B4%25D0%25BC%25D0%25B5%25D1%2582%25D0%25BD%25D0%25BE-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B9_%25D1%258F%25D0%25B7%25D1%258B%25D0%25BA">DSL</a> - domain-specific languages ​​- implemented in the form of libraries or frameworks, sharpened specifically for the needs of the UI.  And most often you can hear the opinion that Go is objectively a bad language for DSL. </p><br><p>  In essence, DSL means creating a new language — terms and verbs — that a developer can operate on.  The code on it should clearly describe the main features of the graphical interface and its components, be flexible enough to unleash the designer's imagination, and still be tough enough to restrict it in accordance with certain rules.  For example, you should be able to place the buttons on some container, and place the icon in the right place in this button, but the compiler should return an error if you try to insert a button in, say, text. </p><br><p>  Plus, languages ​​for describing UI are often declarative - giving the opportunity to describe the interface in the form of "what I would like to see" and let the framework understand from this what code and how to run. </p><br><p>  Some languages ​​were originally developed with such tasks on the sights, but not Go.  It seems that writing Flutter on Go will be the one more task! </p><br><h1 id="oda-flutter">  Ode flutter </h1><br><p>  If you are not familiar with Flutter yet, then I strongly recommend spending the next weekend watching educational videos or reading tutorials that are many.  Because Flutter, without any doubt, overturns the rules of the game in the development of mobile applications.  And, quite likely, not only mobile - there are already renderers (in Flutter terms, embedders) in order to run Flutter applications as <a href="https://github.com/google/flutter-desktop-embedding">native dekstop applications</a> , and as <a href="https://medium.com/flutter-io/hummingbird-building-flutter-for-the-web-e687c2a023a8">web applications</a> . </p><br><p> It is easy to learn, it is logical, it comes with a huge library of beautiful widgets on <a href="https://material.io/">Material Design</a> (and not only), it has a great and large community and an excellent tuling (if you like the ease of working with <code>go build/run/test</code> in Go, then in Flutter you will get a similar experience). </p><br><p>  A year ago I needed to write a small mobile application (for iOS and Android, of course), and I understood that the complexity of developing a high-quality application for both platforms was too great (the application was not the main task) - I had to outsource and pay for it.  In fact, writing a simple, but high-quality application running on all devices was an impossible task, even for a person with almost 20 years of programming experience.  And it has always been nonsense for me. </p><br><p>  With Flutter, I rewrote this application for 3 pm, while learning the framework from scratch.  If someone had told me that this could be a little earlier, I would not have believed it. </p><br><p>  The last time I saw a similar productivity boost with the discovery of a new technology was 5 years ago when I discovered Go.  That moment changed my life. </p><br><p>  So I recommend to start learning Flutter and <a href="https://www.youtube.com/watch%3Fv%3DGLSG_Wh_YWc">this tutorial is very good</a> . </p><br><h1 id="hello-world-na-flutter">  "Hello, World" on Flutter </h1><br><p>  When you create a new application through <code>flutter create</code> , you will receive such a program with a title, text, a counter and a button that increments the counter. </p><br><p><img src="https://habrastorage.org/webt/_1/iu/9g/_1iu9gibgfkoiyadzl0kb8be_j4.gif"></p><br><p>  I think this is a great example.  to write it on our imaginary Flutter on Go.  It has almost all the basic concepts of the framework, where you can test the idea.  Let's look at the code (this is one file): </p><br><pre> <code class="plaintext hljs">import 'package:flutter/material.dart'; void main() =&gt; runApp(MyApp()); class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, ), home: MyHomePage(title: 'Flutter Demo Home Page'), ); } } class MyHomePage extends StatefulWidget { MyHomePage({Key key, this.title}) : super(key: key); final String title; @override _MyHomePageState createState() =&gt; _MyHomePageState(); } class _MyHomePageState extends State&lt;MyHomePage&gt; { int _counter = 0; void _incrementCounter() { setState(() { _counter++; }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text( 'You have pushed the button this many times:', ), Text( '$_counter', style: Theme.of(context).textTheme.display1, ), ], ), ), floatingActionButton: FloatingActionButton( onPressed: _incrementCounter, tooltip: 'Increment', child: Icon(Icons.add), ), ); } }</code> </pre> <br><p>  Let's take a look at the code in parts, analyze what and how it falls on Go, and take a look at the various options that we have. </p><br><h2 id="perevodim-kod-na-go">  We translate the code to Go </h2><br><p>  The beginning will be simple and straightforward - import dependencies and start the function <code>main()</code> .  Nothing complicated or interesting here, the change is almost syntactic: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> hello <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/flutter/flutter"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { app := NewApp() flutter.Run(app) }</code> </pre> <br><p>  The only difference is that instead of running <code>MyApp()</code> - a function that is a constructor, which is a special function that is hidden inside a class called MyApp - we simply call the usual explicit and <code>NewApp()</code> function <code>NewApp()</code> .  It does the same thing, but it is much clearer to explain and understand what it is, how it starts and how it works. </p><br><h3 id="klassy-vidzhetov">  Widget classes </h3><br><p>  In Flutter, everything consists of widgets.  In the Dart version of Flutter, each widget is implemented as a class that inherits special classes for widgets from Flutter. </p><br><p>  In Go, there are no classes, and, accordingly, a class hierarchy, because the world is not object-oriented, and certainly not hierarchical.  For programmers familiar only with a class-oriented OOP model, this may be a revelation, but it really isn't.  The world is a giant interlaced graph of concepts, processes, and interactions.  It is not perfectly structured, but not chaotic, and an attempt to squeeze it into class hierarchies is the most reliable way to make the code base unreadable and cumbersome - just what most of the code bases are for the time being. </p><br><p><img src="https://habrastorage.org/webt/gd/9f/ad/gd9fadtyygideailxszfgw2cs_k.png"></p><br><p>  I really appreciate Go for the fact that its creators have bothered to rethink this ubiquitous class concept and have implemented Go, a much simpler and more powerful concept for the PLO, which, not by chance, turned out to be closer to what the PLO creator, Alan Kay, <a href="https://www.quora.com/What-did-Alan-Kay-mean-by-I-made-up-the-term-object-oriented-and-I-can-tell-you-I-did-not-have-C%2B%2B-in-mind">meant</a> . </p><br><p>  In Go, we represent any abstraction in the form of a specific type - structure: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyApp <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  In the Dart version of Flutter, <code>MyApp</code> should inherit a <code>StatelessWidget</code> and override the <code>build</code> method.  This is needed to solve two problems: </p><br><ol><li>  give our widget ( <code>MyApp</code> ) some special properties / methods </li><li>  enable Flutter to call our code in the build / render process </li></ol><br><p>  I do not know Flutter internals, so suppose that point number 1 is not in question, and we just have to do it.  In Go, for such a task there is a single and obvious solution - <a href="https://golang.org/doc/effective_go.html">embedding the</a> types: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyApp <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { flutter.Core <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  This code will add all the properties and methods of <code>flutter.Core</code> to our <code>MyApp</code> type.  I called it <code>Core</code> instead of <code>Widget</code> , because, firstly, embedding the type still does not make our <code>MyApp</code> widget, and, secondly, this name is very well used in the GopherJS framework <a href="https://github.com/gopherjs/vecty">Vecty</a> (something like React, only for Go).  I will touch on the topic of similarity Vecty and Flutter a little later. </p><br><p>  The second point - the implementation of the <code>build()</code> method that Flutter can use - is also solved in Go easily and unambiguously.  We only need to add a method with a specific signature that satisfies an interface defined somewhere in the library of our fictional Flutter on Go: </p><br><p>  flutter.go: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Widget <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Build(ctx BuildContext) Widget }</code> </pre> <br><p>  And now our main.go: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyApp <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { flutter.Core <span class="hljs-comment"><span class="hljs-comment">// ... } // Build renders the MyApp widget. Implements Widget interface. func (m *MyApp) Build(ctx flutter.BuildContext) flutter.Widget { return flutter.MaterialApp() }</span></span></code> </pre> <br><p>  We can notice a few differences here: </p><br><ul><li>  the code is somewhat more verbose — <code>BuildContext</code> , <code>Widget</code> and <code>MaterialApp</code> point to the <code>flutter</code> import in front of them. </li><li>  the code is somewhat less unfounded - there are no words like <code>extends Widget</code> or <code>@override</code> </li><li>  The <code>Build()</code> method begins with a capital letter, because it means the publicity of the method in Go.  In Dart, publicity is determined by whether the name begins with an underscore (_) or not. </li></ul><br><p>  So, to make a widget in our Flutter on Go, we need to embed the <code>flutter.Core</code> type and implement the <code>flutter.Widget</code> interface.  With this sorted out, dig further. </p><br><h2 id="sostoyanie">  condition </h2><br><p>  That was one of the things that confused me a lot in Flutter.  There are two different classes - <code>StatelessWidget</code> and <code>StatefulWidget</code> .  As for me, a “stateless widget” is the same widget, just without, hmm, data, state — why is there a new class here?  But ok, I can live with that. </p><br><p>  But further - more, you cannot just inherit another class ( <code>StatefulWidget</code> ), but you should write this kind of magic (IDE will do it for you, but not the essence): </p><br><pre> <code class="plaintext hljs">class MyHomePage extends StatefulWidget { @override _MyHomePageState createState() =&gt; _MyHomePageState(); } class _MyHomePageState extends State&lt;MyHomePage&gt; { int _counter = 0; void _incrementCounter() { setState(() { _counter++; }); } @override Widget build(BuildContext context) { return Scaffold() } }</code> </pre> <br><p>  Hmm, let's see what is happening here. </p><br><p>  Fundamentally, the task is as follows: add a state to the widget (state), a counter, in our case, and let the Flutter engine know when we changed the state to redraw the widget.  This is the real complexity of the problem (essential complexity in terms of Brooks). </p><br><p>  All the rest is additional complexity (accidental complexity).  Flutter on Dart comes up with a new <code>State</code> class that uses generics and accepts a widget as a type parameter.  Next, create the <code>_MyHomePageState</code> class, which inherits the <code>State виджета MyApp</code> ... ok, this can still be digested.  But why is the <code>build()</code> method defined by the State class, and not by the class that has the widget?  Brrr .... </p><br><p>  <a href="https://flutter.io/docs/resources/faq">The answer to this question</a> is in the Flutter FAQ and is described in detail <a href="https://docs.flutter.io/flutter/widgets/State/build.html">here</a> and the brief answer is to avoid a certain class of bugs when inheriting <code>StatefulWidget</code> .  In other words, this is a workaround to solve the problem of class-oriented OOP design.  Chic. </p><br><p>  How would we do this in Go? </p><br><p>  Firstly, I would personally by all means choose not to create a separate entity for the “state” - <code>State</code> .  After all, we already have a state in each specific type - these are just the fields of the structure.  Language has already given us this essence, so to speak.  Creating another similar entity will only confuse the programmer. </p><br><p>  The task, of course, is to enable Flutter to react to a change in state (this is the essence of reactive programming, after all).  And if we can "ask" the developer to use a special function ( <code>setState()</code> ), then in a similar way we can instead ask to use a special function to tell the engine when to redraw and when not.  In the end, not all state changes require redrawing, and here we will have even more control: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyHomePage <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { flutter.Core counter <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-comment"><span class="hljs-comment">// Build renders the MyHomePage widget. Implements Widget interface. func (m *MyHomePage) Build(ctx flutter.BuildContext) flutter.Widget { return flutter.Scaffold() } // incrementCounter increments widgets's counter by one. func (m *MyHomePage) incrementCounter() { m.counter++ flutter.Rerender(m) // or m.Rerender() // or m.NeedsUpdate() }</span></span></code> </pre> <br><p>  You can play <code>NeedsUpdate()</code> with different naming options - I like <code>NeedsUpdate()</code> for being direct and because this is a widget property (derived from <code>flutter.Core</code> ), but the global <code>flutter.Rerender()</code> method also looks good.  True, it gives a false sense that the widget is now immediately redrawn, but this is not so - it will be redrawn on the next frame update, and the method call frequency can be much higher than the draw frequency - but our Flutter engine should deal with this. </p><br><p>  But the idea is that we just solved the necessary task without adding: </p><br><ul><li>  new type </li><li>  generics </li><li>  special rules for reading / writing state </li><li>  special new redefined methods </li></ul><br><p>  Plus, the API is much clearer and clearer - just increment the counter (as you would in any other program) and ask Flutter to redraw the widget.  This is something that is not very obvious if we just called <code>setState</code> — which is not just a special function for setting the state, but a function that returns a function (wtf?) In which we already do something with the state.  Again, hidden magic in languages ​​and frameworks makes it very difficult to understand and read code. </p><br><p>  In our case, we solved the same problem, the code is simpler and shorter twice. </p><br><h2 id="vidzhety-s-sostoyaniem-v-drugih-vidzhetah">  Widgets with status in other widgets </h2><br><p>  As a logical continuation of the theme, let's take a look at how the “state widget” is used in another widget in Flutter: </p><br><pre> <code class="plaintext hljs">@override Widget build(BuildContext context) { return MaterialApp( title: 'Flutter Demo', home: MyHomePage(title: 'Flutter Demo Home Page'), ); }</code> </pre> <br><p>  <code>MyHomePage</code> here is a "state widget" (it has a counter), and we create it by calling the constructor <code>MyHomePage()</code> during the build ... Wait, what? </p><br><p>  <code>build()</code> is called to redraw the widget, quite possibly many times a second.  Why do we have to create a widget, especially with the state, every time during the drawing?  This makes no sense. </p><br><p>  <a href="https://flutter.io/docs/resources/technical-overview">It turns out</a> that Flutter uses this separation between <code>Widget</code> and <code>State</code> to hide this initialization / state management from the programmer (more hidden things, more!).  It creates a new widget every time, but the state, if it has already been created, finds it automatically and attaches to the widget.  This magic happens invisibly and I have no idea how it works - you need to read the code. </p><br><p>  I think this is a real evil in programming - to hide and hide from the programmer as much as possible, justifying it with ergonomics.  I am sure that the average programmer will not read the Flutter code in order to understand how this magic works, and it is unlikely that they will understand how and what is interconnected. </p><br><p>  For the Go version, I definitely would not want such a hidden witchcraft, and would prefer explicit and visible initialization, even if it means a slightly more unfounded code.  Flutter's Dart approach can certainly be implemented, but I love Go for minimizing magic, and I would like to see this philosophy in frameworks.  Therefore, my code for widgets with the state in the widget tree I would write like this: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// MyApp is our top application widget. type MyApp struct { flutter.Core homePage *MyHomePage } // NewMyApp instantiates a new MyApp widget func NewMyApp() *MyApp { app := &amp;MyApp{} app.homePage = &amp;MyHomePage{} return app } // Build renders the MyApp widget. Implements Widget interface. func (m *MyApp) Build(ctx flutter.BuildContext) flutter.Widget { return m.homePage } // MyHomePage is a home page widget. type MyHomePage struct { flutter.Core counter int } // Build renders the MyHomePage widget. Implements Widget interface. func (m *MyHomePage) Build(ctx flutter.BuildContext) flutter.Widget { return flutter.Scaffold() } // incrementCounter increments app's counter by one. func (m *MyHomePage) incrementCounter() { m.counter++ flutter.Rerender(m) }</span></span></code> </pre> <br><p>  This code loses the Dart version in that if I want to remove the <code>homePage</code> from the widget tree and replace it with something else, then I will have to clean it in three places, instead of one.  But in return, we get a complete picture of what, where and how is happening, where memory is allocated, who causes whom, and so on - the code in the palm of your hand is understandable and easy to read. </p><br><p>  By the way, Flutter still has such a thing as <a href="https://medium.com/flutter-community/stateful-widgets-be-gone-stateful-builder-a67f139725a0">StatefulBuilder</a> , which adds even more magic and allows you to make widgets with state on the fly. </p><br><h1 id="dsl">  DSL </h1><br><p>  Now we take on the most fun part.  How are we going to have a widget tree on Go?  We want it to look brief, clean, easy in refactoring and changes, describing the spatial relationships between widgets (widgets that are visually close, should be near and in the description), and, at the same time, flexible enough to describe in it an arbitrary code like event handlers. </p><br><p>  I think the option on Dart is quite beautiful and eloquent: </p><br><pre> <code class="plaintext hljs">return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text('You have pushed the button this many times:'), Text( '$_counter', style: Theme.of(context).textTheme.display1, ), ], ), ), floatingActionButton: FloatingActionButton( onPressed: _incrementCounter, tooltip: 'Increment', child: Icon(Icons.add), ), );</code> </pre> <br><p>  Each widget has a constructor that takes optional parameters, and what makes the entry really nice here is the <a href="https://en.wikipedia.org/wiki/Named_parameter">named parameters of the functions</a> . </p><br><h2 id="imenovannye-parametry">  Named Parameters </h2><br><p>  In case you are not familiar with this term, in many languages ​​the parameters of the function are called “positional”, since their position is important for the function: </p><br><pre> <code class="plaintext hljs">Foo(arg1, arg2, arg3)</code> </pre> <br><p>  , and in the case of named parameters, everything is decided by their name in the call: </p><br><pre> <code class="plaintext hljs">Foo(name: arg1, description: arg2, size: arg3)</code> </pre> <br><p>  This adds text, but saves clicks and movements through the code, in an attempt to understand what the parameters mean. </p><br><p>  In the case of the widget tree, they play a key role in readability.  Compare the same code as above, but without named parameters: </p><br><pre> <code class="plaintext hljs">return Scaffold( AppBar( Text(widget.title), ), Center( Column( MainAxisAlignment.center, &lt;Widget&gt;[ Text('You have pushed the button this many times:'), Text( '$_counter', Theme.of(context).textTheme.display1, ), ], ), ), FloatingActionButton( _incrementCounter, 'Increment', Icon(Icons.add), ), );</code> </pre> <br><p>  Not that.  true?  Not only is it more difficult to understand (you need to keep in mind what each parameter means and what its type is, and this is a significant cognitive load), but it also does not give us the freedom to choose which parameters we want to transfer.  For example, you may not want a <code>FloatingActionButton</code> for your Material, so you simply do not specify it in the parameters.  Without named parameters, we will have to either force all possible widgets to be specified, or resort to magic with reflection to find out exactly which widgets have been transmitted. </p><br><p>  And since there is no overloading of functions and named parameters in Go, this will not be an easy task for Go. </p><br><h1 id="derevo-vidzhetov-v-go">  Go tree widgets </h1><br><h2 id="versiya-1">  Version 1 </h2><br><p>  Let's take a closer look at the <a href="https://docs.flutter.io/flutter/material/Scaffold-class.html">Scaffold</a> object, which is a convenient wrapper for a mobile application.  It has several properties - appBar, drawe, home, bottomNavigationBar, floatingActionBar - and these are all widgets.  Creating a tree of widgets, we actually need to somehow initialize this object, passing it the above-mentioned widget properties.  Well, this is not too different from the usual creation and initialization of objects. </p><br><p>  Let's try the approach "in the forehead": </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> flutter.NewScaffold( flutter.NewAppBar( flutter.Text(<span class="hljs-string"><span class="hljs-string">"Flutter Go app"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>), ), <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, flutter.NewCenter( flutter.NewColumn( flutter.MainAxisCenterAlignment, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, []flutter.Widget{ flutter.Text(<span class="hljs-string"><span class="hljs-string">"You have pushed the button this many times:"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>), flutter.Text(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>, m.counter), ctx.Theme.textTheme.display1), }, ), ), flutter.FloatingActionButton( flutter.NewIcon(icons.Add), <span class="hljs-string"><span class="hljs-string">"Increment"</span></span>, m.onPressed, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, ), )</code> </pre> <br><p>  Not the most beautiful UI code, definitely.  The word <code>flutter</code> everywhere asking for it.  to hide it (actually, I had to call the package <code>material</code> , not <code>flutter</code> , but not the essence), the nameless parameters are completely unclear, and these <code>nil</code> s everywhere are completely confusing. </p><br><h2 id="versiya-2">  Version 2 </h2><br><p>  Since anyway most of the code will use one type or function from the <code>flutter</code> package, we can use the “dot import” format to import the package into our namespace and, thus, hide the package name: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> . <span class="hljs-string"><span class="hljs-string">"github.com/flutter/flutter"</span></span></code> </pre> <br><p>  Now, instead of <code>flutter.Text</code> we can write just <code>Text</code> .  This is usually a bad practice, but we are working with the framework, and this import will be literally in every line.  From my practice, this is exactly the case for which such an import is admissible - for example, as when using a wonderful <a href="http://goconvey.co/">GoConvey</a> testing <a href="http://goconvey.co/">framework</a> . </p><br><p>  Let's see what the code will look like: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewScaffold( NewAppBar( Text(<span class="hljs-string"><span class="hljs-string">"Flutter Go app"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>), ), <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, NewCenter( NewColumn( MainAxisCenterAlignment, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, []Widget{ Text(<span class="hljs-string"><span class="hljs-string">"You have pushed the button this many times:"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>), Text(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>, m.counter), ctx.Theme.textTheme.display1), }, ), ), FloatingActionButton( NewIcon(icons.Add), <span class="hljs-string"><span class="hljs-string">"Increment"</span></span>, m.onPressed, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, ), )</code> </pre> <br><p>  Already better, but these nil-s and unnamed parameters .... </p><br><h2 id="versiya-3">  Version 3 </h2><br><p>  Let's see what the code will look like if we use reflection (the ability to inspect the code while the program is running) to analyze the passed parameters.  This approach is used in several early HTTP frameworks on Go ( <a href="https://github.com/go-martini/martini">martini</a> , for example), and is considered a very bad practice - it is insecure, loses the convenience of the type system, is relatively slow and adds magic to the code - but for the sake of experiment you can try: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewScaffold( NewAppBar( Text(<span class="hljs-string"><span class="hljs-string">"Flutter Go app"</span></span>), ), NewCenter( NewColumn( MainAxisCenterAlignment, []Widget{ Text(<span class="hljs-string"><span class="hljs-string">"You have pushed the button this many times:"</span></span>), Text(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>, m.counter), ctx.Theme.textTheme.display1), }, ), ), FloatingActionButton( NewIcon(icons.Add), <span class="hljs-string"><span class="hljs-string">"Increment"</span></span>, m.onPressed, ), )</code> </pre> <br><p>  Not bad, and it looks like the original version of Dart, but the lack of named parameters still hurts the eye much. </p><br><h2 id="versiya-4">  Version 4 </h2><br><p>  Let's step back a bit and ask ourselves what exactly we are trying to do.  We do not need to blindly copy the Dart approach (although this will be a nice bonus - less new to teach people already familiar with Flutter on Dart).  In essence, we simply create new objects and assign properties to them. </p><br><p>  Maybe try this way? </p><br><pre> <code class="go hljs">scaffold := NewScaffold() scaffold.AppBar = NewAppBar(Text(<span class="hljs-string"><span class="hljs-string">"Flutter Go app"</span></span>)) column := NewColumn() column.MainAxisAlignment = MainAxisCenterAlignment counterText := Text(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>, m.counter)) counterText.Style = ctx.Theme.textTheme.display1 column.Children = []Widget{ Text(<span class="hljs-string"><span class="hljs-string">"You have pushed the button this many times:"</span></span>), counterText, } center := NewCenter() center.Child = column scaffold.Home = center icon := NewIcon(icons.Add), fab := NewFloatingActionButton() fab.Icon = icon fab.Text = <span class="hljs-string"><span class="hljs-string">"Increment"</span></span> fab.Handler = m.onPressed scaffold.FloatingActionButton = fab <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> scaffold</code> </pre> <br><p> Такой подход будет работать, и хоть он и решает нашу проблему с "именованными параметрами", он таки сильно запутывает картинку дерева виджетов в целом. Во-первых, порядок определения виджетов меняется на обратный – чем глубже виджет, тем раньше он должен быть создан. Во-вторых, мы потеряли удобную визуальную структуру кода, которая даже с помощью отступов быстро давала понять глубину виджета в дереве. </p><br><p> Кстати, этот подход использовался очень давно в UI фреймворках вроде <a href="https://www.gtk.org/">GTK</a> или <a href="https://www.qt.io/">Qt</a> . Посмотрите, например, на <a href="http://doc.qt.io/qt-5/qtwidgets-mainwindows-mainwindow-mainwindow-cpp.html">код из документации</a> последнего Qt 5: </p><br><pre> <code class="plaintext hljs"> QGridLayout *layout = new QGridLayout(this); layout-&gt;addWidget(new QLabel(tr("Object name:")), 0, 0); layout-&gt;addWidget(m_objectName, 0, 1); layout-&gt;addWidget(new QLabel(tr("Location:")), 1, 0); m_location-&gt;setEditable(false); m_location-&gt;addItem(tr("Top")); m_location-&gt;addItem(tr("Left")); m_location-&gt;addItem(tr("Right")); m_location-&gt;addItem(tr("Bottom")); m_location-&gt;addItem(tr("Restore")); layout-&gt;addWidget(m_location, 1, 1); QDialogButtonBox *buttonBox = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel, this); connect(buttonBox, &amp;QDialogButtonBox::rejected, this, &amp;QDialog::reject); connect(buttonBox, &amp;QDialogButtonBox::accepted, this, &amp;QDialog::accept); layout-&gt;addWidget(buttonBox, 2, 0, 1, 2);</code> </pre><br><p> Поэтому вполне допускаю, что для кого-то такой формат будет привычней и роднее. Но, всё же, тяжело спорить с тем, что это не наилучший способ построения дерева виджетов в виде кода. </p><br><h2 id="versiya-5"> Версия 5 </h2><br><p> Ещё один вариант, который я хочу попробовать – это создание дополнительных типов с параметрами для передачи в функции-конструкторы.  For example: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewScaffold(ScaffoldParams{ AppBar: NewAppBar(AppBarParams{ Title: Text(TextParams{ Text: <span class="hljs-string"><span class="hljs-string">"My Home Page"</span></span>, }), }), Body: NewCenter(CenterParams{ Child: NewColumn(ColumnParams{ MainAxisAlignment: MainAxisAlignment.center, Children: []Widget{ Text(TextParams{ Text: <span class="hljs-string"><span class="hljs-string">"You have pushed the button this many times:"</span></span>, }), Text(TextParams{ Text: fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>, m.counter), Style: ctx.textTheme.display1, }), }, }), }), FloatingActionButton: NewFloatingActionButton( FloatingActionButtonParams{ OnPressed: m.incrementCounter, Tooltip: <span class="hljs-string"><span class="hljs-string">"Increment"</span></span>, Child: NewIcon(IconParams{ Icon: Icons.add, }), }, ), }) }</code> </pre> <br><p> Ухты! Это, очень даже неплохо. Вот эти типы <code>...Params</code> немного бросаются в глаза, но всё равно это сильно лучше остальных вариантов пока что. Такой подход, кстати, довольно часто используется и библиотеках на Go и особенно хорошо работает, когда у вас есть лишь пару структур, которые нужно создавать таким образом. </p><br><p> Вообще-то, есть способ убрать многословность <code>...Params</code> , но для этого потребуется изменение в языке. Есть даже предложение (proposal) как раз под это — <a href="https://github.com/golang/go/issues/12854">"нетипизированные составные литералы"</a> . По сути, это означает возможность сократить <code>FloatingActionButtonParameters{...}</code> до <code>{...}</code> в теле параметров функции. Вот как будет выглядеть код: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewScaffold({ AppBar: NewAppBar({ Title: Text({ Text: <span class="hljs-string"><span class="hljs-string">"My Home Page"</span></span>, }), }), Body: NewCenter({ Child: NewColumn({ MainAxisAlignment: MainAxisAlignment.center, Children: []Widget{ Text({ Text: <span class="hljs-string"><span class="hljs-string">"You have pushed the button this many times:"</span></span>, }), Text({ Text: fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>, m.counter), Style: ctx.textTheme.display1, }), }, }), }), FloatingActionButton: NewFloatingActionButton({ OnPressed: m.incrementCounter, Tooltip: <span class="hljs-string"><span class="hljs-string">"Increment"</span></span>, Child: NewIcon({ Icon: Icons.add, }), }, ), }) }</code> </pre> <br><p> Это почти идеальное совпадение с версией на Dart! Хотя она и потребует создание типов для каждого виджета. </p><br><h2 id="versiya-6"> Версия 6 </h2><br><p> Ещё один вариант, который я хотел бы протестировать это инициализация параметров цепочкой. Я забыл, как этот паттерн называется, но и не важно, потому что паттерны должны рождаться из кода, а не наоборот. </p><br><p> Идея в том, что при создании объекта, мы его возвращаем, и тут же можем вызывать метод-сеттер, который возвращает изменённый объект – и так один за другим: </p><br><pre> <code class="go hljs">button := NewButton(). WithText(<span class="hljs-string"><span class="hljs-string">"Click me"</span></span>). WithStyle(MyButtonStyle1)</code> </pre> <br><p>  or </p><br><pre> <code class="go hljs">button := NewButton(). Text(<span class="hljs-string"><span class="hljs-string">"Click me"</span></span>). Style(MyButtonStyle1)</code> </pre> <br><p> Тогда наш код для Scaffold-виджета будет выглядеть вот так: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Build renders the MyHomePage widget. Implements Widget interface. func (m *MyHomePage) Build(ctx flutter.BuildContext) flutter.Widget { return NewScaffold(). AppBar(NewAppBar(). Text("Flutter Go app")). Child(NewCenter(). Child(NewColumn(). MainAxisAlignment(MainAxisCenterAlignment). Children([]Widget{ Text("You have pushed the button this many times:"), Text(fmt.Sprintf("%d", m.counter)). Style(ctx.Theme.textTheme.display1), }))). FloatingActionButton(NewFloatingActionButton(). Icon(NewIcon(icons.Add)). Text("Increment"). Handler(m.onPressed)) }</span></span></code> </pre> <br><p> Это тоже не сильно чужеродный концепт для Go – многие библиотеки его используют для опций конфигурации, например. Он синтаксически несколько отличается от Dart-версии, но всё таки обладает всеми необходимыми свойствами: </p><br><ul><li> явное построение дерева </li><li> именованные "параметры" </li><li> отступы помогающие понять глубину виджета </li><li> возможность указывать обработчики и произвольный код </li></ul><br><p> Также во всех примерах мне нравится использование классического именования <code>New...()</code> для конструкторов – просто функция, которая создаёт объект. Это сильно проще объяснять новичку в программировании, чем объяснять конструкторы — <strong>"это тоже функция, но у неё имя такое же, как у класса, но ты не увидишь эту функцию, потому что она специальная, и просто глядя на функцию, ты не можешь легко понять – это функция или конструктор объекта с таким именем"</strong> . </p><br><p> Так или иначе, из всех вариантов, 5-й и 6-й мне кажутся наиболее привлекательными. </p><br><h1 id="finalnaya-versiya-koda"> Финальная версия кода </h1><br><p> Соберём все части вместе и попробуем записать наш "hello, world" на воображаемом Flutter на Go: </p><br><p> main.go </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> hello <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/flutter/flutter"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { flutter.Run(NewMyApp()) }</code> </pre> <br><p> app.go: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> hello <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> . <span class="hljs-string"><span class="hljs-string">"github.com/flutter/flutter"</span></span> <span class="hljs-comment"><span class="hljs-comment">// MyApp is our top application widget. type MyApp struct { Core homePage *MyHomePage } // NewMyApp instantiates a new MyApp widget func NewMyApp() *MyApp { app := &amp;MyApp{} app.homePage = &amp;MyHomePage{} return app } // Build renders the MyApp widget. Implements Widget interface. func (m *MyApp) Build(ctx BuildContext) Widget { return m.homePage }</span></span></code> </pre> <br><p> home_page.go: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> hello <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> . <span class="hljs-string"><span class="hljs-string">"github.com/flutter/flutter"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// MyHomePage is a home page widget. type MyHomePage struct { Core counter int } // Build renders the MyHomePage widget. Implements Widget interface. func (m *MyHomePage) Build(ctx BuildContext) Widget { return NewScaffold(ScaffoldParams{ AppBar: NewAppBar(AppBarParams{ Title: Text(TextParams{ Text: "My Home Page", }), }), Body: NewCenter(CenterParams{ Child: NewColumn(ColumnParams{ MainAxisAlignment: MainAxisAlignment.center, Children: []Widget{ Text(TextParams{ Text: "You have pushed the button this many times:", }), Text(TextParams{ Text: fmt.Sprintf("%d", m.counter), Style: ctx.textTheme.display1, }), }, }), }), FloatingActionButton: NewFloatingActionButton( FloatingActionButtonParameters{ OnPressed: m.incrementCounter, Tooltip: "Increment", Child: NewIcon(IconParams{ Icon: Icons.add, }), }, ), }) } // incrementCounter increments app's counter by one. func (m *MyHomePage) incrementCounter() { m.counter++ flutter.Rerender(m) }</span></span></code> </pre> <br><p> Очень даже ничего! </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><h4 id="pohozhest-s-vecty"> Похожесть с Vecty </h4><br><p> Я не мог не обратить внимание на то, как сильно моё решение напоминает то, как мы пишем код на <a href="https://github.com/gopherjs/vecty">Vecty</a> . Во многом, они, в принципе, похожи, только Vecty выводит результат в DOM/CSS/JS, а Flutter под собой несёт мощный и написанный с нуля движок рендеринга и анимаций, дающий красивейшую графику и крутую анимацию на 120 кадрах в секунду. Но мне кажется, что дизайн Vecty очень удачен, и моё решение для Flutter на Go напоминает Vecty неспроста. </p><br><h4 id="luchshee-ponimanie-dizayna-flutter"> Лучшее понимание дизайна Flutter </h4><br><p> Этот мысленный эксперимент был интересен сам по себе – не каждый день приходится писать код на фреймворке, которого не существует. Но он также заставил меня глубже копнуть дизайн и техническую документацию Flutter, чтобы лучше понять что стоит за той скрытой магией. </p><br><h4 id="nedostatki-go"> Недостатки Go </h4><br><p> Отвечая на вопрос <strong>"Может ли Flutter быть реализован на Go?"</strong> мой ответ однозначное <strong>"да"</strong> , но я, безусловно, предубеждён, наверняка ещё не знаю массу ограничений и требований, стоящих перед Flutter, и, вообще, такие вопросы не имеют "правильного" ответа всё равно. Я больше был заинтересован в том, что именно в Go хорошо или плохо ложится на нынешний дизайн. </p><br><p> Эксперимент продемонстрировал, что <strong>наибольшая проблема с Go была исключительно в синтаксисе</strong> . Невозможность вызывать функцию и передать имена параметров создала существенные затруднения в дизайне читабельного и понятного дерева виджетов. Есть предложения по <a href="https://github.com/golang/go/issues/12296">добавлению именованных параметров</a> в будущие версии Go, и, похоже, эти изменения даже обратно-совместимые. Но их добавление – это ещё одна вещь для изучения, ещё один выбор перед каждой функцией и так далее, так что кумулятивная польза не так уж очевидна. </p><br><p> Я не встретил проблем с отсутствием дженериков или исключений в Go. Если вам известен лучший способ достичь описанной задачи в эксперименте с помощью дженериков – напишите пожалуйста в комментариях с примерами кода, я буду искренне заинтересован их услышать. </p><br><h4 id="mysli-o-buduschem-flutter"> Мысли о будущем Flutter </h4><br><p> Мои заключительные мысли будут о том, что Flutter необыкновенно хорош, несмотря на всё то бурчание, которое я себе позволил в этой статье. Соотношение "крутота/так себе" на удивление велико, и Dart достаточно легко схватывается (как минимум, людям, знакомым с другими языками программирования). Учитывая браузерную родословную Dart, я мечтаю, что однажды все браузерные движки (хотя, сколько их там осталось) будут идти с DartVM вместо V8, и Flutter будет интегрирован нативно – и все Flutter приложения автоматически будут также и веб-приложениями. </p><br><p> Работа, проделанная над фреймворком просто астрономическая. Это проект высочайшего качества и с отличным и растущим комьюнити. Как минимум, количество неоправданно качественных материалов и туториалов просто ошеломительное как для фреймворка, версия 1.0 которого вышла меньше месяца назад. Надеюсь, когда-нибудь также внести свою лепту в проект. </p><br><p> Для меня это game changer, и я надеюсь освоить Flutter настолько, насколько возможно и писать мобильные приложения для себя и ради удовольствия, ибо это больше не будет удел компаний со штатом мобильных разработчиков. </p><br><p> Даже если вы никогда не видели себя в качестве разработчиках мобильных UI – попробуйте Flutter, это глоток свежего воздуха. </p><br><h1 id="ssylki">  Links </h1><br><ul><li> <a href="https://flutter.io/">https://flutter.io</a> </li><li> <a href="https://www.youtube.com/watch%3Fv%3DGLSG_Wh_YWc">Flutter Tutorial for Beginners — Build iOS and Android Apps</a> </li><li> <a href="https://github.com/golang/go/issues/12296">Go proposal: An Improved, Golang-Cohesive Design for Named Arguments</a> </li><li> <a href="https://github.com/golang/go/issues/12854">Go proposal: spec: untyped composite literals</a> </li></ul></div>