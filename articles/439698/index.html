<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to programming: a simple 3D shooter from scratch over the weekend, part 1</title>
  <meta name="description" content="This text is intended for those who only master programming. The basic idea is to show stage by stage how you can make a game √† la Wolfenstein 3D on y...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Introduction to programming: a simple 3D shooter from scratch over the weekend, part 1</h1><div class="post__text post__text-html js-mediator-article">  This text is intended for those who only master programming.  The basic idea is to show stage by stage how you can make a game √† la <a href="https://en.wikipedia.org/wiki/Wolfenstein_3D">Wolfenstein 3D on your</a> own.  Attention, I'm not going to compete with Carmack at all, he is a genius and his code is beautiful.  I am aiming for a completely different place: I use the tremendous computing power of modern computers so that students can create fun projects in a few days, not wallowing in the wilds of optimization.  I specifically write slow code, as it is significantly shorter and more simply understood.  Carmack <a href="https://en.wikipedia.org/wiki/Fast_inverse_square_root">writes 0x5f3759df</a> , but I write 1 / sqrt (x).  We have different goals. <br><br>  I am convinced that a good programmer is obtained only from someone who kitsit at home for his own pleasure, and not only sits his pants on pairs at the university.  In our university, programmers are taught on an endless succession of library catalogs and other things that are boring.  Brr  My goal is to show examples of projects that are fun to program.  This is a vicious circle: if it is interesting to do a project, then a person spends a lot of time on it, gains experience, and sees even more interesting things around (it has become more accessible!), And again plunges into a new project.  This is called project training, around solid profit. <br><br>  The sheet was long, so I broke the text into two parts: <br><br><ul><li>  <b>Part one: drawing the walls</b> </li><li>  <a href="https://habr.com/ru/post/439720/">Part two: we inhabit our world + window interface</a> </li></ul><br>  Running code from my repository looks like this: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/zPIVTqVilCM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  This is not a complete game, but only a blank for students.  An example of a complete game written by two freshmen, see <a href="https://habr.com/ru/post/439720/">the second part</a> . <br><a name="habracut"></a><br>  So, I‚Äôve been completely deceived by you, I‚Äôm not going to tell you how to make a full game in one weekend.  I made only 3D engine.  Monsters do not run, and the main character does not shoot.  But at least I wrote this engine for one Saturday, you can check the commit history.  In principle, Sunday is quite enough to make something playable, that is, one weekend you can meet. <br><br>  At the time of this writing, the repository contains 486 lines of code: <br><br><pre><code class="bash hljs">haqreu@daffodil:~/tinyraycaster$ cat *.cpp *.h | wc -l 486</code> </pre> <br>  The project depends on SDL2, but in general the window interface and keyboard event handling appear rather late, <a href="https://github.com/ssloy/tinyraycaster/commit/152b4778206c6931d2d75a81fae59bc6c82189a9">at midnight Saturday</a> :), when all the rendering code has already been done. <br><br>  So, I break all code into stages, starting with the bare C ++ compiler.  As in my previous articles on the schedule ( <a href="https://habr.com/ru/post/436790/">tyts</a> , <a href="https://habr.com/ru/post/437714//">tyts</a> , <a href="https://habr.com/ru/post/438646/">tyts</a> ), I adhere to the rule ‚Äúone stage = one commit‚Äù, since github makes it very convenient to view the history of code changes. <br><br><h1>  Stage 1: save the image to disk </h1><br>  So let's go.  We are still very far from the window interface, for a start we will simply save the pictures to disk.  So, we need to be able to store a picture in the computer‚Äôs memory and save it to a disk in a format that any third-party program will understand.  I want to get this file: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8bc/757/fd3/8bc757fd3da42088dbf24380970e109d.png"><br><br>  <a href="https://github.com/ssloy/tinyraycaster/commit/90b7cfb0f2e715219f81836b8b3130a5f54c3ef2">Here is the</a> full C ++ code that draws what we need: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;fstream&gt; #include &lt;vector&gt; #include &lt;cstdint&gt; #include &lt;cassert&gt; uint32_t pack_color(const uint8_t r, const uint8_t g, const uint8_t b, const uint8_t a=255) { return (a&lt;&lt;24) + (b&lt;&lt;16) + (g&lt;&lt;8) + r; } void unpack_color(const uint32_t &amp;color, uint8_t &amp;r, uint8_t &amp;g, uint8_t &amp;b, uint8_t &amp;a) { r = (color &gt;&gt; 0) &amp; 255; g = (color &gt;&gt; 8) &amp; 255; b = (color &gt;&gt; 16) &amp; 255; a = (color &gt;&gt; 24) &amp; 255; } void drop_ppm_image(const std::string filename, const std::vector&lt;uint32_t&gt; &amp;image, const size_t w, const size_t h) { assert(image.size() == w*h); std::ofstream ofs(filename); ofs &lt;&lt; "P6\n" &lt;&lt; w &lt;&lt; " " &lt;&lt; h &lt;&lt; "\n255\n"; for (size_t i = 0; i &lt; h*w; ++i) { uint8_t r, g, b, a; unpack_color(image[i], r, g, b, a); ofs &lt;&lt; static_cast&lt;char&gt;(r) &lt;&lt; static_cast&lt;char&gt;(g) &lt;&lt; static_cast&lt;char&gt;(b); } ofs.close(); } int main() { const size_t win_w = 512; // image width const size_t win_h = 512; // image height std::vector&lt;uint32_t&gt; framebuffer(win_w*win_h, 255); // the image itself, initialized to red for (size_t j = 0; j&lt;win_h; j++) { // fill the screen with color gradients for (size_t i = 0; i&lt;win_w; i++) { uint8_t r = 255*j/float(win_h); // varies between 0 and 255 as j sweeps the vertical uint8_t g = 255*i/float(win_w); // varies between 0 and 255 as i sweeps the horizontal uint8_t b = 0; framebuffer[i+j*win_w] = pack_color(r, g, b); } } drop_ppm_image("./out.ppm", framebuffer, win_w, win_h); return 0; }</span></span></span></span></code> </pre><br>  If you do not have a compiler at hand, then it does not matter, if you have an account on a githaba, you can view this code, edit it and run (sic!) In one click directly from the browser. <br><br> <a href="&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhi2STzJY0RrTHZou6_dvQ4UNmtumw#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Open in gitpod"></a> <br><br>  Using this link, gitpod will create a virtual machine for you, launch VS Code, and open a terminal on a remote machine.  In the history of terminal commands (poke into the console and click the up arrow) there is already a full set of commands that allow you to compile the code, run it and open the resulting image. <br><br>  So what you need to understand from this code.  First, the colors I store in the four-byte uint32_t integer type.  Each byte is an R, G, B, or A component. The pack_color () and unpack_color () functions allow you to get to the individual components of each color. <br><br>  The second, two-dimensional image I store in the usual one-dimensional array.  To get to the pixel with coordinates (x, y) I do not write image [x] [y], but I write image [x + y * width].  If this method of packaging two-dimensional information in a one-dimensional array for you is new, then right now take a pen and sort it out.  For me personally, this stage does not even reach the brain, it is processed directly in the spinal cord.  Three- and more-dimensional arrays can be packaged in the same way, but we will not go above the two components. <br><br>  Then I simply run through my picture with a simple double cycle, fill it with a gradient, and save it to a disk in the .ppm format. <br><br><hr><br><h1>  Stage 2: draw a level map </h1><br>  We need a map of our world.  At this stage, I just want to define the data structure and draw a map on the screen.  It should look like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7b8/c96/1c7/7b8c961c7be837c6c9777770b0eed987.png"><br><br>  Changes <a href="https://github.com/ssloy/tinyraycaster/commit/c6a12066bffdaf09e0fb68551e9eaea995fdab49">you can see here</a> .  Everything is simple there: I zahardkodil map into a one-dimensional array of characters, defined the function of drawing a rectangle, but walked around the map, drawing each cell. <br><br>  I remind you that this button will let you run the code right at this stage: <br><br> <a href="&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhi2STzJY0RrTHZou6_dvQ4UNmtumw#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Open in gitpod"></a> <br><br><hr><br><h1>  Stage 3: add a player </h1><br>  What do we need to be able to draw a player on the map?  GPS coordinates are enough :) <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cf0/dfa/e21/cf0dfae212fd0372d368f53334218301.png"><br><br>  Add two variables x and y, and draw the player in the appropriate place: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8b8/519/2e6/8b85192e6a40e7b146ecc98d219f895b.png"><br><br>  Changes <a href="https://github.com/ssloy/tinyraycaster/commit/68d2cd560e1fa6b8a8850a55cdf19ff3f34f1b03">you can see here</a> .  I won't remind you more about the guitar pod :) <br><br> <a href="&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhi2STzJY0RrTHZou6_dvQ4UNmtumw#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Open in gitpod"></a> <br><br><hr><br><h1>  Stage 4: virtual rangefinder aka first ray tracing </h1><br>  In addition to the coordinates of the player, it would be nice for us to also know in which direction he is looking.  Therefore, add another variable player_a, which gives the direction of the player‚Äôs gaze (the angle between the direction of the gaze and the x-axis): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/08d/f9a/af5/08df9aaf5713ca862e718a5fb0095d03.png"><br><br>  And now I want to be able to glide along the orange beam.  How to do it?  Extremely simple.  Let's look at the green right triangle.  We know that cos (player_a) = a / c, and that sin (player_a) = b / c. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/99c/338/bcf/99c338bcf91ba076c1bd2bfdb15e129d.png"><br><br>  What happens if I arbitrarily take the value c (positive) and count x = player_x + c * cos (player_a) and y = player_y + c * sin (player_a)?  We will be in the purple point;  By varying the parameter c from zero to infinity, we can make this purple point slide along our orange ray, and c is the distance from (x, y) to (player_x, player_y)! <br><br>  The heart of our graphics engine is such a cycle: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> c = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; c&lt;<span class="hljs-number"><span class="hljs-number">20</span></span>; c+=<span class="hljs-number"><span class="hljs-number">.05</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = player_x + c*<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(player_a); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y = player_y + c*<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(player_a); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(x)+<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(y)*map_w]!=<span class="hljs-string"><span class="hljs-string">' '</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre><br>  We move point (x, y) along the ray, if it hits an obstacle on the map, then we interrupt the cycle, and the variable c gives the distance to the obstacle!  What is not a laser rangefinder? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c9f/52d/3ce/c9f52d3ceaaffc1b4396fd13c9ab24df.png"><br><br>  Changes <a href="https://github.com/ssloy/tinyraycaster/commit/9475f8d10d9d3a3e9eae04e4910f4f7f7cbccdd8">you can see here</a> . <br><br> <a href="&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhi2STzJY0RrTHZou6_dvQ4UNmtumw#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Open in gitpod"></a> <br><br><hr><br><h1>  Stage 5: Sector Overview </h1><br>  One beam is fine, but still our eyes see a whole sector.  Let's call the angle of view fov (field of view): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1d4/83a/e06/1d483ae06cf65809eea61660c1a58db5.png"><br><br>  And we will release 512 rays (by the way, why 512?), Smoothly sweeping the whole sector of the review: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fab/271/d5d/fab271d5dfe3dd4e8b87df6fc4c52676.png"><br>  Changes <a href="https://github.com/ssloy/tinyraycaster/commit/e7a8b510aeefd3eb5fee981f5b3c4334835ce510">you can see here</a> . <br><br> <a href="&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhi2STzJY0RrTHZou6_dvQ4UNmtumw#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Open in gitpod"></a> <br><br><hr><br><h1>  Stage 6: 3D! </h1><br>  And now the key point.  For each of the 512 rays, we got the distance to the nearest obstacle, right?  And now let's make the second picture width (spoiler) 512 pixels;  in which we will draw one vertical segment for each ray, and the height of the segment is inversely proportional to the distance to the obstacle: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4f4/bf6/c7c/4f4bf6c7caa9931a087d04d6f33b4dbc.png"><br><br>  Once again, this is the key moment in creating the illusion of 3D, make sure that you understand what is being said.  When drawing vertical segments, in fact, we draw a palisade, where the height of each stake is the smaller, the further it is from us: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ed6/fc6/030/ed6fc60305a6da0d29d07850ba49e92a.jpg"><br><br>  Changes <a href="https://github.com/ssloy/tinyraycaster/commit/da2257985e6a9b97eaafc13ccf6578dc3fdb1959">you can see here</a> . <br><br> <a href="&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhi2STzJY0RrTHZou6_dvQ4UNmtumw#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Open in gitpod"></a> <br><br><hr><br><h1>  Stage 7: First Animation </h1><br>  At this stage, we draw something dynamic for the first time (I just throw 360 pictures onto the disk).  Everything is trivial: I change player_a, draw the picture, save, change player_a, draw, save.  To make it a bit more fun, I assigned a random color value to each cell type in our map. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/29d/38f/f7a/29d38ff7a03c91429cd5cbd7476fb8ed.gif"><br>  Changes <a href="https://github.com/ssloy/tinyraycaster/commit/ff7d714453501de5aeac21607fc05b4c76fab5d7">you can see here</a> . <br><br> <a href="&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhi2STzJY0RrTHZou6_dvQ4UNmtumw#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Open in gitpod"></a> <br><br><hr><br><h1>  Stage 8: Fish Eye Correction </h1><br>  Did you notice what a great ‚Äúfish eye‚Äù effect we get when we look at the wall up close?  Something like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/362/fe7/f78/362fe7f78fc2d314e09b36f39d0bab6d.png"><br><br>  Why?  Yes, very simple.  Here we are looking at the wall: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e67/632/227/e6763222768e380912c1c47d51a95871.png"><br><br>  To draw our wall we sweep our blue viewing area with a violet ray.  Take the specific value of the direction of the beam, as in this picture.  The length of the orange segment is clearly less than the length of purple.  Since to determine the height of each vertical segment that we draw on the screen, we divide by the distance to the barrier, the fisheye is quite natural. <br><br>  Correcting this distortion is not difficult; <a href="https://github.com/ssloy/tinyraycaster/commit/35ed743b6f4fbe84b454edde5d04c1c5518bcbf0">see how it is done</a> .  Please make sure you understand where the cosine came from.  Draw a scheme on a piece of paper helps a lot. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/df8/a7d/df4/df8a7ddf414fdc2018bd1649be3682f9.gif"><br><br> <a href="&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhi2STzJY0RrTHZou6_dvQ4UNmtumw#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Open in gitpod"></a> <br><br><hr><br><h1>  Stage 9: loading the texture file </h1><br>  It is time to deal with textures.  I am lazy to write an image uploader myself, so I took a great <a href="https://github.com/nothings/stb">stb library</a> .  I prepared a file with textures for the walls, all the textures are square and packed into an image horizontally: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5c6/48e/8fd/5c648e8fd4cca05610b977b3f5b31cfe.png"><br><br>  At this stage, I just load the textures into memory.  To check the performance of the written code, I just draw the texture with index 5 in the upper left corner of the screen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8e4/a78/a9a/8e4a78a9a98ccfe4acd81ceb8f2faafa.png"><br>  Changes <a href="https://github.com/ssloy/tinyraycaster/commit/f84ae5aac9bcbfbf9b031827141e368952ee99bf">you can see here</a> . <br><br> <a href="&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhi2STzJY0RrTHZou6_dvQ4UNmtumw#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Open in gitpod"></a> <br><br><hr><br><h1>  Stage 10: rudimentary use of textures </h1><br>  Now I throw out randomly generated colors and tint my walls, taking the upper left pixel from the corresponding texture: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/87d/21d/0b1/87d21d0b13110a2b05194033b8f609aa.png"><br>  Changes <a href="https://github.com/ssloy/tinyraycaster/commit/df8fb12a3e1ff4327d963c237e4d4e8a42f260fe">you can see here</a> . <br><br> <a href="&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhi2STzJY0RrTHZou6_dvQ4UNmtumw#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Open in gitpod"></a> <br><br><hr><br><h1>  Stage 11: Textured Walls for Real </h1><br>  And now the long-awaited moment has come when we will finally see the brick walls: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/175/e25/e71/175e25e71fccf3ad167a120b878f1b60.png"><br><br>  The basic idea is very simple: here we glide along the current beam and stop at the point x, y.  Let's suppose that we stopped on a ‚Äúhorizontal‚Äù wall, then y is almost integer (not quite, because our way of moving along the beam introduces a small error).  Let's take the fractional part of x and call it hitx.  The fractional part is less than one, therefore, if we multiply hitx by the texture size (I have 64), then this will give us the texture column to be drawn in this place.  It remains to stretch it to the desired size and the trick is: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1f9/444/f1c/1f9444f1cb378b082588479885799b80.png"><br><br>  In general, the idea is extremely primitive, but it requires careful execution, since we also have ‚Äúvertical‚Äù walls (those with hitx will be close to zero [x is integer]).  For them, the texture column is determined by hity, the fractional part of y.  Changes <a href="https://github.com/ssloy/tinyraycaster/commit/8e221cbc89e523a60f4ff9915b94ad7abeef844b">you can see here</a> . <br><br> <a href="&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhi2STzJY0RrTHZou6_dvQ4UNmtumw#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Open in gitpod"></a> <br><br><hr><br><h1>  Stage 12: time to refactor! </h1><br>  At this stage I didn‚Äôt do anything new, I just started general cleaning.  Until now, I had one giant (185 lines!) File, and it became difficult to work in it.  Therefore, I broke it into a small cloud, unfortunately, at the same time almost doubling the size of the code (319 lines), without adding any functionality.  But it has become much more convenient to use, for example, in order to generate an animation, it is enough to do such a cycle: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> frame=<span class="hljs-number"><span class="hljs-number">0</span></span>; frame&lt;<span class="hljs-number"><span class="hljs-number">360</span></span>; frame++) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">stringstream</span></span> ss; ss &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::setfill(<span class="hljs-string"><span class="hljs-string">'0'</span></span>) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::setw(<span class="hljs-number"><span class="hljs-number">5</span></span>) &lt;&lt; frame &lt;&lt; <span class="hljs-string"><span class="hljs-string">".ppm"</span></span>; player.a += <span class="hljs-number"><span class="hljs-number">2</span></span>*M_PI/<span class="hljs-number"><span class="hljs-number">360</span></span>; render(fb, <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>, player, tex_walls); drop_ppm_image(ss.str(), fb.img, fb.w, fb.h); }</code> </pre><br>  Well, here's the result: <br><br><img src="https://raw.githubusercontent.com/ssloy/tinyraycaster/master/doc/012.gif"><br>  Changes <a href="https://github.com/ssloy/tinyraycaster/commit/80e6e4a815e6b17ad731d4c5bd9ca34698fe2cfe">you can see here</a> . <br><br> <a href="&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhi2STzJY0RrTHZou6_dvQ4UNmtumw#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Open in gitpod"></a> <br><br><h1>  To be continued ... immediately </h1><br>  On this optimistic note, I finish the current half of my sheet, the second half <a href="https://habr.com/ru/post/439720/">is available here</a> .  In it, we add monsters and link up with SDL2 so that we can walk in our virtual world. </div><p>Source: <a href="https://habr.com/ru/post/439698/">https://habr.com/ru/post/439698/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>