<div class="post__text post__text-html js-mediator-article">  A few months ago, my USB keyboard project was completed.  Among other things, I designed the electronic circuits, designed the printed circuit boards, programmed the firmware, made the layout in CAD and assembled the device.  The result is a comfortable keyboard that I use every day and affectionately call KeeBee: <br><br> <a href=""><img src="https://habrastorage.org/webt/ad/2w/y9/ad2wy9hofgppmzgmk_a7fqobizo.jpeg"></a> <br>  <i><font color="gray">Keyboard KeeBee in final form</font></i> <br><br>  Several project goals: <br><br><ol><li>  Independent creation of the scheme. <br></li><li>  Writing keyboard firmware. <br></li><li>  Learn how the USB protocol works. </li></ol><a name="habracut"></a><br>  At work, I mainly develop software for cloud services, where many layers of real hardware are missing.  Therefore, it is very pleasant to get rid of some abstractions and go down to the hardware level: here are real electronic devices that can be touched and used. <br><br><h1>  CAD study and layout </h1><br>  I really like the minimalist keyboard in the style of <a href="https://olkb.com/">OLKB</a> Planck and Preonic, which, due to the ortholinear arrangement of the keys, turn out to be very compact.  I also knew right away that I wanted to use the Cherry MX Brown switches.  Having in mind these two components of the design, I started playing with the key layouts in <a href="http://www.openscad.org/">OpenSCAD</a> .  This is a great open source tool that works more like a programming language than a mouse WYSIWYG interface. <br><br>  Taking the dimensions of the elements from the Cherry MX documentation, I <a href="">made a top plate layout</a> , then added switches and keys to get an idea of ​​what the final result would look like.  The top plate is located above the keyboard PCB and serves as a good stabilizer for the switches. <br><br>  Top plate design: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd7/e5c/0d0/dd7e5c0d0f409136cd386b09e6f1cb9b.png"><br><br>  After adding keys: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/247/053/a3e/247053a3edee7464dcaf24b343dc2be4.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/6bc/8fb/e4b/6bc8fbe4b1620d728838609fecc836f1.png"><br><br><h1>  Board prototyping and firmware design </h1><br>  I chose <a href="https://www.digikey.com/product-detail/en/stmicroelectronics/STM32F042K6T6/497-14647-ND/4815294">STM32F042K6T6</a> as the main microcontroller.  This is about three dollars per chip, if you take from one piece.  He has enough contacts for the <a href="https://en.wikipedia.org/wiki/Keyboard_matrix_circuit">matrix scan</a> 69 keys (total 32 contacts).  It runs on an ARM Cortex M0 processor and contains special USB peripherals for sending a USB signal without loading the main processor for this task.  I bought <a href="https://www.digikey.com/product-detail/en/NUCLEO-F042K6/497-15980-ND/5428804">a Nucleo dev board for prototyping</a> with this chip before integrating it into my PCB design.  Nucleo very conveniently lay down on the mock-up board and powered over USB. <br><br>  I placed a small four-key circuit on the breadboard to test the <a href="https://habr.com/ru/post/394585/">diode circuit</a> I was studying.  Ignoring the USB side of the equation, the first step was to force the Cherry switches to safely turn on and off the four corresponding LEDs when the buttons are pressed. <br><br><img src="https://habrastorage.org/webt/6z/ks/xw/6zksxwfpdqzy4winp9vk3if_kd0.jpeg"><br><br>  The scan matrix is ​​a technique that needs to be used when you have more switches than contacts on the microcontroller. <br><br>  When the matrix <a href="">worked satisfactorily</a> , it's time to work on USB. <br><br>  The built-in firmware cycle is essentially as follows: <br><br><ol><li>  Scan all the keys in the matrix. <br></li><li>  Match the location of the buttons with the corresponding characters in the selected layout (QWERTY, Dvorak, etc.). <br></li><li>  Take the matching result, generate USB HID Report packages and send to a USB peripheral device. <br></li><li>  Turn on the LED on the keyboard, if the key is pressed, turn it off - if not. </li></ol><br>  From <a href="">main.cc</a> : <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scan_and_update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ scan_matrix.Scan(key_scans, row_count, column_count); keyboard.SendReport( key_pipeline.MapKeyScans(key_scans, key_count)); update_key_press_status(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Init(); status_led.SetOk(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { scan_and_update(); } }</code> </pre> <br>  The <code>keyboard.SendReport</code> component actually transfers packets to the USB host.  I tried hard to get USB to work properly.  This protocol has many non-trivial layers that require precise timing and proper <a href="">device identification</a> .  In the end, I had to run Wireshark to listen to all the USB packets coming into my Linux laptop and find out where everything was lost.  An Internet search practically did nothing, most questions are answered like this: “Probably, your USB device has broken, you need to buy a new one.”  If you are actually trying to <i>design a</i> USB device, such answers are not very helpful.  I just had to immerse myself in the volume specifications of USB with a lot of unfamiliar terminology. <br><br>  Having fidgeted for a while, I still made the keyboard with four keys correctly identify itself as a USB HID (Human Interface Device) and all clicks were transferred to the laptop correctly: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/901/712/4b7/9017124b76d06f097826194838cc06e2.png"><br><br>  Registering as a USB vendor and getting an official device id is <a href="https://www.usb.org/getting-vendor-id">expensive</a> .  If you just have an amateur project, then you have to <a href="">grab the ID of some similar device</a> .  I thought that “Gear Head” sounds cool, the more they release keyboards, so I chose them. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/457/e29/628/457e296280138ee96564ca190685c836.png"><br><br><h1>  Circuit and PCB </h1><br>  Having received a more or less working firmware and a working prototype, it’s time to draw up a circuit and PCB design in <a href="http://kicad-pcb.org/">KiCAD</a> and make a real PCB.  When I achieved that the scheme for 4 buttons works, there was a relatively simple task to put everything together: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/82c/4e9/047/82c4e9047e47a8b5c7f9d71979fb1643.png"><br><br>  After the development of the scheme and installation of sites for components, you need to produce a layout of the real printed circuit board: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/433/7db/515/4337db515b6a1672924dc9c0e527b20e.png"><br><br>  KiCAD is able to beautifully render future motherboard in 3D: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b8/73a/15f/6b873a15ffb39ac5033f68bfac74722c.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/bb3/caa/3bd/bb3caa3bd098b51889b4db0aeebfd4c0.png"><br><br>  There are a lot of great KiCAD tutorials.  I started with the excellent video <a href="https://www.youtube.com/watch%3Fv%3DJN_Y93RTdSo%26list%3DPLy2022BX6Eso532xqrUxDT1u2p4VVsg-q">series Getting to Blinkey 4.0</a> from Chris Gammela, where he explains in detail all the steps involved in creating an LED elinking scheme in KiCAD from beginning to end. <br><br><h1>  PCB and component order </h1><br>  Having brought the <a href="https://github.com/blakesmith/embedded/tree/master/keebee/hardware">circuit and design of the PCB</a> to a satisfactory level, I began to place a bunch of orders: <br><br><ol><li>  All components from the <a href="">list of materials</a> : switches, LEDs, diodes, microcontrollers, etc. I usually order such things on <a href="https://www.digikey.com/">DigiKey</a> . <br></li><li>  The circuit board itself.  Quite a lot of services are ready to make you a prototype cheap.  I have a great experience with <a href="https://oshpark.com/">OshPark</a> and <a href="https://jlcpcb.com/">JLCPCB</a> .  For this project, I chose JLCPCB because of the price of this size, and also because they were allowed to choose a blue coating. <br></li><li>  All other details: covers and stuff.  For this project, my brother-in-law helped the laser cut the top and bottom keyboard plates from 1/4 ”acrylic sheets.  For the remaining parts, you can use the online services of laser cutting and 3D printing, if there is no access to the equipment. </li></ol><br>  The day when the parcel arrived with the fee is the best: <br><br><img src="https://habrastorage.org/webt/58/zh/tq/58zhtqbwaxb5-dfy2vxzrkg14uu.jpeg"><br><br><img src="https://habrastorage.org/webt/0e/il/ln/0eillnhgbfcciaovcjl3hwushyq.jpeg"><br><br>  JLCPCB is a very affordable service.  This design with the delivery of DHL from China cost less than $ 30, and the whole process took a little more than a week from downloading files to the arrival of the package. <br><br>  Shurin took the <a href="">DXF files</a> from OpenSCAD and threw them into the laser cutter: <br><br><img src="https://habrastorage.org/webt/xr/ww/4i/xrww4ips2bdp6lonon3vxcl8dji.jpeg"><br><br><h1>  Final build </h1><br>  After receiving all the details, I started the assembly.  The first step is to assemble the components of the printed circuit board: a soldering iron for large electronic components and a <a href="https://learn.sparkfun.com/tutorials/how-to-use-a-hot-air-rework-station/all">soldering station</a> for surface mounting small components, such as an STM32 microcontroller. <br><br>  The total assembly time of the board was about three hours - most of it was soldered to 70 diodes and switches. <br><br>  I added a header for JTAG debugging, through which I connected <a href="https://www.adafruit.com/product/3571">JLINK Edu mini</a> for microcontroller firmware using <a href="http://openocd.org/">OpenOCD</a> . <br><br>  Then it's time for final testing and final assembly: <br><br><img src="https://habrastorage.org/webt/hy/yx/w3/hyyxw3ukirnhihemampdyqi9fh0.jpeg"><br><br><img src="https://habrastorage.org/webt/jn/te/zv/jntezvouheop_oqkcylzgvriaj4.jpeg"><br><br><img src="https://habrastorage.org/webt/bt/zn/nu/btznnuwjhqasmyfimlchnur8vki.jpeg"><br><br>  The son decided that this was a great train for his animals: <br><br><img src="https://habrastorage.org/webt/uy/nl/d1/uynld1ae660x2w5um-nta3rvwvy.jpeg"><br><br><img src="https://habrastorage.org/webt/zs/ih/4w/zsih4wdyjnnzezye3e06row6zyi.jpeg"><br><br><h1>  Results </h1><br>  From the initial idea to the final assembly, the project took about three months.  It was extremely useful as a hobby to do what I still use every day at work. <br><br>  All project files are <a href="https://github.com/blakesmith/embedded/tree/master/keebee">published on GitHub</a> , including firmware sources, printed circuit layouts, materials list, and CAD models. <br><br>  Thanks for reading and nice hacks! </div>