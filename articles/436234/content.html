<div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/tq/9u/iw/tq9uiw8d_nbb1bbwrfdg1euyvci.png"></p><br><h1 id="motivaciya">  Motivation </h1><br><p>  When I first started to learn Haskell, I was very annoyed by the widespread use of complex abstractions instead of some specific solutions.  It seemed to me that it would be much better to always follow the KISS principle and write bicycles using elementary language constructions than to sort through all these types of classes in order to write one supposedly convenient structure somewhere in the end. </p><br><p>  I lacked a good example where the efforts spent on mastering the "materiel" would pay off.  For me, one of the most successful such examples was the parsers.  Now I often talk about them when they ask me for which common tasks you can beautifully use Haskell. </p><br><p>  I want to suggest that beginners also go through this path and create from scratch a small base of functions for conveniently implementing parsers, and then use it to write your own parser, the code of which will almost literally repeat the grammar that is being analyzed. </p><br><p>  I hope it will help someone to overcome the fear of abstractions and teach them how to use them (yes, I still think that sometimes it is more efficient to write a bicycle). </p><a name="habracut"></a><br><p>  I have no goal and no desire to make a Haskell course out of the article from scratch, so I assume that the reader is familiar with the syntax and independently developed simple programs.  Just in case, I will briefly talk about the type classes before proceeding to the description of the implementation. </p><br><p>  For those who have never written in Haskell, but want to understand what is going on here, I recommend that you first look at the corresponding page on <a href="https://learnxinyminutes.com/docs/haskell/">Learn X in Y minutes</a> .  As an excellent Russian-language book for beginners, I advise Denis Shevchenko, <a href="https://www.ohaskell.guide/">"About Haskell like a human being"</a> . </p><br><p>  I will try to use the most simple language constructs that beginners can understand.  At the end of the article there is a link to the source repository, where in some parts of the code a more convenient and short record is used, which may be less clear at a glance. </p><br><p>  And yes, gentlemen, Haskelists, many things are explained very simply and clumsily, for particular cases, not very abstract, without the use of terms from category theory and other scary words.  I am glad that you know them and of course easily mastered them.  I also know them, but I do not consider it necessary to throw out such a volume of information in this context to unprepared readers. </p><br><h1 id="klassy-tipov">  Type Classes </h1><br><p>  Type classes in Haskell have nothing to do with classes in C ++ and other object-oriented languages.  If we draw an analogy with OOP, the types of classes are more like the overloading of methods and functions. </p><br><p> Classes define what actions can be performed with objects of the types that are included in the class.  For example, all numbers can be compared by equality, but everything can be ordered except complex ones, and functions in general cannot be compared at all.  The class of types that can be compared is called <code>Eq</code> , ordered - <code>Ord</code> (types do not have to be numeric).  What can be printed by translating into a string belongs to the class <code>Show</code> , it has the “opposite” class <code>Read</code> , which determines how to convert the strings to objects of the desired type. </p><br><p>  For a set of standard classes of types (such as <code>Eq</code> , <code>Show</code> , <code>Read</code> ...), you can ask the compiler to implement the necessary functionality in the standard way, using the <code>deriving</code> keyword after determining the type: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Point</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Point</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xCoord</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Float</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">yCoord</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Float</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  You can define your own type classes: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PrettyPrint</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> pPrint :: a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span></code> </pre> <br><p>  Here <code>PrettyPrint</code> is the class name, <code>a</code> is a type variable.  The <code>where</code> keyword is followed by a list of so-called class methods, i.e.  functions that can be applied to objects of type from this class. </p><br><p>  In order to denote the belonging of a data type to a class, the following construction is used: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PrettyPrint</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Point</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> pPrint (<span class="hljs-type"><span class="hljs-type">Point</span></span> xy) = <span class="hljs-string"><span class="hljs-string">"("</span></span> ++ show x ++ <span class="hljs-string"><span class="hljs-string">", "</span></span> ++ show y ++ <span class="hljs-string"><span class="hljs-string">")"</span></span></code> </pre> <br><p>  The language allows you to specify restrictions on the types of classes to which the function arguments should refer: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">showVsPretty</span></span> :: (<span class="hljs-type"><span class="hljs-type">Show</span></span> a, <span class="hljs-type"><span class="hljs-type">PrettyPrint</span></span> a) =&gt; a -&gt; (<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>) showVsPretty x = (show x, pPrint x)</code> </pre> <br><p>  For each function call, the compiler checks whether these requirements for the type are met, and if it fails, it displays an error (of course, this happens at the compilation stage). </p><br><pre> <code class="haskell hljs">&gt;&gt;&gt; showVsPretty (<span class="hljs-type"><span class="hljs-type">Point</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) (<span class="hljs-string"><span class="hljs-string">"Point {xCoord = 2.0, yCoord = 3.0}"</span></span>,<span class="hljs-string"><span class="hljs-string">"(2.0, 3.0)"</span></span>) &gt;&gt;&gt; showVsPretty <span class="hljs-string"><span class="hljs-string">"str"</span></span> error: <span class="hljs-type"><span class="hljs-type">No</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> for (<span class="hljs-type"><span class="hljs-type">PrettyPrint</span></span> [<span class="hljs-type"><span class="hljs-type">Char</span></span>]) arising from a use <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> 'showVsPretty'</code> </pre> <br><h1 id="realizaciya">  Implementation </h1><br><p>  The parser receives as input a string that should parse according to predefined rules and get the value of the type we need (for example, an integer).  In this case, the input line may not end, and the remainder will serve as an input for further parsing.  In addition, our parser will generally be non-deterministic, i.e.  will return several possible parse results as a list. </p><br><p>  For describing one result of a parser, a two-element tuple <code>(String, a)</code> suitable, where <code>a</code> is a type variable that can designate any custom type. </p><br><p>  Since the parser parses the string according to some rules, we describe it as a function that takes a string as input and returns a list of results: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Parser</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Parser</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unParser</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> -&gt; [(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)] }</span></span></code> </pre> <br><p>  We will consider the parsing successful if the list of results consists of one element and the input string has been completely processed.  We implement an auxiliary function that attempts to perform an unambiguous parsing of the entire string: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parseString</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a parseString s (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (ps) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> [(<span class="hljs-string"><span class="hljs-string">""</span></span>, val)] -&gt; <span class="hljs-type"><span class="hljs-type">Just</span></span> val _ -&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span></code> </pre> <br><h2 id="prosteyshie-parsery">  Simple parsers </h2><br><p>  We implement several simple parsers, which will then come in handy in building more complex combinations. </p><br><p>  We begin by parsing a single character that must satisfy the predicate.  If the input string is empty, then the result of the work is an empty list.  Otherwise, check the value of the predicate on the first character of the string.  If the return value is <code>True</code> , then the parsing result is this character;  return it along with the rest of the string.  Otherwise, parsing also ends in failure. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">predP</span></span> :: (<span class="hljs-type"><span class="hljs-type">Char</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Char</span></span> predP p = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> f <span class="hljs-string"><span class="hljs-string">""</span></span> = [] f (c : cs) | pc = [(cs, c)] | otherwise = []</code> </pre> <br><p>  Now we can write a parser that accepts a specific character at the beginning of a line.  To do this, use the <code>predP</code> just written and give it as an argument a function that compares its argument with the symbol we need: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">charP</span></span> :: <span class="hljs-type"><span class="hljs-type">Char</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Char</span></span> charP char = predP (\c -&gt; c == char)</code> </pre> <br><p>  The following simplest case: a parser that accepts only a specific string entirely.  <code>stringP</code> call it <code>stringP</code> .  The function inside the parser compares the input string with the required one and, if the lines are equal, returns a list of one element: a pair of empty lines (nothing left at the input) and the original one.  Otherwise, the parsing failed, and an empty list of results is returned. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">stringP</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> stringP s = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> fs' | s == s' = [(<span class="hljs-string"><span class="hljs-string">""</span></span>, s)] | otherwise = []</code> </pre> <br><p>  Quite often, you need to skip characters that have a certain property while they are at the beginning of a line (for example, whitespace characters).  At the same time, the result of the analysis is not important to us and will not be useful in the future.  We write the <code>skip</code> function, which skips the initial characters of the string, while the true value of the predicate is preserved.  As a result of the analysis we use an empty tuple. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">skip</span></span> :: (<span class="hljs-type"><span class="hljs-type">Char</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> () skip p = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; [(dropWhile ps, ())])</code> </pre> <br><p>  The following two parsers are very similar to each other.  Both check the input string prefix, only the first returns the prefix if successful, and the second returns an empty tuple, i.e.  allows you to skip a random string at the beginning of the entry  For implementation, the <code>isPrefixOf</code> function, defined in the <code>Data.List</code> module, is <code>Data.List</code> . </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">prefixP</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> prefixP s = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> f input = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s `isPrefixOf` input <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> [(drop (length s) input, s)] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> [] skipString :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> () skipString s = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> f input = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s `isPrefixOf` input <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> [(drop (length s) input, ())] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> []</code> </pre> <br><p>  A little later, we will look at a simpler implementation of the last function and get rid of code duplication. </p><br><h2 id="parser-kak-funktor">  Parser as a functor </h2><br><p>  We can distinguish a whole class of container types for which the following is true: if you know how to transform objects inside a container, then you can convert the containers themselves.  The simplest example is the list as a container and the <code>map</code> function, which is available in almost all high-level languages.  Indeed, you can go through all the elements of the list of type <code>[a]</code> , apply the function <code>a -&gt; b</code> to each and get a list of type <code>[b]</code> . </p><br><p>  This type class is called <code>Functor</code> , the class has one <code>fmap</code> method: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> f </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap :: (a -&gt; b) -&gt; fa -&gt; fb</code> </pre> <br><p>  Suppose we already know how to parse strings into objects of some type <code>a</code> , and, moreover, we know how to convert objects of type <code>a</code> into objects of type <code>b</code> .  Can we say that then there is a parser for objects of type <code>b</code> ? </p><br><p>  If we express this in the form of a function, then it will have the following type: </p><br><pre> <code class="haskell hljs">(a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> b</code> </pre> <br><p>  This type coincides with the type of the <code>fmap</code> function, so we will try to make the parser a functor.  Create from scratch a parser of values ​​of type <code>b</code> , which will first call the first parser (we already have one), and then apply the function to the results of its parsing. </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Parser</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap :: (a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> b fmap f (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p1) = <span class="hljs-type"><span class="hljs-type">Parser</span></span> p2 <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p2 :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; [(<span class="hljs-type"><span class="hljs-type">String</span></span>, b)] p2 s = convert (p1 s) convert :: [(<span class="hljs-type"><span class="hljs-type">String</span></span>, a)] -&gt; [(<span class="hljs-type"><span class="hljs-type">String</span></span>, b)] convert results = map (\(s, val) -&gt; (s, f val)) results</code> </pre> <br><p>  The <code>fmap</code> function has a convenient infix synonym: <code>fmap fx == f &lt;$&gt; x</code> . </p><br><p>  If we use a function as an argument for <code>fmap</code> , which simply replaces its first argument with a new value, we will get another useful operation that has already been implemented for all functors even in duplicate (they differ only in the order of the arguments): </p><br><pre> <code class="plaintext hljs">(&lt;$) :: Functor f =&gt; a -&gt; fb -&gt; fa ($&gt;) :: Functor f =&gt; fa -&gt; b -&gt; fb</code> </pre> <br><p>  Remember the parser that skips a particular string ( <code>skipString</code> )?  Now you can implement it as follows: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">skipString</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> () skipString s = () &lt;$ prefixP s</code> </pre> <br><h2 id="kombinacii-parserov">  Parser Combinations </h2><br><p>  In Haskell, all functions are curried by default and allow partial use.  This means that the function of <code>n</code> arguments is actually a function of one argument, which returns a function of <code>n-1</code> arguments: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">cons</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] cons = (:) cons1 :: [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] cons1 = cons <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">-- функция cons применена частично</span></span></code> </pre> <br><p>  Apply the function of three arguments to some value inside the parser, using <code>fmap</code> .  Types will be as follows: </p><br><pre> <code class="plaintext hljs">f :: c -&gt; a -&gt; b p :: Parser c (fmap fp) :: Parser (a -&gt; b)</code> </pre> <br><p>  The parser of function turned out ?!  Of course, it is possible that the input line actually contains the function representation, but I would like to be able to use this function, or rather combine the <code>Parser (a -&gt; b)</code> parsers <code>Parser (a -&gt; b)</code> and <code>Parser a</code> , to get the <code>Parser b</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">applyP</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> (a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> b</code> </pre> <br><p>  The type of this function is very similar to the type <code>fmap</code> , only the function itself that needs to be applied is also in the container.  This gives an intuitive understanding of how the implementation of the <code>applyP</code> function should look like: get the function from the container (as a result of applying the first parser), get the values ​​to which the function should be applied (the result of applying the second parser) and “pack” the values ​​converted by this function back in the container (create a new parser).  In the implementation we will use list comprehension: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">applyP</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> (a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> b applyP (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p1) (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p2) = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> fs = [ (sx, fx) | (sf, f) &lt;- p1 s, <span class="hljs-comment"><span class="hljs-comment">-- p1 применяется к исходной строке (sx, x) &lt;- p2 sf] -- p2 применяется к строке, оставшейся после предыдущего разбора</span></span></code> </pre> <br><p>  There is a class <code>Applicative</code> , which has a method with the same prototype.  The second class method is called <code>pure</code> and is used to "wrap" or "lift" ( <em>lift</em> ) a value, including a functional one.  When implemented for a parser, the <code>pure</code> function adds its argument to the result of the parser, without changing the input string. </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> f =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Applicative</span></span></span><span class="hljs-class"> f </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> pure :: a -&gt; fa (&lt;*&gt;) :: f (a -&gt; b) -&gt; fa -&gt; fb <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Applicative</span></span> <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> pure x = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; [(s, x)]) pf &lt;*&gt; px = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; [ (sx, fx) | (sf, f) &lt;- unParser pf $ s, (sx, x) &lt;- unParser px $ sf])</code> </pre> <br><p>  The <code>applyP</code> function is the <code>&lt;*&gt;</code> from the <code>Applicative</code> class.  Types belonging to this class are called applicative functors. </p><br><p>  For applicative functors, two auxiliary functions are implemented that will be useful to us: </p><br><pre> <code class="haskell hljs">(*&gt;) :: fa -&gt; fb -&gt; fb (&lt;*) :: fa -&gt; fb -&gt; fa</code> </pre> <br><p>  These functions perform two consecutive actions and return the result of only one of them.  For parsers, they can be used, for example, in order to skip leading gaps before parsing the part of the line that carries the meaning. </p><br><p>  By combining <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> , you can create very convenient designs.  Consider the following data type: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyStructType</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyStruct</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type1</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field2</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type2</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field3</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type3</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p>  The constructor of <code>MyStruct</code> values ​​is also a function, in this case it is of type <code>Type1 -&gt; Type2 -&gt; Type3 -&gt; MyStructType</code> .  You can work with the constructor as with any other function.  Suppose that parsers are already written for the structure field types: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parser1</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Type1</span></span> parser2 :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Type2</span></span> parser3 :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Type3</span></span></code> </pre> <br><p>  Using the <code>fmap</code> function, you can partially apply <code>MyStruct</code> to the first of these parsers: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserStruct'</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> (<span class="hljs-type"><span class="hljs-type">Type2</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Type3</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">MyStructType</span></span>) parserStruct' = <span class="hljs-type"><span class="hljs-type">MyStruct</span></span> &lt;$&gt; parser1</code> </pre> <br><p>  Let's try to continue to use the function, which is now "inside" the parser.  For this you need to use <code>&lt;*&gt;</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserStruct''</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> (<span class="hljs-type"><span class="hljs-type">Type3</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">MyStructType</span></span>) parserStruct'' = parserStruct' &lt;*&gt; parser2 parserStruct :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">MyStructType</span></span> parserStruct = parserStruct'' &lt;*&gt; parser3</code> </pre> <br><p>  As a result, we got a parser for the whole structure (of course, here we use the assumption that in the initial line of the presentation of its fields go in a row).  The same can be done in one line: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserStruct</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">MyStructType</span></span> parserStruct = <span class="hljs-type"><span class="hljs-type">MyStruct</span></span> &lt;$&gt; parser1 &lt;*&gt; parser2 &lt;*&gt; parser3</code> </pre> <br><p>  Such designs will often be found in the example of use. </p><br><p>  Now suppose that we are trying to write a parser that parses simple arithmetic expressions in which integers and identifiers can be present as operands.  Create a separate type of <code>Operand</code> for them: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Operand</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IntOp</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IdentOp</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span></span></code> </pre> <br><p>  If we can already parse integers and identifiers (for example, as in C), then we need <em>one</em> parser for operands that can parse one or the other.  This parser is an alternative of the other two, so we need a function that can combine parsers so that the results of their work are combined.  The result of the parser is a list, and the union of lists is their concatenation.  We implement the <code>altP</code> function combining two parsers: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">altP</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a altP (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p1) (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p2) = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; p1 s ++ p2 s)</code> </pre> <br><p>  Then the operand parser can be implemented using this function (here it is assumed that <code>parserInt</code> and <code>parserIdent</code> already described somewhere: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserOperand</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Operand</span></span> parserOperand = altP parserIntOp parserIdentOp <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> parserIntOp = <span class="hljs-type"><span class="hljs-type">IntOp</span></span> &lt;$&gt; parserInt parserIdentOp = <span class="hljs-type"><span class="hljs-type">IdentOp</span></span> &lt;$&gt; parserIdent</code> </pre> <br><p>  Of course, for the alternatives have already come up with a separate class, which is called <code>Alternative</code> .  There is another method, <code>empty</code> , which describes the neutral element for the alternative operation.  In our case, this is a parser that never parses anything, i.e.  always returns an empty list of results.  For the parser, the implementation of the <code>Alternative</code> class methods looks like this: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Applicative</span></span></span><span class="hljs-class"> f =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Alternative</span></span></span><span class="hljs-class"> f </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> empty :: fa (&lt;|&gt;) :: fa -&gt; fa -&gt; fa <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Alternative</span></span> <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> empty = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (const []) px &lt;|&gt; py = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; unParser px s ++ unParser py s)</code> </pre> <br><p>  The <code>&lt;|&gt;</code> operation is the <code>altP</code> function, only in the infix notation, which is more convenient to use, combining several parsers in a row. </p><br><p>  For all types in this class, two functions are implemented, <code>some</code> and <code>many</code> type <code>fa -&gt; f [a]</code> .  Each of them can be expressed through the other: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">some</span></span> v = (:) &lt;$&gt; v &lt;*&gt; many v many v = some v &lt;|&gt; pure []</code> </pre> <br><p>  In terms of parsers, these functions allow you to parse data sequences, if you know how to parse one data element.  If used, <code>some</code> sequence must be non-empty. </p><br><h1 id="primer-ispolzovaniya">  Usage example </h1><br><p>  Now we are ready to write our parser, for example, for simple arithmetic expressions with the following grammar: </p><br><pre> <code class="plaintext hljs"> expr ::= constExpr | binOpExpr | negExpr const ::= int int ::= digit{digit} digit ::= '0' | ... | '9' binOpExpr ::= '(' expr ' ' binOp ' ' expr ')' binOp ::= '+' | '*' negExpr ::= '-' expr</code> </pre> <br><p>  The expression consists of integer constants, unary minus and two infix binary operations: addition and multiplication.  Brackets are required around an expression with a binary operation, the operation symbol is separated from the operands by exactly one space, leading and trailing spaces are not allowed. </p><br><p>  Examples of correct expression writing: </p><br><pre> <code class="plaintext hljs">"123" "-(10 + 42)" "(1 + ((2 + 3) * (4 + 5)))"</code> </pre> <br><p>  Examples of incorrect entries: </p><br><pre> <code class="plaintext hljs">" 666 " "2 + 3" "(10 * 10)"</code> </pre> <br><p>  We declare the necessary data types (the expression itself and the binary operation): </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ConstExpr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BinaryExpr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Operator</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NegateExpr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Operator</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Add</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Mul</span></span></span></span></code> </pre> <br><p>  You can start parsing!  The expression itself consists of three alternatives.  So we write: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- expr ::= constExpr | binOpExpr | negExpr exprParser :: Parser Expr exprParser = constParser &lt;|&gt; binParser &lt;|&gt; negParser</span></span></code> </pre> <br><p>  The constant is a positive integer.  In our data type, it is "wrapped" in the constructor, so we cannot use the parser for an integer directly, but we can use <code>fmap</code> to get the value of the desired type. </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- const ::= int constParser :: Parser Expr constParser = ConstExpr &lt;$&gt; intParser</span></span></code> </pre> <br><p>  The integer, according to the grammar, is represented as a non-empty sequence of numbers.  To parse a single digit, we use the auxiliary function <code>predP</code> and the predicate <code>isDigit</code> from the <code>Data.Char</code> module.  Now, to build a parser, we use the function <code>some</code> (not <code>many</code> , because there must be at least one number) to parse the sequence of numbers.  The result of this parser returns a list of all possible parsing options, starting with the longest entry.  For example, if the input string is "123ab", the list of results will be as follows: <code>[("ab", "123"), ("3ab", "12"), ("23ab", "1")]</code> .  We need to parse the longest sequence of numbers and convert it to type <code>Int</code> .  The whole implementation is as follows: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- int ::= digit{digit} -- digit ::= '0' | ... | '9' intParser :: Parser Int intParser = Parser $ \s -&gt; let res = unParser (some digitParser) s in case res of [] -&gt; [] ((rest, i) : xs) -&gt; [(rest, read i)] where digitParser = predP isDigit</span></span></code> </pre> <br><p>  The next variant of the expression is the use of a binary operation.  According to the grammar, the input string must first include an opening bracket, the first operand, a space, an operation symbol, another space, the second operand, and a closing bracket.  To parse individual characters (parentheses and spaces) use the function <code>charP</code> .  Operands are expressions, and there is already a parser for them to parse ( <code>exprParser</code> ).  To parse the binary operation symbol, we will describe the auxiliary parser just below.  It remains to carefully combine this set of parsers.  At the beginning and at the end of the expression there should be brackets: you need to check this, but discard the result itself.  For this we use <code>*&gt;</code> and <code>&lt;*</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">binParser</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Expr</span></span> binParser = charP '(' *&gt; ??? &lt;* charP ')'</code> </pre> <br><p>  Between these parsers for the parentheses, the construction of the expression should be done using the <code>BinaryExpr</code> constructor and parsers for the expression and operation.  Let's not forget about the spaces around the operation symbol, using the same method as for parentheses.  This part is as follows: </p><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">BinaryExpr</span></span> &lt;$&gt; exprParser <span class="hljs-comment"><span class="hljs-comment">-- первый операнд &lt;*&gt; (charP ' ' *&gt; binOpParser &lt;* charP ' ') -- операция, окружённая пробелами &lt;*&gt; exprParser -- второй операнд</span></span></code> </pre> <br><p>  Substitute this expression instead of question marks: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- binOpExpr ::= '(' expr ' ' binOp ' ' expr ')' binParser :: Parser Expr binParser = charP '(' *&gt; (BinaryExpr &lt;$&gt; exprParser &lt;*&gt; (charP ' ' *&gt; binOpParser &lt;* charP ' ') &lt;*&gt; exprParser ) &lt;* charP ')'</span></span></code> </pre> <br><p>  A binary operation is either the <code>+</code> character, which understands the value of <code>Add</code> , or <code>*</code> , which understands <code>Mul</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- binOp ::= '+' | '*' binOpParser :: Parser Operator binOpParser = plusParser &lt;|&gt; multParser where plusParser = charP '+' $&gt; Add multParser = charP '*' $&gt; Mul</span></span></code> </pre> <br><p>  Remained the simplest part of the grammar, the negation of expression.  With the symbol <code>-</code> do the same as with brackets and spaces.  Next, we apply the <code>NegateExpr</code> constructor to the result of recursive parsing: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- negExpr ::= '-' expr negParser = charP '-' *&gt; (NegateExpr &lt;$&gt; exprParser)</span></span></code> </pre> <br><p>  So, all parts of the parser are implemented.  The code in many ways resembles a grammar and completely coincides with it in structure. </p><br><p>  The source code is available on GitLab: <a href="https://gitlab.com/fierce-katie/applicative-parsers-demo">https://gitlab.com/fierce-katie/applicative-parsers-demo</a> . </p><br><p>  It is easier to estimate its volume and degree of expressiveness there, since there are far fewer comments.  The project can be assembled with the <a href="https://www.haskellstack.org/">Stack</a> utility and you can launch a primitive interpreter using the parser we wrote: </p><br><pre> <code class="plaintext hljs">$ stack build $ stack exec demo-parser</code> </pre> <br><p>  For those who want to practice further on their own, I can advise the following: </p><br><ul><li>  Grammar can be improved in every way, for example, to allow leading and trailing spaces, add new operations, etc. </li><li>  The parser translates the string into the internal representation of the expression.  This expression can be calculated and converted by the interpreter so that it prints not the result of the parsing but the result of the calculation. </li><li>  Examine the capabilities of the <code>parsec</code> , <code>attoparsec</code> , <code>applicative-parsec</code> and <code>optparse-applicative</code> libraries, try them out. </li></ul><br><p>  Thanks for attention! </p><br><h1 id="poleznye-materialy">  Useful materials </h1><br><ol><li>  <a href="https://learnxinyminutes.com/docs/haskell/">Learn Haskell in Y minutes</a> </li><li>  <a href="https://www.ohaskell.guide/">Denis Shevchenko.</a>  <a href="https://www.ohaskell.guide/">"About Haskell Humanly"</a> </li><li>  <a href="http://hackage.haskell.org/package/parsec">Parsec library</a> </li><li>  <a href="http://hackage.haskell.org/package/attoparsec">Attoparsec library</a> </li><li>  <a href="http://hackage.haskell.org/package/applicative-parsec">Applicative-parsec library</a> </li><li>  <a href="http://hackage.haskell.org/package/optparse-applicative">Optparse-applicative library</a> </li></ol></div>