<div class="post__text post__text-html js-mediator-article"><p>  It so happens that the project comes to a standstill, and its further development becomes impossible.  It is not rare that the failure of such an architecture, which was laid down at the beginning of development, becomes the cause of such a failure.  Or do we have to observe disputes about which of the “two chairs” is better, or maybe even participate and sincerely not understand how an opponent can think like that !? </p><br><p>  Then try not to understand much about the abstractions, where they come from and what to do with them. </p><a name="habracut"></a><br><p>  According to <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25B1%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F">Wikipedia,</a> Abstraction is a theoretical generalization as a result of abstraction.  In its turn, abstraction is a distraction in the process of cognition from non-essential aspects, properties, connections of an object (object or phenomenon) in order to single out their essential, regular features. </p><br><p>  From the definition we can conclude that only meaningful can be an abstraction.  At the same time, perception is only a projection of the real world.  It turns out that all thoughts about the real are reflections on our real models. </p><br><p>  Abstractions form hierarchies, and can be identified with both private entities and unite similar entities into higher-level abstractions. </p><br><h4 id="abstrakcii-v-soznanii">  Abstractions in the mind </h4><br><p>  In addition to the prism of perception, our models are subjected to another distortion: real entities are extremely complex and have different aspects and parameters.  When thinking or talking about something, there is always a context in which the model exists.  And sometimes it happens that the interlocutors have a different context.  And to top it off, the presence or absence of experience (global) leads to an even greater change in our models in accordance with this experience.  As a result, two different people may have a very different perception of the same entities of the real world. </p><br><p>  It turns out that each person constantly deals with abstractions, it remains to learn how to see and manage them clearly.  You can put forward the thesis that the program code is a simulation of thinking based on formal abstractions.  Therefore, in my opinion, software development is one of the best simulators for pumping abstract thinking. </p><br><h5 id="abstrakcii-v-razrabotke">  Abstractions in development </h5><br><p>  Software interfaces are perhaps the most obvious formal abstraction.  All unnecessary is cut off and only “what it does” without “how it does” remains. <br>  By implementing the interface, we create a more realistic model of behavior or interaction, which can already answer the question "how."  By combining the interfaces with each other, we can create a common code architecture.  With proper skill and skill, the architecture created in this way will maintain its structure in the future.  While implementations of composite interfaces may change beyond recognition. </p><br><p>  This architecture simplifies some points in the work.  Unit testing is reduced to writing test implementations of "neighboring" abstractions and test methods that compare input and output.  Module isolation allows you to safely refactor.  Moreover, if the refactoring was unsuccessful and everything broke, then only one module would have to be rolled back.  A rather abstracted module can be used for similar, but different tasks.  In this case, one poor implementation will not affect the work of others - shit isolation. </p><br><div class="spoiler">  <b class="spoiler_title">Example</b> <div class="spoiler_text"><p>  There is a module for processing input data, there are several options for obtaining them: from a database;  from file;  by http.  This task can be solved by selecting a common interface for receiving data and making an implementation for each channel and a data channel for testing.  Now, a single handler using the “data channel” parameter can solve several similar problems.  And if it turns out that one of the implementations is a curve, then it can be converted to affecting other modules. </p></div></div><br><h4 id="abstrakciy-bolshe-ne-nado">  Abstractions are no longer needed </h4><br><p>  There are no perfect solutions, and abstractions are not so smooth.  First, abstractions are subjective, they can cause controversy about where one begins and the other begins.  There is also the problem of excessive abstraction, when each type and tonality of a sneeze creates its own abstraction.  Secondly, this approach increases the complexity of the code by adding new entities and new levels of hierarchy.  I am sure that there will be more shortcomings of this approach, some of them will be subjective, some situational, but there will be </p><br><p>  There must be a balance in everything.  For myself, I brought the following memo. </p><br><ul><li>  If a large and important module is written, it is better to unlink it. </li><li>  If the module is used a lot and / or in different places - it is better to hide it behind the abstraction. </li><li>  If the module should be distributed as a separate library, it is better to use abstractions. </li><li>  If it is possible to change the algorithms or interaction paths, it is better to implement the interaction of abstractions. </li><li>  If a class is used in another class and nowhere else, you can think about combining them or leaving them as they are. </li><li>  If this is a small "one-time" task - it is better not to bother with its complication. </li><li>  If this is a module that most likely will never change - you can display its interface and better leave it as it is. </li></ul><br><h4 id="itogo">  Total </h4><br><p>  Abstractions are a tool embedded in our consciousness, like any other, they have their pros and cons, but knowing the alternatives only helps to find the best way. </p></div>