<div class="post__text post__text-html js-mediator-article"><p>  Hello!  It will be about hotkeys in WEBAPI + JavaScript, we will consider their ways of organizing and the problems that arise primarily in large applications. <br><img src="https://habrastorage.org/webt/zl/e2/zq/zle2zqvpyquemp6mux7dazteywi.jpeg"></p><br><p>  Consider how to handle keys on a specific task. </p><br><h2 id="zadacha">  "Task" </h2><br><p>  Imagine that in an existing project you need to implement keyboard input processing.  At the same time, the project interface and its controllers, for purely historical reasons, such as they are.  And they are the following: </p><br><p> <code>ParentController</code> in which there are two components with their own states and state.  <code>Controller1</code> and the element that uses <code>CTRL+SHIFT+F</code> to search the site, and <code>Controller2</code> with its DOM element, which is a local area, in the presence of which the search is performed inside it.  At the same time they can be on the screen at the same time.  Below are several ways to solve this problem. </p><a name="habracut"></a><br><h4 id="1-keyboardeventhttpsdevelopermozillaorgrudocswebapikeyboardevent-i-ego-ruchnaya-obrabotka">  1. “ <a href="https://developer.mozilla.org/ru/docs/Web/API/KeyboardEvent">KeyboardEvent</a> and its manual processing” </h4><br><p>  KeyboardEvent objects describe the keyboard user experience.  Each event describes a key;  The event type (keydown, keypress, or keyup) determines the type of action produced. </p><br><p>  Sounds great doesn't it?  Let's take a closer look. <br>  Consider intercepting keystrokes <code>CTRL+SHIFT+F</code> , usually corresponding to a global search call. </p><br><pre> <code class="javascript hljs">element.addEventListener(<span class="hljs-string"><span class="hljs-string">'keypress'</span></span>, (event) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> keyName = event.key; <span class="hljs-comment"><span class="hljs-comment">// Приведение к нижнему регистру имени клавиши обязательно // т.к. при нажатии вместе с SHIFT оно будет в верхнем регистре if (event.ctrlKey &amp;&amp; event.shiftKey &amp;&amp; event.key.toLowerCase() === 't') { alert('CTRL+SHIFT+T pressed'); } });</span></span></code> </pre> <br><p>  Now, we can apply to our problem in two ways (for example) </p><br><p>  <strong>Perform key interception in controllers 1 and 2 separately</strong> </p><br><p>  This will lead to the fact that depending on the order in the DOM, you may need to <code>useCapture</code> to ensure the order of processing Controller2 and then Controller1.  So you get isolated logic, but if the application is complex and there are many such controllers, this solution is not good.  some may be on the screen at the same time and they may have their own strict processing order, which does not depend on their position in the DOM tree.  (see <a href="https://habr.com/ru/post/126471/">bubbling and capturing</a> ) </p><br><p>  <strong>Perform key interception in <code>CommonController</code></strong> </p><br><p>  An alternative solution may be to handle clicks in a common parent controller, which knows exactly when to show its children, controlled by the first and second controllers.  This, while increasing the child controllers, will not cause difficulties in catching events and making decisions on which controller to handle the keys.  However, there will be another problem - a thick <code>if</code> appears in the parent controller, which handles all possible cases.  For large applications, this solution is not suitable, because  at some point, another <code>Controller</code> may appear that is not a child of the <code>ParentController</code> then you have to <code>ParentController</code> handler to a higher level, to their common parent, and so on ... Sooner or later one of the controllers will not know too much about the elements inside it. </p><br><p><img src="https://habrastorage.org/webt/ca/di/uz/cadiuzohwqgknd297ncomfzyb9i.png"><br>  In fact, only 80% of browsers can work with <code>KeboardEvent.key</code> , in all others you will need to operate <code>KeboardEvent.keyCode</code> : <code>Number</code> key codes.  Which greatly complicates life.  Here it is worth going to the description of the disadvantages of this approach. </p><br><p>  <strong>Minuses:</strong> </p><br><ul><li>  The organization of the code is not entirely convenient, a map of character codes and their text equivalent and other utilities reducing the amount of code in handlers are required. </li><li>  80% Browser support for working with characters without using their codes is still not enough. </li><li>  Overlapping with the <code>useCapture</code> some handlers by others. </li><li>  If there are hooks with <code>useCapture</code> and nested elements with the same handlers <br>  debugging is difficult. </li><li>  Poor scalability. </li></ul><br><p>  But natively, there are no unnecessary dependencies and libraries. </p><br><p>  Then we will discuss two libraries, one of which was designed to solve their own similar problems. </p><br><h4 id="2-ispolzovanie-biblioteki-hotkeyshttpsgithubcomjaywcjlovehotkeys">  2. “Using the <a href="https://github.com/jaywcjlove/hotkeys">HotKeys</a> library” </h4><br><p>  Three thousand stars on a githaba, modest size and no dependencies.  The Chinese manufacturer promises us a solution that will suit everyone.  However, we will not hurry.  Let's try to solve our problem with its help. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// обработчик клавиш hotkeys('ctrl+shift+f', function(event, handler){ alert('CTRL+SHIFT+T pressed'); });</span></span></code> </pre> <br><p>  The syntax is already much shorter, and the main chip for solving the problem will be the direct display of the components of controllers 1 and 2 on the screen.  A little digging through the library code makes it easy to see that handlers form a stack that fills or clears as they are registered on the screen (Assume an element with a handler that appeared later than an existing one will have priority in the hot key processing queue). </p><br><p>  Often it happens so that the element that should intercept processing appears later.  In this case, we can safely spread the logic of handling handles to each of the controllers.  And other type of chips, help us to separate one stream of clicks from another.  But in the case when the <code>порядок появления на экране ≠ приоритету обработки нажатий</code> - the same problems arise as with the native eventListener's.  We'll have to make everything in a common parent controller. </p><br><p>  In addition, it often happens that you need to block the default behavior, but the event is not considered processed (in other words, there is no unambiguous understanding of whether the event is processed or not, if we received it) or must be processed by two controllers at the same time.  One of which will cause a reaction to the behavior, and the other will just take into account what the event was. </p><br><p>  <strong>Total advantages:</strong> </p><br><ul><li>  Scope allows to separate streams. </li><li>  The syntax is clear and short. </li><li>  The order determines the appearance of the element, not the position in the DOM. </li><li>  Size and no dependencies. </li></ul><br><p>  <strong>Minuses:</strong> </p><br><ul><li>  You can process only one scoop at a time. </li><li>  Debugging is still difficult because of the function calls in the loop, it may not be <strong>known on which handler</strong> <del>  <strong>got lost</strong> </del>  <strong>the event was processed</strong> </li><li>  The statement that the event is processed if it has the defaultPrevented flag and its distribution is aborted - not true. </li><li>  Global functions of calling registration and unsubscribing from events </li></ul><br><p>  Suitable for solving typical tasks, but with the writing of a trading terminal or a large admin panel there will be problems with debugging for sure. </p><br><h4 id="3-ispolzovanie-biblioteki-stack-shortcutshttpsgithubcombusinessduckstack-shortcuts">  3. “Using <a href="https://github.com/BusinessDuck/stack-shortcuts">stack-shortcuts</a> library” </h4><br><p>  As a result of many rakes and attempts to use other people's decisions, I had to make my own <del>  bicycle </del>  A library that helps to debug first of all will retain all the best properties of the popular ones and contribute something new. </p><br><p>  <strong>What tasks were solved during the creation?</strong> </p><br><ul><li>  Reactive working principle </li><li>  Simple debugging handlers </li><li>  Unambiguous processing status of the event </li><li>  Cross Platform </li><li>  Convenience of import and lack of global functions </li><li>  No direct access to the window when connecting </li><li>  No need to call <code>preventDefault</code> or <code>stopPropagation</code> </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// подписка this.shortcuts = shortcuts({ 'CMD+SHIFT+F': function (event, next) { alert('CMD+SHIFT+F pressed'); } }); // утилизация this.shortcuts.destroy();</span></span></code> </pre> <br><p>  Applicable to our problem, the solution completely coincides with the previous library.  There is still no complete separation of processing logic without undue knowledge of each other, but much has become simpler and clearer.  Thanks to the following: </p><br><ul><li>  The binding to the DOM is still absent (with the exception of one listener) and the stack of handlers is filled depending on the order of their registration. </li><li>  <code>scope</code> immediately refused to use <code>scope</code> for isolation.  it is not clear what tasks it solves and it seems that it only complicates the architecture. </li><li>  Debugging and the next function is probably worth more. </li><li>  Mutations in data events that it carries in <code>event.detail</code> </li></ul><br><p>  <strong>Debugging</strong> Handlers are arranged in such a way that a <code>callstack</code> of them is formed before the call.  It allows you to see in the console the entire chain of events passing from the first handler to the next. </p><br><p>  <strong>next ()</strong> - The function call means that the event has not been processed and will be passed to the next handler.  Quite a familiar contract, which is used in intermediate handlers or middleware in <code>express</code> .  So you will always know whether the event is processed or simply mutated or "taken into account". </p><br><p><img src="https://habrastorage.org/webt/qi/px/ia/qipxiaoomxpysaam4fdkwfi6edu.png"></p><br><p>  This is how the call stack looks like if you put a breakpoint in one of them. </p><br><p>  <strong>Well, about the cons:</strong> </p><br><ul><li>  No typepings yet </li><li>  No skoupov - splitskrin site not to do) </li><li>  One combination during registration (there is no such thing as <code>CMD+F,CMD+V,T</code> will not understand the comma) </li></ul></div>