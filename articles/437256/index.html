<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Validation of addresses in the memory on the Cortex-M0 / M3 / M4 / M7</title>
  <meta name="description" content="Hi, Habr! 

 Regarding the recent relaxation of the regime , disturbances in the comments of one neighboring post that the articles about microcontrol...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Validation of addresses in the memory on the Cortex-M0 / M3 / M4 / M7</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr! <br><br>  Regarding the recent <a href="https://habr.com/ru/company/tm/blog/437072/">relaxation of the regime</a> , disturbances in the comments of one neighboring post that the articles about microcontrollers are completely blinking by the LED, as well as the untimely death of my standard blog, I‚Äôm still lazy to restore, I will transfer here useful material about one regrettably poorly lit Press trick in working with cores Cortex-M - checking arbitrary addresses for validity. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rl/he/2w/rlhe2wjgxij3ej65fi5t8lverts.jpeg"></div><br>  One of the very useful, and for some reason, finished features of the never described capabilities on Cortex-M microcontrollers (all) is the ability to verify the correctness of the address in memory.  With its help, you can determine the size of the flash, RAM and EEPROM, determine the presence of specific peripherals and registers on a specific processor, beat down fallen processes while maintaining the overall operating system of the OS, etc. <br><a name="habracut"></a><br>  In normal mode, if you hit a non-existent address on Cortex-M3 / M4 / M7, a BusFault exception is called, and in the absence of its handler, it is escalated to HardFault.  There are no ‚Äúdetailed‚Äù exceptions (MemFault, BusFault, UsageFault) on Cortex-M0, and any failures are immediately escalated to HardFault. <br><br>  In general, HardFault cannot be ignored - it can be a consequence of a hardware failure, for example, and further device behavior will become unpredictable.  But in the particular case, this can and should be done. <br><br><h4>  Cortex-M3 and Cortex-M4: unimplemented BusFault </h4><br>  On Cortex-M3 and above, checking the validity of the address is quite simple - all exceptions (except, obviously, nonmaskable) must be disabled via the FAULTMASK register, specifically, the BusFault processing is disabled, and then poked into the address being checked and see if the BFARVALID flag in the BFAR register has risen , that is, Bus Fault Address Register.  If you soared - you just had a BusFault, i.e.  address is incorrect. <br><br>  The code looks like this, all defaults and functions from the standard (non-vendor) CMSIS, so it should work on any M3, M4 or M7: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cpu_check_address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">volatile</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *address)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Cortex-M3, Cortex-M4, Cortex-M4F, Cortex-M7 are supported */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> BFARVALID_MASK = (<span class="hljs-number"><span class="hljs-number">0x80</span></span> &lt;&lt; SCB_CFSR_BUSFAULTSR_Pos); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_valid = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Clear BFARVALID flag by writing 1 to it */</span></span> SCB-&gt;CFSR |= BFARVALID_MASK; <span class="hljs-comment"><span class="hljs-comment">/* Ignore BusFault by enabling BFHFNMIGN and disabling interrupts */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> mask = __get_FAULTMASK(); __disable_fault_irq(); SCB-&gt;CCR |= SCB_CCR_BFHFNMIGN_Msk; <span class="hljs-comment"><span class="hljs-comment">/* probe address in question */</span></span> *address; <span class="hljs-comment"><span class="hljs-comment">/* Check BFARVALID flag */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((SCB-&gt;CFSR &amp; BFARVALID_MASK) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* Bus Fault occured reading the address */</span></span> is_valid = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* Reenable BusFault by clearing BFHFNMIGN */</span></span> SCB-&gt;CCR &amp;= ~SCB_CCR_BFHFNMIGN_Msk; __set_FAULTMASK(mask); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> is_valid; }</code> </pre> <br><h4>  Cortex-M0 and Cortex-M0 + </h4><br>  With Cortex-M0 and Cortex-M0 + it‚Äôs getting harder, as I said above, they don‚Äôt have BusFault and all the relevant registers, and exceptions immediately escalate to HardFault.  Therefore, there is only one way out - to make it so that the HardFault handler could understand that the exception was caused intentionally, and to return back to the function that called it, passing there a certain flag indicating that HardFault was. <br><br>  This is done purely in assembler.  In the example below, register R5 is set to 1, and two ‚Äúmagic numbers‚Äù are written to registers R1 and R2.  If, after trying to load the value at the checked address, HardFault happens, then it should check the values ‚Äã‚Äãof R1 and R2, and if the necessary numbers are found in them, set R5 to zero.  In the sish code, the value of R5 is passed through a special variable tightly bound to this register, to the assembler the address being checked is in an implicit form, we just know that in arm-none-eabi the first parameter of the function is put in R0. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cpu_check_address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">volatile</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *address)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Cortex-M0 doesn't have BusFault so we need to catch HardFault */</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)address; <span class="hljs-comment"><span class="hljs-comment">/* R5 will be set to 0 by HardFault handler */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* to indicate HardFault has occured */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> result __asm(<span class="hljs-string"><span class="hljs-string">"r5"</span></span>); __<span class="hljs-function"><span class="hljs-function">asm__ </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ldr r5, =1 \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* set default R5 value */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ldr r1, =0xDEADF00D \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* set magic number */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ldr r2, =0xCAFEBABE \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* 2nd magic to be sure */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ldrb r3, [r0] \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* probe address */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br>  The HardFault handler code in its simplest form looks like this: <br><br><pre> <code class="cpp hljs">__attribute__((naked)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hard_fault_default</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Get stack pointer where exception stack frame lies */</span></span> __<span class="hljs-function"><span class="hljs-function">asm__ </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* decide if we need MSP or PSP stack */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movs r0, #4 \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* r0 = 0x4 */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"mov r2, lr \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* r2 = lr */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"tst r2, r0 \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* if(lr &amp; 0x4) */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"bne use_psp \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* { */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"mrs r0, msp \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* r0 = msp */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"b out \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* } */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" use_psp: \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* else { */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"mrs r0, psp \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* r0 = psp */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" out: \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* } */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* catch intended HardFaults on Cortex-M0 to probe memory addresses */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ldr r1, [r0, #0x04] \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* read R1 from the stack */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ldr r2, =0xDEADF00D \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* magic number to be found */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"cmp r1, r2 \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* compare with the magic number */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"bne regular_handler \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* no magic -&gt; handle as usual */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ldr r1, [r0, #0x08] \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* read R2 from the stack */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ldr r2, =0xCAFEBABE \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* 2nd magic number to be found */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"cmp r1, r2 \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* compare with 2nd magic number */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"bne regular_handler \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* no magic -&gt; handle as usual */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ldr r1, [r0, #0x18] \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* read PC from the stack */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"add r1, r1, #2 \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* move to the next instruction */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"str r1, [r0, #0x18] \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* modify PC in the stack */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ldr r5, =0 \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* set R5 to indicate HardFault */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"bx lr \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* exit the exception handler */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" regular_handler: \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* here comes the rest of the fucking owl */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span></code> </pre> <br>  When the exception handler goes to the handler, Cortex drops the registers, which are guaranteed to be corrupted by the handler (R0-R3, R12, LR, PC ...), onto the stack.  The first fragment - it already exists in most of the ready-made HardFault handlers, besides those written under pure bare metal - determines which stack it is: when working in the OS, it can be either MSP or PSP, and they have different addresses.  In bare metal projects, the MSP (Main Stack Pointer) stack is usually set a priori, without verification ‚Äî for the PSP (Process Stack Pointer) cannot be there due to the lack of processes. <br><br>  Having determined the required stack and putting its address in R0, we read R1 values ‚Äã‚Äã(offset 0x04) and R2 (offset 0x08) from it, compare it with magic words, if both match, read PC value (offset 0x18) from the stack, add 2 to it (2 bytes - the size of the instructions on the Cortex-M *) and save back to the stack.  If this is not done, when returning from the handler, we will find ourselves on the same instruction that actually caused the exception, and we will always run in a circle.  Adding 2 moves us to the next instruction at the time of return. <br><br>  <i><b>* Upd.</b></i>  <i>In the comments there was a question about the size of the instructions on the Cortex-M, I‚Äôll bring out the correct answer here: in this case crash is caused by the LDRB instruction, which is present in the ARMv7-M architecture in two versions - 16-bit and 32-bit.</i>  <i>The second option will be selected if at least one of the conditions is fulfilled:</i> <i><br><br></i> <ul><li>  <i>The author clearly indicated the LDRB.W instruction instead of the LDRB (we do not)</i> </li><li>  <i>registers above R7 are used (we have R0 and R3)</i> </li><li>  <i>specified offset greater than 31 bytes (we have no offset)</i> </li></ul> <i><br><br></i>  <i>In all other cases (i.e., when the operands match the format of the 16-bit version of the instruction), the assembler <b>must</b> choose the 16-bit version.</i> <i><br><br></i>  <i>Therefore, in our case there will always be a 2-byte instruction that needs to be stepped over, but if you edit the code a lot, options are possible.</i> <br><br>  Then write 0 to R5, which serves as an indicator of getting into HardFault.  Registers after R3 before special registers are not saved in the stack and are not restored when they exit the handler, so it is on our conscience to spoil them or not to spoil them.  In this case, R5 from 1 to 0, we change purposefully. <br><br>  Returning from an interrupt handler is done strictly in one way.  When entering the handler, a special value is written to the LR register called EXC_RETURN, which to exit the handler must be written to the PC - and not just write, but do it with a POP or BX command (that is, ‚Äúmov pc, lr‚Äù, for example, does not work , although for the first time you might think that it works).  BX LR looks like an attempt to go to a meaningless address (in LR there will be something like 0xFFFFFFF1, which has nothing to do with the real address of the procedure we need to return to), but in reality the processor, seeing this value in the PC (where it will go automatically), he will restore the registers from the stack and continue to perform our procedure - with the following procedure after the HardFault, due to the fact that we increased the PC in this stack by 2. <br><br>  Read about all the offsets and commands <a href="http://infocenter.arm.com/help/index.jsp%3Ftopic%3D/com.arm.doc.dui0497a/Babefdjc.html">can be understood where</a> , of course. <br><br>  Well, or if the magic numbers are not visible, then everything will go to regular_handler, followed by the usual HardFault processing procedure - as a rule, this is a function that prints register values ‚Äã‚Äãto the console, decides what to do next with the processor, etc. <br><br><h4>  Determine RAM Size </h4><br>  Using all of this is simple and straightforward.  We want to write a firmware that runs on several microcontrollers with a different amount of RAM, while each time using RAM in full? <br><br>  Yes Easy: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cpu_find_memory_size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *base, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> block, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxsize)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *address = base; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { address += block; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cpu_check_address(address)) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)(address - base) &lt; maxsize); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)(address - base); } <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> get_cpu_ram_size(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cpu_find_memory_size((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)SRAM_BASE, <span class="hljs-number"><span class="hljs-number">4096</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>); }</code> </pre> <br>  maxsize is needed here, so that at the maximum possible amount of RAM between it and the next block of addresses, there may be no gap at which cpu_check_address will break.  In this example, it is 80 KB.  It also makes no sense to probe all addresses - just look at the minimum possible step between the two models of the controller and put it as a block. <br><br><h4>  The program transition to the bootloader, located unknown where </h4><br>  Sometimes you can do more intricate stunts - for example, imagine that you want to programmatically jump onto a regular factory STM32 bootloader to switch to firmware update mode via UART or USB, without bothering to write your bootloader. <br><br>  The STM32 bootloader lies in the area called System Memory, which you need to switch to, but there is one problem - this area has different addresses, not just on different processor series, but on different models of the same series (you can read the epic tablet in <a href="https://www.st.com/content/ccc/resource/technical/document/application_note/b9/9b/16/3a/12/1e/40/0c/CD00167594.pdf/files/CD00167594.pdf/jcr:content/translations/en.CD00167594.pdf">AN2606).</a> pages 22 to 26).  When introducing the corresponding functionality into the platform in general, and not just into a specific product, I want versatility. <br><br>  In the CMSIS files, the start address of the System Memory is also missing.  Determine it by the Bootloader ID is not possible, because  this is a chicken and egg problem - the bootloader ID lies in the last System Memory byte, which brings us back to the question of address. <br><br>  However, if we look at the STM32 memory card, we will see something like this: <br><br><img src="https://habrastorage.org/webt/l4/nf/b3/l4nfb3xcw87qnsrey9n4mp3t0we.png"><br>  In this case, we are interested in the System Memory environment - for example, there is a one-time programmable area (not in all STM32) and Option bytes (in all) on top.  This structure is observed not only in different models, but in different STM32 lines, with the difference only in the presence of OTP and the presence of a gap in the addresses between the system memory and options. <br><br>  But for us in this case, the most important thing is that the address of the beginning of the Option Bytes is in the regular CMSIS headers - it is called OB_BASE there. <br><br>  Further simple.  We write the search function for the first valid or invalid address up or down from the specified one: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cpu_find_next_valid_address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *stop, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> valid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *address = start; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (address == stop) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cpu_check_address(address) == valid) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> address; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stop &gt; start) { address++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { address--; } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; }</code> </pre> <br>  And we are looking down from Option bytes, first the end of either the system memory, or the OTP adjacent to it, and then the beginning of the system memory - in two passes: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* System memory is the valid area next _below_ Option bytes */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *a, *b, *c; a = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)(OB_BASE - <span class="hljs-number"><span class="hljs-number">1</span></span>); b = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Here we have System memory top address */</span></span> c = cpu_find_next_valid_address(a, b, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* Here we have System memory bottom address */</span></span> c = cpu_find_next_valid_address(c, b, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  And without much difficulty, we arrange this into a function that finds the beginning of the system memory and jumps on it, that is, it starts the bootloader: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jump_to_bootloader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> __</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attribute__</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">((noreturn))</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Sets up and jumps to the bootloader */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jump_to_bootloader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* System memory is the valid area next _below_ Option bytes */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *a, *b, *c; a = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)(OB_BASE - <span class="hljs-number"><span class="hljs-number">1</span></span>); b = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Here we have System memory top address */</span></span> c = cpu_find_next_valid_address(a, b, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* Here we have System memory bottom address */</span></span> c = cpu_find_next_valid_address(c, b, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!c) { NVIC_SystemReset(); } <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> boot_addr = (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)c; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> boot_stack_ptr = *(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>*)(boot_addr); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> dfu_reset_addr = *(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>*)(boot_addr+<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*dfu_bootloader)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*))(dfu_reset_addr); <span class="hljs-comment"><span class="hljs-comment">/* Reset the stack pointer */</span></span> __set_MSP(boot_stack_ptr); dfu_bootloader(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  It depends on the specific processor model ... yes, nothing depends.  The logic will not work on models that have a hole between OTP and system memory - but I didn‚Äôt check if there are any.  Will actively work with OTP - check. <br><br>  Other tricks relate only to the usual procedure for calling a bootloader from your code - do not forget to reset the stack pointer and call the exit procedure in the bootloader before initializing the processor peripherals, clock frequencies, etc.: because of its minimalism, the bootloader can score on initialize the periphery and expect it to be in the default state.  A good way to call a bootloader from an arbitrary location in your program is to write to the RTC Backup Register or simply to a known address in the memory of the magic number, program reboot and check the initial stages of initialization of this number. <br><br>  PS Since all the addresses in the processor's memory card are aligned in the worst case to 4, the procedure described above will speed up the idea of ‚Äã‚Äãstepping over them in steps of 4 bytes instead of one. <br><br><h4>  Important note </h4><br>  NB: note that on a specific controller the validity of a specific address does not necessarily indicate the actual presence of a functional that can be located at this address.  For example, the address of the register controlling some optional peripheral unit may be valid, although the unit itself is absent in this model.  From the manufacturer‚Äôs side, the most interesting dirty tricks are possible, usually rooted in the use of the same crystals for different processor models.  However, in most cases, these procedures work and are very useful. </div><p>Source: <a href="https://habr.com/ru/post/437256/">https://habr.com/ru/post/437256/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>