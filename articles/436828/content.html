<div class="post__text post__text-html js-mediator-article">  Last year (almost a year has already passed), we still switched to the new version of Boost-1.65.1, and under the hood you will find the three boost bugs that we encountered.  It is also important to mention that before that, we used boost -1.62.1 in the software, since some bugs appeared in boost earlier than version 1.65.1. <br><br>  Our project has a special integration team whose main task is to migrate all software to a new version of libraries, Visual Studio, new versions of low-level components (basic ones that most other components depend on), etc.  Also, the integration team is responsible for eliminating all the problems that arise, naturally with the assistance of the component maintainers, if necessary.  So, the bugs that I especially remember. <br><a name="habracut"></a><br><h3>  Bug in boost :: filesystem </h3><br>  This bug surfaced quickly enough.  Tests began to fall with “Access violation” when searching for the full path to the specified file name.  The function called the call boost :: filesystem :: exist, and the program crashed.  Running a few more tests, several more similar cases were noticed, while in all cases the call to boost :: filesystem :: exist was made for global variables.  Apparently, something has changed in the lifetime of the boost-variables.  Ticket for the detected bug is very easy google <a href="https://svn.boost.org/trac10/ticket/12987">bug bug in boost :: filesystem :: exist</a> <br><br>  It turned out that this bug was in boost, starting with version 1.64.  In fact, the problem was in the make_permissions call (used in filesystem :: exist).  In 1.64, the implementation of make_permissions was changed, and now used global variables, which means that when an attempt is made to call filesystem :: exist when initializing a global variable or object, the global variables used in make_permissions may not yet be initialized.  Therefore, an attempt to access an uncreated variable throws an exception. <br><br><div class="spoiler">  <b class="spoiler_title">Workaround</b> <div class="spoiler_text">  For tests where global variables were used only once, they were transferred to the corresponding tests and became local variables.  Do not even ask why this was not done before, I am not the maintainer of this code. <br><br>  In other cases, <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D0%25B4%25D0%25B8%25D0%25BD%25D0%25BE%25D1%2587%25D0%25BA%25D0%25B0_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">singletons were</a> used. <br></div></div><br><h3>  Bug in boost :: python </h3><br>  In tests using boost :: python, a strange thing was discovered.  When executing a trivial eval () call for a literal (for example, "40 + 2") all the rules.  And if variables are defined and then used in expressions, we get the message that undefined variables are used in calculations (ERROR: [name] not defined).  To solve this problem, I have spent more time.  I could not find the problem ticket in the boost tracker, so I had to ask for help from the command of this component.  Information about the bug was promptly found <a href="https://github.com/boostorg/python/commit/b09d80a93e299bdaba29b652010b668b87f1306c">on github</a> . <br><br>  It so happened that the global and local objects were not used in the implementation of eval.  Having wished <i>Good luck</i> in finding fixes without recompiling the source code, the team did not bow :) <br><br><div class="spoiler">  <b class="spoiler_title">Workaround</b> <div class="spoiler_text">  But then I remembered the <a href="https://www.boost.org/users/history/version_1_65_1.html">release notes for boost-1.65.1</a> and there was definitely something for boost :: python. <br><br>  Hurray, there is a way!  The bug was allowed when adding a new implementation of eval with support for char const * argument, which is now called in the old implementation of eval with a string argument (Particularly attentive could notice the call of this function in the code by github-ovsky link).  And the new feature, as expected, is working. <br></div></div><br><h3>  boost :: numpy </h3><br>  This is my least favorite part.  boost :: python :: numeric has been removed and now boost :: python :: numpy appeared as an alternative.  But the code that used numeric had to be pretty much redone, since it’s not just a matter of renaming namespaces, but also of object implementation. <br><br>  In addition, there was misinformation in the boost header that misled me. <br>  According to the source comment, the import_array () call is already being done in numpy :: initialize (): <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> boost { <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> python { <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> numpy { <span class="hljs-comment"><span class="hljs-comment">/** * @brief Initialize the Numpy C-API * * This must be called before using anything in boost.numpy; * It should probably be the first line inside BOOST_PYTHON_MODULE. * * @internal This just calls the Numpy C-API functions "import_array()" * and "import_ufunc()", and then calls * dtype::register_scalar_converters(). */</span></span> <span class="hljs-function"><span class="hljs-function">BOOST_NUMPY_DECL </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> register_scalar_converters=</span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; }}} <span class="hljs-comment"><span class="hljs-comment">// namespace boost::python::numpy</span></span></code> </pre> <br>  But in fact, as it turned out, import_array () is required. <br><br>  In addition, there were problems with testing the changes, since pieces of code with numpy (previously with boost :: python :: numeric) were not covered at all by tests, and the code itself was also used in another component.  Therefore, problems were detected only when testing the corresponding component.  The integration team is not required to write tests for the components, and this situation was the omission of the command itself.  Wow, and I heard a lot from them that broke their code.  But after the team grumbled, they finally covered their code with tests.  However, the offense remained (during the next migration, the team did not want to give access to its component to my colleague, mentioning that last time we broke the code for them. <i>Sasha, weeds!</i> But after three days of negotiations, they surrendered). <br><br><h3>  Conclusion </h3><br>  After this work, I can note the advantages for myself, since I had not used boost very often before (mostly std), so many new things can be emphasized from migration.  It's funny, but it’s a fact, for some reason after this you become a “boost expert” for many colleagues, and, accept, you will be asked questions about it for some time. <br><br>  By the way, in recent years, many companies have begun to actively get rid of boost and, if possible, replace std with a library or something else if there are no possibilities in the standard library.  And we also did not stand aside.  The process started, but not completed, still a lot of work. </div>