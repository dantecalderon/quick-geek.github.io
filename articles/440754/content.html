<div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/tj/bp/mp/tjbpmpejv6ig2dqs8r22x1zcmzw.png" alt="image" align="left">  Today, the use of digital certificates X509 v.3 has become commonplace.  More and more people use them to access the State Services website, the Federal Tax Service, electronic trading, etc.  And more and more people want to know what is in this "chest" called a certificate.  And if the certificate is an analogue of a <a href="https://habr.com/ru/post/357668/">passport</a> , then how can it be read / viewed.  Yes, in operating systems there are various utilities for viewing.  But they will give little to the ordinary citizen.  Take, for example, the gcr-viewer utility, which is essentially a standard viewer for Linux-based systems, and therefore for <a href="https://habr.com/ru/post/434358/">domestic operating systems</a> : <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/lf/7g/nf/lf7gnfqkvwpo2cuhy_mcvulf_a8.png"><br><br><h3>  Standard viewer </h3><br>  The utility is well done, convenient.  And generally conceived as a universal utility for viewing files containing data in various cryptographic formats (certificates, requests, electronic signatures / PKCS # 7, secure PKCS # 12 containers, etc.).  But, unfortunately, it is designed for Western cryptography and does not take into account the OIDs that are entered in your country.  And if you look at the screenshot, already when displaying information about the certificate holder there are incomprehensible characters.  On the left, these are the oids themselves, and on the right in the 16th form, the asn1 structure with their values.  In this case, it is OGRN (1.2.643.100.1), SNILS (1.2.643.100.3) and TIN (1.2.643.3.131.1.1).  And that's how an ordinary citizen should make sure that this is his data.  Do not think that this is only in Linux, it is a common feature of any certificate viewer.  And if you look further, it becomes generally incomprehensible: <br><br><img src="https://habrastorage.org/webt/55/6s/ib/556sib6y76f81ohud2laq0knsho.png"><br><br>  Some extensions, identifiers and values ​​appear.  In this case, under oid-ohm 1.2.643.100.111, the name of the SKZI is hidden, which was used by the user to generate a key pair, the private key of which was used to sign the certificate request, and the public key of which lies in the certificate: <br><br><img src="https://habrastorage.org/webt/yv/yx/uu/yvyxuu6hjoasxtytu7foy-s1o20.png"><br><br>  And here, little is clear to the certificate holder.  He does not even understand what algorithm was used when generating the key, or GOST R 34.10-2001, or GOST R 34.10-2012, and with what key length. <br><br>  You can continue to give examples.  For example, if the validity of the certificate is clear, then where is the key validity period? <br><br>  There are two more questions to which certificate holders would like to have an answer: where to get the chain of root certificates (or better still just get) and a similar question on the list of revoked certificates. <br><br>  And lastly, I would like to have a universal utility that takes into account the peculiarities of the Russian PKI / PKI, which is truly cross-platform and works on domestic and non- <a href="https://hi-tech.mail.ru/review/russian-os/">domestic operating systems</a> .  What to develop?  Of course, in the scripting language, if only because of their cross-platform nature. <br><br>  Then I remembered that quite recently I celebrated my <a href="https://www.linux.org.ru/news/development/14742883">30th birthday with the</a> wonderful scripting language Tcl (Tool Command Language).  It is a pleasure to program on it.  He has a huge number of extensions (package), which allow almost everything.  So for work with ASN-structures there is a package asn.  Moreover, to work with certificates (we are interested in their analysis in this case) there is a pki package.  And for the development of the graphical interface there is a package Tk. <br><br>  All the same can be said about Pyton with Tkinter, and about perl, and about ruby.  Everyone can choose according to their taste.  We stop at a bunch of Tcl / Tk. <br><br>  We will borrow graphic design for the utility from the gcr-viewer utility.  And one more requirement. <br><br>  Since Habr has an <a href="https://habr.com/ru/company/tm/blog/435766/">English version</a> , I would like the utility to have various interfaces (Russian / English).  But this is not the main reason.  More importantly, more and more citizens of the Western world are becoming citizens of the Russian Federation, for example, the world-famous actor Depardieu.  It may be objected - he is French.  But I am also a military translator from French: <br><br><img src="https://habrastorage.org/webt/ma/xr/4d/maxr4dvthbpwapmxmodkjceujh4.png"><br><br>  So it’s easy to add a French interface.  But I think Depardieu has no problems with English.  On the other hand, our country is multinational and it would be quite good if domestic software, domestic operating systems had at least several national interfaces. <br>  A little ahead, here's what came of it: <br><br><img src="https://habrastorage.org/webt/-e/d8/df/-ed8dfn1in3wl7iwa2wmf-w0w-w.png"><br><br><h3>  We invite the translator </h3><br>  So let's start with the "translator".  In the screenshot, he is hiding under the national flag.  The main requirement for the translator is the simultaneous translation, i.e.  the ability to switch to another language at any time.  The functions of the translator in Tcl / Tk are performed by the msgcat package: <br><br><pre><code class="plaintext hljs">package require msgcat</code> </pre> <br>  To set the current language, use the following command: <br><br><pre> <code class="plaintext hljs">msgcat::mclocale ru</code> </pre> <br>  The vocabulary of the “translator” is stored in the ru.msg file as follows: <br><br><pre> <code class="plaintext hljs">#Импортируем процедуру msgcat::mcset и в дальнейшем к ней # обращаемся по короткому имени mcset namespace import -force msgcat::mcset # На английском Русский перевод mcset ru "Language" "Язык" …</code> </pre> <br>  Below is the text of the test <div class="spoiler">  <b class="spoiler_title">script with translator:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#!/usr/bin/wish -f #Загружаем пакет msgcat package require msgcat #Устанавливаем локальный язык ru msgcat::mclocale ru #Импортируем процедуру ::msgcat::mc и в дальнейшем к ней # обращаемся по короткому имени mc namespace import msgcat::mc #Загружаем словарь из файла [msgcat::mclocale].msg. #В данном случае из каталога с данным скриптом. msgcat::mcload [file join [file dirname [info script]]] #Языковые иконки image create photo rf_32x21_f -file rf_32x21.png image create photo gb_32x21_f -file gb_32x21.png #Метка, текст в которой подлежит переводу label .lab -text "[mc Language]: " -relief flat -bd 0 –bg snow -anchor sw -width 10 button .but_lang -image rf_32x21_f -command ::changelang -relief flat -bd 0 pack .lab -side left -pady {2 0} pack .but_lang -side left #Процедура смены языка и синхронный перевод proc ::changelang {} { #Смена языка и синхронный перевод #Смена иконки на кнопке if {[msgcat::mclocale] == "ru"} { msgcat::mclocale en .but_lang configure -image gb_32x21_f } else { msgcat::mclocale ru .but_lang configure -image rf_32x21_f } #Перевод текста .lab configure -text "[mc Language]: " }</code> </pre> <br></div></div><br>  In this script, the procedure :: changelang acts as a translator, called when the .but_lang button is pressed with a flag. <br><br>  If you run this script, it will be clearly seen how the translator works: <br><br><img src="https://habrastorage.org/webt/hs/4y/e6/hs4ye6p49e5soy4ud6aje91-e2i.png"><br><br><h3>  We get the public key </h3><br>  Now that we have decided on a translator, let's proceed to the analysis of the certificate.  For this we need the pki package: <br><br><pre> <code class="plaintext hljs">package require pki).</code> </pre> <br>  The pki package is sharpened to work with keys and RSA algorithm certificates.  If the certificate (proc :: pki :: x509 :: parse_cert) is created with a different key type, then we will not receive information about this key: <br><br><pre> <code class="plaintext hljs"># Handle RSA public keys by extracting N and E switch -- $ret(pubkey_algo) { "rsaEncryption" { set pubkey [binary format B* $pubkey] binary scan $pubkey H* ret(pubkey) ::asn::asnGetSequence pubkey pubkey_parts ::asn::asnGetBigInteger pubkey_parts ret(n) ::asn::asnGetBigInteger pubkey_parts ret(e) set ret(n) [::math::bignum::tostr $ret(n)] set ret(e) [::math::bignum::tostr $ret(e)] set ret(l) [expr {int([::pki::_bits $ret(n)] / 8.0000 + 0.5) * 8}] set ret(type) rsa } }</code> </pre> <br>  Surprisingly, the public key algorithm is still returned (ret (pubkey_algo)) <br>  Similarly, the situation with the examination of the certificate request (proc :: pki :: pkcs :: parse_csr): <br><br><pre> <code class="plaintext hljs"># Parse public key, based on type switch -- $pubkey_type { "rsaEncryption" { set pubkey [binary format B* $pubkey] ::asn::asnGetSequence pubkey pubkey_parts ::asn::asnGetBigInteger pubkey_parts key(n) ::asn::asnGetBigInteger pubkey_parts key(e) set key(n) [::math::bignum::tostr $key(n)] set key(e) [::math::bignum::tostr $key(e)] set key(l) [expr {2**int(ceil(log([::pki::_bits $key(n)])/log(2)))}] set key(type) rsa } default { return -code error "Unsupported key type: $pubkey_type" } }</code> </pre> <br>  But here at least it returns information about the error.  But today, in addition to RSA, for example, the keys on the elliptic curves of the EU, including GOST R 34.10-2012, are in use (GOST R 34.10-2001 is also running for now). <br><br>  But it is enough by default (default) to return the ASN-structure of the public key contained in the certificate or request, and the user himself, depending on the type of key, will parse the public key.  For this, it is enough to add to the returned values ​​the ASN structure of the public key in hexadecimal: <br><br><pre> <code class="plaintext hljs">proc ::pki::x509::parse_cert {cert} { . . . ::asn::asnGetSequence cert subject ::asn::asnGetSequence cert pubkeyinfo #Добавляем в возвращаемый массив ASN-структуру публичного ключа. binary scan $pubkeyinfo H* ret(pubkey_pubkeyinfo) . . . }</code> </pre> <br>  Anything more is not necessary.  In this way, the procedure (proc :: pki :: x509 :: parse_cert returns most of the certificate extensions for the simple reason that it does not know how to parse them (for example, subjectSignTool from our qualified certificates), that is, it gives to the discretion of the user. <br><br>  On the other hand, the procedure :: pki :: x509 :: parse_cert returns with one of the results a <a href="https://habr.com/ru/post/194664/">tbs-certificate</a> that contains all the information from the certificate except its signature (signature) and signature type (signature_algo): <br><br><pre> <code class="plaintext hljs">#Читаем сертификат из файла set fd [open «cert.pem» r] chan configure –translation binary set datacert [read $fd] close $fd #разбираем сертификат array set cert_parse [::pki::x509::parse_cert $datacert] #Сохряняем tbs-сертификат set cert_tbs_hex $cert_parse(cert)</code> </pre> <br>  We write the procedure for extracting information about the public key from the tbs certificate: <br><br><pre> <code class="plaintext hljs">proc ::pki::x509::parse_cert_pubkeyinfo {cert_tbs_hex} { array set ret [list] set wholething [binary format H* $cert_tbs_hex] ::asn::asnGetSequence wholething cert ::asn::asnPeekByte cert peek_tag if {$peek_tag != 0x02} { # Version number is optional, if missing assumed to be value of 0 ::asn::asnGetContext cert - asn_version ::asn::asnGetInteger asn_version ret(version) } ::asn::asnGetBigInteger cert ret(serial_number) ::asn::asnGetSequence cert data_signature_algo_seq ::asn::asnGetObjectIdentifier data_signature_algo_seq ret(data_signature_algo) ::asn::asnGetSequence cert issuer ::asn::asnGetSequence cert validity ::asn::asnGetUTCTime validity ret(notBefore) ::asn::asnGetUTCTime validity ret(notAfter) ::asn::asnGetSequence cert subject ::asn::asnGetSequence cert pubkeyinfo #Сохраняем и возвращаем в hex asn-структуру публичного ключа binary scan $pubkeyinfo H* ret(pubkeyinfo) return $ret(pubkeyinfo) }</code> </pre> <br>  And since we are interested in Russian cryptography, we will immediately write the procedure for parsing a GOST public key: <br><br><pre> <code class="plaintext hljs">proc parse_key_gost {pubkeyinfo_hex} { array set ret [list] set pubkeyinfo [binary format H* $pubkeyinfo_hex] ::asn::asnGetSequence pubkeyinfo pubkey_algoid ::asn::asnGetObjectIdentifier pubkey_algoid ret(pubkey_algo) #Убеждаемся, что это ГОСТ-ключ if {[string first "1 2 643 " $ret(pubkey_algo)] == -1} { return [array get ret] } ::asn::asnGetBitString pubkeyinfo pubkey set pubkey [binary format B* $pubkey] #Значение публичного ключа binary scan $pubkey H* ret(pubkey) ::asn::asnGetSequence pubkey_algoid pubalgost #OID - параметра ::asn::asnGetObjectIdentifier pubalgost ret(paramkey) #OID - Функция хэша ::asn::asnGetObjectIdentifier pubalgost ret(hashkey) #puts "ret(paramkey)=$ret(paramkey)\n" #puts "ret(hashkey)=$ret(hashkey)\n" #parray ret #Возвращаем разобранный ключ: алгоритм ключа, значение ключа и параметры return [array get ret] }</code> </pre><br>  Yes, I almost missed it, after downloading the pki package, you need to add to the array :: pki :: oids oids, which characterize GOST and a qualified certificate or are simply missing in this array: <br><br><pre> <code class="plaintext hljs">package require pki #Добавляемые oid-ы set ::pki::oids(1.2.643.100.1) "OGRN" set ::pki::oids(1.2.643.100.5) "OGRNIP" set ::pki::oids(1.2.643.3.131.1.1) "INN" set ::pki::oids(1.2.643.100.3) "SNILS" set ::pki::oids(1.2.643.2.2.19) "GOST R 34.10-2001" set ::pki::oids(1.2.643.7.1.1.1.1) "GOST R 34.10-2012-256" set ::pki::oids(1.2.643.7.1.1.1.2) "GOST R 34.10-2012-512" set ::pki::oids(1.2.643.2.2.3) "GOST R 34.10-2001 with GOST R 34.11-94" set ::pki::oids(1.2.643.7.1.1.3.2) "GOST R 34.10-2012-256 with GOSTR 34.11-2012-256" set ::pki::oids(1.2.643.7.1.1.3.3) "GOST R 34.10-2012-512 with GOSTR 34.11-2012-512" set ::pki::oids(1.2.643.100.113.1) "KC1 Class Sign Tool" set ::pki::oids(1.2.643.100.113.2) "KC2 Class Sign Tool" . . .</code> </pre> <br>  You can also fill up the vocabulary of the translator by adding to the file ru.msg: <br><br><pre> <code class="plaintext hljs">mcset ru "GOST R 34.10-2001" "ГОСТ Р 34.10-2001" mcset ru "GOST R 34.10-2012-256" "ГОСТ Р 34.10-2012-256" mcset ru "GOST R 34.10-2012-512" "ГОСТ Р 34.10-2012-512" mcset ru "GOST R 34.10-2001 with GOST R 34.11-94" "ГОСТ Р 34.10-2001 с ГОСТ Р 34.11-94" mcset ru "GOST R 34.10-2012-256 with GOSTR 34.11-2012-256" "ГОСТ Р 34.10-2012-256 с ГОСТ Р 34.11-2012-256" mcset ru "GOST R 34.10-2012-512 with GOSTR 34.11-2012-512" "ГОСТ Р 34.10-2012-512 с ГОСТ Р 34.11-2012-512" . . .</code> </pre>  : <br><img src="https://habrastorage.org/webt/am/gu/td/amgutdxuj-xkszh1qpmeaa-hf1g.png"><br><br><h3>  Root certificate chain and certificate revocation list </h3><br>  How to get a chain of root certificates has already been <a href="https://habr.com/ru/post/436370/">considered</a> .  By analogy, we write the procedure for obtaining a list of revoked COC / CRL certificates.  The source code of the utility and its distributions for Linux, OS X (macOS) and MS Windows platforms can be found <br><br><div class="spoiler">  <b class="spoiler_title">here</b> <div class="spoiler_text"><ul><li>  <a href="">source</a> </li><li>  <a href="">Linux32</a> </li><li>  <a href="">Linux64</a> </li><li>  <a href="">OS X</a> </li><li>  <a href="">WIN32</a> </li><li>  <a href="">WIN64</a> </li></ul><br></div></div><br>  In the source code, you can find all the procedures for parsing certificate extensions. <br>  Opponents of Tk (Tcl / Tk, Python / Tkinter, etc.) suggest finding, as they say, 10 (to lessen) differences between the two utilities, the gcr-viewer utility written in gtk and the certViewer utility developed on Tk: <br><br><img src="https://habrastorage.org/webt/pq/k5/a5/pqk5a5yrh7fbjhlrfipmdvu5tyg.png"><br><br><h3>  Certificates on tokens / smartcards PKCS # 11 </h3><br>  You talked about working with certificates (view, get a chain of root certificates, lists of revoked certificates, prints by sha1 and sha256, etc.) stored in files.  But there are more certificates stored on <a href="https://habr.com/ru/post/316328/">PKCS # 11</a> tokens / smartcards.  And the natural desire is not only to see them, then export to a file.  And how to do this, we will tell in the next article: <br><br><img src="https://habrastorage.org/webt/vx/25/cu/vx25culnj3anfl_jwbkgd-t8nk4.png"></div>