<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>REST passion for 200</title>
  <meta name="description" content="I have long wanted to write this article. I was thinking - from which side should I go? But, suddenly, recently, a similar article appeared on Habr√©, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>REST passion for 200</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/za/yt/hf/zaythfh3df4c0ypahyi08iqrbrq.jpeg"><br><br>  I have long wanted to write this article.  I was thinking - from which side should I go?  But, suddenly, recently, a similar article appeared on Habr√©, which caused a storm in a glass.  Most of all I was surprised by the simple fact that the article began to drive into the minus, although she did not even declare something, but rather just raised the question of using the response codes of the web server in REST.  The debate is hot.  And the apotheosis was that the article went into drafts ... kilobytes of comments, opinions, etc.  just disappeared.  Many have become karma victims, count for nothing :) <br><br>  In general, it was the fate of the article that prompted me to write this.  And I very much hope that it will be useful and clarify a lot. <br><br>  I warn you, everything written below is a real experience, not a cognitive balancing act.  And so, drove. <br><a name="habracut"></a><br><h2>  HTTP </h2><br>  The first thing you need to very clearly separate the layers.  Transport layer is http.  Well, actually REST.  This is a fundamentally important thing in accepting everything and ‚Äúyourself‚Äù in it.  Let's first talk only about http. <br><br>  I used the term ‚Äútransport layer‚Äù.  And I did not make a reservation.  The thing is that http itself implements the functions of transporting requests to the server and content to the client, regardless of tcp / ip.  Yes, it is based on tcp / ip.  And it seems, it is necessary to consider his transport.  But no.  And this is why - socket connections are not direct, i.e.  This is not a client-server connection.  Both the http request and the http response can go a long way through a lot of services.  Can be aggregated or decomposed.  Can be cached, can be modified. <br><br>  Those.  the http request as well as the http response have their own route.  And it does not depend on the final back-up, nor on the final front.  Please pay special attention to this. <br><br>  The http paths are not static.  They can be very complex.  For example, if a balancer is built into the infrastructure, it can send received requests to any of the backend nodes.  At the same time, the back itself can implement its own strategy for working with queries.  Some of them will go to microservices directly, some will be processed by the web server itself, some will be supplemented and transferred to someone else, and some will be cached, etc.  This is how the Internet works.  Nothing new. <br><br>  And here it is important to understand - why do we need response codes?  The thing is that the whole model described above makes decisions based on them.  Those.  These are codes that allow you to make infrastructure and transport decisions during http routing. <br><br>  For example, if the balancer encounters a response code from back 503, when sending a request, it can take it as a reason to assume that the node is temporarily unavailable.  I note that the response with code 503 provides for the header Retry-After.  Having received an interval from the header for re-polling, the balancer will leave the node alone for a specified period and will work with those available.  Moreover, such strategies are implemented out of the box by web servers. <br><br>  A small oftopik for depth of understanding - and if the node responded 500?  What should a balancer do?  Switch to another?  And many will answer - of course, all 5xx are the basis for disabling the node.  And they will be wrong.  Code 500 is an unexpected error code.  Those.  one that can never happen again.  And most importantly, switching to another node may not change anything.  Those.  we just turn off the nodes without any benefit. <br><br>  In the case of the 500 we come to the aid of statistics.  The local WEB server of the node can transfer the node itself to the unavailable status with a large number of 500 responses. In this case, the balancer having addressed this node will receive the answer 503 and will not touch it.  The result is the same, but now, this decision is meaningful and eliminates ‚Äúfalse‚Äù triggers. <br><br>  But that's not all.  In such a situation, monitoring will allow admins to connect to the situation to service the node.  Those.  we get not just the implementation of a highly available service, with balancing, etc., but also an effective support process. <br><br>  And all this can make the server response codes.  Any architecture of a web application must begin with the design of the transport layer.  I hope there is no doubt about it. <br><br><h2>  REST </h2><br>  Ask a rhetorical question - what is it?  And what did you answer to him?  I will not give links to obvious proofs, but most likely not quite what it is in essence :) This is just an ideology, a style.  Some thoughts on the topic - how best to communicate with the back.  And not just communicate, but communicate in the WEB infrastructure.  Those.  based on http.  With all those ‚Äúuseful things‚Äù that I wrote about above.  The final decisions on implementing your interface are always <b>yours</b> . <br><br>  Have you ever thought why a separate transport for REST is not invented?  For example, for websocket it is.  Yes, it also starts with http, but then, after the connection is established, it is generally a separate song.  Why not do the same for REST? <br><br>  The answer is simple - why?  There is a beautiful, ready, verified protocol - http.  It scales well.  Allows you to implement complex, high-availability services that can cope with a large load.  All that is needed is to introduce certain conceptual rules so that the developers understand each other. <br><br>  From here follows a simple, obvious conclusion - everything that is inherent in http is also inherent in REST.  These are inseparable entities.  There is no separate REST header, not even a hint that REST is REST.  For any REST server, the request is exactly the same as any other.  Those.  REST is just what we have in mind. <br><br><h2>  Http response codes in REST </h2><br>  Let's talk about how your server should respond to a REST request?  Personally, it seems to me that from all the above written, the answer is already obvious:  REST is no different from any other request; it must be subject to exactly the same rules.  The response code is an integral part of REST and must be relevant to the essence of the response.  Those.  if the object is not found on request, it is 404, if the client has applied with an incorrect request 400, etc.  But, most often, this debate does not end there.  Therefore, I will continue. <br><br>  Is it possible to respond to all with code 200?  And who will forbid you?  Please ... code 200 is the same code as the others.  True, this approach is based on a very simple thesis - my system is perfect, it has no errors.  If you are a person who can create such systems - this can only be envied! <br><br>  But most likely ... it is not perfect.  And mistakes still happen.  And it happens that they happen due to circumstances beyond our control.  And here the typical solution is to create your own error coding system.  This is bad?  Yes this is bad.  This is super bad.  Let's figure out why. <br><br>  And so, taking code 200 as the only correct one, we assume responsibility for the development of a whole layer (critical layer) of the system - error handling.  Those.  The work of many people to develop this layer is sent to the scrap.  And the construction of his ‚Äúbicycle‚Äù begins.  But this megastroyka is doomed to failure. <br><br>  Let's start with the code.  If we are going to answer all 200, we ourselves will have to handle errors.  The classic method is try constructions.  We wrap each code segment with an additional code.  Handlers that do something useful.  For example, put something in the log.  Something important.  That will allow to localize the error.  And if the error occurred not where it was expected?  Or if the error occurred in the error handler?  Those.  This code-level strategy is non-working a priori.  And in the end, the interpreter or platform will process your bugs.  OS, finally.  The essence of the bug is that you do not expect it.  You do not need to hide it, you need to find and fix it.  Therefore, if any REST requests respond with error 500, this is <b>normal</b> .  And what's more - <b>right</b> . <br><br>  Let's go back to the question - why is this right?  Because: <br><br><ol><li>  Code 500 is an infrastructure marker, on the basis of which the node on which the problem occurs can be disabled; </li><li>  The 5xx codes is what is being monitored and if such a code occurs, any monitoring system will notify you immediately.  And the support service will be able to connect to the solution of the problem on time; </li><li>  You do not write additional code.  Do not spend this precious time.  Do not complicate the architecture.  You are not involved in problems that are unusual for you - you write application code.  What they want from you.  What are they paying for? </li><li>  A trace that falls by mistake 500 will be much more useful than your attempts to beat it. </li><li>  If the REST request returns 500 code, the front will already know at what time it‚Äôs processing the algorithm by which algorithm to process it.  Moreover, the essence of the matter will not change in any way; you have not received anything sensible either from 200 or from 500. But from 500 you received a profit - the realization that this is an UNEXPECTED error. </li><li>  Code 500 will come guaranteed.  No matter how bad or well you wrote your code.  This is your fulcrum. </li></ol><br>  Separately, I will drive a nail into the entire ‚Äúbody‚Äù of code 200: <br><br>  7. Even if you try very hard to avoid other response codes from the server other than 200 to your requests, you will not be able to do this.  Any intermediary server can respond to your request with absolutely any code.  And you MUST process this answer correctly. <br><br>  So, at the logical level, the struggle for code 200 is meaningless. <br><br>  Now let's go back to the infrastructure level.  Very often I hear an opinion - the 5xx code is not at the application level, it cannot be given back.  Hmm, well ... there is a contradiction in the statement itself.  You can give.  But this code is not an application layer.  That's true.  To understand this, I propose to consider the case: <br><blockquote> You implement the gateway.  You have several DCs, each with its own communication channel to a certain private service.  Well, for example, to pay for VPN.  And there is a communication channel with the Internet.  You receive a request for an operation with a gateway, but ... it is unavailable. </blockquote>  And so, what should you answer?  To whom?  This is an infrastructural problem and, precisely, backing ran into it.  Of course, you need to safely answer 503. These actions will lead to the fact that the node will be disabled by the balancer for a while.  In this case, the balancer, if properly configured, without breaking the connection with the client, will send a request to another node.  And ... the final client, with a high degree of probability, received 200. And not a custom description of the error, which will not help him in any way. <br><br><h2>  Where and what code to use </h2><br>  This is a difficult question.  There is no definite answer to it.  For each system, a transport layer is designed and the codes in it can be specific. <br><br>  There are accepted standards.  They can be easily found and, again, I will not give obvious proofs.  But, I will give the unobvious - <a href="https://developer.mozilla.org/ru/docs/Web/HTTP/Status">developer.mozilla.org/ru/docs/Web/HTTP/Status</a> <br>  Why him?  The point is that code handlers can behave in different ways, depending on the implementation and context of ‚Äúcode understanding‚Äù.  For example, browsers have a caching strategy tied to response codes.  And some services have their own, custom codes.  For example, CloudFlare. <br><br>  Those.  making decisions about the use of codes, you need to base on all elements of the transport layer from your code on the back code to the code on the client.  This is the only way to find the right answers.  I will not even try to give everyone a universal pill. <br><br><h2>  Roots of evil </h2><br>  Already the third project in which I come suffers with code 200 in REST.  It suffers.  There is no other word.  If you have carefully read everything up to the present moment, you already understand that as soon as the project starts to grow, it will need to develop the infrastructure, its sustainability.  Code 200 kills all these attempts at the root.  And the first thing you have to do is break stereotypes. <br><br>  The root of evil, it seems to me lies in the fact that the code 500 is the first thing that a web developer meets in his professional activity.  This can be said to be a child injury.  And all his efforts at first boil down to getting code 200. <br><br>  By the way, for some reason, at this stage a stable opinion is developed that only answers with code 200 can be supplied with a body.  Of course, this is not the case and with any code any answer can ‚Äúcome‚Äù.  Code is code.  The body is the body. <br><br>  Further, with the development of the developer, he has a need to manage the bugs of his own application.  But ... he does not know how to use logs.  Cannot configure web server.  He is studying.  And they are born the very "great."  Because they are available to him and he can quickly make them.  Further, on this ‚Äúgreat‚Äù it mounts new wheels, strengthens the frame, etc.  And this one is becoming his companion for a sufficiently long period of time, until ... until he has really complex, multicomponent tasks.  And here, as they say - the entrance to the supermarket with "great" and on the rollers is prohibited. <br><br>  PS: The author of the mentioned article restored it from drafts - <a href="https://habr.com/ru/post/440382/">habr.com/ru/post/440382</a> , so you can read it too. <br><br>  PPS: I tried to state all the facets of the need to use the relevant response codes in REST.  I will not respond to comments, please understand me correctly.  I will read them with great attention, but I have nothing to add.  Thank you so much for having the patience to read the article! </div><p>Source: <a href="https://habr.com/ru/post/440900/">https://habr.com/ru/post/440900/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>