<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>New network automation features in Red Hat Ansible</title>
  <meta name="description" content="In the light of the significant improvements implemented in Ansible Engine 2.6, as well as taking into account the release of Ansible Tower 3.3 and th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>New network automation features in Red Hat Ansible</h1><div class="post__text post__text-html js-mediator-article">  In the light of the significant improvements implemented in Ansible Engine 2.6, as well as taking into account the release of Ansible Tower 3.3 and the recent release of Ansible Engine 2.7, let's take a closer look at the prospects for network automation. <br><br><img src="https://habrastorage.org/webt/id/hd/2q/idhd2qop4een4zu8tyq_l1dyy8u.png" width="100%"><br><br>  In this post: <br><br><ul><li>  Plug-in connection httpapi. <ul><li>  Support for Arista eAPI and Cisco NX-API. </li></ul></li><li>  New network automation modules. <ul><li>  net_get and net_put. </li><li>  netconf_get, netconf_rpc, and netconf_config. </li><li>  cli_command and cli_config. </li></ul></li><li>  Improved web interface Ansible Tower. </li><li>  Management of credentials in Ansible Tower when working with network devices. </li><li>  Simultaneous use of different versions of Ansible in Tower </li></ul><br>  Do not forget that the release of each new version of Ansible is accompanied by updating <a href="https://docs.ansible.com/ansible/latest/porting_guides/porting_guides.html">the porting manual</a> , which will greatly facilitate your transition to the new version. <br><a name="habracut"></a><br><h3>  HTTPAPI Connection Plugin </h3><br>  Connection plugins are what allow Ansible to connect to target hosts in order to perform tasks on them.  Starting with Ansible 2.5, a new plugin of this type called network_cli has appeared.  It eliminates the need to use the provider parameter and standardizes the order of execution of network modules, with the result that playbooks for network devices are now designed, executed, and work exactly the same way as playbooks for Linux hosts.  In turn, for Ansible Tower, the difference between network devices and hosts disappears, and it no longer needs to distinguish between usernames and passwords for network devices and machines.  This was discussed in more detail <a href="">here</a> , but if in brief, the login passwords for the Linux server and the Arista EOS switch or the Cisco router can now be used and stored in the same way. <br><br>  In Ansible 2.5, it was possible to connect via the eAPI and NX-API methods only using the old provider method.  Ansible 2.6 no longer has this restriction and you can freely use the httpapi high-level connection method.  Let's see how this is done. <br><br>  You must first enable the eAPI or NX-API on the network device so that you can then use the httpapi method.  This is easily done by the corresponding Ansible command, for example, here's how to enable eAPI on an Arista EOS switch. <br><br><pre><code class="plaintext hljs">[user@rhel7]$ ansible -m eos_eapi -c network_cli leaf01 leaf01 | SUCCESS =&gt; { "ansible_facts": { "eos_eapi_urls": { "Ethernet1": [ "https://192.168.0.14:443" ], "Management1": [ "https://10.0.2.15:443" ] } }, "changed": false, "commands": [] }</code> </pre> <br>  When connected to a real Arista EOS switch, the show management api http-commands command will show that the API is enabled: <br><br><pre> <code class="plaintext hljs">leaf01# show management api http-commands Enabled: Yes HTTPS server: running, set to use port 443 &lt;&lt;&lt;rest of output removed for brevity&gt;&gt;&gt;</code> </pre><br>  The following Ansible Playbook script simply executes the show version command, and then in the debug section it returns only the version from the task's JSON output. <br><br><pre> <code class="plaintext hljs">--- - hosts: leaf01 connection: httpapi gather_facts: false tasks: - name: type a simple arista command eos_command: commands: - show version | json register: command_output - name: print command output to terminal window debug: var: command_output.stdout[0]["version"]</code> </pre><br>  Running this script will produce the following result: <br><br><pre> <code class="plaintext hljs">[user@rhel7]$ ansible-playbook playbook.yml PLAY [leaf01]******************************************************** TASK [type a simple arista command] ********************************* ok: [leaf01] TASK [print command output to terminal window] ********************** ok: [leaf01] =&gt; { "command_output.stdout[0][\"version\"]": "4.20.1F" } PLAY RECAP*********************************************************** leaf01 : ok=2 changed=0 unreachable=0 failed=0</code> </pre><br>  NOTE: Arista eAPI does not support abbreviated versions of commands (such as ‚Äúshow ver‚Äù instead of ‚Äúshow version2), so you have to write them completely.  More information about the httpapi plugin can be found in the documentation. <br><br><h3>  New network automation modules </h3><br>  Ansible 2.6 and October 2.7 released seven new modules for network automation. <br><br><ul><li>  <a href="https://docs.ansible.com/ansible/latest/modules/net_get_module.html">net_get</a> - copies a file from a network device to Ansible Controller. </li><li>  <a href="https://docs.ansible.com/ansible/latest/modules/net_put_module.html">net_put</a> - copies a file from Ansible Controller to a network device. </li><li>  <a href="https://docs.ansible.com/ansible/latest/modules/netconf_get_module.html">netconf_get</a> ‚Äî <a href="https://docs.ansible.com/ansible/latest/modules/netconf_get_module.html">Retrieves</a> configuration / status data from a network device with NETCONF enabled. </li><li>  <a href="https://docs.ansible.com/ansible/latest/modules/netconf_rpc_module.html">netconf_rpc</a> - performs operations on a network device with NETCONF enabled. </li><li>  <a href="https://docs.ansible.com/ansible/latest/modules/netconf_config_module.html">netconf_config</a> ‚Äî device configuration of a netconf, the module allows the user to send an XML file to netconf devices and check if the configuration has changed. </li><li>  <a href="https://docs.ansible.com/ansible/latest/modules/cli_command_module.html">cli_command</a> - runs the cli command on network devices that have a command interface (cli). </li><li>  <a href="https://docs.ansible.com/ansible/latest/modules/cli_config_module.html">cli_config</a> - sends (push) a text configuration to network devices via network_cli. </li></ul><br><h3>  net_get and net_put </h3><br><ul><li>  <a href="https://docs.ansible.com/ansible/latest/modules/net_get_module.html">net_get</a> - copies a file from a network device to Ansible Controller. </li><li>  <a href="https://docs.ansible.com/ansible/latest/modules/net_put_module.html">net_put</a> - copies a file from Ansible Controller to a network device. </li></ul><br>  The net_get and net_put modules are not tied to the hardware of a particular manufacturer and simply copy files from the network device to the devices using standard SCP or SFTP transfer protocols (specified by the protocol parameter).  Both of these modules require the use of the network_cli connection method, and also work only if scp is installed on the controller (pip install scp) and SCP or SFTP is enabled on the network device. <br><br>  We assume that in the example with our playbook, we have already executed the following command on the Leaf01 device: <br><br><pre> <code class="plaintext hljs">leaf01#copy running-config flash:running_cfg_eos1.txt Copy completed successfully.</code> </pre><br>  Here‚Äôs what a playbook with two tasks looks like (the first one copies the file from the Leaf01 device, and the second one copies the file to the Leaf01 device): <br><br><pre> <code class="plaintext hljs">--- - hosts: leaf01 connection: network_cli gather_facts: false tasks: - name: COPY FILE FROM THE NETWORK DEVICE TO ANSIBLE CONTROLLER net_get: src: running_cfg_eos1.txt - name: COPY FILE FROM THE ANSIBLE CONTROLLER TO THE NETWORK DEVICE net_put: src: temp.txt</code> </pre><br><h3>  netconf_get, netconf_rpc and netconf_config </h3><br><br><ul><li>  <a href="https://docs.ansible.com/ansible/latest/modules/netconf_get_module.html">netconf_get</a> ‚Äî <a href="https://docs.ansible.com/ansible/latest/modules/netconf_get_module.html">Retrieves</a> configuration / status data from a network device with NETCONF enabled. </li><li>  <a href="https://docs.ansible.com/ansible/latest/modules/netconf_rpc_module.html">netconf_rpc</a> - performs operations on a network device with NETCONF enabled. </li><li>  <a href="https://docs.ansible.com/ansible/latest/modules/netconf_config_module.html">netconf_config</a> ‚Äî device configuration of a netconf, the module allows the user to send an XML file to netconf devices and check if the configuration has changed. </li></ul><br>  The network configuration control protocol NETCONF (Network Configuration Protocol) is developed and standardized by the IETF.  According to RFC 6241, NETCONF can be used to set, manipulate, and delete network device configurations.  NETCONF is an alternative to the SSH command line (network_cli) and APIs like Cisco NX-API or Arista eAPI (httpapi). <br><br>  To demonstrate the new netconf modules, we first enable netconf on Juniper routers using the <a href="https://docs.ansible.com/ansible/latest/modules/junos_netconf_module.html">junos_netconf</a> module.  Netconf does not support all models of network equipment, so before using it, consult the documentation. <br><br><pre> <code class="plaintext hljs">[user@rhel7 ~]$ ansible -m junos_netconf juniper -c network_cli rtr4 | CHANGED =&gt; { "changed": true, "commands": [ "set system services netconf ssh port 830" ] } rtr3 | CHANGED =&gt; { "changed": true, "commands": [ "set system services netconf ssh port 830" ] }</code> </pre><br>  Juniper Networks offers Junos XML API Explorer for <a href="https://apps.juniper.net/xmlapi/operTags.jsp">Operational Tags</a> and for <a href="https://apps.juniper.net/xmlapi/">Configuration Tags</a> .  Consider an example of a transactional query that Juniper Networks uses in its <a href="https://www.juniper.net/documentation/en_US/junos/topics/task/operational/netconf-session-request-sending.html">documentation to</a> illustrate an RPC query for a specific interface. <br><br><pre> <code class="plaintext hljs">&lt;rpc&gt; &lt;get-interface-information&gt; &lt;interface-name&gt;ge-2/3/0&lt;/interface-name&gt; &lt;detail/&gt; &lt;/get-interface-information&gt; &lt;/rpc&gt; ]]&gt;]]&gt;</code> </pre><br>  This is easily translated into the Ansible Playbook language.  get-interface-information is an RPC call, and additional parameters are specified as key-value pairs.  In this example, there is only one parameter - interface-name - and on our network device we just want to see em1.0.  We use the register parameter set by the task, just to save the results, so we use the debug module and display the results on the terminal screen.  The netconf_rpc module also allows you to translate XML output directly into JSON. <br><br><pre> <code class="plaintext hljs">--- - name: RUN A NETCONF COMMAND hosts: juniper gather_facts: no connection: netconf tasks: - name: GET INTERFACE INFO netconf_rpc: display: json rpc: get-interface-information content: interface-name: "em1.0" register: netconf_info - name: PRINT OUTPUT TO TERMINAL WINDOW debug: var: netconf_info</code> </pre><br>  After launching the playbook, we‚Äôll get this: <br><br><pre> <code class="plaintext hljs">ok: [rtr4] =&gt; { "netconf_info": { "changed": false, "failed": false, "output": { "rpc-reply": { "interface-information": { "logical-interface": { "address-family": [ { "address-family-flags": { "ifff-is-primary": "" }, "address-family-name": "inet", "interface-address": [ { "ifa-broadcast": "10.255.255.255", "ifa-destination": "10/8", "ifa-flags": { "ifaf-current-preferred": "" }, "ifa-local": "10.0.0.4" }, &lt;&lt;&lt;rest of output removed for brevity&gt;&gt;&gt;</code> </pre><br>  Additional information can be found in the <a href="https://docs.ansible.com/ansible/latest/network/user_guide/platform_junos.html">Juniper Platform Guide</a> and in the <a href="https://docs.ansible.com/ansible/latest/plugins/connection/netconf.html">NETCONF documentation</a> . <br><br><h3>  cli_command and cli_config </h3><br><ul><li>  <a href="https://docs.ansible.com/ansible/latest/modules/cli_command_module.html">cli_command</a> - runs a command on network devices using their command line interface (if there is one). </li><li>  <a href="https://docs.ansible.com/ansible/latest/modules/cli_config_module.html">cli_config</a> - sends (push) a text configuration to network devices via network_cli. </li></ul><br>  The cli_command and cli_config modules that appeared in Ansible Engine 2.7 are also not tied to the equipment of a particular manufacturer and can be used to automate various network platforms.  They are repelled by the value of the variable ansible_network_os (specified in the inventory file or in the group_vars folder) in order to use the required pluon cliconf.  A list of all the values ‚Äã‚Äãof the variable ansible_network_os is provided in the <a href="https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html">documentation</a> .  In this version of Ansible, you can still use the old modules for specific platforms, so do not rush to rewrite those with playbooks.  Additional information can be found in the <a href="https://docs.ansible.com/ansible/latest/porting_guides/porting_guides.html">official porting guides</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9c/se/hp/9csehpg6fbtd_op985auxtaj0ty.png"></div><br><br>  Let's see how these modules are used in the Ansible Playbook.  This playbook will run on two Cisco Cloud Services Routers (CSR) systems running IOS-XE.  The variable ansible_network_os in the inventory file is set to ios. <br><br><pre> <code class="plaintext hljs">&lt;config snippet from inventory&gt; [cisco] rtr1 ansible_host=34.203.197.120 rtr2 ansible_host=34.224.60.230 [cisco:vars] ansible_ssh_user=ec2-user ansible_network_os=ios</code> </pre><br>  Here's how cli_config and cli_command are used: <br><br><pre> <code class="plaintext hljs">--- - name: AGNOSTIC PLAYBOOK hosts: cisco gather_facts: no connection: network_cli tasks: - name: CONFIGURE DNS cli_config: config: ip name-server 8.8.8.8 - name: CHECK CONFIGURATION cli_command: command: show run | i ip name-server register: cisco_output - name: PRINT OUTPUT TO SCREEN debug: var: cisco_output.stdout</code> </pre><br>  But the output of this playbook: <br><br><pre> <code class="plaintext hljs">[user@rhel7 ~]$ ansible-playbook cli.yml PLAY [AGNOSTIC PLAYBOOK] ********************************************* TASK [CONFIGURE DNS] ************************************************* ok: [rtr1] ok: [rtr2] TASK [CHECK CONFIGURATION] ******************************************* ok: [rtr1] ok: [rtr2] TASK [PRINT OUTPUT TO SCREEN] **************************************** ok: [rtr1] =&gt; { "cisco_output.stdout": "ip name-server 8.8.8.8" } ok: [rtr2] =&gt; { "cisco_output.stdout": "ip name-server 8.8.8.8" } PLAY RECAP ********************************************************** rtr1 : ok=3 changed=0 unreachable=0 failed=0 rtr2 : ok=3 changed=0 unreachable=0 failed=0</code> </pre><br>  Please note that these modules are <a href="https://docs.ansible.com/ansible/latest/reference_appendices/glossary.html">idempotent</a> as long as you use the appropriate syntax for the corresponding network devices. <br><br><h3>  Improved Ansible Tower Interface </h3><br>  The web interface in Red Hat Ansible Tower 3.3 has become more convenient and functional, allowing you to click less on various tasks. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/af/ll/9w/afll9wu5oydzr0cm5_w25nm5vum.png"></div><br><br>  Credential management, task scheduler, inventory scripts, role-based access control, notifications, and much more are now collected in the main menu on the left side of the screen and are available with one click.  The Jobs View task view screen immediately displays important additional information: who started the task and when;  what inventory were fulfilled during its execution;  What project was the playbook taken from? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tx/fs/76/txfs761e3rvtucyej_tt6dls_km.png"></div><br><br><h3>  Manage credentials for network devices in Ansible Tower </h3><br>  With Red Hat Ansible Tower 3.3, it is much easier to manage logins and passwords for network devices.  In the new web interface, the Credentials command is located immediately in the main menu, in the Resources group. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wb/kx/va/wbkxva0twgq2chggh2hdl3_k4-s.png"></div><br><br>  In Ansible Tower 3.3, a special so-called ‚Äúnetwork‚Äù type of credential (Network) remained, which sets the environment variables ANSIBLE_NET_USERNAME and ANSIBLE_NET_PASSWORD used in the old provider method.  All this still works, as written in the <a href="https://docs.ansible.com/ansible-tower/latest/html/userguide/credentials.html">documentation</a> , so that existing Ansible Playbooks scripts can be used. However, for new high-level connection methods httpapi and network_cli, the network type of credentials is no longer needed, since now Ansible works equally well with login passwords connecting to network devices as well as connecting to Linxu hosts.  Therefore, for network devices, you now need to select the Machine credential type ‚Äî just select it and enter the login password or provide an SSH key. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/he/hz/45/hehz456b54gft88sdrgpdhsopty.png"></div><br><br>  NOTE: Ansible Tower encrypts the password immediately after you save credentials. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7q/oa/37/7qoa37ykv-veitbpdra4kpfyc6w.png"></div><br><br>  Thanks to encryption, credentials can be safely delegated to other users and groups ‚Äî they simply won‚Äôt see or know the password.  For more information about how credentials work, what kind of encryption is used, what other types of credentials (like Amazon AWS, Microsoft Azure and Google GCE) can be found in the <a href="https://docs.ansible.com/ansible-tower/latest/html/userguide/credentials.html">documentation for Ansible Tower</a> . <br><br>  A more detailed description of Red Hat Ansible Tower 3.3 can be found <a href="https://www.ansible.com/blog/ansible-tower-3.3-available-now">here</a> . <br><br><h3>  Simultaneous use of different versions of Ansible in Tower </h3><br>  Suppose we want some playbooks to run via Ansible Engine 2.4.2, and others through Ansible Engine 2.6.4.  Tower has a special virtualenv tool for creating isolated Python environments to avoid problems with conflicting dependencies and different versions.  Ansible Tower 3.3 allows you to set virtualenv at different levels - Organization, Project or Job Template.  Here‚Äôs what the Job Template we‚Äôve created in Ansible Tower for backing up our network. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/po/s4/zv/pos4zvk54sl3u1tn-pesf8iieps.png"></div><br><br>  When you have at least two virtual environments, the Ansible Environment drop-down menu appears in the Ansible Tower main menu, where you can easily specify which version of Ansible should be used during the task. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dd/0s/1x/dd0s1xczwzlre4ywiplhlnsuff8.png"></div><br><br>  Therefore, if you have a mix of playbooks for network automation, some of which use the old provider method (Ansible 2.4 and previous versions), and some are new httpapi plug-ins or network_cli (Ansible 2.5 and higher), you can easily assign each task Ansible version.  In addition, this feature will be useful if developers and production use different versions of Ansible.  In other words, you can safely upgrade Tower without worrying that after that you will have to switch to any one version of the Ansible Engine, which greatly increases the flexibility in automating various types of network equipment and environments, as well as usage scenarios. <br><br>  Additional information on using virtualenv can be found in the <a href="https://docs.ansible.com/ansible-tower/latest/html/upgrade-migration-guide/virtualenv.html">documentation</a> . </div><p>Source: <a href="https://habr.com/ru/post/436318/">https://habr.com/ru/post/436318/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>