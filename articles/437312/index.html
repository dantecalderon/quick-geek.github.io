<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implementing a hot boot of C ++ code in Linux and macOS: digging deeper</title>
  <meta name="description" content="* Link to the library and demo video at the end of the article. To understand what is happening, and who all these people are, I recommend reading the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Implementing a hot boot of C ++ code in Linux and macOS: digging deeper</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/cz/hn/wz/czhnwzufandjpr6jf5cwj1j3p48.png"></p><br><p>  * Link to the library and demo video at the end of the article.  To understand what is happening, and who all these people are, I recommend reading the <a href="https://habr.com/post/435260/">previous article</a> . </p><br><p>  In the last article, we familiarized ourselves with an approach that allows for a hot reboot of c ++ code.  The ‚Äúcode‚Äù in this case is the functions, data, and their coordinated work with each other.  There are no special problems with functions, we redirect the flow of execution from the old function to the new one, and everything works.  The problem arises with data (static and global variables), namely with the strategy of their synchronization in the old and new code.  In the first implementation, this strategy was very clumsy: we simply copy the values ‚Äã‚Äãof all static variables from the old code to the new one, so that the new code, referring to the new variables, works with the values ‚Äã‚Äãfrom the old code.  Of course, this is incorrect, and today we will try to correct this flaw by simultaneously solving a number of small but interesting problems. </p><br><p>  The article omits details regarding mechanical work, such as reading characters and relocations from elf and mach-o files.  The emphasis is on the subtle points that I encountered in the implementation process, and which may be useful to someone who, like me recently, is looking for answers. </p><a name="habracut"></a><br><h3 id="sut">  The essence </h3><br><p>  Let's imagine that we have a class (synthetic examples, please do not look for meaning in them, only the code is important): </p><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Entity.hpp class Entity { public: Entity(const std::string&amp; description); ~Entity(); void printDescription(); static int getLivingEntitiesCount(); private: static int m_livingEntitiesCount; std::string m_description; }; // Entity.cpp int Entity::m_livingEntitiesCount = 0; Entity::Entity(const std::string&amp; description) : m_description(description) { m_livingEntitiesCount++; } Entity::~Entity() { m_livingEntitiesCount--; } int Entity::getLivingEntitiesCount() { return m_livingEntitiesCount; } void Entity::printDesctiption() { std::cout &lt;&lt; m_description &lt;&lt; std::endl; }</span></span></code> </pre> <br><p>  Nothing special, except a static variable.  Now imagine that we want to change the <code>printDescription()</code> method to: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Entity::printDescription() { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"DESCRIPTION: "</span></span> &lt;&lt; m_description &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br><p>  What happens after reloading the code?  In the library with the new code, in addition to the methods of the class <code>Entity</code> , will get the static variable <code>m_livingEntitiesCount</code> .  Nothing bad will happen if we just copy the value of this variable from the old code to the new one, and continue to use the new variable, forgetting about the old one, because all the methods that use this variable directly are in the library with the new code. </p><br><p>  C ++ is very flexible and rich.  And let the elegance of solving some problems in c ++ borders on smelly code, I love this language.  For example, imagine that rtti is not used in your project.  At the same time, you need to have an implementation of the class <code>Any</code> with some type-safe interface: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Any</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Any</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp;&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } };</code> </pre> <br><p>  We will not go into the details of the implementation of this class.  What is important for us is that for implementation we need some kind of mechanism for unambiguous mapping of the type (compile-time entity) into the value of a variable, for example, <code>uint64_t</code> (runtime entity), that is, "number" types.  When using rtti, we have access to such things as <code>type_info</code> and, more <code>type_index</code> , <code>type_index</code> .  But we do not have rtti.  In this case, a fairly common hack (or an elegant solution?) Is such a function: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> typeId() { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> someVar; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>&gt;(&amp;someVar); }</code> </pre> <br><p>  Then the implementation of the <code>Any</code> class will look something like this: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Any</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Any</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp;&amp; value)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_typeId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(typeId&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::decay&lt;T&gt;::type&gt;())</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// copy or move value somewhere {} template &lt;typename T&gt; bool is() const { return m_typeId == typeId&lt;std::decay&lt;T&gt;::type&gt;(); } template &lt;typename T&gt; T&amp; as() { ... } private: uint64_t m_typeId = 0; };</span></span></span></span></code> </pre> <br><p>  For each type, the function will be instantiated exactly 1 time, respectively, each version of the function will have its own static variable, obviously with its own unique address.  What happens when we reload code using this feature?  Calls to the old version of the function will be redirected to the new one.  The new one will have its own static variable, already initialized (we copied the value and the guard variable).  But we are not interested in the value, we use only the address.  And the address of the new variable will be different.  Thus, the data became inconsistent: in the already created instances of the <code>Any</code> class, the address of the old static variable will be stored, and the <code>is()</code> method will compare it with the address of the new one, and "this <code>Any</code> no longer be the same <code>Any</code> " ¬©. </p><br><h3 id="plan">  Plan </h3><br><p>  To solve this problem, you need something smarter than just copying.  Having spent a couple of evenings on googling, reading documentation, source codes and system api, the following plan was drawn up in my head: </p><br><ol><li>  After the assembly of the new code, we are passing through <a href="https://en.wikipedia.org/wiki/Relocation_(computing)">relocations</a> . </li><li>  From these relocations, we get all the places in the code that use static (and sometimes global) variables. </li><li>  Instead of addresses for new versions of variables, we substitute addresses of old versions into the relocation place. </li></ol><br><p>  In this case, there will be no links to new data, the entire application will continue to work with old versions of variables up to the address.  That should work.  It can't fail. </p><br><h3 id="relokacii">  Relocation </h3><br><p>  When the compiler generates a machine code, it inserts several bytes sufficient for writing a real address of a variable or function to each place where a function call or loading a variable address occurs, and also generates a relocation.  He cannot immediately write down the real address, since at this stage he does not know this address.  Functions and variables after linking can appear in different sections, in different places of sections, in the end sections can be loaded at different addresses during execution. </p><br><p>  Relocation contains information: </p><br><ul><li>  What is the address to write the address of the function or variable </li><li>  Address of which function or variable to write </li><li>  The formula by which this address should be calculated </li><li>  How many bytes are reserved for this address </li></ul><br><p>  In different operating systems, relocations are represented differently, but in the end they all work on the same principle.  For example, in elf (Linux), relocations are located in special <code>.rela</code> sections (in the 32-bit version, this is <code>.rel</code> ), which refer to the section with the address that needs to be fixed (for example, <code>.rela.text</code> is the section where relocations are located, applied to the <code>.text</code> section), and each record stores information about the symbol whose address is to be inserted into the relocation location.  In mach-o (macOS), everything is slightly the opposite; there is no separate section for relocations, instead, each section contains a pointer to a relocation table that should be applied to this section, and in each record of this table there is a reference to the relocated symbol. <br>  For example, for such a code (with the <code>-fPIC</code> option): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> globalVariable = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">veryUsefulFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> functionLocalVariable = <span class="hljs-number"><span class="hljs-number">0</span></span>; functionLocalVariable++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> globalVariable + functionLocalVariable; }</code> </pre> <br><p>  the compiler will create this section with Linux relocations: </p><br><pre> <code class="plaintext hljs">Relocation section '.rela.text' at offset 0x1a0 contains 4 entries: Offset Info Type Symbol's Value Symbol's Name + Addend 0000000000000007 0000000600000009 R_X86_64_GOTPCREL 0000000000000000 globalVariable - 4 000000000000000d 0000000400000002 R_X86_64_PC32 0000000000000000 .bss - 4 0000000000000016 0000000400000002 R_X86_64_PC32 0000000000000000 .bss - 4 000000000000001e 0000000400000002 R_X86_64_PC32 0000000000000000 .bss - 4</code> </pre> <br><p>  and the following relocation table on macOS: </p><br><pre> <code class="plaintext hljs">RELOCATION RECORDS FOR [__text]: 000000000000001b X86_64_RELOC_SIGNED __ZZ18veryUsefulFunctionvE21functionLocalVariable 0000000000000015 X86_64_RELOC_SIGNED _globalVariable 000000000000000f X86_64_RELOC_SIGNED __ZZ18veryUsefulFunctionvE21functionLocalVariable 0000000000000006 X86_64_RELOC_SIGNED __ZZ18veryUsefulFunctionvE21functionLocalVariable</code> </pre> <br><p>  And here is the <code>veryUsefulFunction()</code> function (in Linux): </p><br><pre> <code class="plaintext hljs">0000000000000000 &lt;_Z18veryUsefulFunctionv&gt;: 0: 55 push rbp 1: 48 89 e5 mov rbp,rsp 4: 48 8b 05 00 00 00 00 mov rax,QWORD PTR [rip+0x0] b: 8b 0d 00 00 00 00 mov ecx,DWORD PTR [rip+0x0] 11: 83 c1 01 add ecx,0x1 14: 89 0d 00 00 00 00 mov DWORD PTR [rip+0x0],ecx 1a: 8b 08 mov ecx,DWORD PTR [rax] 1c: 03 0d 00 00 00 00 add ecx,DWORD PTR [rip+0x0] 22: 89 c8 mov eax,ecx 24: 5d pop rbp 25: c3 ret</code> </pre> <br><p>  and so after linking the object library to the dynamic library: </p><br><pre> <code class="plaintext hljs">00000000000010e0 &lt;_Z18veryUsefulFunctionv&gt;: 10e0: 55 push rbp 10e1: 48 89 e5 mov rbp,rsp 10e4: 48 8b 05 05 21 00 00 mov rax,QWORD PTR [rip+0x2105] 10eb: 8b 0d 13 2f 00 00 mov ecx,DWORD PTR [rip+0x2f13] 10f1: 83 c1 01 add ecx,0x1 10f4: 89 0d 0a 2f 00 00 mov DWORD PTR [rip+0x2f0a],ecx 10fa: 8b 08 mov ecx,DWORD PTR [rax] 10fc: 03 0d 02 2f 00 00 add ecx,DWORD PTR [rip+0x2f02] 1102: 89 c8 mov eax,ecx 1104: 5d pop rbp 1105: c3 ret</code> </pre> <br><p>  There are 4 places in it, in which 4 bytes are reserved for the address of real variables. </p><br><p>  On different systems, the set of possible relocations is yours.  On Linux, x86-64 as many as <a href="">40 types of relocations</a> .  On macOS on x86-64 there are <a href="https://opensource.apple.com/source/xnu/xnu-1504.7.4/EXTERNAL_HEADERS/mach-o/x86_64/reloc.h.auto.html">only 9 of them</a> .  All types of relocations can be divided into 2 groups: </p><br><ol><li>  Link-time relocations - relocations used in the process of linking object files to an executable file or dynamic library </li><li>  Load-time relocations - relocations used at the time of loading the dynamic library into the process memory </li></ol><br><p>  The second group includes relocations of exported functions and variables.  When a dynamic library is loaded into the process memory, for all dynamic relocations (including global global relocations), the linker searches for the definition of characters in all the libraries already loaded, including the program itself, and the address of the first suitable character is used for relocation.  Thus, you don‚Äôt need to do anything with these relocations, the linker himself will find the variable from our application, because it will fall to it earlier in the list of loaded libraries and programs, and substitute its address into the new code, ignoring the new version of this variable. </p><br><p>  There is a subtle point related to macOS and its dynamic linker.  MacOS implements the so-called two-level namespace mechanism.  If it is rough, then when loading a dynamic library, the linker will first look for characters in this library, and if he does not find it, he will search for others.  This is done for performance reasons, so that relocations are resolved quickly, which is, in general, logical.  But it breaks our flow regarding global variables.  Fortunately, in ld on macOS there is a special flag - <code>-flat_namespace</code> , and if you build a library with this flag, the character search algorithm will be identical to that in Linux. </p><br><p>  The first group includes the relocations of static variables - exactly what we need.  The only problem is that these relocations are not in the compiled library, since they are already resolved by the linker.  Therefore, we will read them from the object files from which the library was assembled. <br>  The possible types of relocations are also limited by whether the assembled position-dependent code is or not.  Since we collect our code in the PIC mode (position-independent code), only the relative relocations are used.  The total relocation we are interested in is: </p><br><ul><li>  Relocations from the <code>.rela.text</code> section in Linux and relocation referenced by the <code>__text</code> section in macOS, and </li><li>  Using characters from the <code>.data</code> and <code>.bss</code> sections on Linux and <code>__data</code> , <code>__bss</code> and <code>__common</code> on macOS, and </li><li>  Relocations are of type <code>R_X86_64_PC32</code> and <code>R_X86_64_PC64</code> on Linux and <code>X86_64_RELOC_SIGNED</code> , <code>X86_64_RELOC_SIGNED_1</code> , <code>X86_64_RELOC_SIGNED_2</code> and <code>X86_64_RELOC_SIGNED_4</code> on macOS </li></ul><br><p>  The subtle point associated with the <code>__common</code> section.  Linux also has a similar <code>*COM*</code> section.  Global variables can fall into <a href="https://www.cs.stevens.edu/~jschauma/631A/elf.html">this section</a> .  But, while I was testing and compiling a bunch of code fragments, on Linux, the relocation of characters from the <code>*COM*</code> section was always dynamic, like normal global variables.  At the same time, in macOS such symbols were sometimes relocated during linking, if the function and the symbol are in the same file.  Therefore, on macOS, it makes sense to take this section into account when reading symbols and relocations. </p><br><p>  Great, now we have a set of all the relocations we need, what to do with them?  The logic here is simple.  When the linker links the library, he writes the symbol address calculated by a <a href="https://www.intezer.com/executable-and-linkable-format-101-part-3-relocations/">specific formula</a> to the relocation address.  For our relocations on both platforms, this formula contains the symbol address as a term.  Thus, the calculated address, already recorded in the function body, has the form: </p><br><pre> <code class="plaintext hljs">resultAddr = newVarAddr + addend - relocAddr</code> </pre> <br><p>  At the same time, we know the addresses of both versions of the variables ‚Äî old, already living in the application, and new.  It remains for us to change it according to the formula: </p><br><pre> <code class="plaintext hljs">resultAddr = resultAddr - newVarAddr + oldVarAddr</code> </pre> <br><p>  and write it to the relocation address.  After that, all functions in the new code will use the already existing versions of the variables, and the new variables will simply lie and do nothing.  What you need!  But there is one subtle point. </p><br><h3 id="zagruzka-biblioteki-s-novym-kodom">  Loading library with new code </h3><br><p>  When the system loads the dynamic library into the process memory, it is free to place it in any place of the virtual address space.  On Ubuntu 18.04, my application is loaded at <code>0x00400000</code> , and our dynamic libraries immediately after <code>ld-2.27.so</code> at addresses in the region of <code>0x7fd3829bd000</code> .  The distance between the program and library load addresses is much larger than the number that would fit into the signed 32-bit integer.  And in link-time relocations, only 4 bytes are reserved for addresses of target characters. </p><br><p>  Having smoked the documentation for compilers and linkers, I decided to try the <code>-mcmodel=large</code> option.  It makes the compiler generate a code without any assumptions about the distance between characters, thus all addresses are 64-bit.  But this option is not friendly with PIC, as if <code>-mcmodel=large</code> cannot be used with <code>-fPIC</code> , at least on macOS.  I still do not understand what the problem is, perhaps on macOS there are no suitable relocations for this situation. </p><br><p>  In the library under windows, this problem is solved as follows.  Hands allocated a piece of virtual memory near the place of loading the application, sufficient to accommodate the necessary sections of the library.  Then the sections are loaded into it by hands, the necessary rights are set up for the memory pages with the corresponding sections, all relocations are resolved by hands, and the rest is patched.  I'm lazy.  I really did not want to do all this work with load-time relocations, especially on Linux.  And why do something that a dynamic linker can already do?  After all, the people who wrote it know much more than I do. </p><br><p>  Fortunately, the documentation found the necessary options that allow you to specify where to load our dynamic library: </p><br><ul><li>  Apple ld: <code>-image_base 0xADDRESS</code> </li><li>  LLVM lld: <code>--image-base=0xADDRESS</code> </li><li>  GNU ld: <code>-Ttext-segment=0xADDRESS</code> </li></ul><br><p>  These options need to be passed to the linker at the time of linking the dynamic library.  There are 2 difficulties. <br>  The first is related to GNU ld.  In order for these options to work, you need to: </p><br><ul><li>  At the time of loading the library area in which we want to load it, was free </li><li>  The address specified in the option must be a multiple of the page size (on x86-64, Linux and macOS are <code>0x1000</code> ) </li><li>  At least in Linux, the address specified in the option must be a multiple of the alignment of the <code>PT_LOAD</code> segment </li></ul><br><p>  That is, if the linker set the alignment to <code>0x10000000</code> , then this library cannot be loaded at <code>0x10001000</code> , even considering that the address is aligned to the page size.  If one of these conditions fails, the library will load "as usual."  I have GNU ld 2.30 in my system, and, unlike LLVM lld, it defaults to aligning the <code>PT_LOAD</code> segment to <code>0x20000</code> , which is very much out of the general picture.  To get around this, you need in addition to the option <code>-Ttext-segment=...</code> specify <code>-z max-page-size=0x1000</code> .  I spent the day until I understood why the library is not loaded where it should be. </p><br><p>  The second difficulty is that the download address must be known at the linking stage of the library.  It is not very difficult to organize.  In Linux, just parse the pseudo-file <code>/proc/&lt;pid&gt;/maps</code> , find the unallocated piece closest to the program that the library will fit into, and use the address of the beginning of this nub when linking.  The size of the future library can be roughly estimated by looking at the sizes of the object files, or by parsing them and calculating the sizes of all sections.  In the end, we need not an exact number, but an approximate size with a margin. </p><br><p>  In macOS there is no <code>/proc/*</code> , instead, it is proposed to use the <code>vmmap</code> utility.  The output of the <code>vmmap -interleaved &lt;pid&gt;</code> command contains the same information as <code>proc/&lt;pid&gt;/maps</code> .  But then another difficulty arises.  If an application creates a child process that executes this command, and the current process identifier is specified as the <code>&lt;pid&gt;</code> , the program will hang tightly.  As I understand it, <code>vmmap</code> stops the process to read its memory mappings, and apparently, if this is the calling process, then something goes wrong.  In this case, you need to specify an additional flag <code>-forkCorpse</code> , so that <code>vmmap</code> creates an empty child process from our process, <code>vmmap</code> mapping from it and kills it, thereby not interrupting the program. </p><br><p>  In general, this is all we need to know. </p><br><h3 id="sobiraem-vse-vmeste">  Putting it all together </h3><br><p>  With these modifications, the final code reload algorithm looks like this: </p><br><ol><li>  Compile new code into object files. </li><li>  According to the object files, we estimate the size of the future library. </li><li>  We read from object files of relocation </li><li>  We are looking for a free piece of virtual memory next to the application. </li><li>  We collect dynamic library with the necessary options, we <code>dlopen</code> through <code>dlopen</code> </li><li>  Patch code according to link-time relocations </li><li>  Patch functions </li><li>  Copy static variables that did not participate in step 6 </li></ol><br><p>  In step 8, only guard variables of static variables are included, so they can be safely copied (thereby preserving the "initialization" of the static variables themselves). </p><br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>  Since this is exclusively a development tool, not intended for any production, the worst thing that can happen if another library with a new code does not fit into memory, or accidentally loads at a different address, it is a restart of the application being debugged.  When running the tests into memory, 31 libraries are loaded in turn with the updated code. </p><br><p>  For the sake of completeness, the implementation lacks 3 more weighty pieces: </p><br><ol><li>  Now the library with the new code is loaded into memory next to the program, although it can get code from another dynamic library that was loaded far.  For fixing, it is necessary to track the belonging of the translation units to these or those libraries and the program, and split the library with the new code if necessary. </li><li>  Reloading code in a multi-threaded application is still unreliable (you can safely reload only code that runs on the same thread as the runloop library).  For fixing, it is necessary to bring part of the implementation into a separate program, and this program, before patching, should stop the process with all threads, perform patching, and return it to work.  I do not know how to do this without an external program. </li><li>  Prevent accidental application crashes after reloading code.  Having fixed the code, you can accidentally dereference an invalid pointer in a new code, after which you will have to restart the application.  It's okay, but still.  Sounds like black magic, I'm still in thought. </li></ol><br><p>  But already the current implementation began to bring benefits to me personally, it is enough for use in my main work.  Need a little getting used to, but the flight is normal. <br>  If I get to these three points and find a sufficient amount of interesting things in their implementation, I will definitely share it. </p><br><h3 id="demo">  Demo </h3><br><p>  Since the implementation allows you to add new broadcast units on the fly, I decided to record a small video in which I write from scratch an indecently simple game about a spaceship plying the universe and shooting square asteroids.  I tried to write not in the style of ‚Äúall in one file‚Äù, but, if possible, putting everything on the shelves, thus generating a lot of small files (that is why there was so much writing).  Of course, for drawing, inputs, windows and other things, the framework is used, but the code of the game itself was written from scratch. <br>  The main feature is that I only launched the application 3 times: at the very beginning, when there was only an empty stage in it, and 2 times after falling due to my carelessness.  The whole game was incrementally added in the process of writing code.  Real time - about 40 minutes.  In general, you are welcome. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/5xfgViYchqg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  As always, I will be glad to any criticism, thanks! </p><br><p>  <a href="https://github.com/ddovod/jet-live">Reference to implementation</a> </p></div><p>Source: <a href="https://habr.com/ru/post/437312/">https://habr.com/ru/post/437312/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>