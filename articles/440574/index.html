<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Russian AI Cup 2018, history 9 places</title>
  <meta name="description" content="so 


 Like last year, my name is Andrei Rybalka, only this time I am 33. And, since I was in the top ten, I decided to share my approach to writing a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Russian AI Cup 2018, history 9 places</h1><div class="post__text post__text-html js-mediator-article"><h1 id="itak">  so </h1><br><p>  Like last year, my name is Andrei Rybalka, only this time I am 33. And, since I was in the top ten, I decided to share my approach to writing a game bot for the <a href="http://russianaicup.ru/">Russian AI Cup 2018</a> again. </p><br><p>  This time the task was football.  The task itself was somewhat reminiscent of the 2014 RAIC, when it was hockey, but the solution was completely different. </p><br><p>  The world this time was three-dimensional and this three-dimensionality was used in full.  The game itself was most reminiscent of the <a href="https://www.rocketleague.com/">Rocket League</a> . </p><br><p>  I will not bore the introductory part, it is easier to show how it looked.  You can watch the games <a href="http://russianaicup.ru/profile/lama">on the website</a> or on video: </p><br><p> <a href="https://www.youtube.com/watch%3Fv%3D1p73XwFCbkA"><img src="https://habrastorage.org/webt/6g/jb/hf/6gjbhf4gdy_4qqrw74huttfudvq.jpeg"></a> </p><a name="habracut"></a><br><p>  So that life does not seem too sweet to us, the developers, in addition to the non-determinism of the game world, also crushed the game tick into 100 sabtics, which initially put an end to exact simulation for most participants, and even more so for me, intending to write a bot on slow java. </p><br><p>  Also, I must say that the championship is divided into rounds, which probably would be more correct to call tours. </p><br><h3 id="kratko-o-turnirnoy-sisteme">  Briefly about the tournament system </h3><br><p>  For a start, 2 weeks to develop.  Then passes the first round.  300 of the best of it pass on. </p><br><p>  After the round, the rules of the game change (and specifically, nitro is added to the game) and another 2 weeks are given, after which the second round passes. </p><br><p>  Then the rules are again complicated (the third player is added), another week is given and we play the final. </p><br><p>  But this is not the end.  After the finals, there is still a week, at the end of which the sandbox just stops, and the 6 best ones in it, excluding the prize winners, are also awarded.  The fundamental difference between the sandbox finals and the championship finals is that in the sandbox games are created in a random format, and not just in the format of the current round. </p><br><h1 id="istorii-uchastiya">  Participation stories </h1><br><p>  The technical part will be lower.  Who is not interested in the story, you can scroll down until it becomes good. </p><br><h3 id="pervyy-raund">  First round </h3><br><p>  Began, like most, from the week of the beta.  I spent a lot of time, 4+ hours each evening. <br>  Before filling in the first version, I went through several iterations. <br>  <em>code, until it starts to beat the previous version - we collect - we consider the current version of the previous version - we repeat</em> . </p><br><p>  I didn‚Äôt hurry with the first one and it happened a few days before the round.  And, since, until now, my bot has not played with anyone, I had no idea what kind of world I am and what positions I can claim in the rating.  When I saw that I had won more than 100 games in a row without a single loss, I calmed down. </p><br><p>  In general, the first loss I had, it seems, in 12th place, by time-limit, and the first game lost in a row is already in the top 10. </p><br><p>  In short, I realized that I have chances to get into the second round, where the top 300 passes. <br>  Therefore, I did not chase the position in it and did not flood anything for the round any more, but simply continued to work. </p><br><p>  At that time I saw that there was still a lot of room for improvement and without connecting nitro (which appeared after the 1st round), so I focused on the main part of the strategy, realizing that before the second round I had more than 2 weeks more and I would have time to fix the nitro. </p><br><h3 id="vtoroy-raund">  Second round </h3><br><p>  The first week I was actively programming, but still not connected nitro.  I wanted to do this in the second week.  But everything turned out differently, because by the end of the first week I had slept with pneumonia.  I was not in a position to program, so I just filled in what was, and, one can say, active participation in the championship for me at this place was over. </p><br><p>  Over the next 3 weeks before the end of the championship, he worked on the strategy for a total of 20 hours. </p><br><p>  As a result, in the second round, my bot basically did not know that there was nitro in the game, but somehow it still took 16th place. </p><br><h3 id="final">  The final </h3><br><p>  The third player was added to the final. </p><br><p>  I wrote on slow Java, and not in C ++, as 7 out of 8 people above me in the rating, and my bot often fell before the timeout, so with the advent of the third player, it began to fall in 100% of the games.  Fortunately, sandbox games are created in a random format, so I automatically <br>  he lost only every third game and therefore flew down not too much.  It seems to have dropped to 18th place. </p><br><p>  If we do not consider programming the correction of coefficients in the evaluation function and the launch of tests, then for the first time, after the onset of the disease, I sat behind the bot the evening before the final.  He added a very simple nitro, directed strictly upwards, made it so that the two attackers stopped running at the same point and colliding there with each other, and cut everything they could for the 3x3 game, starting from the depth of the calculation and ending with the simulation accuracy, so that Only the bot did not die on timeout. <br>  In this form, it played the final. </p><br><p>  In the break between the halves of the final, I sat down behind the bot again and spent a good 10 hours. For the most part, the edits concerned the dynamic selection of coefficients, the early interruption of genetics, etc.  In general, I was looking for a balance between accuracy and depth of miscalculation and speed. <br>  In addition to fighting performance, I made a couple of changes: </p><br><ul><li>  Sent the far (relative to the ball) attacker to a point in the middle between the ball and the opponent's goal </li><li>  A little corrected nitro (the description will be in those. Part).  It was still extremely simple, but it became much more efficient to work. </li></ul><br><p>  Total, having banished tests and having seen account 395: 254 against the previous version, on it calmed down.  This allowed me to take the 9th place in the final. </p><br><h3 id="final-pesochnicy">  Sandbox final </h3><br><p>  I continued to hurt and did not work on the bot for most of the week.  A day before the end, I saw that several people had filled up the latest versions, which often win from me and can be thrown out of the sandbox prizes.  So I spent another couple of hours. </p><br><p>  The only major change is that I dug up my branch in Git three weeks ago, in which I had a simulation of the movement of the enemy with my simplified algorithm.  At that time, it worked poorly, but I brought it to mind, drove the tests, saw <br>  that wins from the previous version almost doubled and flooded.  So, at the time of the stop, I was in 10th place in the general table, which corresponds to the 4th place in the final sandbox. </p><br><h1 id="kak-eto-vsyo-rabotaet-tehnicheskaya-chast">  How it all works (technical part) </h1><br><p>  I apologize in advance if there are inaccuracies in terminology.  Also, I am writing from memory, so it is possible that somewhere I will describe not the final version. </p><br><p>  So, based on genetic algorithms.  A chromosome consists of several genes: </p><br><ul><li>  Fractional number in the range -PI..PI, specifying the direction of movement </li><li>  An integer in the range 0..10, specifying the number of repetitions of this action </li><li>  Fractional number from 0 to 1. If the value is above a certain threshold, make a jump </li></ul><br><p>  A genotype may include a different number of chromosomes, but so that the total number of actions (including repetitions) is 40. </p><br><p>  Initially, I create several dozen random genotypes.  I add to them: </p><br><ul><li>  Trajectory right on the ball </li><li>  Straight trajectories in all directions, only 10 pieces with an offset of 36 degrees </li><li>  A genotype that simply does nothing (without it, the bot always runs somewhere, even if it is already at the optimal point) </li><li>  The best genotype from the previous tick </li></ul><br><p> Then it is all simulated and run through the evaluation function.  N best genotypes "survive" and are cloned M times with mutations.  During mutation, each gene changes in a given range with a probability of 10%.  Well, this is repeated for several generations. <br>  There is no crossing, in this task I do not see any sense in it. </p><br><p>  Total, the maximum possible number of trajectories per tick per player was about 800, but in fact, in most cases it was much less, because  in some cases (for example, when in the near future we will definitely not be able to touch the ball), the movement of players has been replaced by simple heuristics.  In addition, N, M and the number of generations depended on the situation on the field.  First of all, from the distance to the ball.  Also, the miscalculation is interrupted prematurely (but not earlier than the 5th generation), if a trajectory is found with an acceptable estimate. </p><br><h3 id="makro">  Macro </h3><br><p>  The goalkeeper runs to the point in front of the center of the goal.  My tests showed that he plays the best in me standing in front of the goal, and not inside them, like most players in the top. </p><br><p>  The position of the point deviated from the center depending on several factors: the position and direction of the ball's flight, the point the ball hit my goal, if a goal is planned, the location of the nearest attacking opponent, etc. </p><br><p>  If the ball is on the side of the enemy and flies towards its goal, we can go for nitro. </p><br><p>  If my goalkeeper can hit the ball earlier than my attacker (plus a few more conditions), then the attacker ignores the ball and runs to a point in the middle between the ball and the opponent's goal.  I went through a lot of options for exactly where to run.  In my case, this one worked best. </p><br><p>  Otherwise, if the ball is too far, the attacker runs in a straight line to the nearest point of contact of the ball with the floor at which he can intercept the ball (if we don‚Äôt have time to reach the first point of contact, check the next one, etc.) </p><br><p>  Otherwise (when the ball is reached), the attacker goes where the evaluation function will tell him.  Yes, and also, if the nitro is not far away and we can pick it up, we select it. </p><br><p>  In a 3x3 game, the second attacker is more likely to strive for the ball and with a lesser run forward, waiting for a pass from the goalkeeper.  But if you still run, then the point is chosen another - closer to the center line. </p><br><p>  I also each tick one-time simulated the ball 100 ticks forward with 100 mikrotikami (with caching). </p><br><p>  This trajectory has been used in many places.  For example: </p><br><ul><li>  To determine the points of contact of the ball with the floor </li><li>  To find out if the ball threatens my goal and whether the goalkeeper should be switched to simulation mode </li></ul><br><p>  The same exact trajectory was used in the simulation of the trajectories of the players, so as not to recalculate the movement of the ball each time.  But only until the first collision of the ball with any football player. </p><br><p>  By the way, writing Footballist was too lazy, the words Player, Robot were reserved by the strategy, <br>  so my wrapper class was called Dude :) </p><br><h3 id="simulyaciya">  Simulation </h3><br><p>  In most cases, it took place with one microtic, but in some situations switched to accurate mode with a large number of microtics (at the beginning by 100, then reduced to 50 in the game 2x2, because the tests showed that the difference in the results is within the margin of error, and to 10 in 3x3, for otherwise he flew away in timeouts). </p><br><p>  In accurate mode, I switched either at the time of jumping, or being so close to the ball that a collision is possible at the next tick.  Moreover, here, too, was the mass of small crutches, hacks, optimizations, in which I myself can not figure it out. </p><br><p>  For example, the flying ball was still simulated with 1 microtic, but if after the next microtic I saw that a collision had occurred, he would roll back to the previous position and simulate it again with greater accuracy. </p><br><p>  In addition, I also simulated other players (both ours and others), if they were in the air (and, consequently, their trajectory is easier to predict), or were close to the ball.  For opponents in the final version, a simplified version of my own decision-making strategy was used, which was run every 5 ticks (more often it did not allow performance). </p><br><p>  When simulating each character, I calculated myself, the ball and other players for 40 ticks forward (my limit on the number of actions in the genotype) and then for the same number of ticks, only the ball simulated. </p><br><h3 id="nitro">  Nitro </h3><br><p>  Simple to indecency. </p><br><p>  In the final version, nitro is always included, if it is, if the player is in the air, and if he did not hit the ball in the last few ticks. </p><br><p>  At the beginning, I always directed the nitro up strictly, but then I tried to experiment and the best thing was to work the option to go straight to the center of the ball.  I also tried options so that the direction of nitro was chosen by genetics. </p><br><p>  Worked much worse.  Perhaps due to lack of depth busting. </p><br><h3 id="funkciya-ocenki">  Evaluation function </h3><br><p>  The sum of scores on each tick with a 2% attenuation per tick. </p><br><p>  The biggest weight, of course, had a goal.  Several things influenced its weight: </p><br><ul><li>  The distance from the ball to the enemy goalkeeper at the time of the goal (the farther - the better) </li><li>  Y coordinate of the ball (because at the top of the gate it is much harder to beat off) </li><li>  The speed of the ball on the Z axis (which is directed to the enemy gate) </li></ul><br><p>  When attacking me, everything is the same, only with the opposite sign. </p><br><p>  Further, for the attacker, the overall score depended on: </p><br><ul><li>  Distance from the player to the ball (so that he runs to the ball, even if he cannot hit him) </li><li>  Penalty for a jump (to jump only if it brings so many points that they exceed this penalty) </li><li>  Distances on the next simulation tick from the ball to the opponents </li><li>  The coordinates of the Y ball (the higher it is, the less chance the enemy will intercept it) </li><li>  Cosine of the angle between the direction of the ball and the center of the enemy gates </li><li>  Flag, did I touch the ball </li><li>  Flag, whether the enemy touched the ball </li><li>  Bonus for the selection of nitro </li></ul><br><p>  Also, there was a small bonus for hitting an enemy player.  Although in fact, although it happened, but rarely. </p><br><p>  For goalkeeper: </p><br><ul><li>  Bonus for distances to the ball, ball speed in Z, ball position in Y </li><li>  Penalty for jump </li><li>  The penalty for finding the ball in the area in front of my goal </li><li>  The distance to the enemies and to my attackers was taken into account (so that the ball flew away from the enemies, but, if possible, flew closer to my attackers) </li><li>  And a few little things. </li></ul><br><h3 id="machine-learning">  Machine learning </h3><br><p>  There was very little in one of the branches of the gita as an experiment.  But it seems to me worth mentioning anyway.  I did not have time to bring it to mind (and I‚Äôm not sure it made sense). </p><br><p>  In general, I tried with his help to predict whether the enemy can intercept the ball, based on the positions and speeds of the enemy and the ball.  Planned to use this in the evaluation function.  Fine trajectories that can be intercepted. </p><br><p>  But I immediately understood that I could not afford not only a neural network, but nothing at all serious, because it would have to be performed 80 times per trajectory.  Well, even 40 or 20, if not every tick, but still, I didn‚Äôt have any time reserve at all, so I didn‚Äôt even consider these options. </p><br><p>  Here is what I did: </p><br><p>  I drove a few games with a modified bot, in which, when searching for the trajectory, I saved data about myself and the ball, as well as the flag of whether the trajectory at which I intercepted the ball was found. </p><br><p>  I considered all coordinates relative to a football player.  Those.  I always had it in the coordinate [0,0,0], so I saved only 10 fields: the relative position of the ball, the velocity vector of the ball, the velocity vector of the soccer player, the binary flag of interception.  I saved dataset only for the central part of the field, since  I understood that simple algorithms would not pull the registration of boards either. </p><br><p>  Then I fed this dataset to a DecisionTreeClassifier with max_depth = 7. The trained tree gave an accuracy, as I recall, of the order of 90%. </p><br><p>  Next, I exported the tree to a set of if-s (which DecisionTree is essentially). </p><br><p>  It looked something like this: </p><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">predict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dude_vel_x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dude_vel_y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dude_vel_z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ball_rel_pos_x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ball_rel_pos_y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ball_rel_pos_z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ball_vel_x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ball_vel_y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ball_vel_z)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ball_vel_z &lt;= <span class="hljs-number"><span class="hljs-number">6.4765448570251465</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dude_vel_y &lt;= -<span class="hljs-number"><span class="hljs-number">6.087389945983887</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ball_vel_z &lt;= -<span class="hljs-number"><span class="hljs-number">20.188323974609375</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dude_vel_x &lt;= <span class="hljs-number"><span class="hljs-number">13.032730102539062</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ball_rel_pos_y &lt;= -<span class="hljs-number"><span class="hljs-number">1.1829500198364258</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ball_vel_y &lt;= <span class="hljs-number"><span class="hljs-number">18.906089782714844</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ............................</span></span></code> </pre> <br><p>  At this stage, I drove the tests, did not see the improvement, and postponed the proceedings until later, which, because of my adventures, did not come. </p><br><h3 id="shryodinbag">  Shredinbag </h3><br><p>  Somewhere after the first round I caught this rare animal. </p><br><p>  Who does not know, this is a bug that is found only by reading the code, and having found it, the developer wonders how the program could work at all.  And in my case, she also kept in the top 10. </p><br><p>  In general, the bug was that a constructor was called in the gene copy function, in which an optional argument was passed that contains the value of this gene.  In the absence of this argument, the value was chosen randomly.  Thus, when trying to copy a gene, instead of a copy, it created a new random sample. </p><br><p>  In fact, instead of genetics, I had a random search, since each tick simply generated several hundred random trajectories and selected the best one. </p><br><p>  After the correction (consisting in adding 2 characters to the code), it became about 3 times better to play. </p><br><h3 id="ritualnye-tancy">  Ritual dances </h3><br><p>  At some point in time, I noticed that the players sometimes bounce without a reason, being far from the ball, despite the penalty. </p><br><p>  The explanation turned out to be such that I counted the moment of the jump with an accuracy of 100 microtics.  And sometimes it turned out that just at the time of the jump there was a collision of a ball with a barbell.  And depending on the accuracy of the calculation in this particular tick, the intended trajectory either led to a goal or not. </p><br><p>  Roughly speaking, the ball flies to the gates of the enemy and hits the post.  my footballer, running at the other end of the field, simulates a trajectory without a jump (with 1 micro tip) and sees that the ball misses the goal. </p><br><p>  Then another trajectory comes across, with a jump exactly at the moment of hitting the ball against the bar.  And since a tick with a jump, I consider with an accuracy of 100 microtics, not only for a football player, but also for a ball, the calculated angle of the ball‚Äôs rebound differs from the angle obtained in the 1-microtic trajectory, and it may happen that the ball in this more accurate trajectory falls into goal. </p><br><p>  Consequently, this particular trajectory will be chosen and the bot will jump. </p><br><p>  In general, by performing a ritual dance with jumping, the players scored a goal :) </p><br><h3 id="killer-ficha">  Killer feature </h3><br><p>  She's not </p><br><h3 id="testirovanie">  Testing </h3><br><p>  I drove endless games in 8 streams (4 on a computer and on a laptop).  The number of games was chosen so that it was statistically significant. </p><br><p>  With a significant improvement strategy could be satisfied with half a thousand heads in the amount <br>  with smaller edits, left overnight and then the bill went into the thousands. </p><br><h3 id="geneticheskiy-podbor-konstant">  Genetic selection of constants </h3><br><p>  I tried before the first round.  Nothing really gave for the reason that for genetics you need to play a tournament from a large number of games. </p><br><p>  I tried to play games of 100,000 ticks, but this was not enough.  With a small difference in strength (and usually this is the case when selecting constants), for 100k ticks the winner depends too much on the case.  You need to play much more to be sure of the winner.  And I could not afford to leave the selection for a day or more, so I refused this idea. </p><br><h1 id="v-zaklyuchenie">  Finally </h1><br><p>  Traditional thanks to the organizers.  The task was interesting.  It is a pity that I just had to miss almost half of the championship and really did not do anything for nitro or for three players. </p><br><p>  As a result, I watched to the very end in the sandbox how my strategy wins in 2x2 mode without nitro with a score of 13: 2 for some Mr.Smile, who finished 3rd in the final, and after a few games loses to him 12: 2 in 3x3 mode with nitro :) </p><br><p>  And of course, the video from my samopny visualizer: </p><br><p> <a href="https://www.youtube.com/watch%3Fv%3Dn0vzPXpn4Vk"><img src="https://habrastorage.org/webt/kh/hx/om/khhxombmg6eo4otune-_vdhdhbu.jpeg"></a> </p><br><p>  Only probably have to say goodbye to this visualizer in future championships. <br>  For each time more and more convinced that if you claim to normal places, the only option is to write on ... </p><br><p><img src="https://habrastorage.org/webt/gl/zj/1w/glzj1w_lztl_mhea9rqbs9rb5qq.jpeg"></p><br><p>  ... well, you understand. </p><br><p>  Tired every time to rest on the sluggishness of Java and cut the power of the strategy to meet the allotted time. </p><br><p>  I hope someone has found something interesting or useful in my opus with an autobiographical note :) </p></div><p>Source: <a href="https://habr.com/ru/post/440574/">https://habr.com/ru/post/440574/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>