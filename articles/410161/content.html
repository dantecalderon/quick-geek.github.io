<div class="post__text post__text-html js-mediator-article">  In my <a href="https://geektimes.ru/post/295445/">first article,</a> I spoke about this family of controllers, I wrote in a dozens of people with questions about him, although this was not the topic of the article.  People categorically did not want to go to Google, speaking about the lack of information.  I was a little surprised and decided to check - in fact there is practically nothing in the Russian language for the C2000 family (against the background of AVR, STM), and most importantly there are no understandable starting guides.  Information can be found in English, but again it is not enough.  For me, this is somewhat surprising, given that this family of years is not enough.  Therefore, it was decided to the best of my ability to influence the situation. <br><br>  Who needs these controllers in principle ... Do you want to assemble a welding inverter for yourself?  Uninterrupted power supply unit?  Rectifier for galvanic bath?  Chastotnik?  Inverter for alternative energy?  CNC machine?  If at least one item is about you, then the article is dedicated to you! <br><br>  Other readers will also be interested to know about the "new-old" controller, why it is needed and how to work with it.  This family is very simple (much simpler than STM, LPC and other Cortexes), it is easy to buy stones (Ali also exists), they make it possible to implement highly reliable industrial solutions, you can build almost any industrial control system on their basis. <br><br>  You have already decided that this controller is your dream and are ready to rush into battle?  Then buy for $ 17 just such a debugging of the F28027-LaunchPad: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ed/cd/cv/edcdcvjwp5ewu_jl0jbnwwzsfyc.png"></div><br>  Bought?  Now you can and fight.  If the question arose where to buy "better" and "cheaper", then go to the official store.  Go <a href="http://www.ti.com/tool/launchxl-f28027%3FkeyMatch%3Dtms320f28027%2520launchpad%26tisearch%3DSearch-EN-Everything">here</a> and see the price tag of $ 17.  For this amount you will receive the original debug board and delivery by courier to the door.  I ordered once in China for delivery, it was $ 16 and it’s with a discount and a coupon, as well as a “bonus” trip to the post office.  Therefore, I recommend it official.  Go! <br><a name="habracut"></a><br><h2>  C2000 Series Review </h2><br>  You can read more about everything on the <a href="http://www.ti.com/microcontrollers/c2000-performance-mcus/real-time-control/overview.html%3FkeyMatch%3Dtms320%2520c2000%26tisearch%3DSearch-EN-Everything">official website</a> , of course in English.  I will briefly talk about it and express my thoughts about the application.  Please note that this is only my conjecture and they do not pretend to the truth. <br><br>  First, a few words about the C2000 in general.  The distinctive features of the family, which are related to its main purpose of motor control, is the presence of HRPWM (high-precision PWM) and CLA (coprocessor).  The last one is absent in the youngest Piccolo TMS320F2802x, but it is not needed there, the main thing is that HRPWM is in place.  What is it ... Actually HRPWM is a normal PWM, only very accurate and the time of recording and installation of the new fill factor is noticeably faster.  This allows you to get, for example, a different sine shape in a DC / AC inverter or with very high accuracy to control stepper motors in a CNC machine. <br><br>  CLA is essentially a full-fledged core, only it does not have access to the periphery, only to the main core and memory.  It serves to unload the main core from the calculations.  Very easily and naturally, this coprocessor digests the data float, which is important when implementing various algorithms, filters and other things. <br><br><img src="https://habrastorage.org/webt/5o/ui/lh/5ouilh691kdhoflkcrtcs4tmwqy.png"><br><br>  I will talk about the two main families that you will likely encounter: <br><br><ul><li>  <b>Piccolo.</b>  The youngest controllers, but also the cheapest.  My TMS320F28027 is from this family.  If you decide to develop power electronics for commercial purposes, then these will be your main stones - they are quite cheap, easy to use (LQFP, QFN, TSSOP) and allow you to implement almost everything.  For example, their performance is enough for a two-phase PFC, an inverter for solar panels, a frequency converter up to 10 kW with vector control, etc.  As you can see, this is the segment of products that both ordinary people and enterprises buy, which means it is very much in demand.  The main limitations are the frequency of 60 MHz, a limited number of PWM channels. </li><li>  <b>Delfino.</b>  Ideologically, these are all the same Piccolo, only inflated with meldonium.  What does this mean - the frequency is up to 200 MHz, in the older stones there are already 2 full cores + 2 co-processors, large bodies and, correspondingly, many legs, many PWM channels, many ADCs and a whole lot in general.  That is, in the older stones, we have 4 cores with a frequency of 200 MHz, the performance is 800 MIPS, which is quite impressive.  This power can be used in different ways, but the main application is algorithmically complex systems, for example, the rectifier "Vienne" or something.  Also on one such controller, you can implement the entire control system for a CNC machine, for example, milling or gas-flame cutting of metal. </li></ul><br><h2>  Debug card upgrade </h2><br>  When you get a box with a debug board, you will find the missing quartz and capacitors to it.  They are not necessary, but it is desirable to solder.  Kvartsev in the case of the HC-49 I have not found, so I had to borrow from a friend.  He picks up the AVR and STM, so he only found 8 MHz.  Sealed.  22 pF capacitors added according to the old memory, it seemed to do so on megas at school. <br><br>  This solution is not the best and is connected with the PLL setting.  The maximum multiplier for the PLL is x12 (it can be more, but not recommended and it works crookedly).  The maximum frequency is 60 MHz.  The maximum value of the divider at the PLL output is 3. The frequency of the quartz is 8 MHz.  I can not multiply by 8 by an integer and get 60. We are looking for the closest overall value, in this case it is 240. That is, multiplying 8 by 30, and then dividing by 4 I will get the cherished 60 MHz, but then the trouble is x30 PLL multiplier is not allowed , divider / 4 is also unavailable.  There are 2 ways out: <br><br><ul><li>  <b>Bad:</b> 8 MHz frequency multiplied by 7 and divided by 1 and we get 56 MHz.  You can multiply by 8 and get 64 MHz, it will work stably, but in both cases the frequency is not a maximum of 60 MHz.  Not enough perfectionism, alas.  I have just such an option, soldered 8 MHz and made a frequency of 56 MHz. </li><li>  <b>Good:</b> go buy a quartz by 10 or 20 MHz (better than 10) and multiply by 6, and divide by 1, we get the cherished 60 MHz.  I live outside the city and honestly I was too lazy to go to a local store, which is not a fact that there are quartz at 10 MHz.  Of course, the internal RC circuit and quartz at 8 MHz will also go for training, but in your future projects, put quartz at 10 MHz, only non-mammoth mutants in the HC-49 package. </li></ul><br><h2>  Architecture and Peripheral Features </h2><br>  Everything that will happen next refers to the controller TMS320F28027.  To begin, let's just look at the structure that is taken from the <a href="http://www.ti.com/lit/ds/symlink/tms320f28027.pdf">datasheet</a> : <br><br> <a href=""><img src="https://habrastorage.org/webt/sr/da/hb/srdahbswvkrs9zjzbnvevwgqvho.png"></a> <br><br>  The first thing you should pay attention to is that RAM is divided into 3 sectors: M0, M1 and SARAM.  The volumes of these memory sectors in our case are 1k, 1k and 4k.  It is worth noting that in this case the word is not 8 bit, but 16 bit, that is, in a more familiar form, this is 2 kByte + 2 kByte + 8 kByte.  The peculiarity of this module is that the M0 and M1 sectors are more nimble than the remaining 8 KB of RAM.  Formally, you can take it as a cache.  In sectors M0 and M1 usually store the most frequently used data, as well as data that is most critical to memory performance.  By default, we can specify with the help of the linker what is stored where, but I will not raise this topic in this article, here a separate article is needed as a minimum. <br><br>  The second important feature is that all the peripherals are clocked from the system bus, that is, from 60 MHz (in my case 56 MHz).  As an example, I will give the STM32 microcontrollers, where the core frequency is, for example, 180 MHz for F4, but the periphery is clocked through a number of dividers.  For myself, I call this approach “fake megahertz,” although this is quite exaggerated.  Therefore, 60 MHz for TMS320F28 and 180 MHz for stm32 are not that different, and if we recall the presence of CLA, then 60 + 60 MHz is at least comparable.  It is clear that such a comparison is not correct, but it clearly makes it clear that not only megahertz are full. <br><br>  Just an interesting point - pay attention to the general structure: HRPWM, ADC, comparators with an internal DAC, encoder processing module (eCAP) ... Ready-made frequency converter with vector control in its pure form!  This is the essence of this family - minimalism.  On the one hand, the periphery is rather poor against the background of Cortex, but on the other hand it is sufficient to implement both the frequency counter, dc / dc, and dc / ac, and the driver of the stepping motor.  Due to this, working with TMS320F28 controllers is very simple, understandable and not overloaded with unnecessary actions.  But if you suddenly need 3 UARTs, and for them a pair of i2c and 3 more SPIs, then these controllers are definitely not for you - they have different tasks. <br><br><h2>  Environment and Development Environment </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5v/vc/iv/5vvcivdcbwzulr9uocxmccv-ba0.png"></div><br>  Seeing the splash logo?  Remember her.  If you decide to start using in the development of the article’s heroes, then this software is yours, and as you can see, as you can see, <b>controlSUITE</b> . <br><br>  This application is a collection and library of all that is needed for software development for the C2000 family of controllers.  Installing this application is the first thing to do and see its composition, it contains: <br><br><ul><li>  A description of all existing controllers and debug boards based on them.  Source schemes, printed circuit boards, BOMs, mainly in Altium Designer </li><li>  Examples of circuit design and design of printed circuit boards </li><li>  Main libraries for firmware development </li><li>  Mathematics and DSP Libraries, including for use with CLA </li><li>  Example of software projects for each type of peripherals </li><li>  A large number of apnotes for the implementation of most engine control algorithms, dc / dc converters, MPPT controllers and other systems </li><li>  A set of programs that allow you to create an engine management system without programming at all, simply using a graphical environment </li><li>  IDE itself in which development will be carried out </li></ul><br>  All that I have described above is very brief and modest.  It will take a couple of weeks for you to browse and scroll through everything at least diagonally.  Of course, most of this amount of data at the start you do not need, but you need to remember where to go, if something is not clear to you and wonder. <br><br>  Now what we will work with today is the IDE, the graphic part of which is based on the well-known Eclipse.  The compiler is not GCC, but its own from Texas, which in my subjective opinion is definitely better than the first.  Although there are suspicions that it is thoroughly doped all the same gcc.  The development environment is called <b>Code Composer Studio</b> , the current version 7.4. <br><br><h2>  Project creation </h2><br>  At first, I wanted to implement a task identical to the first article, that is, to draw a sine.  In principle, within the framework of a single article, this could be done, leaving a very large amount of trifles behind the scenes, but as you know, the essence is just in trifles.  There are several articles on TMS on the Internet, but all of them are very superficial and boil down to the form “we copy it and it all works”, that is, the process and ideology are not considered at all.  Therefore, within the framework of this article we will create a project, clean it of unnecessary components, set up the firmware in the controller's flash memory and learn how to work with the GPIO, and they are very interesting here. <br><br>  Download CCS7 from the manufacturer’s website, install and proceed to create the project in the usual way: <i>File → New → CCS Project ...</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wb/v0/jy/wbv0jyccatp8jysn2nckh7qaooc.png"></div><br>  We see this window and in it we need to select the controller we are interested in, in my case it is TMS320F28027, specify the name of the project and set the path where it will be stored.  First you need to create a folder where the project will be stored.  The project name and the folder name may not match.  Click the <i>Finish</i> button and our project is created. <br><br>  Now you need to fill our project content and connect it.  Before this, to improve the structure of the project, we create a set of folders like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ee/cg/er/eecgerskm0jeso2ocebvaheeyrc.png"></div><br><ul><li>  <i>inc</i> - a folder that contains all the header files </li><li>  <i>system_inc</i> - this subsection will store the header files of standard libraries, the files that we ourselves will create, for example, main.c are located in the inc folder.  This will not break something mindless or remove excess </li><li>  <i>src</i> - folder with all sources </li><li>  <i>system_src</i> - folder with source files for standard libraries </li></ul><br>  Please note that this structure is not some kind of dogma, but is only my idea of ​​orderliness.  Although I still recommend it to people with minimal experience, over time you will change it to fit your worldview, but for now it minimizes the number of jambs. <br><br>  Now we create a main.h file in the inc folder and connect it to main.c.  Through it there will be connections of base libraries.  And before starting to transfer libraries and other files, let's set the paths to the folders where our future header files will be stored in the project settings.  To do this, in the project tree, right-click on the project (Test) and at the very bottom click <i>Properties</i> or simply press <i>Alt + Enter</i> .  In the opened window, go to <i>Build → C2000 Compiler → Include Options</i> and here we need to go to the two existing paths - set the path to the inc and system_inc folders.  Click <i>Add</i> , then <i>Workspace</i> and then to the desired folder inc, then do the same and cling to the second folder.  Thus, we prescribed relative paths, and we don’t have to reconfigure anything during project transfer.  As a result, we get this picture and click <i>Ok</i> : <br><br><img src="https://habrastorage.org/webt/2x/nd/ql/2xndqlhcm5szyalytbw6oeseyka.png"><br><br>  Now we have an empty project with prescribed paths and other settings, it remains only to fill it with libraries.  The only thing that needs to be done is to check whether everything is connected.  In theory, you should have such a code and a picture, compile the project.  To do this, press <i>CTRL + B</i> or at the top go to <i>Project → Build All</i> .  The project should compile without errors and look like this (the image is clickable): <br><br> <a href=""><img src="https://habrastorage.org/webt/0b/hv/ur/0bhvurabfuhr1-6lqjgzn4svzp0.png"></a> <br><br>  Now let's talk a little about linker.  Initially, when creating an IDE project, it generates the file <i>28027_RAM_lnk.cmd</i> , it places our program in RAM in the process of debugging and flashing.  This is useful when we are debugging, because  flash memory resources are not wasted, and debugging in RAM is significantly faster.  But what if we want to sew into a flash?  For this there is another link file, which will place our program in the flash.  I will show this option. <br><br>  First we delete the file <i>28027_RAM_lnk.cmd</i> .  As I said before - our <b>controlSUITE</b> is everything.  Open it.  Now we go <i>English → Device → Piccolo F2802x → Supporting Libraries → Header Files for F28027x</i> .  On the right we see the folders - these are the standard libraries and everything you need, including linkers.  Now we go to the folder <i>f2802x_common → cmd</i> and here we see a set of linkers for all the stones of the ruler.  As it is not difficult to guess the _RAM files for filling the code into the RAM, and without this tag for filling the flash.  Take the file <i>F28027.cmd</i> and copy to our project instead of the old remote linker. <br><br>  Now it's time to migrate the libraries themselves.  Go to the folder <i>f2802x_common → source</i> and see a bunch of files.  There are two types of libraries: standard registers (analogous to CMSIS) and some kind of SPL.  In this case, we are only interested in the first view, that is, files with the prefix <i>f2802x_</i> .  Of course, you can drag all of them into our project, but why litter it if we don't use everything?  If you need something, then in the future just add.  For now, we restrict ourselves to the following filesets: <br><br><ul><li>  <i>f2802x_codestartbranch.asm</i> </li><li>  <i>f2802x_defaultisr.c</i> </li><li>  <i>f2802x_piectrl.c</i> </li><li>  <i>f2802x_pievect.c</i> </li><li>  <i>f2802x_sysctrl.c</i> </li></ul><br>  Copy the data file and paste it into our <i>system_src</i> folder.  Now go to the folder <i>f2802x_headers → source</i> and <i>pick up the</i> file <i>F2802x_GlobalVariableDefs.c</i> from there and copy it again to our <i>system_src</i> folder.  Next, go to the folder <i>f2802x_headers → cmd</i> and copy the file <i>F2802x_Headers_nonBIOS.cmd</i> from there to the same folder.  This is where the filling of the <i>system_src</i> folder <i>is</i> complete and go to the headers. <br><br>  Go to the folder <i>f2802x_headers → include</i> and copy all the files from there to our <i>system_inc</i> folder.  Now go to the folder <i>f2802x_common → source</i> and copy the files from there: <br><br><ul><li>  <i>f2802x_examples.h</i> </li><li>  <i>f2802x_globalprototypes.h</i> </li><li>  <i>f2802x_i2c_defines.h</i> </li><li>  <i>f2802x_epwm_defines</i> </li><li>  <i>f2802x_swprioritizedisrlevels.h</i> </li><li>  <i>f2802x_defaultisr.h</i> </li></ul><br>  We should have this picture in the project tree: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jw/tu/h-/jwtuh-pssz-pn5_ynxlxugmijtw.png"></div><br>  Now you need to connect the base libraries, the file <i>main.h</i> takes the following form: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"F2802x_Device.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"F2802x_examples.h"</span></span></span></span></code> </pre> <br>  We try to compile.  If the project was compiled without errors and Warnings, then everything is properly connected.  If this does not happen, then double-check everything 10 times, and if it doesn’t work out at all, then write to ps - I will help, as Owl said: <i>“Bez-voz-mez-bottom, that is for nothing”</i> . <br><br><h2>  Starting initialization of the controller and clocking system </h2><br>  In this section, we will write a function that initializes the watchdog timer and interrupt vector, will reset interrupt flags.  We also configure the clocking system, as a result of which the external quartz, rather than the internal RC-chain, will become the clocking source, configure the PLL and enable the clocking for all peripherals. <br><br>  For code accuracy, I propose to render all the basic initializations into a separate file, whose front-end will be the <i>void InitStartSystem (void)</i> function.  To do this, create the files <i>systemInitStart.h</i> and <i>systemInitStart.c</i> .  I'll write the function right away and then just sort its contents: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitStartSystem</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ DisableDog(); XtalOscSel(); InitPll(TMS320_PLLCR, TMS320_DIVSEL); InitPeripheralClocks(); InitPieCtrl(); InitPieVectTable(); }</code> </pre><br>  All functions that are called in <i>InitStartSystem ()</i> are standard.  I advise you to see in detail how they are implemented, for this you can hold down the CTRL and click on the function of interest.  Have you looked?  Now let's take a quick run ... <br><br><ul><li>  <i>DisableDog ()</i> - the function turns off the "dog".  This is a mandatory action when setting up the main part of critical peripherals, for example, a clocking system.  In the library code you often see this, it will be duplicated and duplicated. </li><li>  <i>XtalOscSel ()</i> - this function implements switching from an internal clock source to an external quartz.  <b>An important point!</b>  There is an error in the standard library with this function - it is not declared.  Go to the file <i>f2802x_globalprototypes.h</i> and among all the other declare we add the line <i>extern void XtalOscSel (void)</i> <br><br><img src="https://habrastorage.org/webt/3l/vv/yv/3lvvyvwdfpwbqpek6bphfkheapu.png"><br><br>  <b>The second important point!</b>  Go to the XtalOscSel function and delete the delay function. <br><br><img src="https://habrastorage.org/webt/ve/iq/iw/veiqiwa2locaclbj2-xfbpiakpe.png"><br><br>  <b>The third important point!</b>  Go to the <i>f28027x_exmaples.h</i> file and comment out the delay implementation function. <br><br><img src="https://habrastorage.org/webt/t7/jk/jp/t7jkjpu3nbgcqlqt5aolaniwqxg.png"><br></li><li>  <i>InitPll (TMS320_PLLMUL, TMS320_DIVSEL)</i> - the function sets the PLL.  It transmits 2 values: a multiplier and a divisor.  Their meaning is spelled by defaults in the header file.  <b>An important point!</b>  We open this function in the library and we need to comment out the delay at the very bottom. <br><br><img src="https://habrastorage.org/webt/mg/up/gi/mgupgi_vhx8hvcvg3tgaqsxaxas.png"></li><li>  <i>InitPll (TMS320_PLLMUL, TMS320_DIVSEL)</i> - the function sets the PLL.  It transmits 2 values: a multiplier and a divisor.  Their meaning is spelled by defaults in the header file.  <b>An important point!</b>  We open this function in the library and we need to comment out the delay at the very bottom. </li><li>  <i>InitPeripheralClocks ()</i> - this function simply turns on clocking for all peripherals.  Yes, for all.  C2000 is not a solution for battery powered glands <br>  this solution for units-tens-hundreds of kilowatts and a pitiful 2-3 mA of role will not play here.  Well, you don’t need to remember every time whether you turned on clocking on some SPI or not </li><li>  <i>InitPieCtrl ()</i> - the function turns off all interrupts and resets the interrupt flags </li><li>  <i>InitPieVectTable ()</i> - the function fills the table with interrupt vectors </li></ul><br>  Actually here it is all initialization.  I think many have noticed the "important points" associated with the function of <i>Delay</i> .  Why did we cut it on the vine?  Yes, everything is simple - it's a crutch. <br><br>  TI engineers have added these completely unnecessary delays to some of the functions, added in recent updates.  Why - a mystery not only for me.  Registers and other critical entries and so protected, so it will not make our controller stupid.  By the way, when you initialize in power electronics, you can not "blunt" at all, otherwise they will be women.  Therefore, forget forever the <i>delay</i> functions and other devils, only timers!  Delays are permissible only for some training purposes, for example, to flash quickly with a LED. <br><br>  In order to make sure that the code <b>works</b> , we call the initialization function in main, compile, flash and cling to the oscilloscope on the <b>GPIO18</b> .  This output is similar to the MCO of the STM32, that is, it outputs the system frequency.  The oscilloscope should see a signal with a frequency of 56 MHz.  If the oscilloscope is good, then you will see a meander, if the Chinese (even good), then most likely it will be something closer to the sine.  Setting GPIO18 to display the system frequency can be seen in the <i>InitPeripheralClocks ()</i> function.  First you need to "connect" gpio to the output frequency, and then set the divider equal to 1: <br><br><pre> <code class="cpp hljs"> GpioCtrlRegs.GPAMUX2.bit.GPIO18 = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">// GPIO18 = XCLKOUT SysCtrlRegs.XCLK.bit.XCLKOUTDIV=2; // Set XCLKOUT = SYSCLKOUT/1</span></span></code> </pre><br><h2>  GPIO setup </h2><br>  To work with this family, we need only a reference manual, which the developers at TI have divided into several files, each of which describes a certain periphery, which is very convenient.  Download the datasheet <a href="http://www.ti.com/lit/ds/symlink/tms320f28020.pdf">here</a> and go to the <i>Documentation Support</i> section on page 126. Here we see a set of links to documentation with its brief description: errata, a guide for starting engine management and guides on each periphery.  We are interested in a document called <b>TMS320F2802x / TMS320F2802xx Piccolo System Control and Interrupts Reference Guide</b> , which contains the description of the GPIO and other basic system settings that we are interested in.  We look at the block diagram of GPIO: <br><br> <a href=""><img src="https://habrastorage.org/webt/vp/uu/29/vpuu29qhryyngpm2thgtvtquoeo.png"></a> <br><br>  We see a fairly familiar picture of the device I / O ports.  Here and the ability to enable internal suspenders, and the use of a signal with GPIO for interrupts and other amenities.  The main feature of this periphery in the C2000 is the possibility of hardware interference suppression, for example, the bounce of mechanical button contacts.  Let's look at an interesting diagram: <br><br><img src="https://habrastorage.org/webt/gu/zj/ym/guzjymm5gq08m1gar1284zobjx8.png"><br><br>  It shows the principle of reading the status of inputs.  In most controllers, the input state is read at the clocking frequency of this peripheral, that is, by default, with a frequency of 56 MHz in our case, and for the same stm in the older families, these frequencies are even higher.  I think everyone understands that at this frequency the controller has time to "see" any interference and noise.  Sometimes this frequency is needed, and sometimes not, for example, if we need to poll a button.  Why do we need to poll her every 18 ns?  Therefore, we implemented the possibility of decreasing the clocking frequency of a specific port using the <i>CTRL</i> register and <i>QUALPRDx</i> bits, where X takes a value from 0 to 3: QUALPRD0 is responsible for GPIO0 ... 7, QUALPRD1 is responsible for GPIO8 ... 15 and so on.  In fact, this is a common frequency divider with a ratio from 1 to 510. <br><br><img src="https://habrastorage.org/webt/a5/ro/9e/a5ro9eq9hvvmomonnkm8ggkxzcq.png"><br><br>  It often makes no sense to poll the button, so we will tune the divider to 510, that is, to the maximum.  We look again at the diagram and see that the signal is considered steady only when its level was unchanged at 6 cycles.  The number of cycles required for fixing can be 1, 3, or 6. <b>The larger the divider and the more cycles we fix, the more stable the bounce protection operation will be.</b>  When there will be a bounce of contacts, then at first it will be chaotic transitions from 0 to 1 and back, when the bounce will pass and the signal will stop and will not change for 6 cycles, this will mean that the button is pressed.  All ingenious is simple. <br><br>  Now let's consider the main registers, we will not affect interruptions - only the settings of the ports themselves.  First you need to say that the registers are divided into 2 types: <b>configuration</b> <b>registers</b> and <b>data registers</b> .  The former are responsible for the configuration of properties, for example, input or output.  The second group is responsible for recording and reading the state of the port. <br><br>  <u>Configuration registers:</u> <br><br><ul><li>  <i>GPxCTRL</i> is a register for writing a clock divider.  Instead of “x” we substitute the letter “A” - if we have GPIO0 ... 31, “B” - if we use GPIO32 ... 63 and so on </li><li>  <i>GPAQSELx</i> - register for setting the number of ticks for fixing the input value </li><li>  <i>GPAMUX1</i> is a register for selecting connected peripherals, for example, it indicates that a GPIO or UART is coming on its foot, or maybe PWM. </li><li>  <i>GPADIR</i> - register of the choice of the direction of work of GPIO: input or output  By default, all ports are configured to log on. </li><li>  <i>GPAPUD</i> is the register responsible for connecting the internal braces to the VCC. <br>  It is worth noting that by default some ports have their braces turned off, while others are on. <br>  This is important to remember! </li></ul><br>  <u>Data registers:</u> <br><br><ul><li>  <i>GPADAT</i> - output status register.  If the output is configured for input, then we read the input status from it.  If it is configured to exit, then we can write the value that this output should take, that is, 0 or 1 </li><li>  <i>GPASET</i> is the output setting register in “1”.  To set to “1”, it is necessary to write “1”, while recording “0” the command is ignored. </li><li>  <i>GPACLEAR</i> - output setting register to “0”.  To set to "0", you must write "1", when writing "0", the command is ignored </li><li>  <i>GPATOGGLE</i> is a register that inverts the current value of the output state.  To invert the value, you must write "1", when writing "0" the command is ignored </li></ul><br>  Here is such a simple set of registers.  Even from the description above, it is already possible to understand what needs to be done to configure the port, but prudent engineers or technical writers from TI have made step-by-step instructions: <br><br><img src="https://habrastorage.org/webt/ly/tx/mk/lytxmkk_nwnp8qzigdzblyywwx8.png"><br><br>  I will say right away that steps 6 and 7 are not needed for us, because  Neither the dog nor the interruption, we do not use in this article.  I will describe the rest of the steps briefly for people who learned German at school: <br><br><ul><li>  <i>Step 1</i> - we define the output functionality: that it will be an input or output, <br>  gpio or other output peripherals and other </li><li>  <i>Step 2</i> - enable or disable the internal power supply tightening </li><li>  <i>Step 3</i> - we configure clocking and bounce protection for a specific port </li><li>  <i>Step 4</i> - choose the desired function: gpio or peripherals </li><li>  <i>Step 5</i> - customize the direction of the output: input or output </li></ul><br>  That's the whole setup, as you can see it is elementary and logically understandable.  At once I want to note that it is not necessary in this order to make adjustments, for example, you can adjust the direction (input or output) in the very first step.  It does not matter. <br><br>  <b>Super important!</b> <br><br>  When working with registers in the C2000 family, it is necessary to take into account the moment that they are protected.  Everything described further concerns mainly the registers of the setting group.  If you carefully watched the standard functions, you probably saw some strange commands there: <b>EALLOW;</b>  and <b>EDIS;</b>  .  <i>EALLOW</i> command - removes protection and opens access to work with system registers.  The <i>EDIS</i> command enables back protection and opens access to work with system registers.  That is, any work with system registers should ALWAYS look like this: <br><br><pre> <code class="cpp hljs">EALLOW; <span class="hljs-comment"><span class="hljs-comment">// Работаем с системными регистрами, меняем их значения, настраиваем EDIS;</span></span></code> </pre><br>  Such an operation is not required if we work with data registers, for example, if we set our output to “1” with the help of the <i>GPxSET</i> register, then we don’t have to remove protection from it and switch it back on accordingly.  The documentation says everywhere that you need to protect and what does not, for example, like this: <br><br><img src="https://habrastorage.org/webt/ly/tx/mk/lytxmkk_nwnp8qzigdzblyywwx8.png"><br><br>  Based on all the above, let's configure GPIO0 ... 3 with LEDs on the output.  I propose to put all the GPIO settings into the <i>InitLEDgpio</i> function and write it: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitLEDgpio</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ EALLOW; GpioCtrlRegs.GPADIR.bit.GPIO0 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO2 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO3 = <span class="hljs-number"><span class="hljs-number">1</span></span>; EDIS; }</code> </pre><br>  By default, our GPIOs are already configured as GPIOs, since  all register values ​​are cleared, which means that "0" is already written to the GPAMUX1 register.  For GPIO0 ... 11, the suspender is disabled by default, so we can only take and determine the direction of work on the exit using GPADIR.  If you remember, the LEDs are connected to the controller by cathodes, which means that immediately after initialization they will glow.  Let's right in the initialization function, we will configure these outputs to “1”: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitLEDgpio</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ EALLOW; GpioCtrlRegs.GPADIR.bit.GPIO0 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO2 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO3 = <span class="hljs-number"><span class="hljs-number">1</span></span>; EDIS; GpioDataRegs.GPASET.bit.GPIO0 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioDataRegs.GPASET.bit.GPIO1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioDataRegs.GPASET.bit.GPIO2 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioDataRegs.GPASET.bit.GPIO3 = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, I do not use the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPADAT</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> register </font><font style="vertical-align: inherit;">for recording, but I use </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET, CLEAR, TOGGLE</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Also note that I made this entry outside the protected zone, that is, after the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EDIS</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> command </font><font style="vertical-align: inherit;">. Now in the same function, configure GPIO12 to work with the button and add our function:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitLEDgpio</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ EALLOW; GpioCtrlRegs.GPADIR.bit.GPIO0 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO2 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO3 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPAPUD.bit.GPIO12 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPACTRL.bit.QUALPRD1 = <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; GpioCtrlRegs.GPAQSEL1.bit.GPIO12 = <span class="hljs-number"><span class="hljs-number">2</span></span>; EDIS; GpioDataRegs.GPASET.bit.GPIO0 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioDataRegs.GPASET.bit.GPIO1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioDataRegs.GPASET.bit.GPIO2 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioDataRegs.GPASET.bit.GPIO3 = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First of all, I turn off the internal tightening by writing “1” to the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPAPUD</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> register </font><font style="vertical-align: inherit;">, since </font><font style="vertical-align: inherit;">it is enabled by default for GPIO12. </font><font style="vertical-align: inherit;">As I wrote earlier, all the ports after initialization are configured for input, since </font><font style="vertical-align: inherit;">zeros are written </font><font style="vertical-align: inherit;">in the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPADIR</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> register; we are not setting it up here. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It remains to configure the chatter protection, for this dividers write </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFF</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which corresponds to the value / 510. </font><font style="vertical-align: inherit;">In the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPAQSEL1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> register </font><i><font style="vertical-align: inherit;">,</font></i><font style="vertical-align: inherit;"> write the value “10” or 2, which will set the value to a sample of 6 cycles.</font></font> Done!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order to read the value of a specific input, you just need to read the value from the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPADAT</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> register </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GpioDataRegs.GPADAT.bit.GPIO12) { <span class="hljs-comment"><span class="hljs-comment">// Если кнопка нажата и подает +3.3В (лог. 1) на вход, то выполняем данные действия }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is how we interview the necessary conclusions. </font><font style="vertical-align: inherit;">Now let's call the gpio configuration function in our main function and get its final look:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitStartSystem</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ DisableDog(); XtalOscSel(); InitPll(TMS320_PLLMUL, TMS320_DIVSEL); InitPeripheralClocks(); InitPieCtrl(); InitPieVectTable(); <span class="hljs-comment"><span class="hljs-comment">/*********************************/</span></span> InitLEDgpio(); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we call the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitStartSystem</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">in the main program body in main and this completes the setting. </font><font style="vertical-align: inherit;">We get the following code:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main (void) { InitStartSystem(); while(1) { } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is time to write our first test program and check the whole thing. </font><font style="vertical-align: inherit;">The algorithm is as follows: the LED that is sitting on GPIO3 blinks, and when you press a button on GPIO12, we simply light the GPIO0 LED. </font><font style="vertical-align: inherit;">In this way, we will check the operation of the ports both at the entrance and at the exit. </font><font style="vertical-align: inherit;">We write the following code:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main (void) { InitStartSystem(); while(1) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (GpioDataRegs.GPADAT.bit.GPIO12) { GpioDataRegs.GPACLEAR.bit.GPIO0 = 1; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { GpioDataRegs.GPASET.bit.GPIO0 = 1; } GpioDataRegs.GPATOGGLE.bit.GPIO3 = 1; delay(100000); } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We compile, go to the debugger, launch it and see how one LED blinks constantly, and when the button is pressed another one lights up. </font><font style="vertical-align: inherit;">At the end of the section I will attach a project with this code, if something does not work out, then look into it. </font><font style="vertical-align: inherit;">Especially for those who are hard on texts or understood not all moments, I propose to watch this video for working with GPIO, everything happens there too, as in the “GPIO” section. </font><font style="vertical-align: inherit;">I warn you that the video for an hour, dreary, long, but as much as possible and everything is clear:</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/jlyVy73pa98" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Files from the article </font></font></h2><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Archive with the project for CCS7 download </font></font><a href="https://drive.google.com/open%3Fid%3D1odQL7oE5h4x4iVFxhywkpkLDtQtiqZdW"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can see the code on </font></font><a href="https://github.com/Nordic-Energy/TMS320-Lesson/tree/master/Lesson4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a> </li></ul><br><h2>  Total </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At this stage, I finish today's article. I think you understand that if I decided to immediately show the implementation of a DC / AC inverter, then the volume of the article would be several times larger, or many important little things would be left behind the scenes, which in my opinion is unacceptable. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I hope my article will help everyone to start mastering this family of controllers and begin development in the field of power electronics and machine tools. In the future I will probably write something else on this topic, for example, I would like to consider working with PWM or implement some kind of algorithm. The main thing is to have time. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you still have any questions or something does not work out for you, then you can write me in private messages and I will try to answer your questions and provide all possible assistance in studying. Successes you in learning!</font></font><br><br>  <b>UPD.</b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thanks for the tip from </font></font><a href="https://habr.com/users/belerafonl/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BelerafonL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to the book </font></font><a href="http://padabum.com/d.php%3Fid%3D96921"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Embedded high-performance digital control systems"</font></font></a> </div>