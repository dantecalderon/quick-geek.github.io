<div class="post__text post__text-html js-mediator-article">  Many developers believe that Auto Layout is a brake and problem thing, and it is extremely difficult to debug it.  And it’s good if this conclusion is made on the basis of my own experience, and sometimes it happens simply “I heard, I won’t even try to make friends with it.” <br><br>  But perhaps the reason is not outside, but inside.  For example, the world's most dangerous birds will not attack people for no reason, just for the sake of self-defense.  Therefore, try for a second to assume that this is not Auto Layout is bad, and you do not understand it well enough and do not know how to cook.  So did Anton Sergeyev and dive into the theory in order to understand everything precisely.  We are offered a finished squeeze about the mathematical foundations of Auto Layout. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xm/53/dw/xm53dwqnl0lczpswansphdrgbpi.png" width="360"></div><br><br><a name="habracut"></a><br>  Auto Layout is a <strong>layout system</strong> .  Before delving into it, let's talk about modern layout in general.  Then we will deal with <strong>Auto Layout</strong> - let's figure out <strong>what problem it solves</strong> and how it does it.  Consider the <strong>features in the implementation of Auto Layout in iOS</strong> , and try to develop <strong>practical tips</strong> that can help you work with it. <br><br>  This story will be very close to a mathematical article, so we first agree on the notation in order to speak the same language. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/-eGciYD9i3I" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>About the speaker:</strong> Anton Sergeev ( <a href="https://habr.com/ru/users/antonsergeev88/" class="user_link">antonsergeev88</a> ) works in the Yandex.Maps team, deals with a mobile client for Maps on iOS.  Prior to mobile development, he was in charge of power plant control systems, where the price of errors in the code is too high to be tolerated. <br><br><h2>  Legend <br></h2><br>  Systems of linear equations are familiar to us from school — indicated by a curly bracket, and their solution is already without.  Also, systems of linear equations have entities with which Auto Layout operates - restrictions.  Denoted by a straight line. <br><br><img src="https://habrastorage.org/webt/ql/qb/sa/qlqbsasmt7hb37gbgal6han6-4c.png"><br><br>  A strange and, as we already know, dangerous bird is not accidentally drawn in the upper corner of the slide.  In honor of the cassowary (lat. Cassowary), which, of course, lives in Australia, an algorithm is named in all our iPhones. <br><br>  In Auto Layout there are limitations, we will designate them with colors in order of priority: red - required;  yellow - high;  blue - low. <br><br><h2>  Layout <br></h2><br>  When I made the presentation, I had various elements on the screen, for example, cassowary.  To do this, I determined that the cazuar is a rectangular picture.  You need to place it on a sheet that has axes and its coordinate system, and for this I determined the coordinates of the upper left corner, width and height. <br><br><img src="https://habrastorage.org/webt/5s/rq/ci/5srqci-zsre1tg_nbnn3grczdno.png"><br><br>  Knowing these four values ​​is enough to present any View. <br><br><h3>  Algorithm number 1 <br></h3><br>  While we had cassowary on a sheet, we unobtrusively described the first layout algorithm: <br><br><ul><li>  determine the coordinates and sizes; </li><li>  apply them to a UIView. </li></ul><br>  The algorithm works, but is rather complicated to use, so we will further simplify it. <br><br>  Suppose that below - the solution of some system of linear equations. <br><br><img src="https://habrastorage.org/webt/ca/6i/ab/ca6iabqohj0bqr1rmujisor9fv4.png"><br><br>  The system of linear equations is special in that a mass of operations is defined above it: folding the lines, multiplying them by constants, etc.  These operations are called linear transformations, and with their help the system is reduced to an arbitrary form. <br><br>  The beauty of linear transformations is that they are reversible.  This brings us to an interesting and rather subtle idea, from which the whole modern layout begins. <br><br>  Let there is a View - a rectangle with its own coordinates and size.  We want to arrange it so that the center coincides with the given point.  We will model the center using linear transformations - the <strong>coordinate of the upper left corner + half the width</strong> . <br><br><img src="https://habrastorage.org/webt/yg/el/ic/ygelic6e5xa6orhvnaz7g5p_cki.png"><br><br>  We modeled the center by a linear transformation, it was not there: there were only the coordinates of the left upper point, the width and height. <br><br>  Similarly, you can simulate any other indents, for example, 20 points from the right corner. <br><br><blockquote>  It is the idea of ​​linear transformations that allows us to create different typesetting systems. <br></blockquote><br>  Consider an elementary example.  We write out a system with which we establish the coordinates of the middle and right side, the width and the ratio between width and height.  We solve the system and get an answer. <br><br><img src="https://habrastorage.org/webt/hc/xc/hu/hcxchuyy2qvuvati_laj8afryig.png"><br><br>  So we come to the second algorithm. <br><br><h3>  Algorithm number 2 <br></h3><br>  The second iteration of the algorithm consists of the following items: <br><br><ul><li>  draw up a system of linear equations; </li><li>  we solve it; </li><li>  apply the solution to a UIView. </li></ul><br>  Imagine that we were in the twentieth century, at a time when computer technology was just emerging, and were the first to reach the creation of our typesetting system.  Invented, packed, given to the user, and he begins to use it - fills in the initial parameters and transmits to our system. <br><br><img src="https://habrastorage.org/webt/8b/np/wk/8bnpwkt2ufktqh1wa7dtumctozs.png"><br><br>  A problem appears - this system does not have a single solution.  The problem is not exceptional, it is faced with absolutely all layout systems, and is called the <strong>lack of a solution</strong> . <br><br>  There are not so many ways out of this situation: <br><br><ul><li>  You can <strong>fall</strong> - this is a very common method.  Who works with MacOS, knows that NSLayoutConstraintManager does this. </li><li>  <strong>Return the default value</strong> .  In the context of the layout, we can always return all zeros. </li><li>  A more well-known and delicate way is <strong>to prevent incorrect input</strong> .  This method is used by popular typesetting systems, for example, <strong>Yoga</strong> , known as <strong>Flex Layout</strong> .  Such systems try to create an interface that will not allow incorrect input. </li><li>  There is another way to solve absolutely all problems - it is to <strong>rethink everything from the very beginning</strong> and initially <strong>prevent this problem from occurring</strong> .  Auto Layout went this way. </li></ul><br><h2>  Auto Layout.  Setting and solving the problem <br></h2><br>  We have a rectangular picture and in order to uniquely identify it, we need 4 parameters: <br><br><ul><li>  coordinates of the upper left corner; </li><li>  width and height. </li></ul><br><img src="https://habrastorage.org/webt/9k/m4/mn/9km4mnazc-bszyeglny7jgury1k.png"><br><br>  Auto Layout is very verbose.  Compared to the system of linear equations, it is much more difficult to put everything on the screen with it.  Therefore, we will consider, without losing generality, the one-dimensional case. <br><br><img src="https://habrastorage.org/webt/yy/g-/bz/yyg-bzfkdyhagrqn28bj7ruydg8.png"><br><br>  Everything is very simple: space is a straight line, and all the objects that can fit in it are points on a straight line.  One value: <strong>X = X <sub>P is</sub></strong> enough to determine the position of a point. <br><br>  Consider the Auto Layout approach.  There is a space in which restrictions are set.  The solution we want to get is <strong>X = X <sub>0</sub></strong> , and no other. <br><br>  There is a problem - we have not defined operations with restrictions.  We can not directly draw a conclusion from the record that <strong>X = X <sub>0</sub></strong> , we can not multiply anything and add with nothing.  To do this, we need to convert the constraint into what we can work with - into a system of equations and inequalities. <br><br><img src="https://habrastorage.org/webt/dc/ru/gr/dcrugrl3rwq6esfcnrlz89ora8o.png"><br><br>  Auto Layout converts the system of equations and inequalities as follows. <br><br><ul><li>  First introduces 2 additional variables that are <strong>not negative</strong> and <strong>depend on each other</strong> .  At least one of them is zero. </li><li>  The constraint itself is converted to the record <strong>X = X <sub>0</sub> + a <sup>+</sup> - a <sup>-</sup></strong> . </li></ul><br>  Point <strong>X <sub>0</sub></strong> <sub>&nbsp;</sub>  - solution of the system: if <strong>a <sup>+</sup></strong> and <strong>a <sup>-</sup></strong> are equal to zero, then this will be true.  But <strong>any other point</strong> on this line will be the solution. <br><br>  Therefore, it is necessary to find the best among all the solutions.  To do this, we introduce a functional — an ordinary function that returns a number, and we can compare numbers.  Let's draw a graph and note that the solution we initially wanted to get is the minimum. <br><br>  Got <strong>a linear programming problem</strong> .  In this way, Auto Layout comes with restrictions that are not only in the form of equalities, but also inequalities. <br><br><h3>  Inequality constraints <br></h3><br>  In the case of inequality constraints, the transformation occurs in the same way as with equations: two additional variables are introduced and everything is assembled into the system.  Only the functional is different, and it is equal to <strong>a <sup>-</sup></strong> . <br><br><img src="https://habrastorage.org/webt/su/lp/db/sulpdbiqpzdvnd2s23qwo3zg3p0.png"><br><br>  The graph above shows why this is so - any value of <strong>a <sup>+</sup></strong> with <strong>a <sup>-</sup> = 0</strong> (from <strong>X <sub>0</sub></strong> to <strong>+ ∞</strong> ) will be the optimal solution for the problem. <br><br>  Let's try to combine these two constraints of equations and inequalities into one thing - after all, the constraints do not live closed, they apply to the whole system together. <br><br><img src="https://habrastorage.org/webt/kv/p4/ed/kvp4ed32qay13--nhn6neefffd0.png"><br><br>  For each constraint, a pair of variables is additionally introduced, and a functional is composed.  Since we want all these constraints to be fulfilled simultaneously, the <strong>functional will be equal to the sum of all functionals from each constraint</strong> . <br><br>  We assemble the function f and see that the solution is <strong>X <sub>1</sub></strong> .  As we expected, making up restrictions.  So we come to the third algorithm. <br><br><h3>  Algorithm number 3 <br></h3><br>  To develop something, you need: <br><br><ul><li>  create a system of linear constraints; </li><li>  convert it to a linear programming problem; </li><li>  solve the problem by any known method, for example, by the <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B8%25D0%25BC%25D0%25BF%25D0%25BB%25D0%25B5%25D0%25BA%25D1%2581-%25D0%25BC%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4">simplex method</a> used in Auto Layout; </li><li>  apply the solution to a UIView. </li></ul><br>  It seems that this algorithm is sufficient, but consider the following case: we change the initial set of constraints so that the second constraint is now <strong>X ≥ X</strong> <strong><sub>2</sub></strong> . <br><br><img src="https://habrastorage.org/webt/li/dd/at/liddathmoov5umsnhvnoevax6jy.png"><br><br>  What solution do we expect to see? <br><br><ul><li>  <strong>X <sub>1</sub></strong> ?  Indeed, in the first constraint it is written this way: <strong>X = X <sub>1</sub></strong> , and this solution conflicts with the second constraint. </li><li>  <strong>X <sub>2</sub></strong> ?  There will be a conflict with the first limitation. </li></ul><br>  To get out of the situation, we will perform the transformations that we are already able to do. <br><br>  The graph of the new functional looks different: any point from the interval from <strong>X <sub>1</sub></strong> to <strong>X <sub>2</sub></strong> will be the correct valid solution of the system.  This is called <strong>uncertainty</strong> . <br><br><h3>  Uncertainty <br></h3><br>  Auto Layout has a mechanism for solving such problems - <strong>priorities</strong> .  I remind you that yellow will indicate high priority, and blue - low. <br><br><img src="https://habrastorage.org/webt/7e/go/is/7egoisncevkoitvo8fdxkvcdg7g.png"><br><br>  Convert constraints.  Please note that the resulting system is just black.  We know how to work with it, and there is no information about restrictions in it.  It is in the functionals, of which there will be as many as two.  Auto Layout will first minimize the first and then the second. <br><br>  In linear programming problems, we are not looking for a solution itself, but an area of ​​feasible solutions.  Of course, we want this area to be only one point, and Auto Layout acts in the same way.  First, it minimizes the highest priority functional on ( <strong>-</strong> <strong>∞,</strong> <strong>+ ∞)</strong> and, at the output, gets an area of ​​feasible solutions.  The second linear programming problem Auto Layout solves already on the obtained range of acceptable values.  Such a mechanism is called a <strong>hierarchy of constraints</strong> , and in this problem gives the point <strong>X <sub>2</sub></strong> . <br><br><h3>  Algorithm number 4 <br></h3><br><ul><li>  Create a hierarchy of linear constraints; </li><li>  convert it to a linear programming problem; </li><li>  Solve the linear programming problem sequentially, from the highest priority to the lowest priority. </li><li>  apply the solution to ulview. </li></ul><br>  Let's look at the previous task again.  We are not mathematicians, but engineers, and any engineer should be confused here. <br><br>  There is a serious problem - <strong>infinity</strong> , and I do not know what it is. <br><br>  The Cassowary algorithm under the hood of Auto Layout was not an existing mechanism that conveniently lay down on the Auto Layout task, but was invented as a typesetting tool, and it had special mechanisms to go away from infinity at the very beginning.  For this purpose several types of restrictions were invented: <br><br><ul><li>  <strong>Parameters</strong> - these are the limitations with which we worked.  In the original, they are called <strong>preferences,</strong> sometimes in the Apple documentation - <strong>optional constraints</strong> . </li><li>  <strong>Requirements</strong> or requirements - restrictions with priority <strong>required</strong> . </li></ul><br>  Let's see how requirements with such priorities are transformed from the point of view of mathematics. <br><br><img src="https://habrastorage.org/webt/hm/mn/my/hmmnmycwgdfq9vuip1xeylz4caq.png"><br><br>  We again have a straight line with two points, and the first constraint is <strong>X = X <sub>1</sub></strong> .  On the slide, it is red, that is, this restriction with the priority of required - we will call it a requirement. <br><br>  Auto Layout converts it to a linear equation system containing one equation <strong>X = X <sub>1</sub></strong> .  There is nothing more - no linear programming problems, no optimizations. <br><br>  With inequalities, the situation is similar, but a bit more complicated, because <strong>an additional variable</strong> will appear that can take any values ​​greater than 0. For any value greater than 0, this restriction will be satisfied.  Note that there are no linear programming and optimization problems here either. <br><br>  Let's try to combine all this together, to collect two requirements and convert them into one system.  The attentive reader, noted that we came to the same question from which we started - the <strong>requirements must be consistent</strong> . <br><br><img src="https://habrastorage.org/webt/lj/fu/wx/ljfuwxbedffz_agc5ydwoxiv0os.png"><br><br>  Restrictions like <strong>required</strong> or requirements are a <strong>very powerful tool,</strong> but not the main one, but an auxiliary one.  It was specifically introduced in Auto Layout to solve the problem of infinite intervals, it should be used carefully. <br><br>  Let's try to combine all types of restrictions with which we met in one system.  Suppose we want to solve the problem not on the whole line, but only between <strong>X <sub>0</sub></strong> and <strong>X <sub>3</sub> .</strong>  Transforming all this into a system of linear equations and inequalities, we obtain the following. <br><br><img src="https://habrastorage.org/webt/nl/3k/lw/nl3klwil0nepuuqyjq-nmxxo0rs.png"><br><br>  Regarding the previous system, two additional variables were added - <strong>c</strong> and <strong>d</strong> , but they would not fall into the functionals, since the constraints of the required type do not affect the functionality in its original form. <br><br>  It seems that the task has hardly changed - we minimize the same thing as before, but the initial range of acceptable values ​​is changing, now it is from <strong>X <sub>0</sub></strong> to <strong>X <sub>3</sub></strong> . <br><br><blockquote>  From a mathematical point of view, the requirements — constraints of the type required — are the ability to introduce additional equations into the system without modifying its functionals. <br></blockquote><br>  You need to be very careful with this, because excessive use of required constraints will lead to a <strong>problem without solutions</strong> , and Auto Layout cannot cope with it. <br><br>  We arrive at the last fifth algorithm. <br><br><h3>  Algorithm number 5 <br></h3><br><ul><li>  Identify the necessary restrictions - layout requirements; </li><li>  create a hierarchy of linear constraints; </li><li>  convert all constraints into a linear programming problem; </li><li>  solve the problem of linear programming; </li><li>  apply the solution to ulview. </li></ul><br>  We considered Cassowary, an algorithm that is inside Auto Layout, but when it is implemented, various features arise. <br><br><h3>  Features in iOS <br></h3><br>  <strong>There are no calculations in layoutSubviews ()</strong> . <br><br>  When are they produced?  Answer: always, at any given time, Auto Layout is counted.  The calculation takes place exactly when we add constraints to our view, or we activate them using modern API methods with constraints. <br><br><img src="https://habrastorage.org/webt/rf/rf/ca/rfrfca8zmtb5ukabvarjdfygbii.png"><br><br>  Our views are rectangles, but the problem is that inside Cazuar this information is not contained, it needs to be additionally inserted there.  We have a mechanism for introducing additional restrictions.  If we introduce for each view a set of restrictions with positive width and height, then at the output we will always get rectangles.  That is why we can not impose with the help of Auto Layout view with negative dimensions. <br><br>  The second feature is <strong>intrinsicContentSize</strong> — the intrinsic size that can be set for each view. <br><br><img src="https://habrastorage.org/webt/of/dx/dr/ofdxdrma4ob54homy7amohpvove.png"><br><br>  This is a simple interface for creating 4 additional inequality constraints to be placed in the system.  This mechanism is very convenient, it allows you to reduce the number of explicit restrictions, which simplifies the use of Auto Layout.  The last and most subtle point that people often forget about is <strong>TranslateAutoresizingMaskIntoConstraints.</strong> <br><br><img src="https://habrastorage.org/webt/xz/pz/su/xzpzsulxwqohzm-ehd5rz2kg148.png"><br><br>  This is a <strong>crutch,</strong> which was introduced at the time of iOS 5, so that the old code after the appearance of Auto Layout does not break. <br><br>  Imagine the situation: we impose view on constraints.  Inside the view, we use the view, which knows nothing about constraints, imposes everything on the frames, but inside it, it imposes a view, which has long been transferred to constraints. <br><br><blockquote>  I remind you that there are no frames inside the Kasuar Auto Layout task, only frames. <br></blockquote><br>  The size and position of the view that was rendered on frames is not completely determined by constraints.  When calculating the size and position of all other views, incorrect sizes will be taken into account, even though after Auto Layout we will apply the correct frames there. <br><br>  To avoid this situation, if the value of the TranslateAutoresizingMaskIntoConstraints variable is true, then an additional restriction is implemented for each view that is imposed on the frame.  This set of restrictions may differ from run to run.  Only one thing is known about this set: the frame that was transmitted will be its solution. <br><br>  Compatibility of old code written without constraints and new one written with constraints can often suffer due to improper use of this property.  These constraints necessarily take precedence of requirements, so if we suddenly place constraints on such a view, which have a very high priority, for example, a requirement, we can accidentally create a non-consistent system that will not have solutions. <br><br>  <strong>It is important to know:</strong> <br><br><ul><li>  If we create a view from <strong>Interface Builder</strong> , then the default value for this property will be <strong>false</strong> . </li><li>  If we create a view directly from the code, then it will be <strong>true</strong> . </li></ul><br>  The idea is very simple - the old code, in which the view was created, did not know anything about Auto Layout, and it was necessary to make it so that if the view was used somewhere in a new place, then it would work. <br><br><h2>  Practical advice <br></h2><br>  Total council will be three and begin with the most important. <br><br><h3>  Optimization <br></h3><br><blockquote>  It is important to isolate the problem. <br></blockquote><br>  Have you ever encountered the problem of optimizing the screen, which is laid out on the Auto Layout?  Most likely not, more often you are faced with the problem of optimizing the layout of cells within a table or a <strong>Collection View</strong> . <br><br>  Auto Layout is optimized enough to impose any screen and any interface, but to impose 50 or 100 at once is a problem for it.  To localize and optimize it, let's look at the experiment.  Figures are taken from the <a href="https://constraints.cs.washington.edu/solvers/cassowary-tochi.pdf">article</a> where Kazuar was first described. <br><img src="https://habrastorage.org/webt/jl/cb/qo/jlcbqo-0y685wxkbkniflmjlwli.png"><br><br>  The task is this: create a view chain one by one, and connect each subsequent one with the previous one.  Thus, a sequence of 1000 elements was lined up.  After various operations were measured, the time is specified in milliseconds.  The values ​​are quite large, because Auto Layout was invented at the junction of the 80s and 90s. <br><br>  Collecting such a chain, you can act as follows: <br><br><ul><li>  <strong>Consistently add one constraint</strong> and solve each time.  This will take 38 seconds. </li><li>  You can <strong>add all the restrictions at once at a time</strong> , and only then decide the system.  This solution is more efficient.  According to the old data, the efficiency increases by 70%, but in the current implementation on modern devices there will be only 20%.  But qualitatively one-time addition of restrictions will always be more effective. </li><li>  When the whole chain is assembled, you can <strong>add another constraint</strong> .  As can be seen from the table, this operation is quite cheap. </li><li>  The most interesting thing: <strong>if we do not add any new restrictions, but change some constant in one of the existing ones</strong> , this is an order of magnitude more efficient than deleting or creating a new restriction. </li></ul><br>  The first two points can be described as the primary calculation of interfaces, the last two - as the next one. <br><br><h4>  Primary interface calculation <br></h4><br>  Here you can use the methods of mass adding constraints for optimization: <br><br><ul><li>  <strong>NSLayoutConstraints.activate (_ :)</strong> - when creating a view, collect all the constraints in sequence into an array, cache and then add one at a time. </li><li>  Or create cells in the <strong>Interface Builder.</strong>  He will do everything for us, and will carry out additional optimization, which is often convenient. </li></ul><br><h4>  Subsequent interface calculations <br></h4><br>  Adding or changing constraint is a complicated operation, so it’s better <strong>not to change the set of constraints, but to change only the constants</strong> in the existing constraints.  For this there are the following techniques: <br><br><ul><li>  <strong>Hide UIView</strong> - the most interesting and underused technique.  When you delete a view, the entire cache that was saved in Auto Layout is cleared.  If we just hide it, the cache will not be erased, but at the same time you can impose a view that will have a different display. </li><li>  <strong>Manage priorities for intrinsic constraints</strong> <strong>- IntrinsicContentSize.</strong>  An effective method that allows you to cope well with cells, but is often forgotten about it. </li><li>  <strong>Create more cell types</strong> .  If your cells are very different from one another, they may be of different types. </li></ul><br>  To get acquainted in detail with the techniques, I advise you to watch the session <a href="https://developer.apple.com/videos/play/wwdc2018/220">WWDC 2018S220 High Performance Auto Layout</a> .  It is unique - Apple is deeply involved in the implementation and describes many convenient mechanisms that allow you to create cells optimally. <br><br><h2>  Design constraints <br></h2><br>  Next I will give some practical tips that can help in working with constraints. <br><br><h3>  Start with priorities <br></h3><br>  The more required restrictions, requirements - the greater the likelihood that you will one day come to an inconsistent system that will not have a solution.  You have problems. <br><br><blockquote>  In any incomprehensible situation, lower the priority, no matter what happens. <br></blockquote><br>  Here are very simple rules: <br><br><ul><li>  <strong>The smaller the components, the greater the priorities</strong> .  The less you impose a component (button or loader) - the higher should be the priority. </li><li>  <strong>The larger the components, the lower the priorities</strong> .  If you make a huge screen, then the priorities should be low. </li></ul><br><br><h3>  Freeze requirements <br></h3><br>  We all know that walking on water and working on demand is equally easy when they are frozen. <br><br>  When you create <strong>constraint with the required priority, do not change it in runtime</strong> .  If it needs to be changed, it means that you made a mistake in the design, and in fact this is not a requirement.  Redefine your system so that you can change optional restrictions. <br><br>  The obvious conclusion is <strong>that the lower the priority, the cheaper the modification of the restriction</strong> .  This directly proceeds from the fact that tasks in the hierarchy of priorities are solved sequentially - from higher priority to low priority ones.  If we change something in low priority, then the decision of the upper ones will not affect in any way, and the range of acceptable values ​​will not change.  Auto Layout understands this and solves the system optimally if you change only low-priority constraints. <br><br>  <strong>Accidentally creating conflicting requirements is extremely easy</strong> if you change them in runtime.  You may not even notice.  Moreover, this may not be your final point, when the requirements will become priorities, but only an intermediate one.  As a result, you build the same layout, but the situation when the system is not solvable is extremely expensive in terms of performance.  Therefore, it is better to avoid it at the design stage. <br><br><h3>  Use inequalities <br></h3><br>  <strong>Inequality is a cool tool</strong> that allows you to use Auto Layout, since we cannot use many other typesetting systems, and it is simply wrong to ignore them. <br><br>  The advantages of inequality, such as required, are that it is <strong>much more difficult to create contradictions</strong> with them.  Receptions are quite simple: <br><br><ul><li>  The higher the priority, the greater the inequalities should be. </li><li>  Conversely, the lower the priority, the more equalities can be used. </li></ul><br>  The most important thing that I wanted to convey in this article is an <strong>understanding of how we come to limitations</strong> . <br><br>  We first transformed the requirements into a system of linear equations and came up with problems, and then went a completely different way.  Therefore, when problems or bugs arise, we try to analyze them from the point of view of a system of linear equations, and try to solve it.  This is not true; <strong>restrictions are not equations</strong> .  It is wrong to approach them in this way. <br><br>  <strong>Requirements and parameters are fundamentally different things.</strong>  We are used to working with constraints as if they were just different priorities, but it is important to understand and remember that it is important - both from the point of view of mathematics, and inside when solving - the required type and all the others are solved in fundamentally different ways. <br><br>  <b>Useful links:</b> <br><br>  <a href="https://constraints.cs.washington.edu/solvers/uist97.html">Solving Linear Arithmetic Constraints for User Interface Applications</a> <br>  <a href="https://constraints.cs.washington.edu/solvers/cassowary-tochi.pdf">The Cassowary Linear Constraint Solving Algorithm</a> <br>  <a href="https://dl.acm.org/citation.cfm%3Fid%3D2814244">Constraints as s Design Pattern</a> <br>  <a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/index.html">Auto Layout Guide by Apple</a> <br>  <a href="https://developer.apple.com/videos/wwdc2018/">WWDC 2018 Session 220 High Performance Auto Layout</a> <br>  <a href="https://medium.com/yandex-maps-ios/uilabel-magic-2c83bc62a0db">Magic UILabel or private API Auto Layout - Alexander Goremykin</a> <br>  <a href="https://medium.com/yandex-maps-ios">Medium Yandex.Maps Blog</a> <br><br><blockquote>  By the way, we have already accepted the <a href="https://appsconf.ru/moscow/2019/abstracts/4393">report of</a> Anton in the program <a href="https://appsconf.ru/moscow/2019">AppsConf 2019</a> .  Let me remind you, we moved AppsConf from autumn to spring, and the next most useful conference for mobile developers will be held on April 22 and 23.  It is time to think about the topic for a speech and <a href="https://conf.ontico.ru/lectures/propose%3Fconference%3Dac2019">submit a report</a> , or discuss with the manager the importance of going to the conference and book a ticket. <br></blockquote></div>