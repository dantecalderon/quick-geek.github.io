<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Create an easy chess AI: 5 simple steps</title>
  <meta name="description" content="We translated for you an article by Lauri Hartikka on creating the simplest AI for chess. It was written in 2017, but the basic principles remain the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Create an easy chess AI: 5 simple steps</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/1ba/775/17f/1ba77517fcadb7d7bba3aa6c08a4453c.jpg"><br><br>  We translated for you an article by Lauri Hartikka on creating the simplest AI for chess.  It was written in 2017, but the basic principles remain the same.  All the files that Laurie used are also available. <br><br>  A simple artificial intelligence that can play chess can be created on the basis of four concepts: <br><br><ol><li>  1. Relocation; </li><li>  2. Score board; </li><li>  <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B8%25D0%25BD%25D0%25B8%25D0%25BC%25D0%25B0%25D0%25BA%25D1%2581">3. Minimax</a> ; </li><li>  <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D1%258C%25D1%2584%25D0%25B0-%25D0%25B1%25D0%25B5%25D1%2582%25D0%25B0-%25D0%25BE%25D1%2582%25D1%2581%25D0%25B5%25D1%2587%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">4. Alpha Beta Clipping</a> .  At each stage of working with the algorithm, one of them will be used, this will allow to gradually improve the game abilities of AI. </li></ol><a name="habracut"></a><br><blockquote>  <b>Skillbox recommends:</b> Applied online course <a href="https://skillbox.ru/python-data/%3Futm_source%3Dskillbox.media%26utm_medium%3Dhabr.com%26utm_campaign%3DPTNANA%26utm_content%3Darticles%26utm_term%3Dchess">"Python Data Analyst"</a> . <br><br>  <b>We remind:</b> <i>for all readers of "Habr" - a discount of 10,000 rubles when recording for any Skillbox course on the promotional code "Habr".</i> </blockquote><br>  Ready source code can be found on <a href="https://github.com/lhartikk/simple-chess-ai" rel="noopener noreferrer nofollow">GitHub</a> . <br><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="846819979303538692"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br><h3>  Stage 1. Visualization of the chessboard with the generation of moves </h3><br>  At this stage we will use the <a href="" rel="nofollow noopener noreferrer">chess.js</a> libraries to generate moves and <a href="https://github.com/oakmac/chessboardjs/" rel="nofollow noopener noreferrer">chessboard.js</a> to visualize the board.  The library, which is responsible for the generation of moves, allows you to apply all the chess rules, so that we can count each action for a specific arrangement of the pieces. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/323/905/fa7/323905fa7062bd302e0b97afd1b81d40.png"></a> <br>  When you click on the picture, it will open in full resolution. <br><br>  Working with these libraries allows you to concentrate on the main task - the search and creation of an algorithm that allows you to find the optimal course.  We begin the work by writing a function that returns a random move from the list of all possible. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> calculateBestMove =<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">game</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//generate all the moves for a given position var newGameMoves = game.ugly_moves(); return newGameMoves[Math.floor(Math.random() * newGameMoves.length)]; };</span></span></code> </pre> <br>  Despite the fact that the algorithm is not an ideal chess player, for most players its level will be quite enough. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bed/894/ec5/bed894ec55bc40838b678e42ad45f084.gif"><br>  Black goes randomly.  ( <a href="https://jsfiddle.net/lhartikk/m14epfwb/4/">source and game online</a> ) <br><br><h3>  Stage 2. Position evaluation </h3><br>  Now let's see which side has the advantage in this or that position.  The easiest way is to calculate the relative strength of the pieces on the board; this can be done using a table. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b46/f5e/7d0/b46f5e7d061101f66d73d8acd205d7eb.png"><br><br>  Using the evaluation function, we get the opportunity to create an algorithm that selects the course with the maximum rating. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> calculateBestMove = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">game</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newGameMoves = game.ugly_moves(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bestMove = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-comment"><span class="hljs-comment">//use any negative large number var bestValue = -9999; for (var i = 0; i &lt; newGameMoves.length; i++) { var newGameMove = newGameMoves[i]; game.ugly_move(newGameMove); //take the negative as AI plays as black var boardValue = -evaluateBoard(game.board()) game.undo(); if (boardValue &gt; bestValue) { bestValue = boardValue; bestMove = newGameMove } } return bestMove; };</span></span></code> </pre> <br>  In principle, the level is the same, but the algorithm can already take someone else‚Äôs figure when there is such an opportunity. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b1e/772/b77/b1e772b777bf84f52c2b10f900969c33.gif"><br>  Black got the opportunity to take white pieces.  (Source and game <a href="https://jsfiddle.net/lhartikk/m5q6fgtb/1/">here</a> ). <br><br><h3>  Stage 3. Search tree with minimax </h3><br>  After that we create a search tree.  Now the program can choose the best move from it.  This is done using a minimax algorithm. <br><br>  Here, a recursive tree with the display of all possible moves is analyzed to a predetermined depth.  The position is estimated by the leaves of our tree. <br><br>  Next, we return the minimum or maximum value of the child to the parent node.  It all depends on which turn is being calculated.  In other words, the result is maximized or minimized at each level. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bf9/487/181/bf948718169b06d15fdfbf816839d6a4.jpg"><br>  Here, the best move for White is b2-c3, since he guarantees that the player will get to the position with a score of -50. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> minimax = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">depth, game, isMaximisingPlayer</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (depth === <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -evaluateBoard(game.board()); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newGameMoves = game.ugly_moves(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isMaximisingPlayer) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bestMove = <span class="hljs-number"><span class="hljs-number">-9999</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; newGameMoves.length; i++) { game.ugly_move(newGameMoves[i]); bestMove = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.max(bestMove, minimax(depth - <span class="hljs-number"><span class="hljs-number">1</span></span>, game, !isMaximisingPlayer)); game.undo(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bestMove; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bestMove = <span class="hljs-number"><span class="hljs-number">9999</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; newGameMoves.length; i++) { game.ugly_move(newGameMoves[i]); bestMove = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.min(bestMove, minimax(depth - <span class="hljs-number"><span class="hljs-number">1</span></span>, game, !isMaximisingPlayer)); game.undo(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bestMove; } };</code> </pre> <br>  With the minimax algorithm, our AI has already begun to understand the basic tactics of chess. <br><br>  Minimax with a depth of 2 (Source and game <a href="https://jsfiddle.net/k96eoq0q/1/">here</a> ) <br><br>  It should be noted that the efficiency of the minimax algorithm increases with the depth of the search.  The next step is responsible for this. <br><br><h3>  Stage 4. Alpha Beta Clipping </h3><br>  This is a minimax optimization method that makes it possible to ignore some branches in the search tree.  And this allows you to increase the depth of search, spending the same amount of resources. <br><br>  Alpha-beta pruning is based on a situation where we can stop evaluating a particular branch, if it is found that a new move will lead to a worse situation than the one we saw when evaluating the previous one. <br><br>  The result of minimax optimization does not affect, but everything starts to work faster. <br><br>  This algorithm is much more efficient if you first check the paths leading to good moves. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/005/848/e91/005848e915563e0beb8780644e6ae75d.jpg"><br>  The image shows moves that are no longer needed when using alpha-beta clipping. <br><br>  As you can see, with alpha-beta clipping, the minimax is optimized, and quite significantly. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7da/152/9e0/7da1529e05c765a30f46ad8cf2ff457e.png"><br>  The number of positions that need to be evaluated in the case of a search with a depth of 4 and the initial position, which is shown above.  (source and game are available <a href="https://jsfiddle.net/Laa0p1mh/3/">here</a> ) <br><br><h3>  Stage 5. Improved evaluation function </h3><br>  The initial evaluation function is fairly simple, since it simply counts the points of the pieces on the board.  To optimize it, you can take into account the position of the figures.  For example, if you place a horse in the center of the board, it becomes more expensive - the range of available moves for this figure will expand. <br><br>  At this stage, we will work with a slightly modified version of the square tables, originally described in the <a href="https://chessprogramming.wikispaces.com/Simplified%2Bevaluation%2Bfunction">Chess Programming wiki</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8c0/b56/744/8c0b567444732b5c06de26e352e62967.png"><br><br>  And now our algorithm is playing quite well, of course, compared to the average player. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cbb/f2c/01e/cbbf2c01ec66b9144eb2545ec8ace4a3.gif"><br>  Sources and game are available <a href="https://jsfiddle.net/q76uzxwe/1/">here.</a> <br><br><h3>  Conclusion </h3><br>  The advantage of the proposed algorithm is that it does not make very stupid mistakes.  Of course, the strategy is hardly perfect, but nonetheless. <br><br>  The implementation of our algorithm is only 200 lines of code, so the basic principles are quite simple.  The final version of the program can be &lt;a href=room <a href="https://github.com/lhartikk/simple-chess-ai">github.com/lhartikk/simple-chess-ai'&gt;</a> on GitHub. <br><br>  Other modules can be added to the algorithm, including: <br><br><ul><li>  <a href="https://chessprogramming.wikispaces.com/Move%2BOrdering">ordering moves</a> ; </li><li>  acceleration of the <a href="https://chessprogramming.wikispaces.com/Move%2BGeneration">generation of moves</a> ; </li><li>  <a href="https://chessprogramming.wikispaces.com/Endgame">and endgame evaluation</a> . </li></ul><br><br>  You can learn more about chess algorithms at the <a href="https://chessprogramming.wikispaces.com/">Chess Programming Wiki</a> . <br><br><blockquote>  <b>Skillbox recommends:</b> <br><br><ul><li>  Practical course <a href="https://skillbox.ru/agima/%3Futm_source%3Dskillbox.media%26utm_medium%3Dhabr.com%26utm_campaign%3DAGIMA%26utm_content%3Darticles%26utm_term%3Dchess">"Mobile Developer PRO"</a> </li><li>  Online course <a href="https://skillbox.ru/webdev/%3Futm_source%3Dskillbox.media%26utm_medium%3Dhabr.com%26utm_campaign%3DWEBDEV%26utm_content%3Darticles%26utm_term%3Dchess">"Profession Web Developer"</a> </li><li>  Two-year practical course <a href="https://iamwebdev.skillbox.ru/%3Futm_source%3Dskillbox.media%26utm_medium%3Dhabr.com%26utm_campaign%3DWEBDEVPRO%26utm_content%3Darticles%26utm_term%3Dchess">"I am a web developer PRO"</a> . </li></ul></blockquote></div><p>Source: <a href="https://habr.com/ru/post/437524/">https://habr.com/ru/post/437524/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>