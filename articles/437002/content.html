<div class="post__text post__text-html js-mediator-article"><p> <a href="https://habr.com/ru/post/437002/"><img src="https://habrastorage.org/webt/sy/y_/ph/syy_ph0f1cwt9upm9frbr6z5ggi.jpeg" alt="Correct ASP.NET Core"></a> </p><br><p>  Especially for fans of books from the series "C ++ in 24 hours" I decided to write an article about ASP.NET Core. </p><br><p>  If you have not previously developed for .NET or for any similar platform, then it makes no sense to go under the cat for you.  But if you are interested in knowing what IoC, DI, DIP, Interseptors, Middleware, Filters are (that is, everything that distinguishes Core from classic .NET), then you definitely have a reason to click on "Read more", since without an understanding of all this is clearly not correct. </p><a name="habracut"></a><br><h2 id="ioc-di-dip">  IoC, DI, DIP </h2><br><p>  If the theater begins with a hanger, then ASP.NET Core begins with Dependency Injection.  In order to deal with DI you need to understand what IoC is. </p><br><p>  Speaking about IoC, the Hollywood principle "Don't call us, we'll call you" is often remembered.  Which means "Do not call us, we will call you yourself." </p><br><p>  Different sources lead different patterns to which IoC can be applied.  And most likely they are all right and just complement each other.  Here are some of these patterns: factory, service locator, template method, observer, strategy. </p><br><p>  Let's take a look at IoC using a simple console application as an example. </p><br><p>  Suppose we have two simple classes that implement an interface with one method: </p><br><pre><code class="plaintext hljs">class ConsoleLayer : ILayer { public void Write(string text) { Console.WriteLine(text); } } class DebugLayer : ILayer { public void Write(string text) { Debug.WriteLine(text); } } interface ILayer { void Write(string text); }</code> </pre> <br><p>  Both of them depend on abstraction (in this case, the interface acts as an abstraction). </p><br><p>  And, let's say, we have a higher-level object using these classes: </p><br><pre> <code class="plaintext hljs"> class Logging { private ILayer _instance; public Logging(int i) { if (i == 1) { _instance = new ConsoleLayer(); } else { _instance = new DebugLayer(); } } public void Write(string text) { _instance.Write(text); } }</code> </pre> <br><p>  Depending on the constructor parameter, the _instance variable is initialized by a specific class.  Well and further by a call of Write the conclusion to the console or in Debug will be made.  Everything seems to be quite good, and even seemingly corresponds to the first part of the principle of Dependency Inversion </p><br><blockquote>  Objects of a higher level do not depend on objects of a lower level.  Both those and those depend on abstractions. </blockquote><p>  In our case ILayer acts as an abstraction. </p><br><p>  But we must also have an even higher level object.  The one that uses the Logging class </p><br><pre> <code class="plaintext hljs"> static void Main(string[] args) { var log = new Logging(1); log.Write("Hello!"); Console.Read(); }</code> </pre> <br><p>  Initializing Logging with 1 we get in the Logging class an instance of the class that outputs data to the console.  If we initialize Logging with any other number, then log.Write will output the data to Debug.  Everything seems to work, but it works poorly.  Our higher level Main object depends on the details of the lower level object code - the Logging class.  If we change something in this class, we will need to change the code of the Main class.  To prevent this from happening, we will make an inversion of control - Inversion of Control.  Let's make the Main class control what happens in the Logging class.  The Logging class will receive as a constructor parameter an instance of the class implementing the interface of the ILayer interface. </p><br><pre> <code class="plaintext hljs"> class Logging { private ILayer _instance; public Logging(ILayer instance) { _instance = instance; } public void Write(string text) { _instance.Write(text); } }</code> </pre> <br><p>  And now our Main class will look like this: </p><br><pre> <code class="plaintext hljs"> static void Main(string[] args) { var log = new Logging(new DebugLayer()); log.Write("Hello!"); Console.Read(); }</code> </pre> <br><p>  In fact, we decorate our Logging object using the object we need. </p><br><p>  Now our application also corresponds to the second part of the Dependency Inversion principle: </p><br><blockquote>  Abstractions are independent of details.  Details depend on abstractions.  Those.  we do not know the details of what is happening in the Logging class, we simply pass in a class that implements the necessary abstraction. </blockquote><p>  There is such a term tight coupling - a close relationship.  The weaker the connections between components in an application, the better.  I would like to note that this example of a simple application falls short of the ideal a little.  Why?  Yes, because in the class of the highest level in Main, we twice use the creation of class instances with the help of new.  And there is such a mnemonic phrase “New is a clue” - which means the less you use new, the less close connections of components in an application are and the better.  Ideally, we should not have used new DebugLayer, but we had to get DebugLayer in some other way.  How?  For example, from the IoC container or using reflection from the parameter passed to Main. </p><br><p>  Now we understand what Inversion of Control (IoC) is and what Dependency Inversion (DIP) principle is.  It remains to figure out what Dependency Injection (DI) is.  IoC is a design paradigm.  Dependency Injection is a pattern.  This is what is happening in the Logging class constructor.  We get an instance of a particular dependency.  The Logging class is dependent on the instance of the class implementing ILayer.  And this instance is implemented (injected) through the constructor. </p><br><h2 id="ioc-container">  IoC container </h2><br><p>  IoC container is such an object that contains a lot of some specific dependencies (dependency).  Dependence can be otherwise called a service - as a rule, it is a class with a specific functionality.  If necessary, a dependency of the required type can be obtained from the container.  Injecting dependency into a container is Inject.  Extract - Resolve.  I will give an example of the simplest self-written IoC container: </p><br><pre> <code class="plaintext hljs"> public static class IoCContainer { private static readonly Dictionary&lt;Type, Type&gt; _registeredObjects = new Dictionary&lt;Type, Type&gt;(); public static dynamic Resolve&lt;TKey&gt;() { return Activator.CreateInstance(_registeredObjects[typeof(TKey)]); } public static void Register&lt;TKey, TConcrete&gt;() where TConcrete : TKey { _registeredObjects[typeof(TKey)] = typeof(TConcrete); } }</code> </pre> <br><p>  Just a dozen lines of code, but you can already use it (not in production, of course, but for training purposes). </p><br><p>  You can register a dependency (say, the ConsoleLayer or DebugLayer that we used in the last example) like this: </p><br><pre> <code class="plaintext hljs"> IoCContainer.Register&lt;ILayer, ConsoleLayer&gt;();</code> </pre> <br><p>  And extract from the container in the required place of the program as follows: </p><br><pre> <code class="plaintext hljs"> ILayer layer = IoCContainer.Resolve&lt;ILayer&gt;(); layer.Write("Hello from IoC!");</code> </pre> <br><p>  Dispose () is also implemented in real containers, which allows destroying resources that have become unnecessary. </p><br><p>  By the way, the name of the IoC container does not exactly convey the meaning, since the term IoC is much broader in application.  Therefore, recently the term DI container has been increasingly used (as dependency injection is still used). </p><br><h2 id="service-lifetimes--various-extension-methods-in-composition-root">  Service lifetimes + various extension methods in Composition Root </h2><br><p>  ASP.NET Core applications contain a Startup.cs file which is the starting point of an application that allows you to configure DI.  Configured by the DI in the ConfigureServices method. </p><br><pre> <code class="plaintext hljs"> public void ConfigureServices(IServiceCollection services) { services.AddScoped&lt;ISomeRepository, SomeRepository&gt;(); }</code> </pre> <br><p>  This code will add the SomeRepository class to the DI container that implements the ISomeRepository interface.  The fact that the service is added to the container using AddScoped means that an instance of the class will be created with each page request. <br>  You can add a service to a container without an interface. </p><br><pre> <code class="plaintext hljs"> services.AddScoped&lt;SomeRepository&gt;();</code> </pre> <br><p>  But this method is not recommended, since your application loses its flexibility and close connections appear.  It is recommended to always specify the interface, since in such a case, at any time it is possible to replace one interface implementation with another.  And if the implementations support the principle of Liskov substitution, then by “flick of the wrist,” changing the name of the implementation class will change the functionality of the entire application. </p><br><p>  There are 2 more options to add service - AddSingleton and AddTransient. <br>  When using AddSingleton, the service is created once and when using the application, the call goes to the same instance.  It is necessary to use this method especially carefully, as memory leaks and problems with multithreading are possible. </p><br><p>  AddSingleton has a small feature.  It can be initialized either when it is first accessed. </p><br><pre> <code class="plaintext hljs"> services.AddSingleton&lt;IYourService, YourService&gt;();</code> </pre> <br><p>  either immediately when added to the constructor </p><br><pre> <code class="plaintext hljs"> services.AddSingleton&lt;IYourService&gt;(new YourService(param));</code> </pre> <br><p>  In the second way, you can even add a parameter to the constructor. <br>  If you want to add a parameter to the constructor of a service added not only using AddSingleton, but also using AddTransient / AddScoped, then you can use a lambda expression: </p><br><pre> <code class="plaintext hljs"> services.AddTransient&lt;IYourService&gt;(o =&gt; new YourService(param));</code> </pre> <br><p>  Finally, when using AddTransient, a service is created every time you access it.  Great for lightweight services that do not consume memory and resources. </p><br><p>  If everything should be more or less clear with AddSingleton and AddScoped, then AddTransient needs clarification.  Official documentation gives an example in which a certain service is added to a DI container and as a parameter of the constructor of another service and separately independently.  And in case it is added separately using AddTransient, it creates its own instance 2 times.  I will give a very, very simplified example.  In real life, it is not recommended for use, because  classes for simplicity do not inherit interfaces.  Suppose we have a simple class: </p><br><pre> <code class="plaintext hljs"> public class Operation { public Guid OperationId { get; private set; } public Operation() { OperationId = Guid.NewGuid(); } }</code> </pre> <br><p>  And there is a second class that contains the first as a dependent service and receives this dependency as a parameter of the constructor: </p><br><pre> <code class="plaintext hljs"> public class OperationService { public Operation Operation { get; } public OperationService (Operation operation) { Operation = operation; } }</code> </pre> <br><p>  Now we make the inject of two services: </p><br><pre> <code class="plaintext hljs"> services.AddTransient&lt;Operation&gt;(); services.AddScoped&lt;OperationService&gt;();</code> </pre> <br><p>  And in some controller in Action, add the receipt of our dependencies and the output of values ​​to the Debug window. </p><br><pre> <code class="plaintext hljs"> public IActionResult Index([FromServices] Operation operation, [FromServices] OperationService operationService) { Debug.WriteLine(operation.OperationId); Debug.WriteLine(operationService.Operation.OperationId); return View(); }</code> </pre> <br><p>  So as a result, we get 2 different values ​​Guid.  But if we replace AddTransient with AddScoped, then as a result we will get 2 identical values. </p><br><p>  The IoC container of ASP.NET Core applications by default already contains some services.  For example, IConfiguration is a service with which you can get application settings from the files appsettings.json and appsettings.Development.json.  IHostingEnvironment and ILoggerFactory with which you can get the current configuration and an auxiliary class that allows logging. </p><br><p>  Classes are removed from the container using the following typical construction (the most trivial example): </p><br><pre> <code class="plaintext hljs"> private readonly IConfiguration _configuration; public SomePageController(IConfiguration configuration) { _configuration = configuration; } public async Task&lt;IActionResult&gt; Index() { string connectionString = _configuration["connectionString"]; }</code> </pre> <br><p>  In the scope of the controller, a variable is created with access modifiers private readonly.  The dependency is obtained from the container in the class constructor and is assigned to a private variable.  Further, this variable can be used in any method or Action controller. <br>  Sometimes you do not want to create a variable in order to use it in only one Action.  Then you can use the attribute [FromServices].  Example: </p><br><pre> <code class="plaintext hljs"> public IActionResult About([FromServices] IDateTime dateTime) { ViewData["Message"] = «Московское время " + dateTime.Now; return View(); }</code> </pre> <br><p>  It looks strange, but in order for the code not to call the static class method DateTime.Now () it is sometimes done that the time value is obtained from the service as a parameter.  Thus, it is possible to pass any time as a parameter, which means it becomes easier to write tests and, as a rule, it becomes easier to make changes to the application. <br>  This is not to say that static is evil.  Static methods are faster.  And most likely static can be used somewhere in the IoC container itself.  But if we save our application from all static and new, then we will get more flexibility. </p><br><h2 id="storonnie-di-konteynery">  Third-party DI containers </h2><br><p>  What we considered and what the ASP.NET Core DI default container actually implements is constructor injection.  It is still possible to inject a dependency into property using so-called property injection, but this feature is not present in the container built into ASP.NET Core.  For example, we may have some class that you implement as a dependency, and this class has some public property.  Now imagine that during or after we introduce a dependency, we need to set the property value.  Let's go back to the example similar to the one we recently reviewed. <br>  If we have such a class: </p><br><pre> <code class="plaintext hljs"> public class Operation { public Guid OperationId { get; set; } public Operation() {} }</code> </pre> <br><p>  which we can introduce as an addiction, </p><br><pre> <code class="plaintext hljs"> services.AddTransient&lt;Operation&gt;();</code> </pre> <br><p>  then using the standard container we cannot set the value for the property. <br>  If you want to use such an opportunity to set a value for the OperationId property, then you can use some third-party DI container that supports property injection.  By the way, property injection is not particularly recommended.  However, there are Method Injection and Setter Method Injection, which may be useful to you and which are also not supported by the standard container. </p><br><p>  Third-party containers may have other very useful features.  For example, using a third-party container, you can embed a dependency only in controllers who have a certain word in their name.  And quite often used case - DI containers, optimized for speed. <br>  Here is a list of some third-party DI containers supported by ASP.NET Core: Autofac, Castle Windsor, LightInject, DryIoC, StructureMap, Unity </p><br><p>  Although when using a standard DI container, you cannot use property / method injection, but you can implement the dependent service as a constructor parameter by implementing the “Factory” pattern as follows: </p><br><pre> <code class="plaintext hljs"> services.AddTransient&lt;IDataService, DataService&gt;((dsvc) =&gt; { IOtherService svc = dsvc.GetService&lt;IOtherService&gt;(); return new DataService(svc); });</code> </pre> <br><p>  In this case, GetService will return null if the dependent service is not found.  There is a variation of GetRequiredService, which will throw an exception in case the dependent service is not found. <br>  The process of getting a dependent service using GetService actually uses the Service locator pattern. </p><br><h2 id="autofac">  Autofac </h2><br><p>  Let's sort Autofac on a practical example.  Conveniently, it will be possible to register and receive services from the container, as well as in the default way, and with the help of Autofac. </p><br><p>  Install the NuGet Autofac.Extensions.DependencyInjection package. <br>  Change the value of the ConfigureServices method from void to IServiceProvider.  And add property </p><br><pre> <code class="plaintext hljs"> public IContainer ApplicationContainer { get; private set; }</code> </pre> <br><p>  After this, it will be possible to add a code like the following to the end of the ConfigureServices class of the Startup class (this is just one of the options for registering services): </p><br><pre> <code class="plaintext hljs"> services.AddTransient&lt;ISomeRepository, SomeRepository&gt;(); var builder = new ContainerBuilder(); builder.Populate(services); builder.RegisterType&lt;AnotherRepository&gt;().As&lt;IAnotherRepository&gt;(); this.ApplicationContainer = builder.Build(); return new AutofacServiceProvider(this.ApplicationContainer);</code> </pre> <br><p>  Here is builder.Populate (services);  adds services from IServiceCollection to container.  Well, then you can already register services using builder.RegisterType.  Oh yes.  I almost forgot.  You must change from void to IServiceProvider the return value of the ConfigureServices method. </p><br><h2 id="aop-s-pomoschyu-aspnet-core---autofac-interseptors">  AOP using ASP.NET Core - Autofac Interseptors </h2><br><p>  Speaking about aspect-oriented programming, they mention another term - cross-cutting concerns.  Concern is some piece of information that affects the code.  In the Russian version use the word responsibility.  Well, cross-cutting concerns are responsibilities that affect other responsibilities.  And ideally, they shouldn't influence each other, right?  When they influence each other, it becomes more difficult to change the program.  It is more convenient when all our operations take place separately.  Logging, transactions, caching and more can be accomplished using AOP without changing the code of the classes and methods themselves. </p><br><p>  In the .NET world, a method is often used when AOP code is injected using a post processor into an already compiled application code ( <a href="https://www.postsharp.net/">PostSharp</a> ) Alternatively, interceptors can be used — these are event hooks that can be added to application code.  These interceptors, as a rule, use for their work the decorator pattern that we have already examined. </p><br><p>  Let's create our own spoiler.  The simplest and most typical example that is easiest to reproduce is logging. <br>  In addition to the Autofac.Extensions.DependencyInjection package, we will also install the Autofac.Extras.DynamicProxy package <br>  Installed?  Add a simple class of log that will be called when accessing certain services. </p><br><pre> <code class="plaintext hljs"> public class Logger : IInterceptor { public void Intercept(IInvocation invocation) { Debug.WriteLine($"Calling {invocation.Method.Name} from Proxy"); invocation.Proceed(); } }</code> </pre> <br><p>  Add the registration of the spoiler to our Autofac registration: </p><br><pre> <code class="plaintext hljs"> builder.Register(i =&gt; new Logger()); builder.RegisterType&lt;SomeRepository &gt;() .As&lt;ISomeRepository &gt;() .EnableInterfaceInterceptors() .InterceptedBy(typeof(Logger));</code> </pre> <br><p>  And now each time the class is called, the Intercept method of the Logger class will be called. <br>  Thus, we can simplify our life and not write a log at the beginning of each method.  We will have it automatically.  And if you wish, it will be easy for us to change or disable it for the entire application. </p><br><p>  We can also remove .InterceptedBy (typeof (Logger));  and add call interception only for specific application services using the [Intercept (typeof (Logger))] attribute - you must specify it before the class header. </p><br><h2 id="middleware">  Middleware </h2><br><p>  In ASP.NET, there is a specific chain of code calls that occurs with each request.  Even before the UI / MVC boots up, certain actions are performed. </p><br><p>  That is, for example, if we add to the beginning of the Configure method of the Startup.cs class the code </p><br><pre> <code class="plaintext hljs"> app.Use(async (context, next) =&gt; { Debug.WriteLine(context.Request.Path); await next.Invoke(); });</code> </pre> <br><p>  then we can see in the debug console which files our application requests.  In fact, we get the capabilities of the AOP “out of box” <br>  A little useless, but clear and informative example of using middleware, I'll show you now: </p><br><pre> <code class="plaintext hljs"> public void Configure(IApplicationBuilder app) { app.Use(async (context, next) =&gt; { await context.Response.WriteAsync("Hello!" + Environment.NewLine); await next.Invoke(); }); app.Run(async context =&gt; { await context.Response.WriteAsync("Hello again."); }); }</code> </pre> <br><p>  At each request, the call chain will be executed.  From each app.Use after the next.invoke () call, the transition to the next call is made.  And everything ends after the app.Run runs. <br>  You can execute some code only when accessing a specific route. <br>  This can be done using app.Map: </p><br><pre> <code class="plaintext hljs"> private static void Goodbye(IApplicationBuilder app) { app.Run(async context =&gt; { await context.Response.WriteAsync("Goodbye!"); }); } public void Configure(IApplicationBuilder app) { app.Map("/goodbye", Goodbye); app.Run(async context =&gt; { await context.Response.WriteAsync("Hello!"); }); }</code> </pre> <br><p>  Now, if you just go to the site page, you can see the text “Hello!”, And if you add / Goodbye to the address bar, Goodbye will be displayed. </p><br><p>  In addition to Use and Map, you can use UseWhen or MapWhen to add code to the middleware chain only under certain conditions. </p><br><p>  Still there were still useless examples, right?  Here is a normal example: </p><br><pre> <code class="plaintext hljs"> app.Use(async (context, next) =&gt; { context.Response.Headers.Add("X-Frame-Options", "DENY"); context.Response.Headers.Add("X-Content-Type-Options", "nosniff"); context.Response.Headers.Add("X-Xss-Protection", "1"); await next(); });</code> </pre> <br><p>  Here we add to each request headers to help protect the page from hacker attacks. </p><br><p>  Or here's an example of localization: </p><br><pre> <code class="plaintext hljs"> var supportedCultures = new[] { new CultureInfo("ru"), new CultureInfo("fr") }; app.UseRequestLocalization(new RequestLocalizationOptions { DefaultRequestCulture = new RequestCulture("ru"), SupportedCultures = supportedCultures, SupportedUICultures = supportedCultures });</code> </pre> <br><p>  Now, if you add the? Culture = fr parameter to the page address, then you can switch the language of the application to French (if localization is added to your application, then everything will work) </p><br><h2 id="filters">  Filters </h2><br><p>  If the middleware chain refers to processes up to MVC, then the filters work together with MVC. <br>  The following schematic shows how filters work out. </p><br><p><img src="https://habrastorage.org/webt/jz/n1/hv/jzn1hvufowfcck24q1-nnl-xbx8.png" alt="Filters"></p><br><p>  First, run authorization filters.  Those.  You can create some kind of filter or several filters and enter in them some kind of authorization code that will be processed upon requests. </p><br><p>  Then work out the resource filters.  Using these filters, you can, for example, return some information from the cache. </p><br><p>  Then data binding occurs and Action filters are executed.  With their help, you can manipulate the parameters passed to the Action and the returned result. </p><br><p>  Exception filters as the name suggests suggests adding some kind of general error handling to the application.  It should be quite convenient to handle errors the same everywhere.  A kind of AOP-shny plus. </p><br><p>  Result filters allow you to perform some actions before the execution of the Action controller or after.  They are quite similar to Action filters, but they are executed only if there are no errors.  Suitable for logic tied to the View. </p><br><p> Все должно быть более понятно на примере. А у меня под рукой как раз есть пример упрощенного авторизационного фильтра: </p><br><pre> <code class="plaintext hljs"> public class YourCustomFilter : Attribute, IAuthorizationFilter { public async void OnAuthorization(AuthorizationFilterContext context) { // какая-то логика и в случае, если у пользователе нет прав, можно сделать следующее context.Result = new ContentResult() { Content = "У вас нет прав для доступа к этому ресурсу" }; } }</code> </pre> <br><p> Добавляете этот класс в DI контейнер (как обычно в Startup.cs) </p><br><pre> <code class="plaintext hljs"> services.AddScoped&lt;YourCustomFilter&gt;();</code> </pre> <br><p> И теперь становится возможным добавить какую-то свою авторизацию любому Action добавив следующий атрибут </p><br><pre> <code class="plaintext hljs"> [ServiceFilter(typeof(YourCustomFilter))]</code> </pre> <br><p> Забавная штука – можно создать свое middleware и добавлять его каким-то action в качестве фильтра. Для того чтобы сделать так нужно создать класс с произвольным названием и методом Configure </p><br><pre> <code class="plaintext hljs"> public class MyMiddlewareFilter { public void Configure(IApplicationBuilder applicationBuilder) { applicationBuilder.Use(async (context, next) =&gt; { Debug.WriteLine("Привет от middleware!"); await next.Invoke(); }); } }</code> </pre> <br><p> Теперь этот класс можно добавлять Action-ам с помощью следующего атрибута </p><br><pre> <code class="plaintext hljs"> [MiddlewareFilter(typeof(MyMiddlewareFilter))]</code> </pre> </div>