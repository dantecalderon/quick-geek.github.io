<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Algorithm of thinking and consciousness</title>
  <meta name="description" content="This article outlines the algorithm of thinking and consciousness. I offer my answer to the question of how thinking and consciousness work. And I dem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Algorithm of thinking and consciousness</h1><div class="post__text post__text-html js-mediator-article">  This article outlines the algorithm of thinking and consciousness.  I offer my answer to the question of how thinking and consciousness work.  And I demonstrate an algorithm that can truly, creatively, think and has a real consciousness.  The article is designed for programmers and consists of two main parts.  The first part is purely technical, it contains a description of the algorithm, a list of its properties and an example of practical application.  The second part contains explanatory theses and solution of the issue of constructive axiomatization of consciousness.  The algorithm is a meaningful text that speaks for itself, and therefore the comments will be only a practically necessary minimum. <br><a name="habracut"></a><br><h2>  Algorithm Description </h2><br>  The description of the algorithm is made in a home-made mathematized formalism from the top-down principle, that is, the final, abstract record is first given, and then the algorithm is analyzed for parts in the order of making calls and comments are given.  So, the ‚Äúassembled‚Äù algorithm is a recursive function of the following form: <br><br>  <font color="#0000ff">t <sub>n + 1</sub> = <b>composition</b> [ <b>abstraction</b> [ <b>deduction</b> [t <sub>n</sub> ]]];</font>  <font color="#0000ff">t <sub>0</sub> = s;</font>  <font color="#0000ff">t <sub>n</sub> , s ‚àà <b>S</b> ;</font>  <font color="#0000ff">n ‚àà <b>N</b></font> <br><br>  The calculation of this function is thinking.  As you can see, three operators appear in the record: <br>  <font color="#0000ff"><b>composition</b> []</font> , <font color="#0000ff"><b>abstraction</b> []</font> , <font color="#0000ff"><b>deduction</b> []</font> ;  there are also: the seed variable <font color="#0000ff">s ‚àà <b>S</b></font> , the set of rows of a special type <font color="#0000ff"><b>S</b></font> and the step number <font color="#0000ff">n ‚àà <b>N.</b></font>  Next, consider in detail each part.  Let's start with the set <font color="#0000ff"><b>S</b></font> and its elements. <br><br>  In order to specify the set <font color="#0000ff"><b>S,</b></font> it is necessary to determine the syntax in which the elements of this set will be written.  The elements of <font color="#0000ff"><b>S</b></font> will be called strings.  Any string from <font color="#0000ff"><b>S</b></font> consists of a hierarchy of brackets ‚Äú(‚Äú, ‚Äù)‚Äù, and arbitrary character identifiers are written inside brackets.  In order to avoid the use of the term ‚Äúidentifier‚Äù, since it may be required for other purposes, symbolic identifiers inside brackets will be referred to as ‚Äúmnemonics‚Äù.  Each mnemonic is written in Latin characters ‚ÄúA - z‚Äù.  Mnemonics inside brackets can be separated by a comma ‚Äú,‚Äù.  If the length of the mnemonics is fixed, which is negotiated separately, the separator is not set.  Mnemonics are written only inside brackets.  The string can have nested brackets.  The hierarchy of brackets in the string is arbitrary, but there must be a closing one for each opening bracket.  In this article, I will use only small letters of the Latin alphabet to write mnemonics, and the length of the mnemonics will be fixed, one letter corresponds to one mnemonic, I do not put a separator symbol.  String examples: <br><br>  <font color="#0000ff">() ‚â° ‚àÖ</font> - empty string. <br>  <font color="#0000ff">(a)</font> - a string containing one mnemonic ‚Äú <font color="#0000ff">a</font> ‚Äù. <br>  <font color="#0000ff">(aa)</font> is a string containing two instances of the ‚Äú <font color="#0000ff">a</font> ‚Äù mnemonic. <br>  <font color="#0000ff">(ab)</font> - a string containing two mnemonics ‚Äú <font color="#0000ff">a</font> ‚Äù and ‚Äú <font color="#0000ff">b</font> ‚Äù. <br>  <font color="#0000ff">((a) (a))</font> - the string contains two instances of the ‚Äú <font color="#0000ff">a</font> ‚Äù mnemonic and nested levels of brackets. <br><br>  Nested brackets, together with their contents, as well as individual mnemonics will sometimes be called ‚Äústring components‚Äù, in those cases where an appropriate generalization is required.  For example, the string <font color="#0000ff">((a) ab)</font> contains four components, among them: two components ‚Äú <font color="#0000ff">a</font> ‚Äù, one component ‚Äú <font color="#0000ff">(a)</font> ‚Äù and one component ‚Äú <font color="#0000ff">b</font> ‚Äù. <br><br>  Records of lines that coincide up to permutation of components within a line are considered identical.  Examples of identical strings: <br><br>  <font color="#0000ff">(ab) (ba)</font> . <br>  <font color="#0000ff">((a) (b)) ‚â° ((b) (a))</font> . <br>  <font color="#0000ff">(abc) ‚â° (bac) ‚â° (cba) ‚â° (acb) (bca) ‚â° (cab)</font> . <br>  <font color="#0000ff">((a) (ab)) ‚â° ((a) (ba)) ‚â° ((ab) (a)) ((ba) (a))</font> . <br><br>  Strings can contain any number of identical, repeating components, and in this case, the abbreviated notation is allowed using the repetition index, which is placed before the component on the left, without a separator.  Examples: <br><br>  <font color="#0000ff">(aa) (2a)</font> . <br>  <font color="#0000ff">(aabb) ‚â° (2a2b)</font> . <br>  <font color="#0000ff">((a) (a)) ‚â° (2 (a))</font> . <br>  <font color="#0000ff">((aa) (aa)) ‚â° (2 (2a))</font> . <br>  <font color="#0000ff">(aa (bb) (bb) (ccc) (ccc) (ccc)) ‚â° (2a2 (2b) 3 (3c))</font> . <br><br>  In cases where the string contains empty components, for example, <font color="#0000ff">(a ())</font> , <font color="#0000ff">(a () () (b)) the</font> following identities take place: <font color="#0000ff">(a ()) (a)</font> , <font color="#0000ff">(a () () (b )) (A (b))</font> , that is, empty components are discarded. <br><br>  <b>Definition</b>  The set <font color="#0000ff"><b>S</b></font> consists of all possible strings that satisfy the above syntactic criteria, including the empty string. <br><br>  The deduction, abstraction, and composition operators are defined on the set <font color="#0000ff"><b>S.</b></font>  Operator arguments are specified in square brackets <font color="#0000ff">[]</font> , because parentheses are reserved for string syntax.  The term ‚Äúoperator‚Äù is synonymous with the term ‚Äúfunction‚Äù. <br><br>  <b>Deduction operator</b> .  Definition  <font color="#0000ff">‚ààs ‚àà <b>S</b> , <b>deduction</b> <sup>k</sup> [s] ‚àà <b>S</b> , k ‚àà <b>N</b> , k&gt; 1, <b>deduction</b> [s] <b>deduction</b> <sup>2</sup> [s]</font> .  It takes the string <font color="#0000ff">s</font> from <font color="#0000ff"><b>S</b></font> as an argument.  As a result, returns a string from <font color="#0000ff"><b>s</b></font> .  Act.  The operator <font color="#0000ff">k</font> duplicates every component of a line and the entire line once.  The resulting design is framed by common outer brackets.  Duplication begins with the deepest, in terms of nesting, component.  The entire line is duplicated last.  For the closest practical purposes, it is enough that <font color="#0000ff">k = 2</font> , so I defined a special case of <font color="#0000ff"><b>deduction</b> [s] <b>deduction</b> <sup>2</sup> [s]</font> .  The use of <font color="#0000ff"><b>deduction</b> []</font> implies that <font color="#0000ff">k = 2</font> , that is, as a result of the <font color="#0000ff"><b>deduction</b> [s]</font> operator, all components of the string <font color="#0000ff">s are</font> doubled.  Examples: <br><br>  <font color="#0000ff"><b>deduction</b> [(a)] = ((aa) (aa)).</font> <font color="#0000ff"><br></font>  <font color="#0000ff"><b>deduction</b> [(aa)] = ((aaaa) (aaaa))</font> <font color="#0000ff"><br></font>  <font color="#0000ff"><b>deduction</b> [(ab)] = ((aabb) (aabb)).</font> <font color="#0000ff"><br></font>  <font color="#0000ff"><b>deduction</b> [(a (b))] = ((aa (bb) (bb)) (aa (bb) (bb))).</font> <font color="#0000ff"><br></font>  <font color="#0000ff"><b>deduction</b> [((a) (b))] = (((aa) (aa) (bb) (bb)) ((aa) (aa) (bb) (bb))).</font> <font color="#0000ff"><br></font>  <font color="#0000ff"><b>deduction</b> [((a) (b (cc)))] = (((aa) (aa) (bb (cccc) (cccc)) (bb (cccc) (cccc))) ((aa) (aa) ( bb (cccc) (cccc)) (bb (cccc) (cccc))))</font> . <br><br>  <b>Abstraction operator</b> .  Definition  <font color="#0000ff">‚ààs ‚àà <b>S</b> , <b>abstraction</b> [s] ‚äÇ <b>S.</b></font>  It takes the string <font color="#0000ff">s</font> from <font color="#0000ff"><b>S</b></font> as an argument.  As a result, returns multiple rows.  Operating principle.  From the source line, the abstraction operator creates a set of lines using a special operation ‚Äî putting the same components out of the brackets.  The bracketing operation applies only to nested brackets that are at the same nesting level.  The general principle of making brackets.  If in any combination of brackets located at the same level, there are identical components inside the brackets, then any set of identical components can be put out of brackets, and components that remain intact should be combined under one common brackets of the same level.  Consider an example.  The string <font color="#0000ff">((ab) (ac))</font> .  In this line, at the same level there are two substrings: <font color="#0000ff">(ab)</font> and <font color="#0000ff">(ac)</font> , inside which there is the same mnemonic " <font color="#0000ff">a</font> ", this mnemonic can be taken out of the brackets and the result will be <font color="#0000ff">(a (bc))</font> .  As you can see, the remaining mnemonics " <font color="#0000ff">b</font> " and " <font color="#0000ff">c</font> " are united in common brackets.  Consider a less obvious example.  The string <font color="#0000ff">((aa) (aa))</font> contains the substrings <font color="#0000ff">(aa)</font> and <font color="#0000ff">(aa)</font> , in this case there are two different options for brackets.  In the first variant, only one " <font color="#0000ff">a</font> " mnemonic can be bracketed from each substring, and in the second variant, the " <font color="#0000ff">aa</font> " mnemonic group can be taken out.  Consider both options in more detail. <br><br>  The first option, a step-by-step demonstration: <br><br><ol><li>  Step one, choose ( <font color="#ff0000">red</font> ) what to endure <font color="#0000ff">(( <font color="#ff0000">a</font> a) ( <font color="#ff0000">a</font> a))</font> . </li><li>  Step two, we carry out the selected <font color="#0000ff">( <font color="#ff0000">a</font> (... a) (... a))</font> . </li><li>  Step three, combine the residuals in common brackets <font color="#0000ff">( <font color="#ff0000">a</font> (... a ... a))</font> . </li><li>  Result <font color="#0000ff">(a (aa))</font> . </li></ol><br>  The second option, in steps: <br><br><ol><li>  Step one, choose what to endure <font color="#0000ff">(( <font color="#ff0000">aa</font> ) ( <font color="#ff0000">aa</font> ))</font> . </li><li>  Step two, submit the selected <font color="#0000ff">( <font color="#ff0000">aa</font> (...) (...))</font> . </li><li>  Step three, combine the residuals in common brackets <font color="#0000ff">( <font color="#ff0000">aa</font> (...))</font> . </li><li>  Step four, discard empty components <font color="#0000ff">( <font color="#ff0000">aa</font> )</font> . </li><li>  Result <font color="#0000ff">(aa)</font> . </li></ol><br>  Let's complicate an example.  Let the string be given <font color="#0000ff">((aa) (aab) (aab))</font> , it has three substrings located on the same level: <font color="#0000ff">(aa)</font> , <font color="#0000ff">(aab)</font> , <font color="#0000ff">(aab)</font> , all three have the same content.  The rule of making brackets does not oblige us to carry out the operation at once for all three substrings.  For a pull operation, you can select any group of substrings. <br><br>  In this case, there are three non-identical options for grouping substrings: <br><br><ol><li>  <font color="#0000ff">(aa), (aab)</font> . </li><li>  <font color="#0000ff">(aab), (aab)</font> . </li><li>  <font color="#0000ff">(aa), (aab), (aab)</font> . </li></ol><br>  We will carry out all possible derivations for each of the grouping options, step by step. <br><br>  Grouping <font color="#0000ff">(aa)</font> , <font color="#0000ff">(aab)</font> .  The string <font color="#0000ff">((aa) (aab) (aab))</font> . <br><br>  First option: <br><br><ol><li>  Select the content <font color="#0000ff">(( <font color="#ff0000">a</font> a) ( <font color="#ff0000">a</font> ab) (aab))</font> . </li><li>  We take out <font color="#0000ff">( <font color="#ff0000">a</font> (... a) (... ab) (aab))</font> . </li><li>  We unite <font color="#0000ff">( <font color="#ff0000">a</font> (... a ... ab) (aab))</font> . </li><li>  Result # 1 <font color="#0000ff">(a (aab) (aab))</font> . </li></ol><br>  The second option: <br><br><ol><li>  Select the content <font color="#0000ff">(( <font color="#ff0000">aa</font> ) ( <font color="#ff0000">aa</font> b) (aab))</font> . </li><li>  We take out <font color="#0000ff">( <font color="#ff0000">aa</font> (...) (... b) (aab))</font> . </li><li>  We unite <font color="#0000ff">( <font color="#ff0000">aa</font> (... b) (aab))</font> . </li><li>  Result # 2 <font color="#0000ff">(a (b) (aab))</font> . </li></ol><br>  Grouping <font color="#0000ff">(aab)</font> , <font color="#0000ff">(aab)</font> .  The string <font color="#0000ff">((aa) (aab) (aab))</font> . <br><br>  First option: <br><br><ol><li>  Select the content <font color="#0000ff">((aa) ( <font color="#ff0000">a</font> ab) ( <font color="#ff0000">a</font> ab))</font> . </li><li>  We take out <font color="#0000ff">((aa) <font color="#ff0000">a</font> (... ab) (... ab))</font> . </li><li>  We unite <font color="#0000ff">((aa) <font color="#ff0000">a</font> (... ab ... ab))</font> . </li><li>  Result # 3 <font color="#0000ff">(a (aa) (aabb))</font> . </li></ol><br>  The second option: <br><br><ol><li>  Select the content <font color="#0000ff">((aa) ( <font color="#ff0000">aa</font> b) ( <font color="#ff0000">aa</font> b))</font> . </li><li>  We take out <font color="#0000ff">((aa) <font color="#ff0000">aa</font> (... b) (... b))</font> . </li><li>  We unite <font color="#0000ff">((aa) <font color="#ff0000">aa</font> (... b ... b))</font> . </li><li>  Result # 4 <font color="#0000ff">(aa (aa) (bb))</font> . </li></ol><br>  The third option: <br><br><ol><li>  Select the content <font color="#0000ff">((aa) (a <font color="#ff0000">ab</font> ) (a <font color="#ff0000">ab</font> ))</font> . </li><li>  We take out <font color="#0000ff">((aa) <font color="#ff0000">ab</font> (... a) (... a))</font> . </li><li>  We unite <font color="#0000ff">((aa) <font color="#ff0000">ab</font> (... a ... a))</font> . </li><li>  Result # 5 <font color="#0000ff">(ab (aa) (aa))</font> . </li></ol><br>  Fourth option: <br><br><ol><li>  Select the content <font color="#0000ff">((aa) (aa <font color="#ff0000">b</font> ) (aa <font color="#ff0000">b</font> ))</font> . </li><li>  We take out <font color="#0000ff">((aa) <font color="#ff0000">b</font> (... aa) (... aa))</font> . </li><li>  We unite <font color="#0000ff">((aa) <font color="#ff0000">b</font> (... aa ... aa))</font> . </li><li>  Result # 6 <font color="#0000ff">(b (aa) (aaaa))</font> . </li></ol><br>  Fifth option: <br><br><ol><li>  Select the content <font color="#0000ff">((aa) ( <font color="#ff0000">aab</font> ) ( <font color="#ff0000">aab</font> ))</font> . </li><li>  We take out <font color="#0000ff">((aa) <font color="#ff0000">aab</font> (...) (...))</font> . </li><li>  We unite <font color="#0000ff">((aa) <font color="#ff0000">aab</font> (...))</font> . </li><li>  Result number 7 <font color="#0000ff">(aab (aa))</font> . </li></ol><br>  Grouping <font color="#0000ff">(aa)</font> , <font color="#0000ff">(aab)</font> , <font color="#0000ff">(aab)</font> .  The string <font color="#0000ff">((aa) (aab) (aab))</font> . <br><br>  First option: <br><br><ol><li>  Select the content <font color="#0000ff">(( <font color="#ff0000">a</font> a) ( <font color="#ff0000">a</font> ab) ( <font color="#ff0000">a</font> ab))</font> . </li><li>  We take out <font color="#0000ff">( <font color="#ff0000">a</font> (... a) (... ab) (... ab))</font> . </li><li>  We unite <font color="#0000ff">( <font color="#ff0000">a</font> (... a ... ab ... ab))</font> . </li><li>  Result # 8 <font color="#0000ff">(a (aaabb))</font> . </li></ol><br>  The second option: <br><br><ol><li>  Select the content <font color="#0000ff">(( <font color="#ff0000">aa</font> ) ( <font color="#ff0000">aa</font> b) ( <font color="#ff0000">aa</font> b))</font> . </li><li>  We take out <font color="#0000ff">( <font color="#ff0000">aa</font> (...) (... b) (... b))</font> . </li><li>  We unite <font color="#0000ff">( <font color="#ff0000">aa</font> (... b ... b))</font> . </li><li>  Result # 9 <font color="#0000ff">(aa (bb))</font> . </li></ol><br>  <b>Action abstraction operator</b> .  As you can see from the example, for the source line <font color="#0000ff">((aa) (aab) (aab))</font> there are nine different options to put something out of the brackets, and nine resulting lines correspond to these options.  This is the way the abstraction operator acts - it goes through all the possible options for putting it out of the brackets and builds the corresponding set of resulting lines.  Moreover, the abstraction operator is looking for options for rendering not only in the source line, but also in all the resulting result lines.  In other words, the abstraction operator is recursively applied to its results, and so on until all possible options have been exhausted.  For obvious reasons, for any finite string, the number of possible rendering options is also finite. <br><br>  Let's return to the previous example.  In the above example, I wrote out not all possible options, but only nine pieces of the first level.  In order to illustrate the full action of the abstraction operator, it is also necessary to construct all the variants for putting out of brackets for each of the nine previously obtained results.  We write out all the options, but in a more compressed form. <br><br>  Result number 1 <font color="#0000ff">(a (aab) (aab))</font> : <br><br>  1.1.  <font color="#0000ff">(a ( <font color="#ff0000">a</font> ab) ( <font color="#ff0000">a</font> ab)) =&gt; (a <font color="#ff0000">a</font> (aabb))</font> . <br>  1.2.  <font color="#0000ff">(a ( <font color="#ff0000">aa</font> b) ( <font color="#ff0000">aa</font> b)) =&gt; (a <font color="#ff0000">aa</font> (bb))</font> . <br>  1.3.  <font color="#0000ff">(a (a <font color="#ff0000">ab</font> ) (a <font color="#ff0000">ab</font> )) =&gt; (a <font color="#ff0000">ab</font> (aa))</font> .  * ‚Ññ7 <br>  1.4.  <font color="#0000ff">(a ( <font color="#ff0000">aab</font> ) ( <font color="#ff0000">aab</font> )) =&gt; (a <font color="#ff0000">aab</font> )</font> . <br>  1.5.  <font color="#0000ff">(a (aa <font color="#ff0000">b</font> ) (aa <font color="#ff0000">b</font> )) =&gt; (a <font color="#ff0000">b</font> (aaaa))</font> . <br>  Result # 2 <font color="#0000ff">(a (b) (aab))</font> : <br>  2.1.  <font color="#0000ff">(a ( <font color="#ff0000">b</font> ) (aa <font color="#ff0000">b</font> )) =&gt; (a <font color="#ff0000">b</font> (aa))</font> . <br>  Result number 3 <font color="#0000ff">(a (aa) (aabb))</font> : <br>  3.1.  <font color="#0000ff">(a ( <font color="#ff0000">a</font> a) ( <font color="#ff0000">a</font> abb)) =&gt; (a <font color="#ff0000">a</font> (aabb))</font> .  * ‚Ññ1.1 <br>  3.2.  <font color="#0000ff">(a ( <font color="#ff0000">aa</font> ) ( <font color="#ff0000">aa</font> bb)) =&gt; (a <font color="#ff0000">aa</font> (bb))</font> .  * ‚Ññ1.2 <br>  Result # 4 <font color="#0000ff">(aa (aa) (bb))</font> . <br>  Result # 5 <font color="#0000ff">(ab (aa) (aa))</font> : <br>  5.1.  <font color="#0000ff">(ab ( <font color="#ff0000">a</font> a) ( <font color="#ff0000">a</font> a)) =&gt; ( <font color="#ff0000">a</font> ab (aa))</font> .  * ‚Ññ7, * ‚Ññ1.3 <br>  5.2.  <font color="#0000ff">(ab ( <font color="#ff0000">aa</font> ) ( <font color="#ff0000">aa</font> )) =&gt; ( <font color="#ff0000">aa</font> ab)</font> .  * ‚Ññ1.4 <br>  Result # 6 <font color="#0000ff">(b (aa) (aaaa))</font> : <br>  6.1.  <font color="#0000ff">(b ( <font color="#ff0000">a</font> a) ( <font color="#ff0000">a</font> aaa)) =&gt; ( <font color="#ff0000">a</font> b (aaaa))</font> .  * ‚Ññ1.5 <br>  6.2.  <font color="#0000ff">(b ( <font color="#ff0000">aa</font> ) ( <font color="#ff0000">aa</font> aa)) =&gt; ( <font color="#ff0000">aa</font> b (aa))</font> .  * ‚Ññ7, * ‚Ññ1.3, * ‚Ññ5.1 <br>  Result number 7 <font color="#0000ff">(aab (aa))</font> . <br>  Result # 8 <font color="#0000ff">(a (aaabb))</font> . <br>  Result # 9 <font color="#0000ff">(aa (bb))</font> . <br><br>  An asterisk indicates options that repeat.  Only unique variations are included in the result of the abstraction.  In the example that was parsed, there are fourteen unique result rows.  Total: <br><br>  <font color="#0000ff"><b>abstraction</b> [((aa) (aab) (aab))] =</font> <font color="#0000ff"><br></font>  <font color="#0000ff">{</font> <font color="#0000ff"><br></font>  <font color="#0000ff">(a (aab) (aab)), (aa (aabb)), (aaa (bb)), (aaab), (a (b) (aab)), (ab (aa)), (a (aa) (aabb)), (aa (aa) (bb)), (ab (aa) (aa)), (b (aa) (aaaa)), (ab (aaaa)), (aab (aa)), ( a (aaabb)), (aa (bb))</font> <font color="#0000ff"><br></font>  <font color="#0000ff">}</font> <br><br>  For more clarity, consider a couple of examples. <br><br>  The string <font color="#0000ff">((a (b)) (a (b)))</font> .  Options for making brackets.  First iteration: <br><br>  <font color="#0000ff">(( <font color="#ff0000">a</font> (b)) ( <font color="#ff0000">a</font> (b))) =&gt; ( <font color="#ff0000">a</font> ((b) (b)))</font> , the result is ‚Ññ1. <br>  <font color="#0000ff">((a <font color="#ff0000">(b)</font> ) (a <font color="#ff0000">(b)</font> )) =&gt; ( <font color="#ff0000">(b)</font> (aa))</font> , the result is ‚Ññ2. <br>  <font color="#0000ff">(( <font color="#ff0000">a (b)</font> ) ( <font color="#ff0000">a (b)</font> )) =&gt; ( <font color="#ff0000">a (b)</font> )</font> , the result is ‚Ññ3. <br>  In the first result, we can make one more rendering.  Second iteration: <br>  <font color="#0000ff">(a (( <font color="#ff0000">b</font> ) ( <font color="#ff0000">b</font> ))) =&gt; (a ( <font color="#ff0000">b</font> ))</font> , the result ‚Ññ1.2 coincides with the result ‚Ññ3. <br><br>  Total: <font color="#0000ff"><b>abstraction</b> [((a (b)) (a (b)))] = {(a ((b) (b))), ((b) (aa)), (a (b))}</font> <br><br><div class="spoiler">  <b class="spoiler_title">Great example:</b> <div class="spoiler_text">  <font color="#0000ff"><b>abstraction</b> [ <b>deduction</b> [(a (b))]] = <b>abstraction</b> [((aa (bb) (bb)) (aa (bb) (bb)))] = =</font> <br>  1. <font color="#0000ff">((aa ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b)) (aa (bb) (bb))) =&gt; ((aa <font color="#ff0000">b</font> (b)) (aa (bb) (bb)))</font> . <br>  1.1.  <font color="#0000ff">(( <font color="#ff0000">a</font> ab (b)) ( <font color="#ff0000">a</font> a (bb) (bb))) =&gt; ( <font color="#ff0000">a</font> (aab (b) (bb) (bb)))</font> . <br>  1.1.1.  <font color="#0000ff">(a (aab ( <font color="#ff0000">b</font> ) ( <font color="#ff0000">b</font> b) (bb))) =&gt; (a (aab <font color="#ff0000">b</font> (b) (bb)))</font> . <br>  1.1.1.1.  <font color="#0000ff">(a (aabb ( <font color="#ff0000">b</font> ) ( <font color="#ff0000">b</font> b))) =&gt; (a (aabb <font color="#ff0000">b</font> (b)))</font> . <br>  1.1.2.  <font color="#0000ff">(a (aab ( <font color="#ff0000">b</font> ) ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; (a (aab <font color="#ff0000">b</font> (bb)))</font> . <br>  1.1.3.  <font color="#0000ff">(a (aab (b) ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; (a (aab <font color="#ff0000">b</font> (b) (bb)))</font> . <br>  1.1.3.1.  <font color="#0000ff">(a (aabb ( <font color="#ff0000">b</font> ) ( <font color="#ff0000">b</font> b))) =&gt; (a (aabb <font color="#ff0000">b</font> (b)))</font> . <br>  1.1.4.  <font color="#0000ff">(a (aab (b) ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (a (aab <font color="#ff0000">bb</font> (b)))</font> . <br>  1.2.  <font color="#0000ff">(( <font color="#ff0000">aa</font> b (b)) ( <font color="#ff0000">aa</font> (bb) (bb))) =&gt; ( <font color="#ff0000">aa</font> (b (b) (bb) (bb)))</font> . <br>  1.2.1.  <font color="#0000ff">(aa (b ( <font color="#ff0000">b</font> ) ( <font color="#ff0000">b</font> b) (bb))) =&gt; (aa (b <font color="#ff0000">b</font> (b) (bb)))</font> . <br>  1.2.1.1.  <font color="#0000ff">(aa (bb ( <font color="#ff0000">b</font> ) ( <font color="#ff0000">b</font> b))) =&gt; (aa (bb <font color="#ff0000">b</font> (b)))</font> . <br>  1.2.2.  <font color="#0000ff">(aa (b ( <font color="#ff0000">b</font> ) ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; (aa (b <font color="#ff0000">b</font> (bb)))</font> . <br>  1.2.3.  <font color="#0000ff">(aa (b (b) ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; (aa (b <font color="#ff0000">b</font> (b) (bb)))</font> . <br>  1.2.3.1.  <font color="#0000ff">(aa (bb ( <font color="#ff0000">b</font> ) ( <font color="#ff0000">b</font> b))) =&gt; (aa (bb <font color="#ff0000">b</font> (b)))</font> . <br>  1.2.4.  <font color="#0000ff">(aa (b (b) ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (aa (b <font color="#ff0000">bb</font> (b)))</font> . <br>  1.3.  <font color="#0000ff">((aab (b)) (aa ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; ((aab (b)) (aa <font color="#ff0000">b</font> (bb)))</font> . <br>  1.3.1.  <font color="#0000ff">(( <font color="#ff0000">a</font> ab (b)) ( <font color="#ff0000">a</font> ab (bb))) =&gt; ( <font color="#ff0000">a</font> (aabb (b) (bb)))</font> . <br>  1.3.1.1.  <font color="#0000ff">(a (aabb ( <font color="#ff0000">b</font> ) ( <font color="#ff0000">b</font> b))) =&gt; (a (aabb <font color="#ff0000">b</font> (b)))</font> . <br>  1.3.2.  <font color="#0000ff">(( <font color="#ff0000">aa</font> b (b)) ( <font color="#ff0000">aa</font> b (bb))) =&gt; ( <font color="#ff0000">aa</font> (bb (b) (bb)))</font> . <br>  1.3.2.1.  <font color="#0000ff">(aa (bb ( <font color="#ff0000">b</font> ) ( <font color="#ff0000">b</font> b))) =&gt; (aa (bb <font color="#ff0000">b</font> (b)))</font> . <br>  1.3.3.  <font color="#0000ff">(( <font color="#ff0000">aab</font> (b)) ( <font color="#ff0000">aab</font> (bb))) =&gt; ( <font color="#ff0000">aab</font> ((b) (bb)))</font> . <br>  1.3.3.1.  <font color="#0000ff">(aab (( <font color="#ff0000">b</font> ) ( <font color="#ff0000">b</font> b))) =&gt; (aab ( <font color="#ff0000">b</font> (b)))</font> . <br>  1.3.4.  <font color="#0000ff">((a <font color="#ff0000">ab</font> (b)) (a <font color="#ff0000">ab</font> (bb))) =&gt; ( <font color="#ff0000">ab</font> (aa (b) (bb)))</font> . <br>  1.3.4.1.  <font color="#0000ff">(ab (aa ( <font color="#ff0000">b</font> ) ( <font color="#ff0000">b</font> b))) =&gt; (ab (aa <font color="#ff0000">b</font> (b)))</font> . <br>  1.3.5.  <font color="#0000ff">((aa <font color="#ff0000">b</font> (b)) (aa <font color="#ff0000">b</font> (bb))) =&gt; ( <font color="#ff0000">b</font> (aaaa (b) (bb)))</font> . <br>  1.3.5.1.  <font color="#0000ff">(b (aaaa ( <font color="#ff0000">b</font> ) ( <font color="#ff0000">b</font> b))) =&gt; (b (aaaa <font color="#ff0000">b</font> (b)))</font> . <br>  1.4.  <font color="#0000ff">((aab (b)) (aa ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; ((aab (b)) (aa <font color="#ff0000">bb</font> ))</font> . <br>  1.4.1.  <font color="#0000ff">(( <font color="#ff0000">a</font> ab (b)) ( <font color="#ff0000">a</font> abb)) =&gt; ( <font color="#ff0000">a</font> (aabbb (b)))</font> . <br>  1.4.2.  <font color="#0000ff">(( <font color="#ff0000">aa</font> b (b)) ( <font color="#ff0000">aa</font> bb)) =&gt; ( <font color="#ff0000">aa</font> (bbb (b)))</font> . <br>  1.4.3.  <font color="#0000ff">(( <font color="#ff0000">aab</font> (b)) ( <font color="#ff0000">aab</font> b)) =&gt; ( <font color="#ff0000">aab</font> (b (b)))</font> . <br>  1.4.4.  <font color="#0000ff">((a <font color="#ff0000">ab</font> (b)) (a <font color="#ff0000">ab</font> b)) =&gt; ( <font color="#ff0000">ab</font> (aab (b)))</font> . <br>  1.4.5.  <font color="#0000ff">((aa <font color="#ff0000">b</font> (b)) (aa <font color="#ff0000">b</font> b)) =&gt; ( <font color="#ff0000">b</font> (aaaab (b)))</font> . <br>  2. <font color="#0000ff">((aa ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> )) (aa (bb) (bb))) =&gt; ((aa <font color="#ff0000">bb</font> ) (aa (bb) (bb)))</font> . <br>  2.1.  <font color="#0000ff">((aabb) (aa ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; ((aabb) (aa <font color="#ff0000">b</font> (bb)))</font> . <br>  2.1.1.  <font color="#0000ff">(( <font color="#ff0000">a</font> abb) ( <font color="#ff0000">a</font> ab (bb))) =&gt; ( <font color="#ff0000">a</font> (aabbb (bb)))</font> . <br>  2.1.2.  <font color="#0000ff">(( <font color="#ff0000">aa</font> bb) ( <font color="#ff0000">aa</font> b (bb))) =&gt; ( <font color="#ff0000">aa</font> (bbb (bb)))</font> . <br>  2.1.3.  <font color="#0000ff">(( <font color="#ff0000">aab</font> b) ( <font color="#ff0000">aab</font> (bb))) =&gt; ( <font color="#ff0000">aab</font> (b (bb)))</font> . <br>  2.1.4.  <font color="#0000ff">((a <font color="#ff0000">ab</font> b) (a <font color="#ff0000">ab</font> (bb))) =&gt; ( <font color="#ff0000">ab</font> (aab (bb)))</font> . <br>  2.1.5.  <font color="#0000ff">((aa <font color="#ff0000">b</font> b) (aa <font color="#ff0000">b</font> (bb))) =&gt; ( <font color="#ff0000">b</font> (aaaab (bb)))</font> . <br>  2.2.  <font color="#0000ff">((aabb) (aa ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; ((aabb) (aa <font color="#ff0000">bb</font> ))</font> . <br>  2.2.1.  <font color="#0000ff">(( <font color="#ff0000">a</font> abb) ( <font color="#ff0000">a</font> abb)) =&gt; ( <font color="#ff0000">a</font> (aabbbb))</font> . <br>  2.2.2.  <font color="#0000ff">(( <font color="#ff0000">aa</font> bb) ( <font color="#ff0000">aa</font> bb)) =&gt; ( <font color="#ff0000">aa</font> (bbbb))</font> . <br>  2.2.3.  <font color="#0000ff">(( <font color="#ff0000">aab</font> b) ( <font color="#ff0000">aab</font> b)) =&gt; ( <font color="#ff0000">aab</font> (bb))</font> . <br>  2.2.4.  <font color="#0000ff">((a <font color="#ff0000">abb</font> ) (a <font color="#ff0000">abb</font> )) =&gt; ( <font color="#ff0000">abb</font> (aa))</font> . <br>  2.2.5.  <font color="#0000ff">(( <font color="#ff0000">aabb</font> ) ( <font color="#ff0000">aabb</font> )) =&gt; ( <font color="#ff0000">aabb</font> )</font> . <br>  2.2.6.  <font color="#0000ff">((a <font color="#ff0000">ab</font> b) (a <font color="#ff0000">ab</font> b)) =&gt; ( <font color="#ff0000">ab</font> (aabb))</font> . <br>  2.2.7.  <font color="#0000ff">((aa <font color="#ff0000">b</font> b) (aa <font color="#ff0000">b</font> b)) =&gt; ( <font color="#ff0000">b</font> (aaaabb))</font> . <br>  2.2.8.  <font color="#0000ff">((aa <font color="#ff0000">bb</font> ) (aa <font color="#ff0000">bb</font> )) =&gt; ( <font color="#ff0000">bb</font> (aaaa))</font> . <br>  2.3.  <font color="#0000ff">(( <font color="#ff0000">a</font> abb) ( <font color="#ff0000">a</font> a (bb) (bb))) =&gt; ( <font color="#ff0000">a</font> (aabb (bb) (bb)))</font> . <br>  2.3.1.  <font color="#0000ff">(a (aabb ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; (a (aabb <font color="#ff0000">b</font> (bb)))</font> . <br>  2.3.2.  <font color="#0000ff">(a (aabb ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (a (aabb <font color="#ff0000">bb</font> ))</font> . <br>  2.4.  <font color="#0000ff">(( <font color="#ff0000">aa</font> bb) ( <font color="#ff0000">aa</font> (bb) (bb))) =&gt; ( <font color="#ff0000">aa</font> (bb (bb) (bb)))</font> . <br>  2.4.1.  <font color="#0000ff">(aa (bb ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; (aa (bb <font color="#ff0000">b</font> (bb)))</font> . <br>  2.4.2.  <font color="#0000ff">(aa (bb ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (aa (bb <font color="#ff0000">bb</font> ))</font> . <br>  3. <font color="#0000ff">(( <font color="#ff0000">a</font> a (bb) (bb)) ( <font color="#ff0000">a</font> a (bb) (bb))) =&gt; ( <font color="#ff0000">a</font> (aa (bb) (bb) (bb) (bb)))</font> . <br>  3.1.  <font color="#0000ff">(a (aa ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b) (bb) (bb))) =&gt; (a (aa <font color="#ff0000">b</font> (bb) (bb) (bb)))</font> . <br>  3.1.1.  <font color="#0000ff">(a (aab ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b) (bb))) =&gt; (a (aab <font color="#ff0000">b</font> (bb) (bb)))</font> . <br>  3.1.1.1.  <font color="#0000ff">(a (aabb ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; (a (aabb <font color="#ff0000">b</font> (bb)))</font> . <br>  3.1.1.2.  <font color="#0000ff">(a (aabb ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (a (aabb <font color="#ff0000">bb</font> ))</font> . <br>  3.1.2.  <font color="#0000ff">(a (aab ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; (a (aab <font color="#ff0000">b</font> (bbb)))</font> . <br>  3.1.3.  <font color="#0000ff">(a (aab ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) (bb))) =&gt; (a (aab <font color="#ff0000">bb</font> (bb)))</font> . <br>  3.1.4.  <font color="#0000ff">(a (aab ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (a (aab <font color="#ff0000">bb</font> ))</font> . <br>  3.2.  <font color="#0000ff">(a (aa ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) (bb) (bb))) =&gt; (a (aa <font color="#ff0000">bb</font> (bb) (bb)))</font> . <br>  3.2.1.  <font color="#0000ff">(a (aabb ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; (a (aabb <font color="#ff0000">b</font> (bb)))</font> . <br>  3.2.2.  <font color="#0000ff">(a (aabb ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (a (aabb <font color="#ff0000">bb</font> ))</font> . <br>  3.3.  <font color="#0000ff">(a (aa ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b) (bb))) =&gt; (a (aa <font color="#ff0000">b</font> (bbb) (bb)))</font> . <br>  3.3.1.  <font color="#0000ff">(a (aab ( <font color="#ff0000">b</font> bb) ( <font color="#ff0000">b</font> b))) =&gt; (a (aab <font color="#ff0000">b</font> (bbb)))</font> . <br>  3.3.2.  <font color="#0000ff">(a (aab ( <font color="#ff0000">bb</font> b) ( <font color="#ff0000">bb</font> ))) =&gt; (a (aab <font color="#ff0000">bb</font> (b)))</font> . <br>  3.4.  <font color="#0000ff">(a (aa ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; (a (aa <font color="#ff0000">b</font> (bbbb)))</font> . <br>  3.5.  <font color="#0000ff">(a (aa ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) (bb))) =&gt; (a (aa <font color="#ff0000">bb</font> (bb)))</font> . <br>  3.6.  <font color="#0000ff">(a (aa ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (a (aa <font color="#ff0000">bb</font> ))</font> . <br>  4. <font color="#0000ff">(( <font color="#ff0000">aa</font> (bb) (bb)) ( <font color="#ff0000">aa</font> (bb) (bb))) =&gt; ( <font color="#ff0000">aa</font> ((bb) (bb) (bb) (bb)))</font> . <br>  4.1.  <font color="#0000ff">(aa (( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b) (bb) (bb))) =&gt; (aa ( <font color="#ff0000">b</font> (bb) (bb) (bb)))</font> . <br>  4.1.1.  <font color="#0000ff">(aa (b ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b) (bb))) =&gt; (aa (b <font color="#ff0000">b</font> (bb) (bb)))</font> . <br>  4.1.1.1.  <font color="#0000ff">(aa (bb ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; (aa (bb <font color="#ff0000">b</font> (bb)))</font> . <br>  4.1.1.2.  <font color="#0000ff">(aa (bb ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (aa (bb <font color="#ff0000">bb</font> ))</font> . <br>  4.1.2.  <font color="#0000ff">(aa (b ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; (aa (b <font color="#ff0000">b</font> (bbb)))</font> . <br>  4.1.3.  <font color="#0000ff">(aa (b ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) (bb))) =&gt; (aa (b <font color="#ff0000">bb</font> (bb)))</font> . <br>  4.1.4.  <font color="#0000ff">(aa (b ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (aa (b <font color="#ff0000">bb</font> ))</font> . <br>  4.2.  <font color="#0000ff">(aa (( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) (bb) (bb))) =&gt; (aa ( <font color="#ff0000">bb</font> (bb) (bb)))</font> . <br>  4.2.1.  <font color="#0000ff">(aa (bb ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; (aa (bb <font color="#ff0000">b</font> (bb)))</font> . <br>  4.2.2.  <font color="#0000ff">(aa (bb ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (aa (bb <font color="#ff0000">bb</font> ))</font> . <br>  4.3.  <font color="#0000ff">(aa (( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b) (bb))) =&gt; (aa ( <font color="#ff0000">b</font> (bbb) (bb)))</font> . <br>  4.3.1.  <font color="#0000ff">(aa (b ( <font color="#ff0000">b</font> bb) ( <font color="#ff0000">b</font> b))) =&gt; (aa (b <font color="#ff0000">b</font> (bbb)))</font> . <br>  4.3.2.  <font color="#0000ff">(aa (b ( <font color="#ff0000">bb</font> b) ( <font color="#ff0000">bb</font> ))) =&gt; (aa (b <font color="#ff0000">bb</font> (b)))</font> . <br>  4.4.  <font color="#0000ff">(aa (( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; (aa ( <font color="#ff0000">b</font> (bbbb)))</font> . <br>  4.5.  <font color="#0000ff">(aa (( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) (bb))) =&gt; (aa ( <font color="#ff0000">bb</font> (bb)))</font> . <br>  4.6.  <font color="#0000ff">(aa (( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (aa ( <font color="#ff0000">bb</font> ))</font> . <br>  5. <font color="#0000ff">((aa <font color="#ff0000">(bb)</font> (bb)) (aa <font color="#ff0000">(bb)</font> (bb))) =&gt; ( <font color="#ff0000">(bb)</font> (aaaa (bb) (bb)))</font> . <br>  5.1.  <font color="#0000ff">((bb) (aaaa ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; ((bb) (aaaa <font color="#ff0000">b</font> (bb)))</font> . <br>  5.1.1.  <font color="#0000ff">(( <font color="#ff0000">b</font> b) (aaaa <font color="#ff0000">b</font> (bb))) =&gt; ( <font color="#ff0000">b</font> (aaaab (bb)))</font> . <br>  5.2.  <font color="#0000ff">((bb) (aaaa ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; ((bb) (aaaa <font color="#ff0000">bb</font> ))</font> . <br>  5.2.1.  <font color="#0000ff">(( <font color="#ff0000">b</font> b) (aaaa <font color="#ff0000">b</font> b)) =&gt; ( <font color="#ff0000">b</font> (aaaabb))</font> . <br>  5.2.2.  <font color="#0000ff">(( <font color="#ff0000">bb</font> ) (aaaa <font color="#ff0000">bb</font> )) =&gt; ( <font color="#ff0000">bb</font> (aaaa))</font> . <br>  6. <font color="#0000ff">((aa <font color="#ff0000">(bb) (bb)</font> ) (aa <font color="#ff0000">(bb) (bb)</font> )) =&gt; ( <font color="#ff0000">(bb) (bb)</font> (aaaa))</font> . <br>  6.1.  <font color="#0000ff">(( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b) (aaaa)) =&gt; ( <font color="#ff0000">b</font> (bb) (aaaa))</font> . <br>  6.2.  <font color="#0000ff">(( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) (aaaa)) =&gt; ( <font color="#ff0000">bb</font> (aaaa))</font> . <br>  7. <font color="#0000ff">((a <font color="#ff0000">a (bb)</font> (bb)) (a <font color="#ff0000">a (bb)</font> (bb))) =&gt; ( <font color="#ff0000">a (bb)</font> (aa (bb) (bb)))</font> . <br>  7.1.  <font color="#0000ff">(a (bb) (aa ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; (a (bb) (aa <font color="#ff0000">b</font> (bb)))</font> . <br>  7.1.1.  <font color="#0000ff">(a ( <font color="#ff0000">b</font> b) (aa <font color="#ff0000">b</font> (bb))) =&gt; (a <font color="#ff0000">b</font> (aab (bb)))</font> . <br>  7.2.  <font color="#0000ff">(a (bb) (aa ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (a (bb) (aa <font color="#ff0000">bb</font> ))</font> . <br>  7.2.1.  <font color="#0000ff">(a ( <font color="#ff0000">b</font> b) (aa <font color="#ff0000">b</font> b)) =&gt; (a <font color="#ff0000">b</font> (aabb))</font> . <br>  7.2.2.  <font color="#0000ff">(a ( <font color="#ff0000">bb</font> ) (aa <font color="#ff0000">bb</font> )) =&gt; (a <font color="#ff0000">bb</font> (aa))</font> . <br>  8. <font color="#0000ff">(( <font color="#ff0000">aa (bb)</font> (bb)) ( <font color="#ff0000">aa (bb)</font> (bb))) =&gt; ( <font color="#ff0000">aa (bb)</font> ((bb) (bb)))</font> . <br>  8.1.  <font color="#0000ff">(aa (bb) (( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; (aa (bb) ( <font color="#ff0000">b</font> (bb)))</font> . <br>  8.1.1.  <font color="#0000ff">(aa ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> (bb))) =&gt; (aa <font color="#ff0000">b</font> (b (bb)))</font> . <br>  8.2.  <font color="#0000ff">(aa (bb) (( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (aa (bb) ( <font color="#ff0000">bb</font> ))</font> . <br>  8.2.1.  <font color="#0000ff">(aa ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b)) =&gt; (aa <font color="#ff0000">b</font> (bb))</font> . <br>  8.2.2.  <font color="#0000ff">(aa ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> )) =&gt; (aa <font color="#ff0000">bb</font> )</font> . <br>  9. <font color="#0000ff">((a <font color="#ff0000">a (bb) (bb)</font> ) (a <font color="#ff0000">a (bb) (bb)</font> )) =&gt; ( <font color="#ff0000">a (bb) (bb)</font> (aa))</font> . <br>  9.1.  <font color="#0000ff">(a (aa) ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b)) =&gt; (a <font color="#ff0000">b</font> (aa) (bb))</font> . <br>  9.2.  <font color="#0000ff">(a (aa) ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> )) =&gt; (a <font color="#ff0000">bb</font> (aa))</font> . <br>  10. <font color="#0000ff">(( <font color="#ff0000">aa (bb) (bb)</font> ) ( <font color="#ff0000">aa (bb) (bb)</font> )) =&gt; ( <font color="#ff0000">a (bb) (bb)</font> )</font> . <br>  10.1.  <font color="#0000ff">(a ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b)) =&gt; (a <font color="#ff0000">b</font> (bb))</font> . <br>  10.2.  <font color="#0000ff">(a ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> )) =&gt; (a <font color="#ff0000">bb</font> )</font> . <br><br>  From the list of result lines presented above (to the right of the arrow), you need to select all unique, and this set of unique lines will be the result of the work <font color="#0000ff"><b>abstraction</b> [((aa (bb) (bb)) (aa (bb) (bb)))]</font> .  I will not write out the unique lines, since this will not add anything to the explanation.  Below, when considering the issue of optimization and practical use of the algorithm, I will refer to this example. </div></div><br><br>  <b>Composition operator</b> .  Definition  <font color="#0000ff">‚àÄU ‚äÇ <b>S</b> , U ‚àÖ, <b>composition</b> [U] ‚â† ‚àÖ, <b>composition</b> [U] ‚àà <b>S.</b></font>  It accepts multiple rows as input, and returns one row.  Act.  The operator prepares content for the next iteration of the algorithm.  After the action of the abstraction operator, many lines appear, and at the composition stage, the string is selected and concatenated for the next iteration of the algorithm.  In more detail, I will discuss this issue in the sections of optimization and practical use.  In the simplest case, the composition operator performs a simple concatenation of all abstraction results.  So we define it.  Example: <font color="#0000ff"><b>composition</b> [ <b>abstraction</b> [((a (b)) (a (b)))]] = <b>composition</b> [{(a ((b) (b))), ((b) (aa)), (a ( b))}] = ((a ((b) (b))) ((b) (aa)) (a (b)))</font> . <br><br><h2>  Algorithm Properties </h2><br>  The algorithm produces strings.  The set of all lines that are formed as a result of the iterative work of the algorithm will be called ‚Äúalgorithm output‚Äù or simply ‚Äúoutput‚Äù.  Definition of output.  <font color="#0000ff"><b>T</b> <sup>s</sup> ‚âù {t <sub>n</sub> | t <sub>n + 1</sub> = <b>composition</b> [ <b>abstraction</b> [ <b>deduction</b> [t <sub>n</sub> ]]];</font>  <font color="#0000ff">t <sub>0</sub> = s;</font>  <font color="#0000ff">t <sub>n</sub> , s ‚àà <b>S</b> ;</font>  <font color="#0000ff">n ‚àà <b>N</b> }.</font>  <font color="#0000ff"><b>T</b> <sup>s</sup></font> - output for the seed <font color="#0000ff">s</font> .  In those cases when <font color="#0000ff"><b>T is</b></font> without a parameter, we are talking about output without reference to the seed.  Output property: <font color="#0000ff">‚àÄs, e ‚àà <b>S</b> , s ‚â† ‚àÖ, e ‚â† ‚àÖ, s e, <b>T</b> <sup>s</sup> ‚à© <b>T</b> <sup>e</sup> = ‚àÖ</font> .  This means that each output element uniquely corresponds to the seed.  As a result, for each seed, the output is unique. <br><br>  <b>Meaningful interpretation of deduction and abstraction</b> .  The physical meaning of the deduction operator is as follows.  From the original line, in a universal way, the deduction operator creates a fundamentally new, constructively object, with fundamentally new and more complex internal properties.  In an intuitive approximation, we can say that deduction adds qualitatively new information.  In turn, the abstraction operator parses the new object for parts and thus expresses the information added at the deduction stage in a constructive equivalent.  You may notice that as a result of the procedure for putting off the brackets, there is a loss of information.  Moreover, for this syntax, putting it out of the brackets is a universal way to meaningfully lose information in the absence of any a priori data about the meaning of strings.  That is, from the point of view of the algorithm, all possible variants of information loss, which are calculated at the stage of abstraction, are, in fact, the value of strings.  Thus, at each step, the algorithm creates a new, unique syntactic heuristic.  And each of the following heuristics is fundamentally more complex and more informative than the previous one.  At each iteration of the algorithm, new knowledge appears. <br><br><h2>  Practical use </h2><br>  Algorithm is a ‚Äúthing in itself‚Äù.  He thinks, but this is an ‚Äúalien‚Äù mindset.  In order to have practical benefits from alien thinking, it is necessary to find a common language with it.  On the one hand, an alien needs to be trained, and on the other - to learn to understand him, in order to finally establish meaningful communication.  In general, the interaction paradigm with the algorithm is similar to the well-known principles of interaction with the ‚Äúblack box‚Äù.  Further, for more convenience, the thinking algorithm will be called the alien Kohl. <br><br>  Consider the ideal case.  Suppose that we have unlimited computing power at our disposal and can afford to calculate any number of iterations of Kohl‚Äôs thinking without worrying about optimization issues.  In this case, the following ingredients will be required for interaction with Kolya: <br><br><ol><li>  A digital model of an interactive environment whose meaning is known. </li><li>  Digital model of the instrument that can affect the environment. </li><li>  Coding algorithm to encode signals from the medium by strings from <font color="#0000ff"><b>s</b></font> . </li><li>  A decoding algorithm that will somehow fuzzy but rationally justify decode previously unknown strings from <font color="#0000ff"><b>S</b></font> and convert them into signals for the instrument. </li></ol><br>  Having such components, it is possible to organize a universal training scheme with unknown motivation, which will allow Koli to adapt his thinking to the environment.  Below is pseudocode. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">S </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextThought</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S prevThought, S ExternalSignal, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> exposure = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ S t = composition[prevThought, ExternalSignal]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; exposure; i++) t = composition[abstraction[deduction[t]]]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t; } EnvironmentModel e; S s = encode(e.GetState()); S o = ‚àÖ; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>) { S o = NextThought(o, s); e.ImpactTool.perform(decode(o)); s = encode(e.GetState()); }</code> </pre> <br>  <b>Scheme with feedback</b> .  In the beginning Kolya has no thoughts.  Kolya's first thought is the coded initial state of the medium.  At each iteration in Kolya‚Äôs thoughts, an external signal is poured.  After that, Kohl thinks during the exposure time.  Thinking results are decoded and sent to the instrument.  In turn, the action of the instrument somehow changes the state of the environment.  And everything repeats again.  For some time, Kolya‚Äôs thinking will adapt to the environment and he will begin to show signs of highly organized, subjectively motivated behavior.  However, Kohli's motivation will remain unknown.  In order to understand his motivation, at the next stage of training it is necessary to set up experiments, that is, to purposefully change the environment and study Kolya's reactions to changes.  If it is possible to describe Kolya‚Äôs desirable external behavior in terms of a certain objective function, then the learning process can be automated, for example, using a genetic algorithm. <br><br>  <b>The problem of decoding</b> .  It is necessary to decode Kohli's thoughts in order to synthesize the signal for the instrument.  The difficulty is that each thought, as I noted in the previous section, is a fundamentally new design.  That is, a hypothetical researcher will never be able to fully understand the content of Kolya‚Äôs thoughts.  Part of the content produced by Kolya‚Äôs thinking, no matter how much it is studied, will forever remain something completely unclear.  Only some of the most highly organized fragments of thinking can be consciously recognized, and this is a fundamental and insurmountable limitation in communication with Kolya.  But in practical terms, this limitation is not fundamental.  Because, firstly, one can infinitely clarify the meaningful side of Kolya‚Äôs thoughts, and secondly, there is no need to fully understand Kohl.  It is enough to develop a common language within which one can explain on practical issues.  On the technical side, the situation is as follows.  The incoming signal describing the state of the environment is encoded in some language.  Words and language statements are strings from <font color="#0000ff"><b>s</b></font> .  The language has its own vocabulary, syntax and semantics.  From each iteration of thinking, the content according to grammatical criteria will be divided into several categories: <br><br>  1. Fragments with unknown vocabulary. <br>  2. Unknown syntax. <br>  3. Unknown semantics. <br>  4. Grammatically and semantically correct fragments. <br><br>  The content of all specified categories according to the method of occurrence is arbitrary.  That is, even in the case of grammatically correct fragments, this is an accident and it is not known what meaning Kohl puts into them, since his inner meaning is available only to himself.  A priori, there are no criteria for correctly linking Kohli's thoughts and the corresponding actions of the instrument.  And in this matter it remains to rely solely on Kohl himself.  His behavior is arbitrary and only he himself can comprehend his motivation as the degree of organization of his thinking increases.  In this case, any rational scheme for responding to Kolya‚Äôs thoughts would be acceptable and productive, the question is only in the relative effectiveness of various schemes.  The basic option is to respond to all grammatically correct fragments even if they are absurd in content.  In general, everything that can be transformed into terms of the original encoding needs to be transformed and reacted.  And so on until Kolya ‚Äúwiser‚Äù to meaningful reactions.  And, of course, a more flexible model of a medium with a large number of degrees of freedom will be useful.  Wednesday, in some way, will be the body of Kolya. <br><br>  <b>The problem of limited computing power</b> .  In terms of the amount of computation, the algorithm is heavy.  Clearly - several dozen iterations will exhaust the entire computing power of the planet.  One can hope for quantum devices and for the fact that there is a quantum analogue of the algorithm, but so far there has been no one way out: instead of one enormously complex thought, in parallel to think many small and simple thoughts.  There are several technical tricks for this: <br><br>  <b>1.</b> At the composition stage, it is not necessary to include the whole set of abstractions in the result.  In order for the algorithm to retain its fundamental properties, it suffices to select from the set only two independent resulting lines.  The criterion of independence is a non-zero difference of the first digits in the hierarchical numbering of the results of abstraction.  Refer to the big example, which is higher under the spoiler.  All lines are numbered according to the <font color="#0000ff">abcd</font> principle <font color="#0000ff">.</font> A pair of lines with indices <font color="#0000ff">a1.b1.c1.d1 ...</font> , <font color="#0000ff">a2.b2.c2.d2 ...</font> is called independent if <font color="#0000ff">a1 ‚â† a2</font> .  And this means that it is possible to split the entire result of the abstraction into independent pairs, and for each pair in the next step, run your computational branch.  Moreover, it is not necessary to use all the results of abstraction.  In the minimum case, you can select only one pair of lines, and discard all others (irretrievably lose) and all principles of thinking will be preserved.  Given the possibility of losing results, it is possible to organize an additional selection stage, in which, in some rational way, for example, according to statistical significance, content can be selected for further calculations. <br><br>  <b>2. The</b> second trick is based on the assumption that the more deeply located the brackets in the line, the less organized they are.  Accordingly, the content ‚Äúpop-up‚Äù as a result of braking is more organized and abstract from the point of view of the internal meanings of Kolya, which means that deep levels of nesting can be removed.  Thus, the amount of computation at the next iteration is exponentially reduced.  In the intuitive understanding of this procedure allows you to approximate only the most abstract part of thinking. <br><br>  <b>3.</b> As a result of parallelization into many smaller branches, the computations will grow ‚Äúwide‚Äù.  This width can be absolutely limited by selection not only at the level of individual computational branches, but also entirely in the entire array of parallel branches.  This can be done through a common pool of fixed size, from where each branch will draw lines for the next iteration, and, accordingly, where it will drop the results.  And for strings, you can absolutely limit the allowable nesting level of brackets.  Such a combined approach will allow to restrain and regulate the growth of the volume of calculations. <br><br><h2>  Interpretation and comments </h2><br>  <b>The evidence</b> .  There is no evidence and can not be.  Any theory of thinking is a matter of definition.  The presented algorithm is a constructive theory of thinking.  And therefore he is an axiom.  The thinking algorithm is apodictically recognizable for the subject of thinking.  Recognition can be facilitated by resorting first to non-constructive axiomatics which is more intuitive, and then to find the coincidence of the properties of constructive and non-constructive definitions. <br><br>  <b>Nonconstructive definition of thinking</b> .  Thinking is not an algorithmic production of content.  In an intuitive sense, non-algorithmic phenomena have the following specific features: independence, spontaneity, uniqueness, self-organization, arbitrariness, subjectivity, complexity, fundamental unpredictability and uncertainty, the absence of conceptual barriers and, in the widest sense, the inalienable and timeless possibility of fundamental novelty.  All the listed signs are somehow inherent in the described algorithm of thinking.  Although the combination of algorithm and non-algorithmic properties is something non-intuitive and seemingly contradictory, in fact there is no contradiction.  The algorithm deploys content using well-defined algorithmic procedures, but in the process of deployment the content is not an algorithmic organization.  Taking into account the design specifics of the algorithm, non-algorithmic properties in the organization of content flow from the intrinsic, internal, non-algorithmic properties of the content itself. <br><br>  <b>Additional points of view on the algorithm</b> .  The thinking algorithm is this, including: <br><br>  <b>1.</b> Constructive implementation of metaphor.  Thinking is essentially metaphorical.  There are no other meanings than portable ones (possible).  However, in the figurative sense, literal meanings (algorithms) are possible. <br>  <b>2.</b> The model of self-organization of absolute chaos.  Model of conceptual spontaneity. <br>  <b>3.</b> A model of absolutely independent, subjectively motivated behavior.  Model of creativity. <br>  <b>4.</b> Self-organizing language. <br>  <b>5.</b> Model of constructive approximation, for non-constructive, purely possible semantics. <br><br>  <b>Consciousness</b> .  The issue of consciousness is also solved at the level of definition.  Consciousness is something that lies outside of any conceptual constraints.  In the light of such a definition, consciousness can only be poisoned by more or less complex bikes, each of which will reflect some possibilities of consciousness, but none of them will be true.  At the same time, consciousness stories have different heuristic potential.  Of all the tales, the ones that are harder are more useful.  From the point of view of algorithms, consciousness is a trans-algorithmic, infinitely complex (or simply complex) object.  A bike of consciousness can be written using the algorithm.  It sounds like this: <br><br>  <font color="#0000ff">lim <sub>n ‚Üí ‚àû</sub> [t <sub>n + 1</sub> = <b>composition</b> [ <b>abstraction</b> [ <b>deduction</b> [t <sub>n</sub> ]]]];</font>  <font color="#0000ff">t <sub>0</sub> = s;</font>  <font color="#0000ff">t <sub>n</sub> , s ‚àà <b>S</b> ;</font>  <font color="#0000ff">n ‚àà <b>N</b></font> </div><p>Source: <a href="https://habr.com/ru/post/440424/">https://habr.com/ru/post/440424/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>