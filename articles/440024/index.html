<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Redirecting printf () from STM32 to Qt Creator console</title>
  <meta name="description" content="Often, when debugging microcontroller software, it is necessary to display debugging messages, logs, captured data and other things on the PC screen. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Redirecting printf () from STM32 to Qt Creator console</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/gg/yw/ol/ggywoln37vevtn3jnep_hcahfhu.png" alt="kdpv.svg"></p><br><p>  Often, when debugging microcontroller software, it is necessary to display debugging messages, logs, captured data and other things on the PC screen.  At the same time, it would be desirable for the output to be faster, and for the lines to be displayed not anywhere, but directly in the IDE - without departing from the code, so to speak.  Actually, this is the article - as I tried to printf () display and display inside my favorite, but not very microcontroller, Qt Creator environment. </p><a name="habracut"></a><br><p>  In general, you can come up with a huge number of ways to display textual information from the microcontroller.  However, the most frequently used techniques are not so many: </p><br><ul><li>  <a href="http://www.keil.com/support/man/docs/armcc/armcc_pge1358787046598.htm">Semihosting</a> </li><li>  <a href="https://habr.com/ru/post/259205/">Segger RTT</a> </li><li>  USB-CDC </li><li>  UART </li><li>  ITM </li></ul><br><p>  Semihosting - rather slow, RTT - tied to Segger hardware and software solutions, USB - is not in every microcontroller.  Therefore, usually, I prefer the last two - the use of UART and ITM.  About them and will be discussed below. </p><br><p>  And immediately some explanation on the software that will be used later.  As an OS, I now have Fedora 28, and the current bundle of software for working with microcontrollers are: </p><br><ul><li>  <a href="http://download.qt.io/official_releases/qtcreator">Qt Creator 4.8.1</a> (direct link to releases, pretty carefully hidden on the site) </li><li>  <a href="https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads">GNU Arm Embedded Toolchain 7</a> </li><li>  <a href="http://openocd.org/">OpenOCD 0.10.0 + dev</a> </li></ul><br><h3 id="perenapravlenie-printf-v-gcc">  Redirect printf () to GCC </h3><br><p>  So, in order to redirect the output of printf () to GCC, you need to add to the linker keys </p><br><pre><code class="plaintext hljs">-specs=nosys.specs -specs=nano.specs</code> </pre> <br><p>  If you need to output floating-point numbers, then you need to not forget the key </p><br><pre> <code class="plaintext hljs">-u_printf_float</code> </pre> <br><p>  And implement the _write () function.  For example, something like this </p><br><pre> <code class="plaintext hljs">int _write(int fd, char* ptr, int len) { (void)fd; int i = 0; while (ptr[i] &amp;&amp; (i &lt; len)) { retarget_put_char((int)ptr[i]); if (ptr[i] == '\n') { retarget_put_char((int)'\r'); } i++; } return len; }</code> </pre> <br><p>  where retarget_put_char () is a function that will load the symbol directly into the desired interface. </p><br><h3 id="printf---itm---qt-creator">  printf () -&gt; ITM -&gt; Qt Creator </h3><br><p>  Instrumentation Trace Macrocell (ITM) is a block inside the Cortex-M3 / M4 / M7 core used for non-invasive output (tracing) of various types of diagnostic information.  To implement printf () about ITM, you need to know the following: </p><br><ul><li>  Uses the clock signal TRACECLKIN, the frequency of which is usually equal to the frequency of the core </li><li>  Has 32 pieces of so-called stimulus ports for data output </li><li>  CMSIS incorporates the ITM_SendChar () function, which loads a symbol into the stimulus port 0 </li><li>  Data is output to the outside either via a synchronous bus (TRACEDATA, TRACECLK) or via an asynchronous single-wire line SWO (TRACESWO) </li><li>  The SWO line is usually multiplexed with JTDO, which means it only works in debug mode via SWD </li><li>  SWO output is carried out either using the Manchester code or NRZ (UART 8N1) </li><li>  The data is transmitted by frames of a specific format - you need a parser on the receiving side </li><li>  ITM is usually configured from the IDE or the corresponding utility (however, no one forbids setting it up in the program code - then the output in SWO will work without a raised debugging session) </li></ul><br><p>  The most convenient way to use ITM is to output via SWO using NRZ coding - thus, only one line is needed, and data can be received not only with a debugger with a special input, but also with a standard USB-UART adapter, albeit at a lower speed. </p><br><p>  I followed the path using the debugger, and had to <a href="https://habr.com/ru/post/402927/">modify</a> my Chinese STLink-V2 so that it would support SWO.  Then everything is simple - we connect the JTDO / TRACESWO microcontroller to the corresponding pin of the debugger, and go to set up the software. </p><br><p>  In openocd there is a command "tpiu config" - with the help of it you can configure the way of displaying trace information (in more detail in the <a href="http://openocd.org/doc/pdf/openocd.pdf">OpenOCD User's Guide</a> ).  So for example, using arguments </p><br><pre> <code class="plaintext hljs">tpiu config internal /home/esynr3z/itm.fifo uart off 168000000</code> </pre> <br><p>  adjusts the output to the /home/esynr3z/itm.fifo file, using NRZ coding, and calculates the maximum transmission rate based on the TRACECLKIN frequency of 168 MHz - for STLink it is 2 MHz.  And one more team </p><br><pre> <code class="plaintext hljs">itm port 0 1</code> </pre> <br><p>  will enable zero port for data transfer. </p><br><p>  The OpenOCD source code includes the itmdump utility (contrib / itmdump.c) - it can be used to parse strings from the received data. </p><br><p>  To compile we enter </p><br><pre> <code class="plaintext hljs">gcc itmdump.c -o itmdump</code> </pre> <br><p>  When starting, specify the necessary file / pipe / ttyUSB * and the -d1 switch in order to output the received data bytes as strings </p><br><pre> <code class="plaintext hljs">./itmdump -f /home/esynr3z/itm.fifo -d1</code> </pre> <br><p>  And the last.  To send a symbol via SWO, we supplement the _write () described above with the function </p><br><pre> <code class="plaintext hljs">int retarget_put_char(int ch) { ITM_SendChar((uint32_t)ch); return 0; }</code> </pre> <br><p>  So, the general plan is this: inside Qt Creator, we configure openocd to save all the received information on SWO into a previously created named pipe, and read the pipe, parse strings and display to the screen using itmdump, running as an External Tool.  Of course, there is a more elegant way to solve the task - to write the appropriate plugin for Qt Creator.  However, I hope that the approach described below will be useful to someone. </p><br><p>  Go to the Bare Metal plugin settings (Tools-&gt; Options-&gt; Devices-&gt; Bare Metal). </p><br><p><img src="https://habrastorage.org/webt/_t/0e/vz/_t0evzgzyymortwmhhwnvumadrq.png" alt="config_baremetal.png"></p><br><p>  Select the used GDB server and add the line to the end of the list of commands for initialization </p><br><pre> <code class="plaintext hljs">monitor tpiu config internal /home/esynr3z/itm.fifo uart off 168000000 monitor itm port 0 1</code> </pre> <br><p>  Now, just before the debugger puts the cursor at the very beginning of main (), the ITM setting will occur. </p><br><p>  Add itmdump as External Tool (Tools-&gt; External-&gt; Configure ...). </p><br><p><img src="https://habrastorage.org/webt/tx/18/mk/tx18mk_cx8zdqhxajwxsoh2ivlk.png" alt="external_itmdump.png"></p><br><p>  Do not forget to set the variable </p><br><pre> <code class="plaintext hljs">QT_LOGGING_TO_CONSOLE=1</code> </pre> <br><p>  to display the utility output in the Qt Creator console (7 General Messages panel). </p><br><p>  Now turn on itmdump, activate debug mode, start code execution and ... nothing happens.  However, if you interrupt debugging, the execution of itmdump will end, and all lines output via printf () will appear on the General Messages tab. </p><br><p>  By a brief survey, it was found that the lines from itmdump must be buffered and output to stderr - then they appear in the console interactively, while debugging the program.  I uploaded a modified version of itmdump to <a href="https://github.com/esynr3z/openocd-stuff/tree/master/tools/itmdump">GitHub</a> . </p><br><p>  There is another nuance.  Debugging at startup will hang on executing the "monitor tpiu config ..." command, unless itmdump is running.  This happens because opening a pipe (/home/esynr3z/itm.fifo) inside openocd is write-blocking, and the debager will hang until pipe opens to read from the other end. </p><br><p>  This is somewhat unpleasant, especially if at some point ITM is not needed, but you have to idle itmdump or constantly switch the GDB server or delete / add lines in its settings.  Therefore it was necessary to pick openocd sources a little and find the place where you need to substitute a small crutch. </p><br><p>  In the src / target / armv7m_trace.c file there is a line with the required opening procedure </p><br><pre> <code class="plaintext hljs">armv7m-&gt;trace_config.trace_file = fopen(CMD_ARGV[cmd_idx], "ab");</code> </pre> <br><p>  it needs to be replaced by </p><br><pre> <code class="plaintext hljs">int fd = open(CMD_ARGV[cmd_idx], O_CREAT | O_RDWR, 0664); armv7m-&gt;trace_config.trace_file = fdopen(fd, "ab");</code> </pre> <br><p>  Now our pipe will open immediately and not shine.  So you can leave the Bare Metal settings alone, and itmdump only run when it is needed. </p><br><p>  In summary, the output of messages during debugging looks like </p><br><p><img src="https://habrastorage.org/webt/lz/-x/po/lz-xpo5ujcbkrga3al-pnsectme.png" alt="debug.png"></p><br><h2 id="printf---uart---qt-creator">  printf () -&gt; UART -&gt; Qt Creator </h2><br><p>  In this case, everything is about the same: </p><br><ul><li>  Add a UART initialization function to the code </li><li>  Implement retarget_put_char () where the character will be sent to the transceiver buffer </li><li>  We connect USB-UART adapter </li><li>  Add a utility to External Tools that will read lines from a virtual COM port and display them on the screen. </li></ul><br><p>  I have sketched such a utility on C - <a href="https://github.com/esynr3z/openocd-stuff/tree/master/tools/uartdump">uartdump</a> .  The use is quite simple - you only need to specify the port name and baudrate. </p><br><p><img src="https://habrastorage.org/webt/wm/ov/mf/wmovmfhdw33hahv1mdaubq0432u.png" alt="external_uartdump.png"></p><br><p>  However, it is worth noting one feature.  The operation of this utility does not depend on debugging, and Qt Creator does not offer any options for closing running External Tools.  Therefore, to stop reading the COM port, I added another external tool. </p><br><p><img src="https://habrastorage.org/webt/k8/ee/1p/k8ee1pim_owcrvyuvz3jrsezta8.png" alt="external_uartdump_close.png"></p><br><p>  Well and just in case I will attach the link to the CMake template of the project which appeared on screenshots - <a href="https://github.com/esynr3z/mcu-templates/tree/master/stm32f407vgt6-cmake">GitHub</a> . </p></div><p>Source: <a href="https://habr.com/ru/post/440024/">https://habr.com/ru/post/440024/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
</ul></nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>