<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Effects of SVG filters. Part 2. Outline text with feMorphology</title>
  <meta name="description" content="Sara Soueidan, a freelance UI / UX developer of the interface and author of many technical articles living in Lebanon, offers a series of articles on ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Effects of SVG filters. Part 2. Outline text with feMorphology</h1><div class="post__text post__text-html js-mediator-article"><p>  Sara Soueidan, a freelance UI / UX developer of the interface and author of many technical articles living in Lebanon, offers a series of articles on the SVG filters and consists of the following articles: </p><br><h1 id="effekty-filtracii-svg">  Effects of filtering SVG </h1><br><ol><li>  <a href="https://habr.com/ru/post/439282/">SVG filters 101</a> . </li><li>  Effects of filtering SVG: outline text using feMorphology </li></ol><br><div class="spoiler">  <b class="spoiler_title">Not yet translated</b> <div class="spoiler_text"><ol><li>  <a href="https://tympanus.net/codrops/2019/01/29/svg-filter-effects-poster-image-effect-with-fecomponenttransfer/">SVG Filter Effects: Poster Image Effect with feComponentTransfer</a> . </li><li>  <a href="https://tympanus.net/codrops/2019/02/05/svg-filter-effects-duotone-images-with-fecomponenttransfer/">SVG Filter Effects: Duotone Images with feComponentTransfer</a> . </li></ol></div></div><br><p>  In the second part of the series about the SVG filters, <strong>Sara Soueidan</strong> introduces the <strong>feMorphology</strong> filter and gives several examples of its use for creating interesting effects. </p><br><p><img src="https://habrastorage.org/webt/pt/1l/yq/pt1lyq3deuk69mcyf2ax_yt9_tc.png"></p><a name="habracut"></a><br><p>  In the <a href="https://tympanus.net/codrops/2019/01/15/svg-filters-101/"><strong>first part of this series</strong></a> on the effects of SVG filters, we introduced the basics of SVG filters - how to create them and how to use them.  We also looked at some of the most commonly used filtering operations, i.e.  filter primitives.  Since  we will reuse this information, then I recommend stopping and reading that article before moving further on this. </p><br><p>  <strong>&lt;feMorphology&gt;</strong> is one of my favorite SVG filter operations.  It is also one of the simplest operations, and the results of its application to various elements are always predictable. </p><br><h2 id="chto-takoe-morfing">  What is morphing? </h2><br><p>  Morphing means transforming or changing the shape or appearance of an object. </p><br><p>  The morphological filter operates on the shape of the object.  It provides two predefined form transformations: erosion (ie, thinning or reduction) and expansion (ie, A. thickening or expansion).  In other words, the <strong>feMorphology</strong> primitive can be used to compress or expand an element. </p><br><p>  Technically speaking, both of these operations work at the pixel level, extending the pixel to adjacent pixels ( <strong>dilate</strong> ), or destroying adjacent pixels at the edges of a pixel that is controlled ( <strong>erode</strong> ), while maintaining the contour on the border of that pixel.  The amount by which a pixel expands, or the number of adjacent pixels used to stretch or expand a pixel, is determined by the <strong>radius</strong> parameter. </p><br><pre><code class="plaintext hljs">&lt;feMorphology in=".." result=".." operator="dilate || erode" radius=""&gt; &lt;/feMorphology&gt;</code> </pre> <br><p>  The radius of the morph can be represented as the radius of a circle or ellipse.  All adjacent pixels enclosed in a circle of this radius, starting from the input pixel, are considered to be a single community of pixels and will be used in the expansion or erosion effect. </p><br><p>  However, in fact, the radius actually characterizes the size of the core, called the structuring element, which is more like a matrix.  For now, it is sufficient to represent it in the form of a small rectangle whose width and height are given by the pixels specified in the <strong>radius</strong> attribute. <br><img src="https://habrastorage.org/webt/hn/vy/ch/hnvychycyjlugtdv4rebde8gcro.png"></p><br><p>  To use the filter, we do not need to go into the boring little things that morphing does at the pixel level.  It is enough to know that you can provide one or two radius values ‚Äã‚Äãin <strong>feMorphology</strong> , which will determine the amount by which the element will contract or expand.  If you specify two numbers in the <strong>radius</strong> attribute, then the first will correspond to the x-radius, and the second to the y-radius. </p><br><h2 id="morfing-izobrazheniy">  Morph Images </h2><br><p>  If the <strong>feMorphology</strong> operation <strong>is</strong> applied to images, then two, as a rule, predictable, results will follow: </p><br><ul><li>  The image size is reduced if the <strong>erode</strong> operator is <strong>used</strong> , or increases if the <strong>dilate</strong> operator is <strong>used</strong> . </li><li>  With any operator, the image looks as if it was painted with a large paint brush, with a small amount of fine details. </li></ul><br><p>  Thus, to apply the morph effect to the image, our code should look like this: </p><br><pre> <code class="plaintext hljs">&lt;svg width="450" height="300" viewBox="0 0 450 300"&gt; &lt;filter id="erode"&gt; &lt;feMorphology operator="erode" radius="3"&gt;&lt;/feMorphology&gt; &lt;/filter&gt; &lt;image xlink:href="..." width="90%" height="90%" x="10" y="10" filter="url(#erode)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><p>  In this fragment we blur (compress) the image (in pixels) by 3 pixels.  The following figure shows the result of this code.  Please note that the image size on the right is slightly smaller: </p><br><p><img src="https://habrastorage.org/webt/o6/_z/zo/o6_zzo1nl1ppmugvmhevox8afxi.png" alt="On the right, the result of applying the blur effect of the morph to the image on the left."><br>  Pic_2.  On the right, the result of applying the blur effect of the morph to the image on the left. </p><br><p>  Now, if we keep the same morphing radius and change the operator from <strong>erode</strong> to <strong>dilate</strong> , the effect will be similar, but also distinctly different: </p><br><p><img src="https://habrastorage.org/webt/lf/ia/uv/lfiauvdmlzkld2fqfuzrm81pvpa.png"><br>  Fig_3.  On the right, the result of applying the <strong>dilate morph</strong> operation to the image on the left. </p><br><p>  In both cases, the image looks like an abstract drawn version of itself, and its overall size changes as the pixels expand or contract. </p><br><p>  But in addition to these results, probably the first thing you notice is the difference in colors that results from each of these two effects: <strong>erode</strong> creates an image with a large number of dark pixels, while <strong>dilate</strong> brightens the result.  This is due to the fact that: </p><br><ul><li>  <strong>erode</strong> (this value is used by default) sets for each pixel the lowest brightness or the highest opacity of its community, respectively for each of the R, G, B and A channels; </li><li>  <strong>dilate</strong> sets for each channel of each pixel values ‚Äã‚Äãcorresponding to the brightest or least transparent value of its community. </li></ul><br><p>  If technical details are discarded to the side, then applying <strong>feMorphology</strong> to images will almost always have the same result: compressing or stretching the fine details of the image as a copy of the image with a dark or light main outline. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/SaraSoueidan/embed/preview/eyyMea" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  However, applying <strong>feMorphology</strong> to monochrome elements, such as text, only compresses or stretches it, without making any noticeable changes in the color of the pixels, because we still have only one color to work with ... </p><br><h2 id="dobavlenie-cvetnogo-kontura-k-tekstu-s-pomoschyu-femorphology">  Add color contour to text with feMorphology </h2><br><p>  Now we can add a contour to the text in SVG using the <strong>stroke</strong> attribute for this text. </p><br><pre> <code class="plaintext hljs">&lt;!-- Adding an outline to SVG text using strokes --&gt; &lt;text font-size="80px" dx="100" dy="200" font-weight="700" stroke="deepPink" stroke-width="3px"&gt;Stroked Text&lt;/text&gt;</code> </pre> <br><p>  Adding a contour, which is usually centered on the edges of the text so that half of its thickness is overlapped by the text itself, makes the text thinner, even if it was not intended.  Instead, we can expand ( <strong>dilate</strong> ) the text to the thickness of the contour or stroke using <strong>feMorphology</strong> . </p><br><p>  Unless otherwise indicated, the text usually has one color.  So, applied to the text, <strong>feMorphology</strong> allows to reduce or increase the thickness of the text.  Once the text is expanded with <strong>feMorphology</strong> , it can be used as input to other filter primitives to create the outline of the text, which is what we need. </p><br><p>  Before we dive into how to do this, look at the picture showing the difference between the text with the outlined contour and the contour added with <strong>feMorphology</strong> . </p><br><p><img src="https://habrastorage.org/webt/cu/rd/-d/curd-dnppif0tvvgoyb4sxrccn0.png" alt="Comparing the source text with the text having a stroke, and the contour created with ** feMorphology **"><br>  Fig_4.  Compare the source text with the text that has a stroke and the outline created with the help of <strong>feMorphology</strong> . </p><br><p>  Notice that the source text on the second line became thinner after adding a smooth contour, compared to the text of the third line, expanded with <strong>feMorphology</strong> . </p><br><p>  So, let's step by step create a colored piece of text with an outline.  Here is the result to which we will strive: </p><br><p><img src="https://habrastorage.org/webt/9o/ox/dc/9ooxdcthwek445glxn3u9kobgsy.png" alt="Final result"><br>  Pic_5.  Final result. </p><br><p>  So, we will create an SVG containing our text and a filter that triggers a simple expansion operation.  The size of the text expansion depends on the thickness of the outline that we want to receive. </p><br><pre> <code class="plaintext hljs">&lt;svg width="900" height="200" viewBox="100 0 900 200"&gt; &lt;filter id="outline"&gt; &lt;feMorphology in="SourceAlpha" result="DILATED" operator="dilate" radius="4"&gt;&lt;/feMorphology&gt; &lt;/filter&gt; &lt;!-- DILATED TEXT --&gt; &lt;text font-size="85px" dx="125" dy="130" font-weight="700" filter="url(#outline)"&gt;upgrade yourself&lt;/text&gt; &lt;/svg&gt;</code> </pre> <br><p>  The above code will get the alpha channel of the text, which is just a black version of the text, and increases the font thickness by 4px.  The result of the code at this stage is as follows: </p><br><p><img src="https://habrastorage.org/webt/th/ap/aj/thapajsoryyxflgrf1ky85t28wg.png" alt="Text after thickening"><br>  Fig_6.  Text after thickening. </p><br><p>  ... compared to source text that has a dark blue fill color: </p><br><p><img src="https://habrastorage.org/webt/lo/g6/e0/log6e0ykecbusfnf0lf8auxrcfc.png" alt="Source text"><br>  Fig_7.  Source text. </p><br><p>  To create a contour effect, we will place the source text on top of the expanded text, leaving only the edges of the expanded text (our additional 4px) visible around the source text, making them look like a contour.  Text overlaying its outline (extended text) will be performed using <strong>feMerge</strong> .  How this is done we discussed in the <a href="https://tympanus.net/codrops/2019/01/15/svg-filters-101/">previous article</a> . </p><br><p>  What else we need to do before positioning the outline around the text is to color the outline itself.  Just as we did in the previous article, fill the filter area with the desired color, and then add the color layer with the already expanded text layer, i.e.  our contour using the <strong>in</strong> operator.  As a result, only those parts of the color fill that intersect with the expanded text will be displayed, thus coloring it.  Then, we merge the resulting colored outline with the source text to get the desired result. </p><br><p>  Now our code looks like this: </p><br><pre> <code class="plaintext hljs">&lt;svg width="900" height="200" viewBox="100 0 900 200"&gt; &lt;filter id="outline"&gt; &lt;feMorphology in="SourceAlpha" result="DILATED" operator="dilate" radius="4"&gt;&lt;/feMorphology&gt; &lt;feFlood flood-color="#32DFEC" flood-opacity="1" result="PINK"&gt;&lt;/feFlood&gt; &lt;feComposite in="PINK" in2="DILATED" operator="in" result="OUTLINE"&gt;&lt;/feComposite&gt; &lt;feMerge&gt; &lt;feMergeNode in="OUTLINE" /&gt; &lt;feMergeNode in="SourceGraphic" /&gt; &lt;/feMerge&gt; &lt;/filter&gt; &lt;!-- DILATED TEXT --&gt; &lt;text font-size="85px" dx="125" dy="130" font-weight="700" filter="url(#outline)"&gt;upgrade yourself&lt;/text&gt; &lt;/svg&gt;</code> </pre> <br><p>  The process of creating filtering effects in SVG consists in presenting the final result in the form of small sequential operations, using the result of one operation as input to another and, finally, merging all the layers created by them to achieve the final result. </p><br><p>  And here is a demo of the code above: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/SaraSoueidan/embed/preview/QzxQqK" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  The text fill color can be specified either in your CSS or in the <strong>text</strong> element using the <strong>fill</strong> attribute.  The outline color can be configured in the <strong>flood-color</strong> attribute of the <strong>feFlood</strong> primitive. </p><br><p>  Fine!  And if you want to change the color of the contour?  You will have to use the <strong>feFlood</strong> primitive <strong>again</strong> and combine the color fill with the outline.  And every time you want to change the color of the outline, you have to do the same thing over and over again.  This, admittedly, is too tiring.  Fortunately, there is an easier way. </p><br><h2 id="vybivanie-teksta">  Text knocking out </h2><br><p>  In addition to adding a contour to the text, we can also create a contour, i.e.  embossed text, which means that the inside of the text will be ‚Äúcut out‚Äù so that you can see the background behind it through the outline.  An example of such an effect may look like the text in the following GIF, which shows the changing color of the background, and how this background can be seen inside our text.  Here is a demo that we will create in this section: </p><br><p><img src="https://habrastorage.org/webt/go/bq/ew/gobqewey5txr4yvz2mgvmiirnfa.gif" alt="Embossed text example"><br>  Fig_8.  An example of embossed text. </p><br><p>  This effect is easier to create, and the code needed to execute it is noticeably shorter.  The main difference here is that instead of layering the source text over the extended one, we will use the same source text to cut the inside of the extended text.  This means that only the added thickness of the expanded text will remain, and the interior will be removed, thereby leaving us only the outline. </p><br><p>  If instead of capturing and expanding the alpha channel of the text (which is black by default), you capture the source text itself (which can have any fill color!), Expand it, and then use the text again to cut the inside of the expanded text, you will get an outline, which comes from the very source text.  This means that the color of this contour will always match the color of the source text.  And since we can define the color of the source text in CSS, this means that you have an outline of the text that is separate from its styles.  (Cheers separation of worries!) Then you can apply this filter to any piece of text and change the color of this text in CSS at any time, without the need to adjust the filter code.  Our improved code now looks like this: </p><br><pre> <code class="plaintext hljs">&lt;svg width="900" height="450" viewBox="0 0 900 450"&gt; &lt;filter id="outliner"&gt; &lt;!-- Start by grabbing the alpha channel of the text and dilating it--&gt; &lt;feMorphology operator="dilate" radius="8" in="SourceAlpha" result="THICKNESS" /&gt; &lt;!-- Next, grab the original text (SourceGraphic) and use it to cut out the inside of the dilated text --&gt; &lt;feComposite operator="out" in="THICKNESS" in2="SourceGraphic"&gt;&lt;/feComposite&gt; &lt;/filter&gt; &lt;text dx="100" dy="300" filter="url(#outliner)" letter-spacing="10px"&gt;SVG Rocks&lt;/text&gt; &lt;/svg&gt;</code> </pre> <br><p>  Using a good font, our demo now looks like this: </p><br><p><img src="https://habrastorage.org/webt/ck/vc/5d/ckvc5dlnx9qb8ufj89lg21kj_wi.png"><br>  Figure_9.  The result of our work. </p><br><p>  In our style sheet, we can select the outline color as well as the background color of the SVG.  You can also select an image behind the text inside the SVG.  In the code below, I use CSS animations for no reason at all to change the background color, except that it's beautiful. </p><br><pre> <code class="plaintext hljs">svg text { font-family: 'Bangers', cursive; font-size: 150px; letter-spacing: 13px; fill: #000; /* This fill color determines the color of the outline */ } svg { background-color: gold; animation: colorsssss 2s linear infinite; animation-delay: 3s; } @keyframes colorsssss { 50% { background-color: deepPink; } }</code> </pre> <br><p>  Above SVG filter is reusable via SVG as well as HTML.  If you want to apply it to an HTML element, you can do it with the <strong>filter</strong> property;  just put the filter in HTML and ‚Äúcall‚Äù it in CSS: </p><br><pre> <code class="plaintext hljs">h2 { filter: url(#outliner); /* You can change the color of the outline here by changing the color of the heading */ color: deepPink; }</code> </pre> <br><p>  And our finished demo, which includes an HTML header with a filter applied to it: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/SaraSoueidan/embed/preview/EoEZwr" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  My favorite thing about this filter recipe is that it can be used as a visual enhancement.  If the browser does not support SVG filters, or it does not support CSS filters, or it does not support the use of SVG filters in HTML elements, the user will receive the source text without contours and a translucent effect applied to it.  Oh, and the cherry on the cake on top?  Both SVG and HTML text will be fully searchable and editable.  Hooray progressive improvement!  Long live the SVG! </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  Using just two filtering operations in SVG, you can apply the effect of the selected text to the SVG or HTML text content.  Put this filter in HTML and use it whenever you need. </p><br><p>  In the next article in this series, we will look at <strong>feComponentTransfer</strong> , one of my favorite filter primitives, and see how it works and what effects we can create with it.  Stay with us. </p></div><p>Source: <a href="https://habr.com/ru/post/439722/">https://habr.com/ru/post/439722/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
</ul></nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>