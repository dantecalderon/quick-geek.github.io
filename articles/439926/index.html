<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Retain inside and outside ViewModel</title>
  <meta name="description" content="At some point, I noticed periodic conversations about how the ViewModel actually works from google architectural components. Realizing that I do not f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Retain inside and outside ViewModel</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/up/t3/f6/upt3f6ndiin15ecpmcockiqw2v8.jpeg" alt="image"></div><br>  At some point, I noticed periodic conversations about how the <a href="https://developer.android.com/topic/libraries/architecture/viewmodel">ViewModel</a> actually works from google architectural components.  Realizing that I do not fully understand the Internet myself, I was surprised to find that there are an incredible number of similar articles on how to prepare a ViewModel, be friends with LiveData, add dependencies to it through Dagger, link with RxJava and other titles of varying degrees of utility, however, there is almost nothing about what is going on inside. <a name="habracut"></a>  So I'll try to close the gap myself. <br><br><h3>  Attention </h3><br>  TL; DR If you feel sorry for the time - shake down to the conclusion, you will lose little. <br><br>  So the first thing you can pay attention to is that there are 2 different packages of architectural components with ViewModel, namely: <br><br>  1) Old <b>android.arch.lifecycle</b> <br>  2) New <b>androidx.lifecycle</b> <br><br>  <b>Spoiler</b> : there is no particular difference between them. <br><br>  All the work lies behind the challenge: <br><br><pre><code class="kotlin hljs">ViewModelProviders.of(activity).<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(MyViewModel::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br>  Let's start with the method <font color="#0000bb">of</font> <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ViewModelProvider </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull FragmentActivity activity)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> of(activity, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ViewModelProvider </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull FragmentActivity activity, @Nullable Factory factory)</span></span></span><span class="hljs-function"> </span></span>{ Application application = checkApplication(activity); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (factory == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { factory = ViewModelProvider.AndroidViewModelFactory.getInstance(application); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ViewModelProvider(ViewModelStores.of(activity), factory); }</code> </pre> <br>  <font color="#0000bb">checkApplication</font> simply checks for null, and <font color="#0000bb">AndroidViewModelFactory</font> is just a thread-safe singleton that stores Application.  So they are of no particular interest, the most interesting in the <font color="#0000bb">ViewModelStores.of</font> method: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ViewModelStore </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull FragmentActivity activity)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (activity <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ViewModelStoreOwner) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((ViewModelStoreOwner) activity).getViewModelStore(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> holderFragmentFor(activity).getViewModelStore(); }</code> </pre> <br>  At first glance, it looks rather strange - why is it even checking for the presence of the <font color="#0000bb">FragmentActivity</font> <font color="#0000bb">ViewModelStoreOwner</font> interface if <b>it already implements it</b> ?  - It wasn‚Äôt always like this - until February 2018, when <b>Support Library 27.1.0 was released</b> , FragmentActivity never implemented ViewModelStoreOwner.  At the same time, ViewModel worked quite well for itself. <br><br>  So let's start with the old case - the <font color="#0000bb">holderFragmentFor</font> method was <font color="#0000bb">launched</font> : <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HolderFragment </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">holderFragmentFor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FragmentActivity activity)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sHolderFragmentManager.holderFragmentFor(activity); }</code> </pre> <br>  Then just get or create a new <font color="#0000bb">holder</font> fragment: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-function">HolderFragment </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">holderFragmentFor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FragmentActivity activity)</span></span></span><span class="hljs-function"> </span></span>{ FragmentManager fm = activity.getSupportFragmentManager(); HolderFragment holder = findHolderFragment(fm); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (holder != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> holder; } holder = mNotCommittedActivityHolders.get(activity); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (holder != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> holder; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!mActivityCallbacksIsAdded) { mActivityCallbacksIsAdded = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; activity.getApplication().registerActivityLifecycleCallbacks(mActivityCallbacks); } holder = createHolderFragment(fm); mNotCommittedActivityHolders.put(activity, holder); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> holder; }</code> </pre> <br>  Well, <font color="#0000bb">HolderFragment</font> itself <font color="#0000bb">is of</font> course <b>retained</b> <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HolderFragment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ setRetainInstance(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); }</code> </pre> <br>  Actually, the <b>ViewModelStere</b> object is stored in it, which in turn holds the <font color="#0000bb">ViewModel</font> pack in itself: <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewModelStore</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> HashMap&lt;String, ViewModel&gt; mMap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">put</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String key, ViewModel viewModel)</span></span></span><span class="hljs-function"> </span></span>{ ViewModel oldViewModel = mMap.put(key, viewModel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oldViewModel != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { oldViewModel.onCleared(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> ViewModel </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String key)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mMap.get(key); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (ViewModel vm : mMap.values()) { vm.onCleared(); } mMap.clear(); } }</code> </pre> <br>  Go back to the case when the support library version is 27.1.0 and higher.  FragmentActivity already implements the ViewModelStoreOwner interface, that is, the implementation of the only <font color="#0000bb">getViewModelStore</font> method: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ViewModelStore </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getViewModelStore</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getApplication() == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"Your activity is not yet attached to the Application instance. You can't request ViewModel before onCreate call."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mViewModelStore == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { FragmentActivity.NonConfigurationInstances nc = (FragmentActivity.NonConfigurationInstances)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getLastNonConfigurationInstance(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nc != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mViewModelStore = nc.viewModelStore; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mViewModelStore == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mViewModelStore = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ViewModelStore(); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mViewModelStore; } }</code> </pre> <br>  Here I will simplify a little - <b>NonConfigurationInstances</b> is an object with what should not depend on the configuration (obviously from the name), which lies in the <font color="#0000bb">Activity</font> and sweeps inside the <font color="#0000bb">ActivityClientRecord</font> through <font color="#0000bb">ActivityThread</font> during the re-creation between <font color="#0000bb">onStop</font> and <font color="#0000bb">onDestroy</font> <br><br>  In general, it looks quite funny - instead of a live hacking with ViewModel transfer inside the <font color="#0000bb">retain</font> fragment, the developers made a clever move - they used exactly the same mechanism, but got rid of the need to create an extra fragment each time. <br><br>  <font color="#0000bb">Activity</font> has always had an interesting <b>onRetainNonConfigurationInstance</b> method.  In the Activity class, he essentially did nothing.  At all: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onRetainNonConfigurationInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre> <br>  Description in the documentation while promising: <blockquote>  If you‚Äôre a little bit different, you‚Äôll have to create a new one.  You can retrieve your event by yourself. </blockquote><br><img src="https://habrastorage.org/webt/dw/ks/hh/dwkshhmtdwgxh4pgaz7d9j16ynk.png" alt="image"><br><br>  That is, that there is no sun - it will come out in <font color="#0000bb">getLastNonConfigurationInstance ()</font> after recreating the Activity.  The developers of architectural components took advantage of this.  Of the minuses - up to 4 android does not work, there will have the old fashioned way through the retain fragment. <br><br>  The ViewModel's <font color="#0000bb">clear ()</font> method was called extremely simply - in the <font color="#0000bb">onDestroy</font> FragmentActivity method. <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onDestroy(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mViewModelStore != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; !<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isChangingConfigurations()) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mViewModelStore.clear(); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mFragments.dispatchDestroy(); }</code> </pre><br>  In fact, with Androidx, almost everything is the same, the only difference is that the getViewModelStore () method is no longer in FragmentActivity, but in <font color="#0000bb">ComponentActivity</font> , from which FragmentActivity is inherited in AndroidX.  Only the call to the clear () method has changed, it was taken from onDestroy to an independent callback that is created in the ComponentActivity constructor: <br><br><pre> <code class="java hljs"> getLifecycle().addObserver(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GenericLifecycleObserver() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStateChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LifecycleOwner source, Lifecycle.Event event)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event == Lifecycle.Event.ON_DESTROY) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isChangingConfigurations()) { getViewModelStore().clear(); } } } });</code> </pre> <br>  For the record - during the creation of the article were used: <br><br>  Support library 27.0.0, 28.0.0 <br>  androidx.lifecycle: lifecycle-viewmodel: 2.0.0 <br>  androidx.lifecycle: lifecycle-extensions: 2.0.0 <br>  android.arch.lifecycle: extensions: 1.1.1 <br>  android.arch.lifecycle: viewmodel: 1.1.1 <br><br><h3>  Findings: </h3><br>  - ViewModel did survive the re-creation of activity in the <b>retain</b> fragment until the Support library 27.1.0 appeared in February 2018 <br>  - C version <font color="#0000bb">Support library 27.1.0</font> and further, as well as in <font color="#0000bb">AndroidX</font> ViewModel went to wait for the re-creation of the Activity in <b>FragmentActivity.NonConfigurationInstances</b> ( <font color="#0000bb">ComponentActivity.NonConfigurationInstances</font> for AndroidX), in fact by the same mechanism through which retain fragments work, but creating an extra fragment is not required , all ViewModel are sent ‚Äúnear‚Äù with retain fragments. <br>  - The mechanism of the ViewModel is almost the <b>same</b> in AndroidX and the Support library <br>  - If you suddenly need (yes, I can‚Äôt even imagine why) you can drag through the data that the Activity should live while the re-creation is <font color="#0000bb">alive</font> - you can use the <font color="#0000bb">onRetainNonConfigurationInstance ()</font> / <font color="#0000bb">getLastNonConfigurationInstance () binding</font> <br>  - That the old decision, that the new look is something between a documented hack and crutches </div><p>Source: <a href="https://habr.com/ru/post/439926/">https://habr.com/ru/post/439926/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>