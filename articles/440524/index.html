<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Level 80 Overagineering or Raducer: Path from switch-case to classes</title>
  <meta name="description" content="What are we talking about? 


 Let's look at the metamorphosis of the reducer in my Redux / NGRX applications for the last couple of years. Starting w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Level 80 Overagineering or Raducer: Path from switch-case to classes</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/ud/sm/oe/udsmoenal1bazibn-vxzwkytz_8.jpeg" alt="image"></p><br><h2 id="o-chem-poydet-rech">  What are we talking about? </h2><br><p> Let's look at the metamorphosis of the reducer in my Redux / NGRX applications for the last couple of years.  Starting with the oak <code>switch-case</code> , continuing the selection from the object by key and ending with classes with decorators, blackjack and TypeScript.  We will try to review not only the history of this path, but also to find some causal link. </p><a name="habracut"></a><br><blockquote>  If you, like me, are asking questions about getting rid of a boilerplate in Redux / NGRX, then you might be interested in <a href="https://habr.com/ru/post/435322/">this article</a> . <br><br>  If you already use the approach to selecting a reducer from an object by key and are fed up with it, you can immediately flip through to "Class-Reduced Reducers". </blockquote><br><h2 id="shokoladnyy-switch-case">  Chocolate switch-case </h2><br><blockquote>  Usually <code>switch-case</code> vanilla, but it seemed to me that this seriously discriminated against all other types of <code>switch-case</code> . </blockquote><p>  So, let's take a look at the typical problem of asynchronous creation of some entity, for example, a Jedi. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> actionTypeJediCreateInit = <span class="hljs-string"><span class="hljs-string">'jedi-app/jedi-create-init'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> actionTypeJediCreateSuccess = <span class="hljs-string"><span class="hljs-string">'jedi-app/jedi-create-success'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> actionTypeJediCreateError = <span class="hljs-string"><span class="hljs-string">'jedi-app/jedi-create-error'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reducerJediInitialState = { <span class="hljs-attr"><span class="hljs-attr">loading</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-comment"><span class="hljs-comment">// –°–ø–∏—Å–æ–∫ –¥–∂–µ–¥–∞–µ–≤ data: [], error: undefined, } const reducerJedi = (state = reducerJediInitialState, action) =&gt; { switch (action.type) { case actionTypeJediCreateInit: return { ...state, loading: true, } case actionTypeJediCreateSuccess: return { loading: false, data: [...state.data, action.payload], error: undefined, } case actionTypeJediCreateError: return { ...state, loading: false, error: action.payload, } default: return state } }</span></span></code> </pre> <br><p>  I will be very frank and admit that I have never used a <code>switch-case</code> in my practice.  I would like to believe that I even have a list of reasons for this: </p><br><ul><li>  <code>switch-case</code> too easy to break: you can forget to insert <code>break</code> , you can forget about <code>default</code> . </li><li>  <code>switch-case</code> too verbose. </li><li>  <code>switch-case</code> <a href="https://stackoverflow.com/questions/4442835/what-is-the-runtime-complexity-of-a-switch-statement">almost</a> O (n).  It is not that important in itself, because  Redux doesn‚Äôt brag about amazing performance by itself, but this fact infuriates my inner connoisseur of beauty. </li></ul><br><p>  The logical way to comb all this is <a href="https://redux.js.org/recipes/reducing-boilerplate">offered by the official Redux documentation</a> - to choose a reducer from an object by key. </p><br><h2 id="vybor-redyusera-iz-obekta-po-klyuchu">  Selecting a reducer from an object by key </h2><br><p>  The idea is simple - every change of the state can be described by a function of the state and action, and each such function has a certain key (the <code>type</code> field in the action) that corresponds to it.  Since  <code>type</code> is a string, nothing prevents us from comprehending an object to all such functions, where the key is <code>type</code> and the value is a pure state transformation function (reducer).  In this case, we can choose the necessary reducer by key (O (1)), when a new action comes to the root reducer. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> actionTypeJediCreateInit = <span class="hljs-string"><span class="hljs-string">'jedi-app/jedi-create-init'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> actionTypeJediCreateSuccess = <span class="hljs-string"><span class="hljs-string">'jedi-app/jedi-create-success'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> actionTypeJediCreateError = <span class="hljs-string"><span class="hljs-string">'jedi-app/jedi-create-error'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reducerJediInitialState = { <span class="hljs-attr"><span class="hljs-attr">loading</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">data</span></span>: [], <span class="hljs-attr"><span class="hljs-attr">error</span></span>: <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reducerJediMap = { [actionTypeJediCreateInit]: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ ...state, <span class="hljs-attr"><span class="hljs-attr">loading</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }), [actionTypeJediCreateSuccess]: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, action</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">loading</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">data</span></span>: [...state.data, action.payload], <span class="hljs-attr"><span class="hljs-attr">error</span></span>: <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>, }), [actionTypeJediCreateError]: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, action</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ ...state, <span class="hljs-attr"><span class="hljs-attr">loading</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">error</span></span>: action.payload, }), } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reducerJedi = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state = reducerJediInitialState, action</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// –í—ã–±–∏—Ä–∞–µ–º —Ä–µ–¥—å—é—Å–µ—Ä –ø–æ `type` —ç–∫—à–Ω–∞ const reducer = reducerJediMap[action.type] if (!reducer) { // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∏—Å—Ö–æ–¥–Ω—ã–π —Å—Ç–µ–π—Ç, –µ—Å–ª–∏ –Ω–∞—à –æ–±—ä–µ–∫—Ç –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –ø–æ–¥—Ö–æ–¥—è—â–µ–≥–æ —Ä–µ–¥—å—é—Å–µ—Ä–∞ return state } // –í—ã–ø–æ–ª–Ω—è–µ–º –Ω–∞–π–¥–µ–Ω–Ω—ã–π —Ä–µ–¥—å—é—Å–µ—Ä –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –Ω–æ–≤—ã–π —Å—Ç–µ–π—Ç return reducer(state, action) }</span></span></code> </pre> <br><p>  The most delicious thing here is that the logic inside <code>reducerJedi</code> remains the same for any reducer, and we can reuse it.  There is even a <a href="https://github.com/kolodny/redux-create-reducer">redux-create-reducer nano-library for this</a> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { createReducer } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'redux-create-reducer'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> actionTypeJediCreateInit = <span class="hljs-string"><span class="hljs-string">'jedi-app/jedi-create-init'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> actionTypeJediCreateSuccess = <span class="hljs-string"><span class="hljs-string">'jedi-app/jedi-create-success'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> actionTypeJediCreateError = <span class="hljs-string"><span class="hljs-string">'jedi-app/jedi-create-error'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reducerJediInitialState = { <span class="hljs-attr"><span class="hljs-attr">loading</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">data</span></span>: [], <span class="hljs-attr"><span class="hljs-attr">error</span></span>: <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reducerJedi = createReducer(reducerJediInitialState, { [actionTypeJediCreateInit]: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ ...state, <span class="hljs-attr"><span class="hljs-attr">loading</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }), [actionTypeJediCreateSuccess]: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, action</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">loading</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">data</span></span>: [...state.data, action.payload], <span class="hljs-attr"><span class="hljs-attr">error</span></span>: <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>, }), [actionTypeJediCreateError]: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, action</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ ...state, <span class="hljs-attr"><span class="hljs-attr">loading</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">error</span></span>: action.payload, }), })</code> </pre> <br><p>  It seems to be nothing like that happened.  True, a spoon of honey is not without a barrel of tar: </p><br><ul><li>  For complex reduser we have to leave comments, because  This method does not provide a way out of the box to provide some explanatory meta-information. </li><li>  Objects with lots of reducers and keys are not very readable. </li><li>  Only one key corresponds to each reducer.  And what if you want to run the same reducer for several action games? </li></ul><br><p>  I almost burst into tears of happiness when I moved to class-based reducers, and below I‚Äôll tell you why. </p><br><h2 id="redyusery-na-osnove-klassov">  Class-based Reducers </h2><br><p>  Buns: </p><br><ul><li>  Class methods are our reducers, and methods have names.  Just the very meta-information that tells you what this reducer is doing. </li><li>  Class methods can be decorated, which is a simple declarative way to link the reduction gears and the corresponding actions (just actions, not one action!) </li><li>  Under the hood, you can use all the same objects to get O (1). </li></ul><br><p>  In the end, I would like to get something like that. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> actionTypeJediCreateInit = <span class="hljs-string"><span class="hljs-string">'jedi-app/jedi-create-init'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> actionTypeJediCreateSuccess = <span class="hljs-string"><span class="hljs-string">'jedi-app/jedi-create-success'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> actionTypeJediCreateError = <span class="hljs-string"><span class="hljs-string">'jedi-app/jedi-create-error'</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReducerJedi</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// –°–º–æ—Ç—Ä–∏–º –Ω–∞ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –æ "Class field delcaratrions", –∫–æ—Ç–æ—Ä–æ–µ –Ω—ã–Ω—á–µ –≤ Stage 3. // https://github.com/tc39/proposal-class-fields initialState = { loading: false, data: [], error: undefined, } @Action(actionTypeJediCreateInit) startLoading(state) { return { ...state, loading: true, } } @Action(actionTypeJediCreateSuccess) addNewJedi(state, action) { return { loading: false, data: [...state.data, action.payload], error: undefined, } } @Action(actionTypeJediCreateError) error(state, action) { return { ...state, loading: false, error: action.payload, } } }</span></span></code> </pre> <br><p>  I see a purpose, but I do not see obstacles. </p><br><h3 id="shag-1-dekorator-action">  Step 1. <code>@Action</code> decorator. </h3><br><p>  We need to get any number of actions in this decorator, and to preserve these as some kind of meta-information that can be accessed later.  To do this, we can use the wonderful <a href="https://github.com/rbuckton/reflect-metadata">reflect-metadata</a> polyfill, which patches <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect">Reflect</a> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> METADATA_KEY_ACTION = <span class="hljs-string"><span class="hljs-string">'reducer-class-action-metadata'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Action = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...actionTypes</span></span></span><span class="hljs-function">) =&gt;</span></span> (target, propertyKey, descriptor) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.defineMetadata(METADATA_KEY_ACTION, actionTypes, target, propertyKey) }</code> </pre> <br><h3 id="shag-2-prevraschaem-klass-v-sobstvenno-redyuser">  Step 2. We turn the class into, in fact, a reducer. </h3><br><blockquote>  We drew a circle, drew a second one, and now a little magic and we get an owl! </blockquote><p>  As we know, each reducer is a pure function that takes the current state and action and returns a new state.  A class is, of course, a function, but not exactly the one we need, and the ES6 classes cannot be called without <code>new</code> .  In general, you need to somehow convert it. </p><br><p>  So, we need a function that accepts the current class, passes through each of its methods, collects meta-information with action types, collects an object with reduction gears, and creates the final reduction gear from this object. </p><br><p>  Let's start with the collection of meta-information. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getReducerClassMethodsWthActionTypes = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">instance</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// –ü–æ–ª—É—á–∞–µ–º –Ω–∞–∑–≤–∞–Ω–∏—è –º–µ—Ç–æ–¥–æ–≤ –∏–∑ –ø—Ä–æ—Ç–æ—Ç–∏–ø–∞ –∫–ª–∞—Å—Å–∞ const proto = Object.getPrototypeOf(instance) const methodNames = Object.getOwnPropertyNames(proto).filter( (name) =&gt; name !== 'constructor', ) // –ù–∞ –≤—ã—Ö–æ–¥–µ –º—ã —Ö–æ—Ç–∏–º –ø–æ–ª—É—á–∏—Ç—å –∫–æ–ª–ª–µ–∫—Ü–∏—é —Å —Ç–∏–ø–∞–º–∏ —ç–∫—à–Ω–æ–≤ –∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–º–∏ —Ä–µ–¥—å—é—Å–µ—Ä–∞–º–∏ const res = [] methodNames.forEach((methodName) =&gt; { const actionTypes = Reflect.getMetadata( METADATA_KEY_ACTION, instance, methodName, ) // –ú—ã —Ö–æ—Ç–∏–º –ø—Ä–∏–≤—è–∑–∞—Ç—å –∫–æ–Ω–µ–∫—Å—Ç `this` –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –º–µ—Ç–æ–¥–∞ const method = instance[methodName].bind(instance) // –ù–µ–æ–±—Ö–æ–¥–∏–º–æ —É—á–µ—Å—Ç—å, —á—Ç–æ –∫–∞–∂–¥–æ–º—É —Ä–µ–¥—å—é—Å–µ—Ä—É –º–æ–≥—É—Ç —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —ç–∫—à–Ω —Ç–∏–ø–æ–≤ actionTypes.forEach((actionType) =&gt; res.push({ actionType, method, }), ) }) return res }</span></span></code> </pre> <br><p>  Now we can convert the resulting collection to an object. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getReducerMap = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">methodsWithActionTypes</span></span></span><span class="hljs-function">) =&gt;</span></span> methodsWithActionTypes.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reducerMap, { method, actionType }</span></span></span><span class="hljs-function">) =&gt;</span></span> { reducerMap[actionType] = method <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reducerMap }, {})</code> </pre> <br><p>  Thus, the final function might look like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { createReducer } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'redux-create-reducer'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> createClassReducer = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReducerClass</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reducerClass = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReducerClass() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> methodsWithActionTypes = getReducerClassMethodsWthActionTypes( reducerClass, ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reducerMap = getReducerMap(methodsWithActionTypes) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> initialState = reducerClass.initialState <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reducer = createReducer(initialState, reducerMap) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reducer }</code> </pre> <br><p>  Next, we can apply it to our <code>ReducerJedi</code> class. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reducerJedi = createClassReducer(ReducerJedi)</code> </pre> <br><h3 id="shag-3-smotrim-chto-poluchilos-v-itoge">  Step 3. We look that turned out as a result. </h3><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// –ü–µ—Ä–µ–º–µ—Å—Ç–∏–º –æ–±—â–∏–π –∫–æ–¥ –≤ –æ—Ç–¥–µ–ª—å–Ω—ã–π –º–æ–¥—É–ª—å import { Action, createClassReducer } from 'utils/reducer-class' const actionTypeJediCreateInit = 'jedi-app/jedi-create-init' const actionTypeJediCreateSuccess = 'jedi-app/jedi-create-success' const actionTypeJediCreateError = 'jedi-app/jedi-create-error' class ReducerJedi { // –°–º–æ—Ç—Ä–∏–º –Ω–∞ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –æ "Class field delcaratrions", –∫–æ—Ç–æ—Ä–æ–µ –Ω—ã–Ω—á–µ –≤ Stage 3. // https://github.com/tc39/proposal-class-fields initialState = { loading: false, data: [], error: undefined, } @Action(actionTypeJediCreateInit) startLoading(state) { return { ...state, loading: true, } } @Action(actionTypeJediCreateSuccess) addNewJedi(state, action) { return { loading: false, data: [...state.data, action.payload], error: undefined, } } @Action(actionTypeJediCreateError) error(state, action) { return { ...state, loading: false, error: action.payload, } } } export const reducerJedi = createClassReducer(ReducerJedi)</span></span></code> </pre> <br><h2 id="kak-zhit-dalshe">  How to live on? </h2><br><p>  Something we left behind the scenes: </p><br><ul><li>  What if the same action type matches several reducers? </li><li>  It would be great to add <a href="https://github.com/mweststrate/immer">immer</a> out of the box. </li><li>  What if we want to use classes to create our actions?  Or functions (action creators)?  I wish the decorator could accept not only the types of actions, but also the actions creators. </li></ul><br><p>  All this functionality with additional examples is in a small library <a href="https://github.com/keenondrums/reducer-class">reducer-class</a> . </p><br><p>  It is worth noting that the idea of ‚Äã‚Äãusing classes for reducers is not new.  <a href="https://github.com/amcdnl">@amcdnl</a> once created a great library of <a href="https://github.com/amcdnl/ngrx-actions">ngrx-actions</a> , but it seems that he is now scoring it and switching to <a href="https://github.com/ngxs/store">NGXS</a> .  In addition, I wanted more stringent typing and reset ballast as Angular-specific functionality.  <a href="https://github.com/keenondrums/reducer-class">Here you can find a list of key differences between the reducer-class and ngrx-actions.</a> </p><br><blockquote>  If you like the idea of ‚Äã‚Äãclasses for the reduction devices, then you might also like to use classes for your action games.  Take a look at <a href="https://github.com/keenondrums/flux-action-class">flux-action-class</a> . </blockquote><p>  I hope you did not waste your time, and the article was just a little useful to you.  Please kick and criticize.  We will learn to code better together. </p></div><p>Source: <a href="https://habr.com/ru/post/440524/">https://habr.com/ru/post/440524/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>