<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A simple way to add multiple languages ‚Äã‚Äãto the site</title>
  <meta name="description" content="Introduction 
 As part of my project, I was faced with the task of making the company's current website multilingual. More precisely: to create the ab...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>A simple way to add multiple languages ‚Äã‚Äãto the site</h1><div class="post__text post__text-html js-mediator-article"><h2>  Introduction </h2><br>  As part of my project, I was faced with the task of making the company's current website multilingual.  More precisely: to create the ability to quickly and easily translate the site into English, Polish, Italian, etc. <br><br>  An Internet search showed that the existing options for creating a multilingual site are extremely cumbersome and inefficient.  Connecting third-party libraries is often problematic, and tips for writing your own solution are associated with a large amount of uniform work. <br><br>  Writing an alternative method of changing the locale took me only a few hours, and maintaining semantic unity minimizes changes with the subsequent addition of new pages. <br><br>  The source files of the sample site with automatic translation can be downloaded <a href="https://github.com/NickZabolotskiy/multi-language-site">on github</a> <br><a name="habracut"></a><br><h2>  Existing Alternatives </h2><br>  When the task first appeared in development, the first step, of course, was the study of ready-made solutions and tips on the forums on how to most easily and correctly implement the possibility of changing the locale.  The most popular Internet resources for creating multilingual websites are offering the following solutions: <br><br><ul><li>  Creating duplicate html blocks with text in different languages, of which only one is left active for the user, while the rest are hidden (display: none). <br><br>  The obvious disadvantage of this method is the incredibly rapid increase in the code and the instantaneous loss of readability and maintainability of the code.  In addition, this solution is vulnerable to errors in the text and scalability in terms of increasing the number of languages ‚Äã‚Äã(hereinafter referred to as locales). <br></li><li>  Connecting a third-party machine translation service (such as google translate) with a large number of built-in languages ‚Äã‚Äãand minimal changes in the source code of the page. <br><br>  When the task first appeared in the task list, we used this method as the most obvious and convenient, however, experience with clients - native speakers from the United States and Israel showed that machine translation often makes mistakes when changing locale, and users of sites extremely sharply react to such translation errors.  In the end, the strategic partners strongly advised to change the method of changing the locale, and this method had to be abandoned. <br></li><li>  Change language using js features or third-party libraries / frameworks, such as jQuery, based on searching and directly modifying DOM elements. <br><br>  A feature of this approach is the search for a huge number of js selectors, the text inside which you need to replace.  This approach may work well for small projects, but as the number of pages increases, the number of text replacement functions increases proportionally, which leads to a loss of efficiency in large projects. <br></li></ul><br><h2>  Alternative solution </h2><br>  The basis of the approach that I propose as an alternative to the existing methods is, oddly enough, the base of the js code I wrote, which is generally trivial, but the rule is the design of selectors, which allows for flexible and simple translation of any number of pages into any language changes to the code base and unnecessary data duplication. <br><br>  In changing the locale with an alternative approach, there are three main players: <br><br><ul><li>  html page with an established rule for the design of block selectors with text <br></li><li>  general js service, the main task of which is to replace textContet DOM elements according to the rule for the design of selectors <br></li><li>  JSON file of locale containing structure with content of html blocks in all languages ‚Äã‚Äãused when changing locale <br></li></ul><br>  Compliance with the design rules for selectable elements allows you to eliminate the need to change the js code of the locale change service, which is a big plus in terms of the scalability of the project. <br><br><h2>  The rule of building selectors </h2><br>  Most methods of changing the page locale (among the alternatives 1.3 and partially 2) imply the need to ‚Äúmark‚Äù the variable html block in some way, as correctly by changing the class field.  The same mechanism uses an alternative option. <br><br>  The first step in the design of the selectors is to divide the source page into top-level functional blocks.  On our company page are blocks: <br>  Each block is given a code name, for example, <br><br><ul><li><p>  <strong>Menu</strong> </p></li><li><p>  <strong>Business card</strong> (home) </p></li><li><p>  <strong>Example of the service</strong> (example) </p></li><li><p>  <strong>Partners</strong> (clients) </p></li><li><p>  <strong>Scope of service</strong> (userfulBlock) </p></li><li><p>  <strong>Examples of the service</strong> (examples) </p></li><li><p>  <strong>Contacts and feedback</strong> (contacts) </p></li></ul><br><div class="spoiler">  <b class="spoiler_title">An example on the site</b> <div class="spoiler_text"><img src="https://ferretvideo.com/articles/changeLocale/2.jpg" alt="An example on the site"><br></div></div><br>  After that, we further divide each block into smaller functional blocks, as is done when using the React library. <br><br><div class="spoiler">  <b class="spoiler_title">An example on the site</b> <div class="spoiler_text"><img src="https://ferretvideo.com/articles/changeLocale/1.jpg" alt="An example on the site"><br></div></div><br>  We assign our names to the selected areas and get the structure of the form: <br><br><ul><li><p>  <strong>menu</strong> </p></li><li><p>  <strong>home</strong> main, description, buttons </p></li><li><p>  <strong>example</strong> statistics, headline, description, buttons </p></li><li><p>  <strong>clients</strong> buttons </p></li><li><p>  <strong>userfulBlock</strong> headline, userfulCards, elseBlock </p></li><li><p>  <strong>examples</strong> headline, cards </p></li><li><p>  <strong>contacts</strong> headline, description, contacts, form </p></li></ul><br>  Further we continue this procedure until we reach the blocks containing the source text. <br><br>  As a result, we get a ready-made JSON file structure of the locale, containing all the necessary texts to change the language.  Also, based on this algorithm, the rule for building selectors is determined: <br><br>  Each selector starts with the locale keyword and further, according to the dash case style, the names of all parent blocks are added, including the block containing the source text, for example, the example description in the first card will have the locale-example-cards-description selector <br><br><div class="spoiler">  <b class="spoiler_title">An example on the site</b> <div class="spoiler_text"><img src="https://ferretvideo.com/articles/changeLocale/3.jpg" alt="An example on the site"><br></div></div><br>  An example of the resulting json file locale can be seen <a href="https://github.com/NickZabolotskiy/multi-language-site">on github</a> <br><br><h2>  Service change locale </h2><br>  The locale change service is a module that contains the function to load a locale file. <br><br><pre><code class="javascript hljs">loadLocale(defLang)</code> </pre> <br>  with optional parameter defLang - language set after loading the locale (default language), as well as the main function of changing the current locale <br><br><pre> <code class="javascript hljs">changeLocale(lang)</code> </pre> <br>  indicating the required language. <br><br><h3>  Load locale function </h3><br>  The locale download function uses a standard XMLHttpRequest request for data.  The use of this standard standard is due to the desire to minimize the number of dependencies and the ease of use of the query.  After receiving the locale file, a notification about data acquisition is displayed in the console, and the function of changing the locale to the default language is called if this language was passed to the function as an optional parameter.  You can view the function code here: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadLocale</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">defLang</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); xhr.open(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-string"><span class="hljs-string">'http://localhost:3000/locale.json'</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); xhr.onreadystatechange = saveLocale.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); xhr.onerror = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"no found page"</span></span>); }; xhr.send(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveLocale</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xhr.readyState == XMLHttpRequest.DONE &amp;&amp; xhr.status == <span class="hljs-number"><span class="hljs-number">200</span></span>) { locale = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(xhr.responseText); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"locale loaded"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(defLang) changeLocale(defLang); } } }</code> </pre><br><h3>  Locale change function </h3><br><h4>  Data types </h4><br>  It is a recursive function whose main task is to crawl an object containing the page locale (using the DFS algorithm).  Using recursion when building a function allows you to code the algorithm as simply and concisely as possible, but too much recursion depth can lead to stack overflow.  Features of the workaround for this problem can be found on the forum of the same name, or by reading the relevant articles on habr.com. <br><br>  The basis of the recursive function is the processing of 4 data types: <br><br><ul><li>  a field containing a string of source text used to add to the page. <br>  For example: <br><br><pre> <code class="plaintext hljs">"main": "–ü—Ä–æ–¥–∞—é—â–∏–π –∫–≤–µ—Å—Ç –∏–∑ –≤–∞—à–µ–≥–æ –≤–∏–¥–µ–æ"</code> </pre> <br></li><li>  a field containing an array of source lines used to add to <br>  page.  Such a field is necessary for creating lists whose elements can be changed. <br>  order  For example: <br><br><pre> <code class="plaintext hljs">"menu":["Home","Example","Clients","Info","Contacts"]</code> </pre> <br></li><li>  A nested data structure containing its own set of fields required for building <br>  page architecture.  For example: <br><br><pre> <code class="plaintext hljs"> "home": { "main": "selling quest from your video", "description": "for social networks &amp; sites", "buttons": ["try","order"] }</code> </pre><br></li><li>  An array of nested data structures with the same set of fields used.  Such <br>  arrays are used when lists of identical blocks of code appear, for example, <br>  cards of team members, or portfolio or tariffs of services provided. <br>  For example: <br><br><pre> <code class="plaintext hljs"> "usefulCards": [ { "headline": "Marketers and agencies", "statistics": ["convers 26%", "retent 25%"], "button": "ORDER" }, { "headline": "Production studios and TV platforms", "statistics": ["convers 24%", "retent 33%"], "button": "ORDER" }, { "headline": "Conference creators", "statistics": ["convers 65%", "retent 15%"], "button": "ORDER" }, { "headline": "Bloggers and streamers", "statistics": ["convers 24%", "retent 33%"], "button": "ORDER" } ],</code> </pre><br>  On the site, it might look like this: <br><br><div class="spoiler">  <b class="spoiler_title">An example on the site</b> <div class="spoiler_text"><img src="https://ferretvideo.com/articles/changeLocale/4.jpg" alt="An example on the site"><br></div></div><br></li></ul><br><h4>  Processing functions </h4><br>  Processing the data type with the source text is a separate function. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getText</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key, object, name,startIndex</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br>  The host field name of the structure with the source text, the current locale object containing the text that you want to add and the current name of the selector needed to find the DOM element. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getText</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key, object, name, startIndex</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elementKey=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(startIndex) elementKey = startIndex; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( ; elementKey &lt; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementsByClassName(name + <span class="hljs-string"><span class="hljs-string">"-"</span></span> + key).length; elementKey++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-built_in"><span class="hljs-built_in">isNaN</span></span>(elementKey)) <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementsByClassName(name + <span class="hljs-string"><span class="hljs-string">"-"</span></span> + key)[elementKey].textContent = object[key]; }</code> </pre><br>  Processing the array of strings with source text is also performed by a separate function. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getArrayText</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key, object, name,startIndex</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br>  The signature and the body of this function is no different from the past, except that elements from the array are assigned to the DOM elements. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getArrayText</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key, object, name, startIndex</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elementKey=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(startIndex) elementKey = startIndex; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( ; elementKey &lt; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementsByClassName(name + <span class="hljs-string"><span class="hljs-string">"-"</span></span> + key).length; elementKey++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-built_in"><span class="hljs-built_in">isNaN</span></span>(elementKey)) <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementsByClassName(name + <span class="hljs-string"><span class="hljs-string">"-"</span></span> + key)[elementKey].textContent = object[key][elementKey % object[key].length]; }</code> </pre><br>  The main recursive replacement function of the text is engaged in the classification of the current locale field into one of the 4 types listed above and the corresponding reaction to the resulting type: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">changeText</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, object, startIndex</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> object) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.isArray(object[key]) &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> object[key] != <span class="hljs-string"><span class="hljs-string">'string'</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> object[key][<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'string'</span></span>) getArrayText(key, object, name); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> object[key] == <span class="hljs-string"><span class="hljs-string">"object"</span></span> ){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">isNaN</span></span>(key)) changeText(name + <span class="hljs-string"><span class="hljs-string">"-"</span></span> + key, object[key]); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> changeText(name, object[key],key); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> getText(key, object, name, startIndex); }</code> </pre><br>  This function accepts the current language locale and the root selector (in this case ‚Äúlocale‚Äù) as input.  Further, when a nested structure or array of structures is detected, the function will recursively call itself, changing the input parameters accordingly. <br><br>  The main advantage of the alternative approach is that the service described above does not require any functional changes, and is added as a js file using the locale file you created. <br><br><h2>  Conclusion </h2><br>  The essence of the approach described above consists in a fixed rule for describing selectors and building a locale file.  Because of this, there is a unique opportunity to translate any pages out of the box and reuse the already translated material. <br><br>  The algorithm for building selectors described above is not mandatory and critical for the operation of the service.  The service is flexible for extending and adding new methods and algorithms, as well as for building selector names and the json locale structure.  A possible advantage will be saving the locale in the browser‚Äôs cookie and changing the locale, depending on the location of the service user. <br><br>  The source files of the sample site with automatic translation can be downloaded <a href="https://github.com/NickZabolotskiy/multi-language-site">on github</a> . </div><p>Source: <a href="https://habr.com/ru/post/437124/">https://habr.com/ru/post/437124/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>