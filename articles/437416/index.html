<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Capacity Management: Looking for the Perfect Balance</title>
  <meta name="description" content="Hello! My name is Ivan Davydov, I do research on performance in Yandex.Money. 


 Imagine that you have powerful servers, each of which hosts a number...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Capacity Management: Looking for the Perfect Balance</h1><div class="post__text post__text-html js-mediator-article"><p>  Hello!  My name is Ivan Davydov, I do research on performance in Yandex.Money. </p><br><p>  Imagine that you have powerful servers, each of which hosts a number of applications.  If the latter are not very many, they do not interfere with each other's work - they are comfortable and cozy.  One day you come to microservices and bring some of the ‚Äúheavy‚Äù functionality into separate applications. </p><br><p>  Here you can get carried away, and microservices will become too much, as a result of which it will become difficult to manage them and ensure their fault tolerance.  As a result, on each server will be a bunch of a dozen applications that are fighting for shared resources.  It turns out "big family", but in a big family do not click with your beak! </p><br><p>  Once we also encountered this.  My story will be about hard and sleepless nights when I sat under a lamp in the night and fired on the prod.  It all started with the fact that we began to notice on the combat servers the problems associated with the network. </p><br><p><img src="https://habrastorage.org/webt/oy/x6/zl/oyx6zly8ejckx_cr0devc65tdb0.png"></p><a name="habracut"></a><br><p>  They strongly influenced the performance and made a noticeable drawdown.  At the same time, it turned out that the same errors also occur with a normal user thread, but to a much smaller extent. </p><br><p>  The problem was hidden in the utilization of TCP sockets for more than 100%.  This happens when all the sockets available on the servers are constantly opened and closed.  Because of this, there are network problems of interaction between applications and various kinds of errors appear - the remote host is unavailable, the HTTP / HTTPS connection is disconnected (connection / read timeout, SSL peer shut down incorrectly) and others. </p><br><p>  Even if you do not have your own electronic payment service, it is not very difficult to estimate the scale of pain during any regular sale - the traffic increases several times, and the degradation of performance can lead to significant losses.  So we came to two conclusions - it is necessary to evaluate how current capacities are used and to isolate applications from each other. </p><br><p>  To isolate applications, we decided to resort to containerization.  For this we used a hypervisor, which contains many separate containers with applications.  This allows you to isolate CPU, memory, I / O, network resources, as well as process trees, users, file systems, and so on. </p><br><p>  With this approach, each application has its own environment, which provides flexibility, isolation, reliability, and increases the overall system performance.  This is a beautiful and elegant solution, but before that you need to answer a number of questions: </p><br><ul><li>  What performance margin does one application instance currently have? </li><li>  How does the application scale and is there resource redundancy in the current configuration? </li><li>  Is it possible to improve the performance of a single instance and what is the ‚Äúbottleneck‚Äù? </li></ul><br><p>  With such questions, colleagues came to us - a team of productivity researchers. </p><br><h2 id="chem-my-zanimaemsya">  What are we doing? </h2><br><p>  We do everything to ensure the performance of our service and, first of all, we research and improve it for the business processes of our production.  Each business process, whether it be payment for goods in a purse store or money transfer between users, in essence, represents for us a chain of inquiries in the system. </p><br><p>  We conduct experiments and compile reports to evaluate system performance at high intensity of incoming requests.  The reports contain performance metrics and a detailed description of the problems and bottlenecks identified.  With this information we improve and optimize our system. </p><br><p>  Assessing the potential of each application is complicated by the fact that several microservices that use the power of all the involved instances are involved in organizing the sequence of business process requests. </p><br><p>  Metaphorically speaking, we know the power of our army, but we do not know the potential of each of the fighters.  Therefore, in addition to ongoing research, it is necessary to evaluate the resources used in the capacity management process.  This process is called ‚ÄúCapacity management.‚Äù </p><br><p>  Our research helps to identify and prevent a shortage of resources, to predict iron purchases and to have accurate data on the current and potential capabilities of the system.  As part of this process, the current application performance (both median and maximum) is monitored and current stock data is provided. </p><br><p>  <strong>The essence of power management is finding a balance between consumed resources and performance.</strong> </p><br><p>  Pros: </p><br><ul><li>  At any moment, we know what happens with the performance of each application. </li><li>  Less risks when adding new microservices. </li><li>  Lower costs for the purchase of new equipment. </li><li>  Those powers that are already there are used more intelligently. </li></ul><br><h1 id="kak-rabotaet-upravlenie-moschnostyami">  How power management works </h1><br><p>  Let's return to our situation with a variety of applications.  We conducted a study, the purpose of which was to assess how power is used on production servers. </p><br><p>  In short, the action plan is as follows: </p><br><ol><li>  Determine user intensity on specific applications. </li><li>  Make a profile of shooting. </li><li>  Evaluate the performance of each application instance. </li><li>  Evaluate scalability. </li><li>  Compile reports and conclusions on the minimum required number of instances for each application in a combat environment. </li></ol><br><p>  <em>And now more.</em> </p><br><h2 id="instrumenty">  Instruments </h2><br><p>  We use Heka and Zabbix to collect custom intensity metrics.  Grafana is used to visualize the collected metrics. </p><br><p>  <strong>Zabbix is</strong> needed to monitor server resources, such as: CPU, Memory, Network connections, DB and others.  <strong>Heka</strong> provides data on the number and execution time of incoming / outgoing requests, collecting metrics for internal application queues, and an infinite amount of other data.  <strong>Grafana</strong> is a flexible visualization tool that is used by various Yandex.Money teams.  We are no exception. </p><br><p><img src="https://habrastorage.org/webt/5q/ru/bu/5qrubu5iblepg4sostjygegfp58.png"><br>  <em>Grafana can show such things, for example.</em> </p><br><p>  <strong>Apache JMeter is</strong> used as a traffic generator.  With it, a shooting script is compiled, which includes the implementation of requests, monitoring the validity of a response, flexible control of the feed stream and much more.  This tool has both its advantages and disadvantages, but I will not go "why this particular product?" </p><br><p>  In addition to JMeter, the <strong>yandex-tank</strong> framework is a tool for load testing and analyzing the performance of web services and applications.  It allows you to connect your modules to get any desired functions and display the results in the console or in the form of graphs.  The results of our firing are displayed in Lunapark (similar to <a href="https://overload.yandex.net/">https://overload.yandex.net</a> ), where we can observe them in detail in real time, down to the second peaks, providing the necessary and sufficient discreteness, and thereby respond more quickly to bursts, arising from the shooting.  In grafan, discreteness can also be configured, but this solution is more costly in physical and logical resources.  And sometimes we even unload the raw data and visualize it through the GUI Jmeter.  But only - shhh! </p><br><p>  By the way, about degradation.  Virtually any disruptions that occur in the application under a large flow of traffic are promptly analyzed using <strong>Kibana</strong> .  But this is also not a panacea - some network problems can be analyzed only through the removal and analysis of traffic. </p><br><p>  With the help of Grafana, we analyzed the user intensity in the application for several months.  We decided to take the total processor time for executing requests for the unit of measurement, that is, the number of requests and the time of their execution were taken into account.  So we made a list of the most "heavy" requests that make up the bulk of the flow to the application.  It was this list that formed the basis of the shooting profile. </p><br><p><img src="https://habrastorage.org/webt/5r/kc/5n/5rkc5nqnllvdoxoeqs4wlgstxfs.png"><br>  <em>User intensity per application for several months</em> </p><br><h2 id="profil-strelby-i-pristrelka">  Shooting profile and zeroing </h2><br><p>  We call shooting a script launch as part of an experiment.  The profile is made up of two parts. </p><br><p>  The first part is the creation of a query script.  When implementing, it is necessary to analyze the user intensity for each incoming request of the application and make a percentage ratio between them to identify the top most caused and long-running.  The second part is the selection of flow growth parameters: with what intensity and for how long the load is applied. </p><br><p>  For greater clarity, the method of compiling a profile is best demonstrated by example. </p><br><p>  In Grafana, a graph is plotted that reflects the user intensity and the proportion of each request in the total flow.  Based on this distribution and the response time for each of the requests, groups are created in JMeter, each of which is an independent traffic generator.  The scenario is based only on the most ‚Äúheavy‚Äù requests, since it is difficult to implement everything (in some applications there are more than a hundred), and this is not always required because of their relatively low intensity. </p><br><p><img src="https://habrastorage.org/webt/so/r-/lh/sor-lhmdrw0z5egoxcjye2z1htk.png"><br>  <em>The percentage of requests</em> </p><br><p>  In this study, user intensity at a constant flow is considered, and occasional ‚Äúbursts‚Äù occurring are most often considered in private. </p><br><p>  In our example, two groups are considered.  The first group includes ‚Äúrequest 1‚Äù and ‚Äúrequest 2‚Äù in the ratio of 1 to 2. Similarly, requests 3 and 4 are included in the second group. The remaining requests of the component have much lower intensity, so we do not include them in the script. </p><br><p><img src="https://habrastorage.org/webt/fe/oo/mv/feoomv8l4vvhd7oab7ia8sdm_iq.png"><br>  <em>Distribution of requests by groups in Jmeter</em> </p><br><p>  Based on the median response time for each group, the performance is assessed according to the formula: </p><br><p>  x = 1000 / t, where t is the median time, ms </p><br><p>  We obtain the result of the calculation and estimate the approximate intensity with increasing number of streams: </p><br><p>  TPS = x * p, where p is the number of threads, TPS is the transaction per second, and x is the result of the previous calculation. </p><br><p>  If the request is processed in 500 ms, then at one stream we have 2 Tps, and at 100 streams, ideally, we should have 200 Tps.  Based on the results obtained, the initial growth parameters can be selected.  After the first iterations of research, these parameters are usually adjusted. </p><br><p>  When the shooting scenario is ready, we launch the shooting - shooting for one minute in one stream.  This is done in order to test the performance of the script at a constant flow, estimate the response time to queries in each of the groups and get a percentage of the queries. </p><br><p>  When running such a profile, we found that with the same intensity, the percentage ratio of requests is maintained, since the average response time in the second group is longer than in the first.  Therefore, we set the same flow rate for both groups.  In other cases, we would have to experimentally select the parameters for each group separately. </p><br><p>  In this example, the intensity was applied stepwise, that is, a certain number of flows were added at a certain interval. </p><br><p><img src="https://habrastorage.org/webt/6u/th/hw/6uthhwf_o2ehsuukwdc2ko_4emi.png"><br>  <em>Intensity growth parameters</em> </p><br><p>  The growth intensity parameters were as follows: </p><br><ul><li>  The target number of streams is 100 (determined during adjustment). </li><li>  Growth for 1000 seconds (~ 16 min.). </li><li>  100 steps. </li></ul><br><p>  Thus, every 10 seconds we add one thread.  The interval between the addition of flows and the number of added flows vary depending on the behavior of the system at a particular step.  Often the intensity is supplied with a smooth growth, so that you can monitor the status of the system at each of the steps. </p><br><h2 id="boevye-strelby">  Battle Shooting </h2><br><p>  Usually shooting starts at night from remote servers.  At this time, user traffic is minimal - this means that shooting will have almost no effect on users, and the error in the results will be less. </p><br><p> According to the results of the first firing in one instance, we adjust the number of flows and the growth time, analyze the behavior of the system as a whole and find deviations in the work.  After all adjustments, re-shooting in one instance is launched.  At this stage, we determine the maximum performance and monitor the use of hardware resources as the server with the application, and all that stands behind it. </p><br><p>  According to the results of the shooting, the performance of one instance of our application was about 1000 Tps.  At the same time, an increase in the response time for all requests without an increase in productivity was recorded, that is, we reached saturation, but not degradation. </p><br><p>  At the next stage, we compare the results obtained from other instances.  This is important, as the iron can be different, which means that different instances can give very different indicators.  So it was with us - some of the servers turned out to be an order of magnitude more productive due to generation and characteristics.  Therefore, we have identified a group of servers with the best results and investigated the scalability of them. </p><br><p><img src="https://habrastorage.org/webt/cm/kt/qc/cmktqc3ytdxz24bkphym7ozyrjg.png"><br>  <em>Server performance comparison</em> </p><br><h2 id="masshtabiruemost-i-poisk-uzkih-mest">  Scalability and bottleneck search </h2><br><p>  The next step is to examine performance on 2, 3, and 4 instances.  In theory, performance should grow linearly with the number of instances.  In practice, this is usually not the case. </p><br><p>  In our example, it turned out almost perfect. </p><br><p><img src="https://habrastorage.org/webt/0s/2z/na/0s2znafo_1qtkiiyqj29t2-xhws.png"></p><br><p>  The reason for the saturation of productivity growth was the exhaustion of pools of connectors before the subsequent backend.  This is solved by controlling the size of the pools on the outgoing and incoming side and leads to an increase in application performance. </p><br><p>  In other studies, we have come up with more interesting things.  Experiments have shown that along with performance, the utilization of CPU and database connections is greatly increasing.  In our case, this happened due to the fact that in the configuration with one instance we rested on the application settings of our own pools, and with two instances we doubled this number, thereby doubling the outgoing flow.  The database was not ready for this volume.  Because of this, pools began to get clogged up to the database, the percentage of consumed CPU reached the critical level of 99%, and the query processing time increased, and some of the traffic fell off altogether.  And we got these results already with two instances! </p><br><p>  In order to finally be convinced of our fears, we fired 3 instances.  The results turned out to be approximately the same as in the first two, except that they quickly arrived at a breakdown. </p><br><p>  There is another example of ‚Äúgags‚Äù, which, in my opinion, is the most painful - this is poorly written code.  There can be anything, starting with queries to the database, which are executed in minutes, ending with code that is not efficiently using the memory of a Java machine. </p><br><h2 id="itogi">  Results </h2><br><p>  As a result, the performance instance studied in our example application instance was more than 5 times higher in performance. </p><br><p>  To increase performance, it is necessary to calculate a sufficient number of handler pools in the application settings.  Two instances for a specific application are enough, and the use of all 15 that are available is redundant. </p><br><p>  After the study, the following results were obtained: </p><br><ul><li>  User intensity for 1 month was determined and monitored. </li><li>  Revealed performance margin per application instance. </li><li>  The results of errors occurring under a large flow. </li><li>  Identified bottlenecks for further work on increasing productivity. </li><li>  Identified the minimum number of instances for the application to work correctly.  And, as a result, revealed the redundancy of capacity utilization. </li></ul><br><p>  The results of the study formed the basis of the project on the transfer of components into containers, which we will discuss in future articles.  Now we can say for sure how many containers and with what characteristics you need to have, how to rationally use their capacities and what it takes to work to ensure the performance at the proper level. </p><br><p>  Come to our cozy <a href="https://t.me/loadland">telegram chat</a> , where you can always ask for advice, help colleagues and just talk about performance research. </p><br><hr><br><p>  That's all for today.  Ask questions in the comments and subscribe to the Yandex.Money blog - we will soon tell you about phishing and how not to fall for it. </p></div><p>Source: <a href="https://habr.com/ru/post/437416/">https://habr.com/ru/post/437416/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>