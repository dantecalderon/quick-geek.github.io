<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Eliminating recursion in Python</title>
  <meta name="description" content="Hi, Habr! I present to you the translation of the article "Removing a recursion in Python, part 1" by Eric Lippert. 


 Over the past 20 years, I have...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Eliminating recursion in Python</h1><div class="post__text post__text-html js-mediator-article"><p>  Hi, Habr!  I present to you the translation of the article <a href="https://ericlippert.com/2018/12/03/removing-a-recursion-in-python/">"Removing a recursion in Python, part 1"</a> by Eric Lippert. </p><br><p>  Over the past 20 years, I have admired the simplicity and capabilities of Python, although in fact I have never worked with it and have not studied it in detail. </p><br><p>  Recently, I looked at him closer - and it turned out to be a really pleasant language. </p><br><p>  A recent question on StackOverflow made me think about how to convert a recursive algorithm into an iterative algorithm, and it turned out that Python is quite a suitable language for this. <br>  The problem faced by the author of the question was as follows: </p><a name="habracut"></a><br><ul><li>  The player is in an arbitrary cell on a numbered box; </li><li>  The goal is to return to cell number 1; </li><li>  If the player is on the even square, he pays one coin and goes half way to square 1; </li><li>  If a player is on an odd square, he can pay 5 coins and go straight to the first square or pay one coin and take one step to square 1 - to the even square. </li></ul><br><p>  The question is: what is the smallest amount of coins you need to pay to return from the current cell to the first one. </p><br><p>  The task has an obvious recursive solution: </p><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> + cost(s // <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> min(<span class="hljs-number"><span class="hljs-number">1</span></span> + cost(s - <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">5</span></span>)</code> </pre> <br><p>  However, this program fell, reaching a maximum recursion depth, most likely due to the fact that the author of the question experimented with very large numbers. <br>  Therefore, the question arises: how to turn a recursive algorithm into an iterative algorithm in Python? </p><br><p>  Before we begin, I want to note that of course there are faster solutions to this particular problem, in itself it is not very interesting. </p><br><p>  Rather, this task served only as a starting point in the question of how to generally get rid of a single recursive call in a Python program. </p><br><p>  The point is that you can transform any simple recursive method and get rid of recursion, and this is just an example that was at hand. </p><br><p>  The technique I‚Äôm going to show, of course, doesn‚Äôt quite correspond to how it is customary to write in Python, probably a solution in Python-style would use generators or other language features. </p><br><p>  What I want to show here is how to get rid of recursion, using a sequence of small and safe transformations that lead the function to a form in which it is easy to replace recursion with iteration. </p><br><p>  To begin, let's see how to bring the program to this form. </p><br><p>  At the first step of our transformation, I want the calculations made before the recursive call to be reduced to the calculation of the argument, and the calculations, after the recursive call, are performed in a separate method that accepts the result of the recursive call. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_one</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_min</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> min(n + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>: argument = s // <span class="hljs-number"><span class="hljs-number">2</span></span> result = cost(argument) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> add_one(result) argument = s - <span class="hljs-number"><span class="hljs-number">1</span></span> result = cost(argument) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get_min(result)</code> </pre> <br><p>  The second step I want to make the calculation of the argument in a separate function: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># ... def get_argument(s): if s % 2 == 0: return s // 2 return s - 1 def cost(s): if s &lt;= 1: return 0 argument = get_argument(s) result = cost(argument) if s % 2 == 0: return add_one(result) return get_min(result)</span></span></code> </pre> <br><p>  In the third step, I want to add an auxiliary function that will select the continuation function called after returning from recursion. </p><br><p>  Note that the helper function returns a function. </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#... def get_after(s): if s % 2 == 0: return add_one return get_min def cost(s): if s &lt;= 1: return 0 argument = get_argument(s) after = get_after(s) # after —ç—Ç–æ —Ñ—É–Ω–∫—Ü–∏—è! result = cost(argument) return after(result)</span></span></code> </pre> <br><p>  Now we write this in a more general and concise form: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#... def is_base_case(s): return s &lt;= 1 def base_case_value(s): return 0 def cost(s): if is_base_case(s): return base_case_value(s) argument = get_argument(s) after = get_after(s) return after(cost(argument))</span></span></code> </pre> <br><p>  It can be seen that each change made has retained the meaning of the program. </p><br><p>  Now the parity check of the number is performed twice, although before the changes there was only one check. </p><br><p>  If we want, we can solve this problem by combining two auxiliary functions into one that returns a tuple. </p><br><p>  But let's not worry about this as part of the solution to this problem. </p><br><p>  We have reduced our recursive method to the most general form. </p><br><ul><li>  In the base case: <br><ul><li>  calculate the value to return; </li><li>  return it. </li></ul></li><li>  In the non-base case: <br><ul><li>  calculate the recursion argument; </li><li>  make a recursive call; </li><li>  calculate the return value; </li><li>  return it. </li></ul></li></ul><br><p>  Something important to pay attention to at this step is that <code>after</code> should not contain <code>cost</code> calls itself. </p><br><p>  The method I show here removes a single recursive call. </p><br><p>  If you have 2 or more recursions, then we will need another solution. </p><br><p>  Once we have brought our recursive algorithm to this form, it is easy to convert it to iterative. </p><br><p>  The trick is to present what is happening in the recursive program. </p><br><p>  How we do recursive descent: we call <strong>get_argument</strong> before the recursive call and call the <strong>after</strong> function <strong>after</strong> returning from recursion. </p><br><p>  That is, all <strong>get_argument</strong> calls occur before all <strong>after</strong> calls. <br>  Therefore, we can convert this to 2 cycles: the first one calls <strong>get_argument</strong> and forms the list of <strong>after</strong> functions, and the second one calls all <strong>after</strong> functions: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#... def cost(s): # –°–æ–∑–¥–∞—ë–º —Å—Ç–µ–∫ –∏–∑ —Ñ—É–Ω–∫—Ü–∏–π "after". –í—Å–µ —ç—Ç–∏ —Ñ—É–Ω–∫—Ü–∏–∏ # –ø—Ä–∏–Ω–∏–º–∞—é—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ–≥–æ –≤—ã–∑–æ–≤–∞ –∏ –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç # –∑–Ω–∞—á–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –≤—ã—á–∏—Å–ª—è–µ—Ç —Ä–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π –º–µ—Ç–æ–¥. afters = [ ] while not is_base_case(s): argument = get_argument(s) after = get_after(s) afters.append(after) s = argument # –¢–µ–ø–µ—Ä—å —É –Ω–∞—Å –µ—Å—Ç—å —Å—Ç–µ–∫ —Ñ—É–Ω–∫—Ü–∏–π "after" : result = base_case_value(s) while len(afters) != 0: after = afters.pop() result = after(result) return result</span></span></code> </pre> <br><p>  No more recursion! </p><br><p>  It looks like magic, but all that we are doing here is the same thing that the recursive version of the program did and in the same order. </p><br><p>  This example reflects the idea that I often repeat about the call stack: <em>its purpose is to communicate what will happen next, not what has already happened!</em> </p><br><p>  The only useful information in the call stack in the recursive version of the program is what the value of the <strong>after is</strong> , since this function is called next, and everything else on the stack is not important. </p><br><p>  Instead of using the call stack as an inefficient and cumbersome way of storing the stack <strong>after</strong> , we can simply store the stack of functions <strong>after</strong> . </p><br><p>  <a href="https://ericlippert.com/2018/12/17/removing-a-recursion-in-python-part-2/">Next time</a> we will look at a more complicated way to remove recursion in Python. </p></div><p>Source: <a href="https://habr.com/ru/post/440178/">https://habr.com/ru/post/440178/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>