<div class="post__text post__text-html js-mediator-article"><p>  Hi, Habr!  I present to you the translation of the article <a href="https://ericlippert.com/2018/12/03/removing-a-recursion-in-python/">"Removing a recursion in Python, part 1"</a> by Eric Lippert. </p><br><p>  Over the past 20 years, I have admired the simplicity and capabilities of Python, although in fact I have never worked with it and have not studied it in detail. </p><br><p>  Recently, I looked at him closer - and it turned out to be a really pleasant language. </p><br><p>  A recent question on StackOverflow made me think about how to convert a recursive algorithm into an iterative algorithm, and it turned out that Python is quite a suitable language for this. <br>  The problem faced by the author of the question was as follows: </p><a name="habracut"></a><br><ul><li>  The player is in an arbitrary cell on a numbered box; </li><li>  The goal is to return to cell number 1; </li><li>  If the player is on the even square, he pays one coin and goes half way to square 1; </li><li>  If a player is on an odd square, he can pay 5 coins and go straight to the first square or pay one coin and take one step to square 1 - to the even square. </li></ul><br><p>  The question is: what is the smallest amount of coins you need to pay to return from the current cell to the first one. </p><br><p>  The task has an obvious recursive solution: </p><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> + cost(s // <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> min(<span class="hljs-number"><span class="hljs-number">1</span></span> + cost(s - <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">5</span></span>)</code> </pre> <br><p>  However, this program fell, reaching a maximum recursion depth, most likely due to the fact that the author of the question experimented with very large numbers. <br>  Therefore, the question arises: how to turn a recursive algorithm into an iterative algorithm in Python? </p><br><p>  Before we begin, I want to note that of course there are faster solutions to this particular problem, in itself it is not very interesting. </p><br><p>  Rather, this task served only as a starting point in the question of how to generally get rid of a single recursive call in a Python program. </p><br><p>  The point is that you can transform any simple recursive method and get rid of recursion, and this is just an example that was at hand. </p><br><p>  The technique I’m going to show, of course, doesn’t quite correspond to how it is customary to write in Python, probably a solution in Python-style would use generators or other language features. </p><br><p>  What I want to show here is how to get rid of recursion, using a sequence of small and safe transformations that lead the function to a form in which it is easy to replace recursion with iteration. </p><br><p>  To begin, let's see how to bring the program to this form. </p><br><p>  At the first step of our transformation, I want the calculations made before the recursive call to be reduced to the calculation of the argument, and the calculations, after the recursive call, are performed in a separate method that accepts the result of the recursive call. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_one</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_min</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> min(n + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>: argument = s // <span class="hljs-number"><span class="hljs-number">2</span></span> result = cost(argument) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> add_one(result) argument = s - <span class="hljs-number"><span class="hljs-number">1</span></span> result = cost(argument) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get_min(result)</code> </pre> <br><p>  The second step I want to make the calculation of the argument in a separate function: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># ... def get_argument(s): if s % 2 == 0: return s // 2 return s - 1 def cost(s): if s &lt;= 1: return 0 argument = get_argument(s) result = cost(argument) if s % 2 == 0: return add_one(result) return get_min(result)</span></span></code> </pre> <br><p>  In the third step, I want to add an auxiliary function that will select the continuation function called after returning from recursion. </p><br><p>  Note that the helper function returns a function. </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#... def get_after(s): if s % 2 == 0: return add_one return get_min def cost(s): if s &lt;= 1: return 0 argument = get_argument(s) after = get_after(s) # after это функция! result = cost(argument) return after(result)</span></span></code> </pre> <br><p>  Now we write this in a more general and concise form: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#... def is_base_case(s): return s &lt;= 1 def base_case_value(s): return 0 def cost(s): if is_base_case(s): return base_case_value(s) argument = get_argument(s) after = get_after(s) return after(cost(argument))</span></span></code> </pre> <br><p>  It can be seen that each change made has retained the meaning of the program. </p><br><p>  Now the parity check of the number is performed twice, although before the changes there was only one check. </p><br><p>  If we want, we can solve this problem by combining two auxiliary functions into one that returns a tuple. </p><br><p>  But let's not worry about this as part of the solution to this problem. </p><br><p>  We have reduced our recursive method to the most general form. </p><br><ul><li>  In the base case: <br><ul><li>  calculate the value to return; </li><li>  return it. </li></ul></li><li>  In the non-base case: <br><ul><li>  calculate the recursion argument; </li><li>  make a recursive call; </li><li>  calculate the return value; </li><li>  return it. </li></ul></li></ul><br><p>  Something important to pay attention to at this step is that <code>after</code> should not contain <code>cost</code> calls itself. </p><br><p>  The method I show here removes a single recursive call. </p><br><p>  If you have 2 or more recursions, then we will need another solution. </p><br><p>  Once we have brought our recursive algorithm to this form, it is easy to convert it to iterative. </p><br><p>  The trick is to present what is happening in the recursive program. </p><br><p>  How we do recursive descent: we call <strong>get_argument</strong> before the recursive call and call the <strong>after</strong> function <strong>after</strong> returning from recursion. </p><br><p>  That is, all <strong>get_argument</strong> calls occur before all <strong>after</strong> calls. <br>  Therefore, we can convert this to 2 cycles: the first one calls <strong>get_argument</strong> and forms the list of <strong>after</strong> functions, and the second one calls all <strong>after</strong> functions: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#... def cost(s): # Создаём стек из функций "after". Все эти функции # принимают результат рекурсивного вызова и возвращают # значение, которое вычисляет рекурсивный метод. afters = [ ] while not is_base_case(s): argument = get_argument(s) after = get_after(s) afters.append(after) s = argument # Теперь у нас есть стек функций "after" : result = base_case_value(s) while len(afters) != 0: after = afters.pop() result = after(result) return result</span></span></code> </pre> <br><p>  No more recursion! </p><br><p>  It looks like magic, but all that we are doing here is the same thing that the recursive version of the program did and in the same order. </p><br><p>  This example reflects the idea that I often repeat about the call stack: <em>its purpose is to communicate what will happen next, not what has already happened!</em> </p><br><p>  The only useful information in the call stack in the recursive version of the program is what the value of the <strong>after is</strong> , since this function is called next, and everything else on the stack is not important. </p><br><p>  Instead of using the call stack as an inefficient and cumbersome way of storing the stack <strong>after</strong> , we can simply store the stack of functions <strong>after</strong> . </p><br><p>  <a href="https://ericlippert.com/2018/12/17/removing-a-recursion-in-python-part-2/">Next time</a> we will look at a more complicated way to remove recursion in Python. </p></div>