<div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/6h/-4/-w/6h-4-wzp5wlydal3wkp2df8aq5a.jpeg"><br><br>  Sooner or later, developers are faced with the task of deleting unnecessary data.  And the more complex the service, the more nuances must be taken into account.  In this article, I will tell you how we implemented a “delete” in a database with a hundred links. <br><a name="habracut"></a><br><h2>  Prehistory </h2><br>  To monitor the performance of most <b>Mail.ru Group</b> and <b>VKontakte</b> projects, a proprietary service called <b>Monitoring is used</b> .  Starting its history from the end of 2012, for 6 years the project has grown into a huge system, which has acquired a lot of functionality.  Monitoring regularly checks the availability of servers and the correctness of responses to requests, collects statistics on memory usage, processor utilization, etc.  When the parameters of the monitored server are beyond the allowed values, those responsible for the server receive notifications in the system and via SMS. <br><br>  All checks and incidents are logged to track the dynamics of server characteristics, so the database has reached the order of hundreds of millions of records.  Periodically, new servers appear, and the old ones are no longer used.  Information about unused servers must be removed from the Monitoring system in order to: <i>a) not overload the interface with unnecessary information,</i> and <i>b) release the unique identifiers</i> . <br><br><h2>  Deletion </h2><br>  It is not for nothing that in the title of the article the word “deletion” was written in quotes.  You can remove an object from the system in several ways: <br><br><ul><li>  completely removing from the database; </li><li>  marking objects as deleted and hiding from the interface.  As a marker, you can use Boolean, or DateTime for more accurate logging. </li></ul><br><h4>  Iteration # 1 </h4><br>  Initially, the first approach was used when we simply executed <code>object.delete()</code> and the object was deleted with all dependencies.  But over time, we had to abandon this approach, since one object could have dependencies with millions of other objects, and the cascading deletion tightly blocked the tables.  And since the service performs thousands of checks every second and logs them, locking the tables led to a serious slowdown in the service, which was unacceptable for us. <br><br><h4>  Iteration # 2 </h4><br>  To avoid long locks, we decided to delete the data in chunks.  This would allow to record actual monitoring data during the intervals between deletions of objects.  The list of all objects that will be deleted in cascade can be obtained using the method that is used in the admin panel when deleting an object (when confirming the deletion): <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> django.contrib.admin.util <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> NestedObjects <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> django.db <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> DEFAULT_DB_ALIAS collector = NestedObjects(using=DEFAULT_DB_ALIAS) collector.collect([obj]) objects_to_delete = collector.nested() <span class="hljs-comment"><span class="hljs-comment"># Recursive delete objects</span></span></code> </pre> <br>  The situation has improved: the load was distributed over time, new data began to be recorded faster.  But we immediately ran into the next pitfall.  The fact is that the list of deleted objects is formed at the very beginning of the deletion, and if in the process of “portioned” deletion new dependent objects are added, then the parent element cannot be deleted. <br><br>  We immediately abandoned the idea in case of an error in recursive deletion again to collect data on new dependencies or prohibit adding dependent entries during deletion, because <i>a) you can go into an infinite loop</i> or <i>b) you have to find all the add code of all dependent objects</i> . <br><br><h4>  Iteration # 3 </h4><br>  We thought about the second type of deletion, when the data is marked and hidden from the interface.  Initially, this approach was rejected, because finding all requests and adding a filter to the absence of a remote parent element seemed to be a task for at least a week.  In addition, there was a high probability of missing the necessary code, which would lead to unpredictable consequences. <br><br>  Then we decided to use decorators to override the query manager.  Further, it is better to see the code than to write a hundred words. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exclude_objects_for_deleted_hosts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*fields)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Decorator that adds .exclude({field__}is_deleted=True) for model_class.objects.get_queryset :param fields: fields for exclude condition """</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(model_class)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply_filters</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(qs)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> field <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> filter_fields: qs = qs.exclude(**{ <span class="hljs-string"><span class="hljs-string">'{}is_deleted'</span></span>.format(<span class="hljs-string"><span class="hljs-string">'{}__'</span></span>.format(field) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> field <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> qs model_class.all_objects = copy.deepcopy(model_class.objects) filter_fields = set(fields) get_queryset = model_class.objects.get_queryset model_class.objects.get_queryset = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span>: apply_filters(get_queryset()) <span class="hljs-comment"><span class="hljs-comment"># save info about model decorator setattr(model_class, DECORATOR_DEL_HOST_ATTRIBUTE, filter_fields) return model_class return wrapper</span></span></code> </pre><br>  The <code>exclude_objects_for_deleted_hosts(fields)</code> decorator for the specified fields of the fields model automatically adds an <code>exclude</code> filter for each request, which just removes the records that should not be displayed in the interface. <br><br>  Now it is enough for all models, which will be affected in any way by the removal, to add a decorator: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@exclude_objects_for_deleted_hosts('host') class Alias(models.Model): host = models.ForeignKey(to=Host, verbose_name='Host', related_name='alias')</span></span></code> </pre><br>  Now, in order to remove the <code>Host</code> object, it is enough to change the <code>is_deleted</code> attribute: <br><br><pre> <code class="python hljs">host.is_deleted = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-comment"><span class="hljs-comment"># after this save the host and all related objects will be inaccessible host.save()</span></span></code> </pre> <br>  All requests will automatically exclude records referencing deleted objects: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># model decorator @exclude_objects_for_deleted_hosts('checker__monhost', 'alias__host') CheckerToAlias.objects.filter( alias__hostname__in=['cloud.spb.s', 'cloud.msk.s'] ).values('id')</span></span></code> </pre><br>  It turns out such a SQL query: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> monitoring_checkertoalias.id <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> monitoring_checkertoalias <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> monitoring_checker <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (<span class="hljs-string"><span class="hljs-string">`monitoring_checkertoalias`</span></span>.<span class="hljs-string"><span class="hljs-string">`checker_id`</span></span> = monitoring_checker.<span class="hljs-string"><span class="hljs-string">`id`</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Hosts</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (<span class="hljs-string"><span class="hljs-string">`monitoring_checker`</span></span>.<span class="hljs-string"><span class="hljs-string">`monhost_id`</span></span> = Hosts.<span class="hljs-string"><span class="hljs-string">`id`</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> dcmap_alias <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (<span class="hljs-string"><span class="hljs-string">`monitoring_checkertoalias`</span></span>.<span class="hljs-string"><span class="hljs-string">`alias_id`</span></span> = dcmap_alias.<span class="hljs-string"><span class="hljs-string">`id`</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Hosts</span></span> T5 <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (<span class="hljs-string"><span class="hljs-string">`dcmap_alias`</span></span>.<span class="hljs-string"><span class="hljs-string">`host_id`</span></span> = T5.<span class="hljs-string"><span class="hljs-string">`id`</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> (<span class="hljs-string"><span class="hljs-string">`Hosts`</span></span>.<span class="hljs-string"><span class="hljs-string">`is_deleted`</span></span> = <span class="hljs-literal"><span class="hljs-literal">TRUE</span></span>) <span class="hljs-comment"><span class="hljs-comment">-- раз, проверка для monitoring_checker AND NOT (T5.`is_deleted` = TRUE) -- два, проверка для dcmap_alias AND dcmap_alias.name IN ('dir1.server.p', 'dir2.server.p') );</span></span></code> </pre> <br>  As you can see, in the request additional joines were added for the fields specified in the decorator and for checking <code>`is_deleted` = TRUE</code> . <br><br><h2>  Little about numbers </h2><br>  It is logical that additional joines and conditions increase query execution time.  The study of this question showed that the degree of "complication" depends on the structure of the database, the number of records and the presence of indices. <br><br>  Specifically, in our case, for each level of dependency, the request is penalized by about 30%.  This is the maximum penalty that we get on the largest table with millions of records; on a smaller table, the penalty is reduced to a few percent.  Fortunately, we have the necessary indexes set up, and for the majority of critical queries, the necessary joines were already there, so we did not feel a big difference in performance. <br><br><h2>  Unique Identifiers </h2><br>  Before you delete the data, you may need to free the identifiers that you plan to use in the future, because this may cause a non-unique value error when creating a new object.  Despite the fact that in the Django-application will not be visible deleted objects, they will still be in the database.  Therefore, for deleted objects we add uuid to the identifier. <br><br><pre> <code class="python hljs">host.hostname = <span class="hljs-string"><span class="hljs-string">'{}_{}'</span></span>.format(host.hostname, uuid.uuid4()) host.is_deleted = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> host.save()</code> </pre><br><h2>  Exploitation </h2><br>  For each new model or dependency, you need to update the decorator if you need one.  To simplify the search for dependent models, we wrote a “smart” test: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_deleted_host_decorator_for_models</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">recursive_host_finder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(model, cache, path, filters)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># cache for skipping looked models cache.add(model) # process all related models for field in (f for f in model._meta.fields if isinstance(f, ForeignKey)): if field.related_model == Host: filters.add(path + field.name) elif field.related_model not in cache: recursive_host_finder(field.related_model, cache.copy(), path + field.name + '__', filters) # check all models for current_model in apps.get_models(): model_filters = getattr(current_model, DECORATOR_DEL_HOST_ATTRIBUTE, set()) found_filters = set() if current_model == Host: found_filters.add('') else: recursive_host_finder(current_model, set(), '', found_filters) if found_filters or model_filters: try: self.assertSetEqual(model_filters, found_filters) except AssertionError as err: err.args = ( '{}\n !!! Fix decorator "exclude_objects_for_deleted_hosts" ' 'for model {}'.format(err.args[0], current_model), ) raise err</span></span></code> </pre><br>  The test recursively checks all models for dependencies on the model being deleted, then looks to see if the decorator has been set to the required fields for this model.  If something is missing, the test will delicately tell you where to add the decorator. <br><br><h2>  Epilogue </h2><br>  Thus, with the help of a decorator, it was possible with a little blood to realize the “deletion” of data that has a large number of dependencies.  All requests automatically receive the required <code>exclude</code> filter.  The imposition of additional conditions slows down the process of obtaining data, the degree of "complication" depends on the database structure, the number of records and the presence of indices.  The proposed test will tell you which models need to add decorators, and in the future will monitor their consistency. </div>