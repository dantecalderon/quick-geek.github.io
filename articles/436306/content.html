<div class="post__text post__text-html js-mediator-article"><h2>  annotation </h2><br>  In this article I want to share my own experience with machine learning in the data store on Vertica. <br><br>  Let's be honest, I am not an expert analyst who can describe in detail the whole diversity of research methods and data prediction algorithms.  But still, being an expert on Vertica and having a basic experience with ML, I will try to talk about ways to work with predictive analysis in Vertica using the built-in functionality of the server and the language R. <br><br><h2>  Machine Learning Library Vertica </h2><br>  Starting with version 7, Vertica was supplemented with the Machine Learning library, with which you can: <br><br><ul><li>  prepare sample data for machine learning; </li><li>  train machine learning models on prepared data; </li><li>  Conduct a predictive analysis of storage data on stored machine learning models. </li></ul><br>  The library comes immediately with Vertica installation for all versions, including the free Community.  Working with it is framed in the form of calling functions from under SQL, which are described in detail in the documentation with examples of use on the prepared demonstration data. <br><a name="habracut"></a><br><h2>  An example of working with ML in Vertica </h2><br>  As a simple example of how ML works, I took the sample data for mtcars cars that are part of the ML data sample for Vertica.  This data includes two tables: <br><br><ul><li>  mtcars_train - prepared for training model of machine learning data </li><li>  mtcars - data for analysis </li></ul><br>  Let's look at the data for training: <br><br><pre><code class="sql hljs">=&gt;<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> mtcars_train;</code> </pre> <br><img src="https://habrastorage.org/webt/mu/4_/o0/mu4_o0ovpeupz4c3qkf1uvnegya.jpeg"><br><br>  In the data set on the models of cars painted their characteristics.  Let's try to train machine learning so that according to the characteristics of cars it was possible to predict what type of gearbox is involved in a car - a manual gearbox or automatic gearbox.  To do this, we need to build a logistic regression model on the prepared data, finding the dependence of the box type type “am” and the weight fields of the car “wt”, the number of cylinders “cyl” and the number of speeds in the box “gear”: <br><br><pre> <code class="sql hljs">=&gt;<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> LOGISTIC_REG(<span class="hljs-string"><span class="hljs-string">'logistic_reg_mtcars'</span></span>, <span class="hljs-string"><span class="hljs-string">'mtcars_train'</span></span>, <span class="hljs-string"><span class="hljs-string">'am'</span></span>, <span class="hljs-string"><span class="hljs-string">'cyl, wt, gear'</span></span>); Finished in 19 iterations</code> </pre> <br>  The called function analyzed the relationship between am and the cyl, wt, gear fields, revealed the dependency formula, and recorded the dependency modeling result in the Vertica database in the “logistic_reg_mtcars” model.  With the help of this saved model, it is now possible to analyze data on cars and predict the presence of an automatic box. <br><br>  Information on the model can be viewed: <br><br><pre> <code class="sql hljs">=&gt;<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> GET_MODEL_SUMMARY(<span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PARAMETERS</span></span> model_name=<span class="hljs-string"><span class="hljs-string">'logistic_reg_mtcars'</span></span>);</code> </pre> <br><img src="https://habrastorage.org/webt/hd/aj/gp/hdajgpkb3a4jvlq2-czafzt9mv0.jpeg"><br><br>  We now use the model on the data on cars, saving the result in a new table: <br><br><pre> <code class="sql hljs">=&gt;<span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> mtcars_predict_results <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> car_model, am, PREDICT_LOGISTIC_REG(cyl, wt, gear <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PARAMETERS</span></span> model_name=<span class="hljs-string"><span class="hljs-string">'logistic_reg_mtcars'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">prediction</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> mtcars );</code> </pre> <br>  And comparing the real values ​​of am with those obtained in the prediction prediction: <br><br><pre> <code class="sql hljs">=&gt;<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> mtcars_predict_results;</code> </pre> <br><img src="https://habrastorage.org/webt/48/rt/zh/48rtzhy3c4ahjfqrupulpfy_mqy.jpeg"><br><br>  In this case, the forecast for 100% coincided with the actual type of box in the presented models.  In the case of preparing new data for training, you will need to delete and re-save the model. <br><br><h2>  ML functionality in Vertica </h2><br>  The ML library in Vertica supports the following types of predictive analysis: <br><br><ul><li>  <b>Forecasting:</b> <br><ul><li>  Linear regression </li><li>  Random forest for regression </li><li>  SVM (Support Vector Machine) for Regression </li></ul></li><li>  <b>Classification:</b> <br><ul><li>  Logistic regression </li><li>  Naive bayes </li><li>  Random Forest for Classification </li><li>  SVM (Support Vector Machine) for Classification </li></ul></li><li>  <b>Clustering:</b> <br><ul><li>  k-means </li></ul></li></ul><br>  To prepare the data for training, the following functionality is presented: <br><br><ul><li>  Data balancing </li><li>  Cleaning emissions </li><li>  Encoding categorical (textual) column values </li><li>  Replacing missing data </li><li>  Data normalization </li><li>  Principal component analysis </li><li>  Data sampling </li><li>  Singular value decomposition </li></ul><br>  Considering the ML functional in Vertica, it can be said that the built-in library allows solving a fairly wide range of tasks, but it does not have a foundation for studying patterns and dependencies in the data.  There are functions for preparing data for machine learning, but without visualizing the distribution of data in the form of graphs, such data can be prepared and training models trained on them except analysis gurus with expert knowledge of the data being analyzed. <br><br><h2>  R Studio with Vertica </h2><br>  For more thorough and interactive predictive data analysis, the ideal language is R, which has a visual environment for working with R Studio data.  The tangible benefits of using R with Vertica will be: <br><br><ul><li>  interactivity environment with the ability to save the state for further analysis after the next launch; </li><li>  visual viewing of data in the form of tables and graphs; </li><li>  power of the R language for working with data sets; </li><li>  a variety of predictive analysis algorithms, similar to those presented in Vertica ML. </li></ul><br>  As disadvantages of R with big data, you can mention the requirements for RAM, the speed of working with large data arrays and the need to import and export Vertica data.  These shortcomings are covered by the possibility of embedding written functions R for direct execution on a cluster in Vertica, which will be discussed below. <br><br><h2>  A little introduction to R </h2><br>  Let's reproduce the forecast on the boxes of the machine on the Vertica data with the help of R. In order not to scare away programmers unfamiliar with this language, I will conduct a short course of the young fighter R. <br><br>  So, the language R is the same procedural language, having objects, classes and functions. <br>  An object can be a data set (vector, list, data ...), value (text, number, date, time ...) or a function.  For values, numeric, string, boolean, and date-time types are supported.  For datasets, the numbering of arrays starts with 1, not 0. <br><br>  Classically, instead of "=" in R, the assignment operator "&lt;-" is used.  Although it is not forbidden to use the assignment in the other direction "-&gt;" and even the usual "=".  The "=" operator itself is used when calling functions to specify named parameters. <br><br>  Instead of "."  "$" is used to access dataset fields.  The point is not a keyword and is used in the names of objects to increase their readability.  Thus, “my.data $ field” will be decrypted as an array of field “field” records from the “my.data” data set. <br><br>  For framing texts, you can use both single and double quotes. <br><br>  <b>Most importantly:</b> R is sharpened to work with data sets.  Even if the code says "a &lt;-1", then rest assured, R internally believes that "a" is an array of 1 element.  The language design allows working with data sets as with ordinary variables: add and subtract, connect and disconnect, filter by measurements.  The easiest way to create an array listing its elements is to call the function “c (comma-separated array elements)”.  The name "c" is apparently taken as a short abbreviation of the Collection, but I will not say for sure. <br><br><h2>  Data loading from DBMS to R </h2><br>  To work with RDBMS via ODBC for R you need to install the RODBC package.  It can be installed in R Studio on the packages tab or using the R command: <br><br><pre> <code class="plaintext hljs">install.packages('RODBC') library('RODBC')</code> </pre> <br><br>  Now we can work with Vertica.  We make an ODBC alias to the server and get the test and full data for the car: <br><br><pre> <code class="plaintext hljs"># Создаем подключение к Vertica con &lt;- odbcConnect(dsn='VerticaDSN') # получаем данные таблицы mtcars_train mtcars.train &lt;- sqlQuery(con, "SELECT * FROM public.mtcars_train") # получаем данные таблицы mtcars&lt;/b&gt; mtcars.data &lt;- sqlQuery(con, "SELECT * FROM public.mtcars") # закрываем соединение odbcClose(con)</code> </pre> <br>  When loading data from R sources for text type and date-time fields, their belonging to the factors is automatically set.  The “am” field has a numeric type and is perceived by R as a numerical indicator, and not a factor, which will not allow a logistic regression.  Therefore, we transform this field into a numerical factor: <br><br><pre> <code class="plaintext hljs">mtcars.data$am = factor(mtcars.data$am) mtcars.train$am = factor(mtcars.train$am)</code> </pre> <br>  In R Studio, it is convenient to interactively view data, build predictive analysis charts, and write code in R with prompts: <br><br> <a href=""><img src="https://habrastorage.org/webt/r2/ft/b8/r2ftb85rnjcmpiblxomwdiicr7k.jpeg"></a> <br><br><h2>  Building a model in R </h2><br>  Let us build a logistic regression model over a prepared data set for the same dimensions as in Vertica: <br><br><pre> <code class="plaintext hljs">mtcars.model &lt;- glm(formula = am ~ cyl + wt + gear, family = binomial(), data = mtcars.train)</code> </pre> <br>  <b>Explanation:</b> in the R language, the formula of the predictive analysis is indicated as: <br><br><pre> <code class="plaintext hljs">&lt;поле результата анализа&gt;~&lt;влияющие на анализ поля&gt;</code> </pre> <br><h2>  Data analysis by model in R </h2><br>  We initialize the resulting data set by taking all the records from the mtcars in the required fields: <br><br><pre> <code class="plaintext hljs">mtcars.result &lt;- data.frame(car_model = mtcars.data$car_model, am = mtcars.data$am, predict = 0)</code> </pre> <br>  Now, using the constructed model, you can perform an analysis on the data itself: <br><br><pre> <code class="plaintext hljs">mtcars.result$predict &lt;- predict.glm(mtcars.model, newdata = subset(mtcars.data, select = c('cyl', 'wt', 'gear')), type = 'response' )</code> </pre> <br>  The result of the analysis is returned to the predict field as a percentage of the probability of the forecast.  Simplify by analogy with Vertica to values ​​of 0 or 1, considering the forecast to be positive with a probability of more than 50%: <br><br><pre> <code class="plaintext hljs">mtcars.result$predict &lt;- ifelse(mtcars.result$predict &gt; 0.5, 1, 0)</code> </pre> <br>  We calculate the total number of records for which the predicted predict field did not coincide with the real value in am: <br><br><pre> <code class="plaintext hljs">nrow(mtcars[mtcars.result$am != mtcars.result$predict, ])</code> </pre> <br>  R returned zero.  Thus, the forecast has converged on all car models, as in ML from Vertica. <br><br>  <b>Please note:</b> records from mtcars were returned by a filter (the first parameter in square brackets) with all columns (the second missing comma parameter in square brackets). <br><br><h2>  Local storage and loading of data in R </h2><br>  When exiting from R, the studio offers to save the state of all objects in order to continue working after the restart.  If for some reason you need to save and then restore the state of individual objects, for this R provides special functions: <br><br><pre> <code class="plaintext hljs"># Сохранить объект модели в файл save(mtcars.model, file = 'mtcars.model') # Восстановить объект модели из файла load('mtcars.model')</code> </pre> <br><h2>  Saving data from R to Vertica </h2><br>  In case R Studio was used to prepare data for training Vertica ML models or it was used to analyze it directly, which should be further used in the Vertica database, R data sets can be written to the Vertica table. <br><br>  Since the ODBC library for R is designed for an OLTP RDBMS, it cannot generate table creation requests for Vertica correctly.  Therefore, to successfully write data, you will need to manually create the necessary table in Vertica using SQL, the set of fields and types of which coincides with the recordable data set R. <br><br>  Further, the write process itself looks simple (do not forget to open and then close the con connection): <br><br><pre> <code class="plaintext hljs">sqlSave(con, mtcars.result, tablename = 'public.mtcars_result', append = TRUE, rownames = FALSE, colnames = FALSE)</code> </pre> <br><h2>  Vertica's work with R </h2><br>  Interactive work with data in R Studio is well suited for the mode of research and data preparation.  But it is completely unsuitable for analyzing data streams and large arrays in automatic mode.  One of the variants of the hybrid scheme of predictive analysis of R with Vertica is the preparation of data for training on R and the identification of dependencies for building models.  Next, using the ML functions built into Vertica, the prediction models are trained on the data prepared on R, taking into account the identified dependencies of the variables. <br><br>  There is also a more flexible option when all the power of the R language is used directly from under Vertica.  To do this, under Vertica, an R distribution was developed in the form of a plug-in library, which allows using transformation functions written directly in the R language in SQL queries. The documentation details the installation of R support for Vertica and the additional R packages required for operation, if required. <br><br><h2>  Saving Model R to Vertica </h2><br>  To use the analysis model previously prepared in R Studio in the R functions working from under Vertica, you need to save them on Vertica servers.  It is not convenient and reliable to save files on each cluster server locally, new servers can be added to the cluster, and if you change the model, you need to remember to rewrite all files again. <br><br>  The most convenient way is to serialize model R into text and save the Vertica function as UDF, which will return this text as a constant (do not forget to open and then close the con connection): <br><br><pre> <code class="plaintext hljs"># Сериализуем модель в текст mtcars.model.text &lt;- rawToChar( serialize(mtcars.model, connection = NULL, ascii = TRUE)) # Собираем текст функции для выполнения в Vertica # (в тексте модели одинарные кавычки дублируются) mtcars.func &lt;- paste0( "CREATE OR REPLACE FUNCTION public.MtCarsAnalizeModel() RETURN varchar(65000) AS BEGIN RETURN '", gsub("'", "''", mtcars.model.text), "'; END; GRANT EXECUTE ON FUNCTION public.MtCarsAnalizeModel() TO public;" ) # Создаем функцию на Vertica sqlQuery(con, mtcars.func)</code> </pre> <br>  The proposed method allows you to bypass the restriction of Vertica on the passed parameters in the transformation function, where you only need to transfer constants or expressions from constants.  In Vertica, UDF SQL is compiled not as functions, but as calculated expressions, that is, when a parameter is passed, instead of calling the function, its text (in this case, a constant), which was saved in the code above, is transferred. <br><br>  If the model is changed, it will be necessary to recreate its function in Vertica.  It makes sense to wrap this code in a universal function that generates a function in Vertica with the specified name from the transferred model. <br><br><h2>  R functions for working in Vertica </h2><br>  In order to connect the R functions to Vertica, you need to write data analysis and registration functions in Vertica. <br><br>  The function of working with data from under Vertica itself should have two parameters: the resulting data set (as data.frame) and the parameters of work (as list): <br><br><pre> <code class="plaintext hljs">MtCarsAnalize &lt;- function(data, parameters) { if ( is.null(parameters[['model']]) ) { stop("NULL value for model! Model cannot be NULL.") } else { model &lt;- unserialize(charToRaw(parameters[['model']])) } names(data) &lt;- c('car_model', 'cyl', 'wt', 'gear') result &lt;- data.frame(car_model = data$car_model, predict = 0) result$predict &lt;- predict.glm(model, newdata = subset(data, select = c('cyl', 'wt', 'gear')), type = 'response' ) result$predict &lt;- ifelse(result$predict &gt; 0.5, TRUE, FALSE) return(result) }</code> </pre> <br>  In the function body, it is checked that the model parameter is passed, the text of which is translated into a binary form and deserialized into an object of the analysis model.  Since Vertica passes its own query field names to the function dataset, the explicit field names are set to the data set.  Based on the obtained data, a result set is constructed with the name of the machine model and the zero predict.  Next, a forecast is made using only the fields needed for the analysis from the obtained data set.  The predict result set is set to boolean values ​​(for variety instead of numeric) and the result is returned from the function. <br><br>  It now remains to describe the registration of this function in Vertica: <br><br><pre> <code class="plaintext hljs">MtCarsAnalizeFactory &lt;- function() { list(name = MtCarsAnalize, udxtype = c("transform"), intype = c("varchar", "int", "float", "int"), outtype = c("varchar", "boolean"), outnames = c("car_model", "predict"), parametertypecallback=MtCarsAnalizeParameters) } MtCarsAnalizeParameters &lt;- function() { parameters &lt;- list(datatype = c("varchar"), length = 65000, scale = c("NA"), name = c("model")) return(parameters) }</code> </pre> <br>  The MtCarsAnalizeFactory function describes the name of the function used for the operation, the fields for the incoming and outgoing data sets, and the second function describes the parameter “model” being passed.  Vertica data types are specified as field types.  When transferring and returning data, Vertica automatically converts the values ​​into the required data types for the R language. A table of type compatibility can be found in the Vertica documentation. <br><br>  You can test the work of the written function for Vertica on the data loaded into R Studio: <br><br><pre> <code class="plaintext hljs">test.data = subset(mtcars.data, select = c('car_model', 'cyl', 'wt', 'gear')) test.params = list(model = mtcars.model.text) test.result = MtCarsAnalize(test.data, test.params)</code> </pre> <br><h2>  Connecting the function library to Vertica </h2><br>  We save all the above functions into a single file "mtcars_func.r" and upload this file to one of the servers from the Vertica cluster in "/ home / dbadmin". <br><br>  <b>An important point:</b> in R Studio, you need to set the option to save the translation of lines in files to Posix mode (LF).  This can be done in the global options, the Code section, the Saving tab.  If you are working on Windows, by default the file will be saved with a carriage return and will not be able to be loaded into Vertica. <br><br>  Connect to the server from the Vertica cluster where you saved the file and load the library: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIBRARY</span></span> MtCarsLibs <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">'/home/dbadmin/mtcars_func.r'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-string"><span class="hljs-string">'R'</span></span>;</code> </pre> <br>  Now from this library you can register the R function: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> TRANSFORM <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> public.MtCarsAnalize <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-string"><span class="hljs-string">'R'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-string"><span class="hljs-string">'MtCarsAnalizeFactory'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIBRARY</span></span> MtCarsLibs; <span class="hljs-keyword"><span class="hljs-keyword">GRANT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> TRANSFORM <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> public.MtCarsAnalize(<span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">float</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>;</code> </pre> <br><h2>  Call R functions in Vertica </h2><br>  Call the function R, passing it the text of the model, which was previously saved as a UDF function: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> MtCarsAnalize(car_model, cyl, wt, gear <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PARAMETERS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">model</span></span> = public.MtCarsAnalizeModel()) <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> public.mtcars;</code> </pre> <br><img src="https://habrastorage.org/webt/8a/om/ve/8aomvezlxe_-0n4gnyonxkr25om.jpeg"><br><br>  It can be verified that, just as in the previous cases, the prediction that is 100% consistent with the real situation is given: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> c.*, p.predict, p.predict = c.am::<span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> valid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> public.mtcars c <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> MtCarsAnalize(car_model, cyl, wt, gear <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PARAMETERS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">model</span></span> = public.MtCarsAnalizeModel()) <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> public.mtcars ) p <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> c.car_model = p.car_model</code> </pre> <br>  <b>Note that</b> the transformation functions in Vertica return their own data set from the fields and records defined inside the functions, however, they can be used in queries if they are wrapped in a subquery. <br><br>  When the R functions are connected, Vertica copies the source code into its installation, which then compiles it into machine code.  The source R file uploaded to the server after being connected to the library is not required for further work.  The speed of the functions taking into account the binary compilation is high enough to work with large data arrays, however, it is worth remembering that all R operations are carried out in memory and there is a risk to go to a swap if there is a shortage of OS memory to support the needs of Vertica and R . <br><br>  If the function is called on a partition of data specified in PARTITION BY for OVER, then Vertica parallelizes the execution of each partition on the cluster servers.  Thus, if there was a manufacturer still present in the data set, besides the machine model, it would be possible to specify it in PARTITION BY and parallelize the execution of the analysis for each manufacturer. <br><br><h2>  Vertica's other machine learning capabilities </h2><br>  In addition to R for Vertica, you can develop your own transformation functions in C, Java, and Python.  Each of the languages ​​has its own nuances and peculiarities of writing and connecting to Vertica.  Together with your own ML, all this gives Vertica a good basis for predictive data analysis. <br><br><h2>  Thanks and links </h2><br>  I would like to sincerely thank my friend and colleague Vlad Malofeev from Perm, who introduced me to R and helped him figure out one of our joint projects. <br><br>  Initially, in the project, where the forecast was made on the difficult conditions for the future using the data of the past year, the developers tried to use SQL and Java.  This caused great difficulties in view of the quality of these sources and greatly hampered the development of the project.  Vlad came to the project with R, we hooked up with R under Vertica, he drove the data to the studio and everything spun and twisted beautifully at once.  Literally for weeks, everything that lasted for months was solved, saving the project from complex code. <br><br>  The following example of data with cars can be downloaded from the GIT repository: <br><br><pre> <code class="plaintext hljs">git clone https://github.com/vertica/Machine-Learning-Examples</code> </pre> <br>  and upload to Vertica: <br><br><pre> <code class="plaintext hljs">/opt/vertica/bin/vsql -d &lt;name of your database&gt; -f load_ml_data.sql</code> </pre> <br>  If you want to go deep into ML and learn how to work with R, I recommend to study the book in Russian <b>“R in action.</b>  <b>Analysis and visualization of data in the language of R "</b> .  It is written in simple accessible human language and is suitable for beginners who have not previously encountered machine learning. <br><br>  <a href="https://www.vertica.com/docs/9.2.x/HTML/Content/Authoring/ExtendingVertica/R/InstallingRForVertica.htm%3FTocPath%3DExtending%2520Vertica%257CDeveloping%2520User-Defined%2520Extensions%2520(UDxs)%257CDeveloping%2520with%2520the%2520R%2520SDK%257C_____1">Here</a> you can see information about the connection of the R library to Vertica. <br><br>  For those who have already begun to learn and use ML in Python, you should pay attention to IDE Rodeo, this is an analogue of R Studio, because without interactive, qualitative analysis is impossible.  I think everything described in this article under R in a similar way can be developed in Python, including saving the model to UDF functions and developing analysis functions for Vertica.  If you check, do not forget to unsubscribe about the results in the comments, I would be grateful for the information. <br><br>  Thank you for your time and I hope that I was able to demonstrate the simplicity and incredible possibilities of the symbiosis of R and Vertica. </div>