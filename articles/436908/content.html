<div class="post__text post__text-html js-mediator-article"><p>  Hi, dear reader, I’ve been studying mobile apps for quite some time.  Most applications do not try to somehow hide their "secret" functionality from me.  And I am happy at this time, because I don’t have to study someone's obfuscated code. </p><br><p><img src="https://habrastorage.org/webt/v-/hc/cq/v-hccqahz7gg_it346vryqg8pii.png" alt="image"></p><br><p>  In this article I would like to share my vision of obfuscation, and also tell about an interesting method of hiding business logic in applications with NDK, which I found relatively recently.  So if you are interested in live examples of obfuscated code in Android - I ask for cat. </p><a name="habracut"></a><br><p>  Under the obfuscation in the framework of this article we will mean the reduction of the executable code of the Android application to a difficult to analyze form.  There are several reasons why it is difficult to analyze the code: </p><br><ol><li>  No business wants to be picked in its "insides". </li><li>  Even if you have a dummy application, you can always find an interesting one (example with <a href="https://infinitesuns.io/instagram-under-the-hood">instagram</a> ). </li></ol><br><p>  Many developers solve the problem with a simple fork of the ProGuard config.  This is not the best way to protect data (if this is your first time hearing about this, see the <a href="https://en.wikipedia.org/wiki/ProGuard_(software)">wiki</a> ). </p><br><p>  I want to give a good example of why the alleged “protection” with ProGuard does not work.  Take any simple example from Google Samples. </p><br><p><img src="https://habrastorage.org/webt/bh/vf/9o/bhvf9o1ft2qjf8j-1og1tdjdi4s.png" alt="image"></p><br><p>  Having connected to it ProGuard with a standard config, we will receive the decompiled code: </p><br><p><img src="https://habrastorage.org/webt/ke/vu/k2/kevuk2vdz6o6m-hy7ukwrfsyusy.png" alt="image"></p><br><p>  “Oooh, nothing is clear” - we say calm down.  But after a couple of minutes of switching between files, we will find similar pieces of code: </p><br><p><img src="https://habrastorage.org/webt/fc/jc/kl/fcjcklka1h4yttolcoiszcnoqvu.png" alt="image"></p><br><p>  In this example, the application code seems rather difficult (data logging, video capture creation), so some of the methods used in the original code are easily understood after processing by the ProGuard config. </p><br><p>  Further more, take a look at the data classes in Kotlin.  The default data class creates the “toString” method, which contains the names of the instance variables and the name of the class itself. </p><br><p>  Source data class: </p><br><p><img src="https://habrastorage.org/webt/q9/u-/vs/q9u-vsnag2z8zjz5fhgc3v5qg3m.png" alt="image"></p><br><p>  It can turn into a tasty morsel for reverser: </p><br><p><img src="https://habrastorage.org/webt/pn/8x/vv/pn8xvv_otazeei_8kft215qaieu.png" alt="image"><br>  (autogeneration of the toString method in Kotlin) </p><br><p>  It turns out that ProGuard hides far from the entire source code of the project. </p><br><p>  If I still have not convinced you of the inexpediency of protecting the code in this way, then let's try to leave the “.source” attribute in our project. </p><br><pre><code class="plaintext hljs">-keepattributes SourceFile</code> </pre> <br><p>  This line is in many opensource projects.  It allows you to view StackTrace when the application crashes.  However, by pulling the “.source” from the smali code, we will get the whole project hierarchy with the full class names. </p><br><p>  By definition, obfuscation is “casting the source code in an unreadable form in order to counteract different types of recordings”.  However, ProGuard (when used with a standard config) does not make the code unreadable - it works as a minifier, compressing the names and throwing out extra classes from the project. </p><br><p>  This use of ProGuard is an easy, but not quite suitable for a good obfuscation solution on the “chance”.  A good developer needs to force the receiver (or an attacker) to be frightened by “Chinese characters” that are difficult to deobfuse. </p><br><p>  If you are interested in learning more about ProGuard, then I suggest the following <a href="https://habr.com/ru/post/436564">informative article</a> . </p><br><h2 id="chto-pryachem">  What are we hiding </h2><br><p>  Now let's see what is usually hidden in applications. </p><br><ul><li>  Encryption keys: </li></ul><br><p><img src="https://habrastorage.org/webt/jf/25/am/jf25amyjucvcyu_e2pw6lcureei.png" alt="image"></p><br><ul><li>  The specific logic of the application: </li></ul><br><p><img src="https://habrastorage.org/webt/ke/_k/bb/ke_kbbma_2ykdvu8tqpw3cg8wg4.png" alt="image"></p><br><p>  In the code, something more unexpected can often be hidden (observations from personal experience), for example: </p><br><ul><li>  Project Developer Names </li><li>  Full path to the project </li><li>  “Client_secret” for Oauth2 protocol </li><li>  PDF-book "How to develop under Android" (probably, that was always at hand) </li></ul><br><p>  Now we know that we can hide in Android applications and can move on to the main point, namely how to hide this data. </p><br><h2 id="sposoby-sokrytiya-dannyh">  Ways to hide data </h2><br><h3 id="variant-1-nichego-ne-skryvat-ostavit-vse-na-vidu">  Option 1: Do not hide anything, leave everything in sight </h3><br><p>  In that case, I'll just show you this picture :) </p><br><p>  “Help Dasha find business logic.” </p><br><p><img src="https://habrastorage.org/webt/td/bb/mi/tdbbmimmetmzt4exlorkdvmg00w.png" alt="image"></p><br><p>  <em>This is a cost-free and completely free solution suitable for:</em> </p><br><ul><li>  <em>Simple applications that do not interact with the network and do not store sensitive user information;</em> </li><li>  <em>Applications that use only public API.</em> </li></ul><br><h3 id="variant-2-ispolzovat-proguard-s-pravilnymi-nastroykami">  Option 2: Use ProGuard with the right settings. </h3><br><p>  This decision still has the right to life, because, first of all, it is simple and free.  Despite the aforementioned drawbacks, it has a significant plus: if ProGuard rules are properly configured, the application can really become obfuscated. </p><br><p>  However, you need to understand that such a solution after each build requires the developer to decompile and check whether everything is normal.  Having spent several minutes studying the APK file, the developer (and his company) can become more confident in the safety of their product. </p><br><div class="spoiler">  <b class="spoiler_title">How to learn the APK file</b> <div class="spoiler_text"><p>  Check the application for obfuscation is quite simple. </p><br><p>  In order to get the APK file from the project there are several ways: </p><br><ul><li>  take from the project directory (in Android Studio, usually the name of the folder “build”); </li><li>  Install the application on your smartphone and get the APK using the “Apk Extractor” application. </li></ul><br><p>  After that, using the Apktool utility, we get the Smali-code (instructions for getting here <a href="https://ibotpeaches.github.io/Apktool/documentation">https://ibotpeaches.github.io/Apktool/documentation</a> ) and try to find something suspiciously readable in the project lines.  By the way, to search for readable codes, you can stock up on already prepared bash commands. </p></div></div><br><p>  <em>This solution is suitable for:</em> </p><br><ul><li>  <em>Applications of toys, applications online stores, etc .;</em> </li><li>  <em>Applications that are really thin clients, and all data arrives solely from the server side;</em> </li><li>  <em>Applications that do not write on all of their banners "Secure application number 1".</em> </li></ul><br><h3 id="variant-3-ispolzovat-open-source-obfuscator">  Option 3: Use Open Source Obfuscator </h3><br><p>  Unfortunately, I don’t know really good free obfuscators for mobile applications.  And obfuscators that can be found on the network can bring you a lot of headaches, since it will be too difficult to build such a project for new API versions. </p><br><p>  Historically, the existing cool obfuscators are made for machine code (for C / C ++).  Good examples: </p><br><ul><li>  Obfuscator-LLVM, <a href="https://github.com/obfuscator-llvm/obfuscator">https://github.com/obfuscator-llvm/obfuscator</a> </li><li>  Movfuscator, <a href="https://github.com/xoreaxeaxeax/movfuscator">https://github.com/xoreaxeaxeax/movfuscator</a> </li></ul><br><p>  For example, Movfuscator replaces all opcodes mov-s, makes the code linear, removing all branching.  However, it is highly recommended not to use such a method of obfuscation in a combat project, because then the code risks becoming very slow and heavy. </p><br><p>  <em>This solution is suitable for applications where the main part of the code is NDK.</em> </p><br><h3 id="variant-4-ispolzovat-proprietarnoe-reshenie">  Option 4: Use proprietary solution </h3><br><p>  This is the most competent choice for serious applications, as proprietary software: <br>  a) supported; <br>  b) will always be relevant. </p><br><p>  An example of obfuscated code when using such solutions: </p><br><p><img src="https://habrastorage.org/webt/xk/x7/5v/xkx75v1yn0je9uvfy7ttbbwy1iw.png" alt="image"></p><br><p>  In this code snippet you can see: </p><br><ol><li>  The most incomprehensible variable names (with the presence of Russian letters); </li><li>  Chinese characters in the lines, not giving to understand what is really happening in the project; </li><li>  There are a lot of traps added to the project (“switch”, “goto”), which greatly change the codeflow of the application. </li></ol><br><p>  <em>This solution is suitable for:</em> </p><br><ul><li>  <em>Banks;</em> </li><li>  <em>Insurance companies;</em> </li><li>  <em>Mobile operators, applications for storing passwords, etc.</em> </li></ul><br><h3 id="variant-5-ispolzovat-react-native">  Option 5: Use React-Native </h3><br><p>  I decided to highlight this point, since writing cross-platform applications has now become a really popular activity. </p><br><p>  In addition to a very large community, JS has a very large number of open obfuscators.  For example, they can turn your application into emoticons: </p><br><p><img src="https://habrastorage.org/webt/ef/an/kd/efankdx-wuwfmyzhtvsi3-effly.png" alt="image"></p><br><p>  I would really like to advise you of this decision, but then your project will work a little faster than a turtle. </p><br><p>  But, having reduced the requirement for obfuscation of the code, we can create a really well-protected project.  So google “js obfuscator” and obfuscate our output bundle file. </p><br><p>  <em>This solution is suitable for those who are ready to write a cross-platform application on React Native.</em> </p><br><div class="spoiler">  <b class="spoiler_title">Xamarin</b> <div class="spoiler_text"><p>  It would be very interesting to learn about obauscators on Xamarin, if you have experience using them - please tell us about it in the comments. </p></div></div><br><h3 id="variant-6-ispolzovat-ndk">  Option 6: Use NDK </h3><br><p>  I myself often had to use NDK in my code.  And I know that some developers believe that using NDK saves their application from reversers.  This is not entirely true.  First you need to understand exactly how hiding works with the help of NDK. </p><br><p><img src="https://habrastorage.org/webt/hq/9e/-k/hq9e-k1lty2u1tv9be3dv0poqiw.png" alt="image"></p><br><p>  It turns out very simple.  In the code there is some JNI-agreement that when you call C / C ++ code in the project, it will be converted as follows. </p><br><p>  Native class NativeSummator: </p><br><p><img src="https://habrastorage.org/webt/5z/2p/k6/5z2pk6hs0lmfse8dxao4sez47_y.png" alt="image"></p><br><p>  The implementation of the native sum method: </p><br><p><img src="https://habrastorage.org/webt/jn/cc/km/jncckm1ohdbdkncwgi4mczi4mxw.png" alt="image"></p><br><p>  Implementation of the native static sum method: </p><br><p><img src="https://habrastorage.org/webt/mp/ru/df/mprudfyoyvzkj_f8s6vwfhsbvp8.png" alt="image"></p><br><p>  It becomes clear that to call the native method, use the search function <code>Java_&lt;package name&gt;_&lt;Static?&gt;&lt;class&gt;_&lt;method&gt;</code> in the dynamic library. </p><br><p>  If you look at the Dalvik / ART code, we will find the following lines: </p><br><p><img src="https://habrastorage.org/webt/g2/rk/om/g2rkom7si2csod_xiu3qw7t_khw.png" alt="image"></p><br><p>  ( <a href="">source</a> ) </p><br><p>  First, we will generate the following <code>Java_&lt;package name&gt;_&lt;class&gt;_&lt;method&gt;</code> from the Java object, and then we will try to split the method in the dynamic library using the “dlsym” call, which will try to find the function we need in the NDK. </p><br><p>  This is how JNI works.  Its main problem is that by decompiling the dynamic library, we will see all the methods at a glance: </p><br><p><img src="https://habrastorage.org/webt/pp/mi/-q/ppmi-qaydf_mtotxyr-q06cjt0c.png" alt="image"></p><br><p>  So, we need to come up with a solution so that the address of the function is obfuscated. </p><br><p>  At first, I tried to write data directly to our JNI table, but I realized that the <a href="https://ru.wikipedia.org/wiki/ASLR">ASLR</a> mechanisms and different versions of Android simply wouldn't allow me to make this method work on all devices.  Then I decided to find out what methods NDK provides to developers. </p><br><p>  And, about a miracle, there was a method “RegisterNatives”, which does exactly what we need (it calls the internal function <a href="">dvmRegisterJNIMethod</a> ). </p><br><p>  We define an array describing our native method: </p><br><p><img src="https://habrastorage.org/webt/uk/ef/or/ukeforgmtg-unwkwoblwq_1vz4q.png" alt="image"></p><br><p>  And register our declared method in the JNI_OnLoad function (the method is called after initializing the dynamic library, <a href="">tyts</a> ): </p><br><p><img src="https://habrastorage.org/webt/s2/ik/-5/s2ik-5gk0vexpigegllnt5vjtw8.png" alt="image"></p><br><p>  Hurray, we hid the “hideFunc” function on our own.  Now apply our favorite llvm-obfuscator and enjoy the security code in the final form. </p><br><p>  <em>This solution is suitable for applications that already use NDK (connecting the NDK to a project involves a large number of difficulties, therefore for non-NDK applications this solution is not so relevant).</em> </p><br><h2 id="vyvod">  Conclusion </h2><br><p>  In fact, the application should not store any sensitive data, or it should be available only after user authentication.  However, it happens that business logic forces developers to store tokens, keys and specific elements of the code logic inside the application.  I hope this article will help you if you do not want to share such sensitive data and be an “open book” for writers. </p><br><p>  I consider obfuscation to be an important structural part of any modern application. </p><br><p>  Be thoughtful about code concealment issues and don’t look for easy ways!  :) </p><br><p>  <em>By the way, thanks to <a href="https://habr.com/ru/users/miproblema/" class="user_link">miproblema</a> user for help with some issues.</em>  <em>Subscribe to her telegram channel, it's interesting there.</em> </p><br><p>  <em>And also many thanks to the users of <a href="https://habr.com/ru/users/sverkunchik/" class="user_link">sverkunchik</a> and <a href="https://habr.com/ru/users/scaptaincap/" class="user_link">SCaptainCAP</a> for their help in editing the article.</em> </p></div>