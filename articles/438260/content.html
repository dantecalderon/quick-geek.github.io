<div class="post__text post__text-html js-mediator-article"><p>  There will be a very long wall of text with random thoughts.  Key ideas: </p><br><ol><li>  In C ++, compile time is very important, </li><li>  Build performance without optimizations is also important. </li><li>  Cognitive load is more important.  I will not specifically discuss this point here, but if a programming language makes me feel stupid, it’s unlikely I will use it or, all the more, love it.  C ++ does this to me all the <em>time</em> . </li></ol><br><p>  Erik Niebler's “ <a href="http://ericniebler.com/2018/12/05/standard-ranges/">Standard Ranges</a> ” blogpost dedicated to C ++ 20 range recently covered the entire twitter universe, accompanied by a bunch of not-very-flattering comments (this is also put it mildly!) About the state of modern C ++. </p><br><p><img src="https://habrastorage.org/webt/ny/dx/5q/nydx5qeuovqndtlu3-xuilzmfpe.png"></p><br><p>  Even I made my contribution ( <a href="https://twitter.com/aras_p/status/1076947443823136768">link</a> ): </p><br><blockquote>  This example of Pythagorean triples on C ++ 20 ranges, in my opinion, looks monstrous.  And yes, I understand that rengy can be useful, projections can be useful and so on.  However, the example is creepy.  Why would anyone need this? </blockquote><p>  Let's take a closer look at all this under the cut. <a name="habracut"></a></p><hr><br><p>  All of this was a little out of control (even after a week, comments continued to flow into this thread tree!). </p><br><p>  Now, I have to apologize to Eric for starting with his article;  My crying of Yaroslavna will be mainly about the “general state of C ++”.  "A handful of bitchy guys from gamedev" a year ago came to <a href="https://www.boost.org/doc/libs/1_62_0/libs/geometry/doc/html/geometry/design.html">explain the essence of Boost.Geometry</a> in much the same way, and the same thing happened about dozens of other aspects of the C ++ ecosystem. </p><br><p>  But you know, Twitter is not the best place for delicate conversations, etc., etc.  We'll have to turn the thought right here and now! </p><br><h1 id="pifagorovy-troyki-v-stile-renzhey-c20">  Pythagorean troika in the style of crayfish C ++ 20 </h1><br><p>  Keep the full example text from Eric's <a href="http://ericniebler.com/2018/12/05/standard-ranges/">post</a> : </p><br><pre><code class="cpp">// Пример программы на стандартном C++20.
// Она печатает первые N пифагоровых троек.
#include &lt;iostream&gt;
#include &lt;optional&gt;
#include &lt;ranges&gt;   // Новый заголовочный файл!

using namespace std;

// maybe_view создаёт вьюху поверх 0 или 1 объекта
template&lt;Semiregular T&gt;
struct maybe_view : view_interface&lt;maybe_view&lt;T&gt;&gt; {
  maybe_view() = default;
  maybe_view(T t) : data_(std::move(t)) {
  }
  T const *begin() const noexcept {
    return data_ ? &amp;*data_ : nullptr;
  }
  T const *end() const noexcept {
    return data_ ? &amp;*data_ + 1 : nullptr;
  }
private:
  optional&lt;T&gt; data_{};
};

// "for_each" создает новую вьюху, применяя
// трансформацию к каждому элементу из изначального ренжа,
// и в конце полученный ренж ренжей делает плоским.
// (Тут используется синтаксис constrained lambdas из C++20.)
inline constexpr auto for_each =
  []&lt;Range R,
     Iterator I = iterator_t&lt;R&gt;,
     IndirectUnaryInvocable&lt;I&gt; Fun&gt;(R&amp;&amp; r, Fun fun)
        requires Range&lt;indirect_result_t&lt;Fun, I&gt;&gt; {
      return std::forward&lt;R&gt;(r)
        | view::transform(std::move(fun))
        | view::join;
  };

// "yield_if" берёт bool и значение, 
// возвращая вьюху на 0 или 1 элемент.
inline constexpr auto yield_if =
  []&lt;Semiregular T&gt;(bool b, T x) {
    return b ? maybe_view{std::move(x)}
             : maybe_view&lt;T&gt;{};
  };

int main() {
  // Определяем бесконечный ренж пифагоровых троек:
  using view::iota;
  auto triples =
    for_each(iota(1), [](int z) {
      return for_each(iota(1, z+1), [=](int x) {
        return for_each(iota(x, z+1), [=](int y) {
          return yield_if(x*x + y*y == z*z,
            make_tuple(x, y, z));
        });
      });
    });

    // Отображаем первые 10 троек
    for(auto triple : triples | view::take(10)) {
      cout &lt;&lt; '('
           &lt;&lt; get&lt;0&gt;(triple) &lt;&lt; ','
           &lt;&lt; get&lt;1&gt;(triple) &lt;&lt; ','
           &lt;&lt; get&lt;2&gt;(triple) &lt;&lt; ')' &lt;&lt; '\n';
  }
}</code></pre><br>
<p>Пост Эрика появился из его же <a href="http://ericniebler.com/2014/04/27/range-comprehensions/">более раннего поста</a>, написанного пару лет назад, который в свою очередь являлся ответом на статью Бартоша Милевского «<a href="https://bartoszmilewski.com/2014/04/21/getting-lazy-with-c/">Getting Lazy with C++</a>», в котором простая сишная функция для распечатки первых N пифагоровых троек выглядела так: </p><br>
<pre><code class="cpp">void printNTriples(int n)
{
    int i = 0;
    for (int z = 1; ; ++z)
        for (int x = 1; x &lt;= z; ++x)
            for (int y = x; y &lt;= z; ++y)
                if (x*x + y*y == z*z) {
                    printf("%d, %d, %d\n", x, y, z);
                    if (++i == n)
                        return;
                }
}</code></pre><br>
<p>Там же были перечислены проблемы с этим кодом:</p><br>
<blockquote>Всё отлично, пока вы не хотите изменять или переиспользовать этот код. Но что если, например, вместо распечатывания на экране вы захотите рисовать тройки как треугольники? Или вдруг вы захотели остановиться сразу же, как одно из чисел достигло сотни?</blockquote><p>После чего ленивые вычисления со сборкой списков (list comprehensions) представляются как <em>главный способ</em> решать этим проблемы. Конечно, это действительно <em>какой-то способ</em> решить данные проблемы, ведь в языке C++ для этой задачи недостаточно встроенной функциональности, которая есть в каком-нибудь Haskell и других языках. C++20 получит <em>больше</em> для этого встроенных ништяков, на что и намекает пост Эрика. Но до этого мы ещё доберёмся.</p><br>
<h1 id="pifagorovy-troyki-v-stile-prostogo-c">Пифагоровы тройки в стиле простого C++</h1><br>
<p>Так, давай вернёмся к стилю решения задачи, основанному на простом C/C++ («простом» — в смысле, «подходит, пока не нужно модифицировать или переиспользовать», по версии Бартоша). Держите законченную программу, которая распечатывает первую сотню троек:</p><br>
<pre><code class="cpp">// simplest.cpp
#include &lt;time.h&gt;
#include &lt;stdio.h&gt;

int main()
{
    clock_t t0 = clock();

    int i = 0;
    for (int z = 1; ; ++z)
        for (int x = 1; x &lt;= z; ++x)
            for (int y = x; y &lt;= z; ++y)
                if (x*x + y*y == z*z) {
                    printf("(%i,%i,%i)\n", x, y, z);
                    if (++i == 100)
                        goto done;
                }
    done:

    clock_t t1 = clock();
    printf("%ims\n", (int)(t1-t0)*1000/CLOCKS_PER_SEC);
    return 0;
}</code></pre><br>
<p>Вот как её можно собрать: <code>clang simplest.cpp -o outsimplest</code>. Сборка занимает 0.064 секунды, на выходе имеем экзешник размером 8480 байтов, который отрабатывает 2 миллисекунды и потом печатает числа (всё это на моём железе: 2018 MacBookPro; Core i9 2.9GHz; компилятор — Xcode 10 clang).</p><br>
<pre><code class="plaintext">(3,4,5)
(6,8,10)
(5,12,13)
(9,12,15)
(8,15,17)
(12,16,20)
(7,24,25)
(15,20,25)
(10,24,26)
...
(65,156,169)
(119,120,169)
(26,168,170)</code></pre><br>
<p>Стоять! Это был дефолтная, неопитмизированная («Debug») сборка; давайте теперь соберём с оптимизациями («Release»): <code>clang simplest.cpp -o outsimplest -O2</code>. Это займёт 0.071 секнду на компиляцию и на выходе получится экзешник того же размера (8480 байт), который работает за 0 миллисекунд (то есть, ниже чувствительности таймера <code>clock()</code>).</p><br>
<p>Как правильно заметил Бартош, алгоритм здесь нельзя переиспользовать, ведь он смешан с манипуляциями результатом вычислений. Вопрос «действительно ли это является проблемой» выходит за рамки этой статьи (<em>лично я считаю, что «переиспользуемость» и задача «избежать дублирования любой ценой» слишком переоценены</em>). Давайте предположим, что это проблема, и нам действительно нужно что-то, что вернёт первые N троек, но никаких манипуляций над ними производить не станет.</p><br>
<p>Что бы сделал я — простейшую и из простых вещей, создать нечто пригодное для вызова, что будет возвращать следующую тройку. Это может выглядеть так:</p><br>
<pre><code class="cpp">// simple-reusable.cpp
#include &lt;time.h&gt;
#include &lt;stdio.h&gt;

struct pytriples
{
    pytriples() : x(1), y(1), z(1) {}
    void next()
    {
        do
        {
            if (y &lt;= z)
                ++y;
            else
            {
                if (x &lt;= z)
                    ++x;
                else
                {
                    x = 1;
                    ++z;
                }
                y = x;
            }
        } while (x*x + y*y != z*z);
    }
    int x, y, z;
};

int main()
{
    clock_t t0 = clock();

    pytriples py;
    for (int c = 0; c &lt; 100; ++c)
    {
        py.next();
        printf("(%i,%i,%i)\n", py.x, py.y, py.z);
    }

    clock_t t1 = clock();
    printf("%ims\n", (int)(t1-t0)*1000/CLOCKS_PER_SEC);
    return 0;
}</code></pre><br>
<p>Оно собирается и работает примерно за то же самое время. Отладочный экзешник вырастает на 168 байт, релизный остаётся того же размера.</p><br>
<p>Я сделал структуру <code>pytriples</code>, для которой каждый следующий вызов <code>next()</code> переходит к следующей валидной тройке; вызывающий код может делать с этим результатом всё, что душе угодно. Поэтому я просто зову его сто раз, и каждый раз распечатываю результат на экран.</p><br>
<p>Несмотря на то, что реализация является функционально эквивалентной тому, что делал цикл из трёх вложенных for-ов в изначальном примере, в реальности <code>он стал гораздо менее очевидным</code>, по крайней мере, для меня. Совершенно ясно, <em>как</em> он делает то, что он делает (несколько ветвлений и простые операции над целыми числами), но далеко не сразу понятно <em>что именно</em> он делает на высоком уровне.</p><br>
<p>Если бы в C++ было чего-нибудь вроде концепции <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B0">корутин</a>, стало бы возможно реализовать генератор троек, такой же лаконичный, как вложенные циклы в изначальном примере, но при этом не имеющий ни одну из перечисленных «проблем» (Джейсон Мейзель именно об этом говорит в статье «<a href="https://medium.com/%40jasonmeisel/ranges-code-quality-and-the-future-of-c-99adc6199608">Ranges, Code Quality, and the Future of C++</a>»); это могло быть нечто вроде (это предварительный синтаксис, потому что в стандарте C++ корутин нет):</p><br>
<pre><code class="cpp">generator&lt;std::tuple&lt;int,int,int&gt;&gt; pytriples()
{
    for (int z = 1; ; ++z)
        for (int x = 1; x &lt;= z; ++x)
            for (int y = x; y &lt;= z; ++y)
                if (x*x + y*y == z*z)
                    co_yield std::make_tuple(x, y, z);
}</code></pre><br>
<h1 id="vernyomsya-k-renzham-v-c">Вернёмся к ренжам в C++</h1><br>
<p>Может ли стиль записи в виде ренжей C++20 более ясно справиться с этой задачей? Давайте взглянем на пост Эрика, на основную часть кода:</p><br>
<pre><code class="cpp">auto triples =
    for_each(iota(1), [](int z) {
        return for_each(iota(1, z+1), [=](int x) {
            return for_each(iota(x, z+1), [=](int y) {
                return yield_if(x*x + y*y == z*z,
                    make_tuple(x, y, z));
                });
            });
        });</code></pre><br>
<p>Каждый решает за себя. По мне так, подход с корутинами, описанный выше, куда как более читабельный. Тот способ, которым в C++ создаются лямбды, и то, как в стандарте C++ придумали записывать вещи особо умным способом («что такое <em>йота</em>? это греческая буква, глядите какой я умный!») — обе этих вещи выглядят громоздко и нескладно. Множество return-ов кажется необычным, если читатель привык к императивному стилю программирования, но возможно, к этому можно и привыкнуть.</p><br>
<p><em>Быть может</em>, вы осилите свести глаза особым образом и представить, что это приемлемый и приятный синтаксис.</p><br>
<p>Тем не менее, я отказываюсь верить, что мы, простые смертные без докторской степени в C++, сможем написать утилиты, необходимые для работы вот такого кода:</p><br>
<pre><code class="cpp">template&lt;Semiregular T&gt;
struct maybe_view : view_interface&lt;maybe_view&lt;T&gt;&gt; {
  maybe_view() = default;
  maybe_view(T t) : data_(std::move(t)) {
  }
  T const *begin() const noexcept {
    return data_ ? &amp;*data_ : nullptr;
  }
  T const *end() const noexcept {
    return data_ ? &amp;*data_ + 1 : nullptr;
  }
private:
  optional&lt;T&gt; data_{};
};
inline constexpr auto for_each =
  []&lt;Range R,
     Iterator I = iterator_t&lt;R&gt;,
     IndirectUnaryInvocable&lt;I&gt; Fun&gt;(R&amp;&amp; r, Fun fun)
        requires Range&lt;indirect_result_t&lt;Fun, I&gt;&gt; {
      return std::forward&lt;R&gt;(r)
        | view::transform(std::move(fun))
        | view::join;
  };
inline constexpr auto yield_if =
  []&lt;Semiregular T&gt;(bool b, T x) {
    return b ? maybe_view{std::move(x)}
             : maybe_view&lt;T&gt;{};
  };</code></pre><br>
<p><em>Быть может</em>, что для кого-то это язык родной, но для меня всё это ощущается как если бы кто-то решил, что Perl излишне читабельный, а Brainfuck — излишне нечитабельный, поэтому давайте целиться между ними. Я программировал в основном на C++ все последние 20 лет. Может быть, я слишком тупой, чтобы во всём этом разобраться, отлично.</p><br>
<p>И да, конечно, <code>maybe_view</code>, <code>for_each</code>, <code>yield_if</code> — все они являются «переиспользуемыми компонентами», которые можно перенести в библиотеку; эта тема, про которую я расскажу… да прямо сейчас.</p><br>
<h1 id="problemy-s-podhodom-vsyo-yavlyaetsya-bibliotekoy">Проблемы с подходом «Всё Является Библиотекой»</h1><br>
<p>Существует как минимум два понимания производительности:</p><br>
<ol>
<li>Во время компиляции</li>
<li>Во время выполнения неоптимизированной сборки</li>
</ol><br>
<p>Продолжим иллюстрировать это на примере примера с пифагоровыми тройками, но на самом деле, эти проблемы справедливы для множества других фичей C++, реализованных как часть библиотек, а не как часть синтаксиса.</p><br>
<p>Финальная версия C++20 ещё не вышла, поэтому для быстрой проверки я взял текущее лучшее приближение ренжей, коим является <a href="https://github.com/ericniebler/range-v3">range-v3</a> (написанное самим Эриком Ниблером), и собрал относительно него канонический пример с пифагоровыми тройками.</p><br>
<pre><code class="cpp">// ranges.cpp
#include &lt;time.h&gt;
#include &lt;stdio.h&gt;
#include &lt;range/v3/all.hpp&gt;

using namespace ranges;

int main()
{
    clock_t t0 = clock();

    auto triples = view::for_each(view::ints(1), [](int z) {
        return view::for_each(view::ints(1, z + 1), [=](int x) {
            return view::for_each(view::ints(x, z + 1), [=](int y) {
                return yield_if(x * x + y * y == z * z,
                    std::make_tuple(x, y, z));
            });
        });
    });

    RANGES_FOR(auto triple, triples | view::take(100))
    {
        printf("(%i,%i,%i)\n", std::get&lt;0&gt;(triple), std::get&lt;1&gt;(triple), std::get&lt;2&gt;(triple));
    }

    clock_t t1 = clock();
    printf("%ims\n", (int)(t1-t0)*1000/CLOCKS_PER_SEC);
    return 0;
}</code></pre><br>
<p>Я использовал версию после 0.4.0 (<code>9232b449e44</code> за 22 декабря 2018 года), и собрал с помощью команды <code>clang ranges.cpp -I. -std=c++17 -lc++ -o outranges</code>. Оно <strong>собралось за 2.92 секунды</strong>, исполняемый файл получился размером 219 килобайт, а <strong>время выполнения увеличилось до 300 миллимекунд</strong>.</p><br>
<p>И да, это сборка без оптимизаций. Оптимизированная сборка (<code>clang ranges.cpp -I. -std=c++17 -lc++ -o outranges -O2</code>) компилируется за 3.02 секунды, экзешник выходит размером 13976 байтов, и выполняется за 1 миллисекунду. Скорость выполнения в рантайме хороша, размер экзешника чуть увеличился, а вот время компиляции всё так же осталось проблемой.</p><br>
<p>Углубимся в подробности.</p><br>
<h1 id="vremya-kompilyacii--ogromnaya-problema-dlya-c">Время компиляции — огромная проблема для C++</h1><br>
<p>Время компиляции этого реально наипростейшего примера заняло на 2.85 секунды дольше, чем версия с «простым C++».</p><br>
<p>Если вы вдруг подумали, что «меньше 3 секунд» — слишком маленькое время, то совершенно нет. За три секунды современный CPU может произвести несметное число операций. Например, за какое время clang сможет скомпилировать настоящий полноценный движок базы данных (<a href="https://sqlite.org/index.html">SQLite</a>) в отладочном режиме, включая все 220 <em>тысяч</em> строчек кода? За 0.9 секунд на моём ноутбуке. В какой такой вселенной стало нормальным, чтобы тривиальный пример на 5 строчек компилировался в три раза дольше целого движка баз данных?</p><br>
<p>Время компиляции С++ было источником боли на всех нетривиальных по размеру кодовых базах, где я работал. Не верите мне? Хорошо, попробуйте собрать какую-нибудь из широкоизвестных кодовых баз (Chromium, Clang/LLVM, UE4, и так далее отлично подойдут для примера). Среди множества вещей, которые <em>действительно</em> хочется иметь в C++, вопрос времени компиляции, наверное, на самом первом месте списка, и был там всегда. Тем не менее, складывается ощущение, что сообщество C++ в массе своей притворяется, что это совсем даже и не проблема, и в каждой следующей версии языка они перекладывают в заголовочные файлы <em>ещё больше</em> разных вещей, <em>ещё больше</em> вещей появляется в шаблонном коде, который обязан быть в заголовочных файлах.</p><br>
<p>В большинстве своём это связано с доисторической концепцией «просто скопипастим всё содержимое файла» модели <code>#include</code>, унаследованной из Си. Но в Си есть тенденция хранить в заголовках только объявления структур и прототипы функций, в C++ же обычно нужно свалить туда все шаблонные классы/функции.</p><br>
<p><a href="https://github.com/ericniebler/range-v3">range-v3</a> представляет из себя кусок кода размером 1.8 мегабайтов, и всё это в заголовочных файлах! Несмотря на то, что пример с сотней пифагоровых троек занимает 30 строчек, после обработки заголовков компилятору придётся скомпилировать 102 тысячи строк. В «простом C++» после всех преобразований получается 720 строк.</p><br>
<p><em>Но ведь именно для этого есть предкомпилированные заголовки и/или модули!</em> — так и слышу, что вы это сейчас сказали. Справедливо. Давайте положим заголовки библиотеки ренжей в precompiled header (pch.h с текстом: <code>#include &lt;range/v3/all.hpp&gt;</code>, заинклудим получившийся pch.h, создадим PCH: <code>clang -x c++-header pch.h -I. -std=c++17 -o pch.h.pch</code>, скомпилируем с помощью pch: <code>clang ranges.cpp -I. -std=c++17 -lc++ -o outranges -include-pch pch.h.pch</code>). Время компиляции станет 2.24 секунды. То есть, PCH может сэкономить нам около 0.7 секунды времени компиляции. С оставшимися 2.1 секундами они никак не помогут, и это куда дольше, чем подход с простым C++ :(</p><br>
<h1 id="proizvoditelnost-sborki-bez-optimizaciy--vazhna">Производительность сборки без оптимизаций — важна</h1><br>
<p>В рантайме пример с ренжами оказался <strong>в 150 раз медленней</strong>. Возможно, замедление в 2 или 3 раза ещё можно считать приемлемым. Всё, что в 10 раз медленней можно отнести в категорию непригодного к использованию. Больше, чем в сто раз медленней? Серьёзно?</p><br>
<p>На реальных кодовых базах, решающих реальные проблемы, разница в два порядка означает, что программа просто не сможет обработать настоящий объем данных. Я работаю в индустрии видеогейминга; по чисто практическим причинам это означает, что отладочные сборки игрового движка или тулинга не смогут обрабатывать настоящие игровые уровни (производительность даже не приблизится к необходимому уровню интерактивности). Возможно, существует такая индустрия, в которой можно запустить программу на наборе данных, подождать результата, и если это займет от 10 до 100 раз больше времени в отладочном режиме, это будет «досадно». Неприятно, раздражающе тормозно. Но если делается нечто, <em>обязанное быть интерактивным</em>, «досадно» превращается в «неприменимо». Вы буквально не сможете играть в игру, если она рендерит изображение со скоростью всего 2 кадра в секунду.</p><br>
<p>Да, сборка с оптимизациями (<code>-O2</code> в clang) работает со скоростью «простого C++»… ну да, ну да, «zero cost abstractions», где-то слышали. Бесплатные абстракции до тех пор, пока вам неинтересно время компиляции и возможно использовать оптимизирующий компилятор.</p><br>
<p>Но отладка оптимизированного кода — это <em>сложно</em>! Конечно, это возможно, и даже является очень полезным навыком. Подобно тому, как езда на одноколёсном велосипеде тоже возможна и учит наиважнейшему навыку балансирования. Кое-кто умеет получать от этого удовольствие, и даже вполне неплох в данном занятии. Но большинство людей никогда не выберут моноцикл в качестве основного средства передвижения, так же как большинство людей не отлаживают оптимизированный код, если есть хоть малейшая возможность этого избежать.</p><br>
<p>Arseny Kapoulkine делал крутой стрим «<a href="https://www.youtube.com/watch%3Fv%3Dm1jAgV4ZOhQ">Optimizing OBJ loader</a>» на YouTube, там он упёрся в проблему тормознутости отладочной сборки, и сделал её в 10 раз быстрее, выбросив некоторые куски STL (<a href="https://github.com/zeux/meshoptimizer/commit/1996f143b8b3">коммит</a>). Побочными эффектами стало ускорение компиляции (<a href="https://twitter.com/zeuxcg/status/1043155003681124352">исходник</a>) и упрощение отладки, поскольку реализация STL от Microsoft адски помешана на вложенных вызовах функций.</p><br>
<p>Это не к тому, что «STL — плохо»; возможно написать такую реализацию STL, которая не будет тормозить десятикратно в неоптимизированной сборке (EASTL и libc++ так умеют), но по какой-то причине Microsoft STL <em>невероятно сильно</em> тормозит потому, что они излишне сильно заложились на принцип «инлайнинг всё починит».</p><br>
<p>Как <em>пользователю языка</em>, мне всё равно, чья это проблема! Всё что мне известно изначально — «STL тормозит в отладочном режиме», и я бы предпочёл, чтобы кто-то это исправил уже. Ну или мне придётся искать альтернативы (например, не использовать STL, самостоятельно написать нужные лично мне вещи, или вообще отказаться от C++, как вам такое).</p><br>
<h1 id="sravnim-s-drugimi-yazykami">Сравним с другими языками</h1><br>
<p>Давайте коротко взглянем на очень схожую реализацию «лениво вычисляемых пифагоровых троек» на C#:</p><br>
<pre><code class="cs">using System;
using System.Diagnostics;
using System.Linq;

class Program
{
    public static void Main()
    {
        var timer = Stopwatch.StartNew();
        var triples =
            from z in Enumerable.Range(1, int.MaxValue)
            from x in Enumerable.Range(1, z)
            from y in Enumerable.Range(x, z)
            where x*x+y*y==z*z
            select (x:x, y:y, z:z);
        foreach (var t in triples.Take(100))
        {
            Console.WriteLine($"({t.x},{t.y},{t.z})");
        }
        timer.Stop();
        Console.WriteLine($"{timer.ElapsedMilliseconds}ms");
    }
}</code></pre><br>
<p>По мне так, это кусок весьма и весьма читабелен. Сравните вот эту строчку на C#:</p><br>
<pre><code class="cs">var triples =
    from z in Enumerable.Range(1, int.MaxValue)
    from x in Enumerable.Range(1, z)
    from y in Enumerable.Range(x, z)
    where x*x+y*y==z*z
    select (x:x, y:y, z:z);</code></pre><br>
<p>с примером на C++:</p><br>
<pre><code class="cpp">auto triples = view::for_each(view::ints(1), [](int z) {
    return view::for_each(view::ints(1, z + 1), [=](int x) {
        return view::for_each(view::ints(x, z + 1), [=](int y) {
            return yield_if(x * x + y * y == z * z,
                std::make_tuple(x, y, z));
        });
    });
});</code></pre><br>
<p>Мне ясно видно, что здесь чище написано. А вам? Если честно, то альтернатива на C# LINQ тоже выглядит перегруженной:</p><br>
<pre><code class="cs">var triples = Enumerable.Range(1, int.MaxValue)
    .SelectMany(z =&gt; Enumerable.Range(1, z), (z, x) =&gt; new {z, x})
    .SelectMany(t =&gt; Enumerable.Range(t.x, t.z), (t, y) =&gt; new {t, y})
    .Where(t =&gt; t.t.x * t.t.x + t.y * t.y == t.t.z * t.t.z)
    .Select(t =&gt; (x: t.t.x, y: t.y, z: t.t.z));</code></pre><br>
<p>Сколько собирается этот код на C#? Я использую Mac, поэтому запустив на компиляторе Mono (который тоже написан на C#) версии 5.16 команду <code>mcs Linq.cs</code> получилось скомпилировать второй пример за 0.20 секунд. Эквивалентный пример на «простом C#» уложился в 0.17 секунд.</p><br>
<p>То есть, ленивые вычисления в стиле LINQ <strong>добавляют 0.03 секунды работы компилятора</strong>. Сравните с дополнительными 3 секундами для C++ — это <strong>в 100 раз больше</strong>!</p><br>
<h1 id="no-ved-nelzya-prosto-proignorirovat-to-chto-ne-nravitsya">Но ведь нельзя просто проигнорировать то, что не нравится?</h1><br>
<p>Да, в какой-то степени.</p><br>
<p>Например, мы здесь в <a href="https://unity3d.com/">Unity</a> любим шутить, что «за добавление в проект Boost можно оказаться уволенным по статье». Похоже, всё же не увольняют, потому что в прошлом году я обнаружил, что кто-то добавил <a href="https://www.boost.org/doc/libs/1_66_0/doc/html/boost_asio.html">Boost.Asio</a>, всё стало дико медленно собираться, и мне пришлось разбираться с тем, что простое добавление <code>asio.h</code> инклудит за собой весь <code>&lt;windows.h&gt;</code>, со всеми <a href="http://aras-p.info/blog/2018/01/12/Minimizing-windows.h/">кошмарными макросами</a> внутри.</p><br>
<p>По большей части мы стараемся не использовать и большую часть STL. У нас есть собственные контейнеры, созданные по той же причине, что описаны во <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2271.html">введении к EASTL</a> — более однообразный способ доступа, работающий между различными платформами/компиляторами, более хорошая производительность в сборках без оптимизаций, лучшая интеграция с нашими собственными аллокаторами памяти и трекингом аллокаций. Есть и кое-какие другие контейнеры, чисто по причинам производительности (<code>unordered_map</code> в STL <em>даже по идее</em> не может быть быстрой, поскольку стандарт требует использования separate chaining; наша же хэш-таблица использует вместо этого открытую адресацию). Большая часть стандартной библиотеки нам и не нужна совсем.</p><br>
<p>Тем не менее.</p><br>
<p>Требуется время, чтобы убедить каждого нового сотрудника (особенно джуниоров, только что вышедших из университета) что нет, «современный» C++ не означает автоматически, что он лучше старого (<em>он может быть лучше! а может и не быть</em>). Или например, что «код на Си» не обязательно значит, что его сложно понимать и он весь завален багами (<em>может быть, так и есть! а может и нет</em>). </p><br>
<p>Всего пару недель назад я жаловался всем и каждому, как я пытаюсь понять один конкретный кусок (нашего собственного) кода, и не могу, потому что этот код «слишком сложный» для меня. Другой (джуниор) подсел рядом и спросил, почему я выгляжу так, как будто готов ‎(ﾉಥ益ಥ）ﾉ﻿ ┻━┻, я сказал «ну, потому что пытаюсь понять этот код, но для меня он слишком сложный». Его мгновенная реакция была вроде: <em>«о, это какой-то старый код в стиле Си?»</em>. И я такой: <em>«нет, в точности до наоборот!»</em>. (Код, о котором идёт речь, был чем-то вроде <a href="https://twitter.com/aras_p/status/1069882742429638657">шаблонного метапрограммирования</a>). Он не работал ни над большими кодовыми базами, ни над C или C++, но <em>нечто</em> уже убедило его, что нечитаемым должен быть именно код на Си. Я виню университет; обычно студентам сразу же втирают, что «Си — это плохо», и потом никогда не объясняют — почему; это оставляет неизгладимый отпечаток на неокрепшей психике будущих программистов.</p><br>
<p>Поэтому да, я определённо склонен игнорировать те части C++, которые мне не нравятся. Но обучать всех коллег вокруг весьма утомительно, поскольку слишком многие находятся под влиянием идей вроде «современное — значит хорошее», или «стандартная библиотека должна быть лучше, чем что угодно, что мы сможем написать сами».</p><br>
<h1 id="pochemu-takoe-proishodit-s-c">Почему такое происходит с C++?</h1><br>
<p>Понятия не имею. У них есть очень сложная задача, «как продолжать эволюцию языка, сохраняя почти стопроцентную обратную совместимость с решениями, сделанными на протяжении многих десятков лет». Наложите этот факт на то, что C++ пытается служить сразу нескольким хозяевам, учитывать множество способов использования и уровней опыта, и у вас появилась огромная проблема!</p><br>
<p>Но до какой-то степени, есть ощущение, что большая часть комитета C++ и экосистемы сфокусирована на «сложности» в смысле доказательства собственной полезности.</p><br>
<p><img width="200" align="left" src="https://habrastorage.org/webt/o_/2x/jx/o_2xjxxntoachxd_-e9-8idprlm.jpeg"> В интернетах ходит шутка о стадиях развития программиста на C/C++. Я помню, как был на средней стадии где-то лет 16 назад. Был очень поражён Boost, в том смысле что: «вау, <em>такие шутки можно делать</em>, это так круто!». Не задаваясь вопросом, <em>зачем</em> это вообще делать.</p><br>
<p>Точно так же, ну например, автомобили Formula 1 или гитары с тремя грифами. Поразительно? Конечно. Чудо инженерной мысли? Безусловно. Требует огромного скилла, чтобы управляться с ними? Да! <em>Не является правильным инструментом</em> для 99% ситуаций, в которых вы когда либо находились? Точняк.<br>
<br clear="all">
</p><br>
<p>Кристер Эриксон красиво сказал об этом <a href="https://twitter.com/ChristerEricson/status/1078095388244996096">здесь</a>:</p><br>
<blockquote>Цель программиста в том, чтобы делать поставки в срок и в рамках бюджета. Не «писать код». Имхо, большинство сторонников современного C++ 1) придают чрезмерное значение исходному коду вместо 2) времени компиляции, отладки, когнитивной нагрузки, создаваемой новыми концепциями и добавленной сложностью, требованиями проекта, и так далее. Решает пункт 2.</blockquote><p>И да, люди, обеспокоенные состоянием C++ и стандартных библиотек, конечно, могут объединить усилия и попытаться улучшить их. Некоторые так и делают. Некоторые слишком заняты (или они так думают) чтобы тратить время на комитеты. Некоторые игнорируют куски стандартов и делают свои собственные параллельные библиотеки (вроде <a href="https://github.com/electronicarts/EASTL">EASTL</a>). Некоторые пришли к выводу, что C++ уже не спасти, и пытаются сделать собственные языки (<a href="https://inductive.no/jai/">Jai</a>) или перепрыгнуть на другую лодку (<a href="https://www.rust-lang.org/">Rust</a>, <a href="https://unity.com/unity/features/job-system-ECS">подмножества C#</a>).</p><br>
<h1 id="prinimaem-i-dayom-obratnuyu-svyaz">Принимаем и даём обратную связь</h1><br>
<p>Я знаю, насколько это неприятно, когда «куча озлобленных людей в интернете» пытается сказать, что вся твоя работа — лошадиного навоза не стоит. Я работаю, возможно, над <a href="https://unity3d.com/">самым популярным в мире игровым движком</a>, которым пользуются миллионы, и часть из них любит говорить, прямо или непрямо, насколько он отвратительный. Это тяжело; я и другие коллеги вложили в это столько раздумий и усилий, и вдруг кто-то проходит мимо и говорит, что мы тут все идиоты и наша работа — мусор. Печально!</p><br>
<p>Скорей всего, что-то подобное испытывает каждый, кто работает над C++, STL или любой другой широко используемой технологией. Они годами работали над чем-то важным, и тут куча Разъярённых Жителей Нижнего Интернета пришла и расфигачила твою любимую работу.</p><br>
<p>Слишком легко перейти в защитную позу, это наиболее естественная реакция. Обычно — не самая конструктивная.</p><br>
<p>Если не обращать внимания на буквальных троллей, которые ноют по интернетам просто для удовольствия, большинство жалобщиков <em>действительно имеют</em> проблемы или неприятности, стоящие за ними. Они могут плохо это формулировать, или преувеличивать, или жалобщик не подумал над множеством других точек зрения кроме своей собственной, но тем не менее, существует <em>вполне конкретная проблема</em>, лежащая за всеми этими проявлениями.</p><br>
<p>Что я делаю, когда кто-то жалуется на вещь, над которой я работал? Нужно забыть о «себе» и «своей работе», и принять их точку зрения. С чем они пытаются разобраться, какие проблемы пытаются решить? Задача любого софта/библиотек/языков — помочь пользователям решить их проблемы. Это может быть или идеальный инструмент для решения этих проблем, или «ок, это может сработать», или совершенно ужасно плохое решение.</p><br>
<ul>
<li>«Я очень упорно над этим работал, но да, похоже что мой инструмент не очеь хорош в решении ваших проблем» — это совершенно правильный исход!</li>
<li>«Я очень упорно над этим работал, но не знаю или не учёл ваших потребностей, давайте я разберусь, что здесь можно сделать» — это тоже отличный исход!</li>
<li>«Простите, я не понимаю вашей проблемы» — тоже подойдёт!</li>
<li>«Я очень упорно над этим работал, но похоже, ни у кого нет проблем, которые решает моя работа» — очень печальных исход, но он <em>может</em> случиться, и <em>случается</em> на практике.</li>
</ul><br>
<p>Некоторые из ответов вида «весь фидбек будет проигнорирован, если он не оформлен в виде документа, представленного на собрании комитета C++», которые я видел в последнее время не кажутся мне продуктивным подходом. Точно так же, защита архитектуры библиотеки с помощью аргумента вида «это была популярная бибилиотека в Boost!» не учитывает той части мира C++, которая не считает, что Boost — это что-то хорошее.</p><br>
<p>Индустрия видеогейминга, если смотреть глобально, тоже виновата. Игровые технологии традиционно создаются с помощью C или C++ просто потому, что вплоть до самого последнего времени остальные системные языки программирования просто не существовали (но теперь есть как минимум Rust, составляющий достойную конкуренцию). Учитывая ту зависимость от C++, в которую попала индустрия, она совершенно точно не проделала достаточной работы, чтобы её замечали, и не занимается достаточно улучшением языка, библиотек и экосистемы.</p><br>
<p>Да, это тяжелая работа, и да — жаловаться в интернете куда проще. И кто бы ни начал работать над будущим C++, это самое будущее не в решении «непосредственных проблем» (вроде поставки игры или чего-то такого); они должны работать над чем-то куда более долговременным. Существуют компании, которые могут это позволить; любая компания, производящая большой игровой движок или большой издатель с централизованной технологической группой совершенно точно может этим заняться. Если это будет стоить того, но знаете, это как-то лицемерно, говорить «C++ — фигня полная, нам это не нужно», и при этом никогда не доносить разработчикам языка, что же вам нужно.</p><br>
<p>Моё впечатление от всего этого в том, что большинство игровых технологий чувствуют себя достаточно хорошо с последними (C++11/14/17) нововведениями в сам язык C++ — например, полезными оказались лямбды, <code>constexpr if</code> очень крут, и так далее. Но есть тенденция игнорировать то, что добавилось в стандартные библиотеки, как по причине описанных выше проблем в архитектуре и реализациях STL (долгое время компиляции, плохая производительность в отладке), так и просто потому, что они эти дополнения недостаточно вкусные, или компании уже написали свои собственные контейнеры/строки/алгоритмы/… многие годы назад, и не понимают, зачем им менять то, что уже работает.</p><br>
<blockquote>Минутка рекламы. <strong>19-20 апреля в Москве</strong> состоится конференция <strong>C++ Russia 2019</strong>. Будет множество хардкорных докладов, всё как вы любите. Один из наших гостей — <strong>Arno Schödl</strong>, отличный докладчик и CTO компании Think-Cell, расскажет про «<strong>Text Formatting For a Future Range-Based Standard Library</strong>». Искали место, где можно обсудить ренжи и другие новые фичи? Вы его нашли. Как попасть на конференцию, можно узнать <a href="http://cppconf.ru/registration/%3Futm_source%3Dhabr%26utm_medium%3D438260">на официальном сайте</a> (<strong>с первого февраля</strong> цены на билеты повысятся).</blockquote></div>