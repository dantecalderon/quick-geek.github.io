<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Rust 1.32 release</title>
  <meta name="description" content="The Rust development team is pleased to announce the release of a new version of Rust, 1.32.0. Rust is a programming language that allows everyone to ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Rust 1.32 release</h1><div class="post__text post__text-html js-mediator-article"><p>  The Rust development team is pleased to announce the release of a new version of Rust, 1.32.0.  Rust is a programming language that allows everyone to create reliable and efficient software. </p><br><p> If you have a previous version of Rust installed using <code>rustup</code> , then to update Rust to version 1.32.0, you just need to run: </p><br><pre> <code class="bash hljs">$ rustup update stable</code> </pre> <br><p>  If you have not yet installed <code>rustup</code> , you can <a href="https://www.rust-lang.org/install.html">install it</a> from the corresponding page of our website.  <a href="">Detailed notes for the release of Rust 1.32.0</a> can be found on GitHub. </p><br><blockquote>  A <code>rustup</code> note: there have been several new releases of <code>rustup</code> !  To update <code>rustup</code> itself, perform a <code>rustup self update</code> . </blockquote><br><h2 id="chto-voshlo-v-stabilnuyu-versiyu-1320">  What is included in the stable version 1.32.0 </h2><br><p>  Rust 1.32.0 acquired several life-enhancing improvements, changed the default memory allocator and made more functions constant.  Read about these changes below or see <a href="">the release notes for</a> details. </p><a name="habracut"></a><br><h4 id="makros-dbg">  Dbg macro </h4><br><p>  Let's start with a life-enhancing improvement.  Are you using "print debugging"?  If yes, and you want to print some value in the process of working on the code, you have to do this: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{:?}"</span></span>, x); <span class="hljs-comment"><span class="hljs-comment">// –∏–ª–∏ –¥–∞–∂–µ —Ç–∞–∫ println!("{:#?}", x);</span></span></code> </pre> <br><p>  This is not <em>the biggest</em> obstacle that slows down development, but it takes too much effort to easily debug output <code>x</code> values.  In addition, the context is not taken into account.  If you have several such <code>println!</code>  Now, it becomes difficult to determine what is related to the output until you yourself add context information to each call, which requires even more work. </p><br><p>  For these purposes, in Rust 1.32.0 <a href="https://github.com/rust-lang/rust/pull/56395/">we added a new dbg macro!</a>  : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span>; dbg!(x); }</code> </pre> <br><p>  After starting this program, you will see: </p><br><pre> <code class="plaintext hljs">[src/main.rs:4] x = 5</code> </pre> <br><p>  Together with the variable name and its value, the file name and the line number where the <code>dbg!</code> call was made will be displayed <code>dbg!</code>  . </p><br><p>  Also <code>println!</code>  prints to standard output, so it's best to use <code>eprintln!</code>  for printing standard error.  Macro <code>dbg!</code>  prints to <code>stderr</code> , and rightly so. </p><br><p>  This works even in difficult cases.  Consider an example of factorial implementation: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span></span>(n: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> { n } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { n * factorial(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) } }</code> </pre> <br><p>  In order to debug it, we can use <code>eprintln!</code>  : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span></span>(n: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> { eprintln!(<span class="hljs-string"><span class="hljs-string">"n: {}"</span></span>, n); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> { eprintln!(<span class="hljs-string"><span class="hljs-string">"n &lt;= 1"</span></span>); n } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> n = n * factorial(n - <span class="hljs-number"><span class="hljs-number">1</span></span>); eprintln!(<span class="hljs-string"><span class="hljs-string">"n: {}"</span></span>, n); n } }</code> </pre> <br><p>  We want to output <code>n</code> at each iteration and see the context of each of the branches.  For <code>factorial(4)</code> following will be displayed: </p><br><pre> <code class="plaintext hljs">n: 4 n: 3 n: 2 n: 1 n &lt;= 1 n: 2 n: 6 n: 24</code> </pre> <br><p>  This is acceptable, but not particularly good.  Perhaps we could work on improving the display of context information to make the conclusion clearer.  But then, instead of debugging your code, we‚Äôll work on improving the debugging code. </p><br><p>  Consider the same example using <code>dbg!</code>  : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span></span>(n: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dbg!(n &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { dbg!(<span class="hljs-number"><span class="hljs-number">1</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { dbg!(n * factorial(n - <span class="hljs-number"><span class="hljs-number">1</span></span>)) } }</code> </pre> <br><p>  We simply wrapped a macro with each of the expressions we want to output.  As a result, we get: </p><br><pre> <code class="plaintext hljs">[src/main.rs:3] n &lt;= 1 = false [src/main.rs:3] n &lt;= 1 = false [src/main.rs:3] n &lt;= 1 = false [src/main.rs:3] n &lt;= 1 = true [src/main.rs:4] 1 = 1 [src/main.rs:5] n * factorial(n - 1) = 2 [src/main.rs:5] n * factorial(n - 1) = 6 [src/main.rs:5] n * factorial(n - 1) = 24 [src/main.rs:11] factorial(4) = 24</code> </pre> <br><p>  Since the <code>dbg!</code> macro <code>dbg!</code>  returns the debugged value itself, unlike <code>eprintln!</code>  , which returns <code>()</code> , we do not need to make <em>any</em> changes in the structure of our code.  Additionally, we get a <em>much</em> more useful conclusion. </p><br><p>  We paid a lot of attention to such a small macro, since we hope that it will simplify your debugging process.  Of course, we are also continuing to work on supporting <code>gdb</code> and co. </p><br><h4 id="po-umolchaniyu-ubran-jemalloc">  <code>jemalloc</code> removed by <code>jemalloc</code> </h4><br><p>  A long time ago, Rust had a big runtime, similar to Erlang.  For him, <a href="http://jemalloc.net/">jemalloc</a> was chosen instead of the system allocator, because it was often more productive.  Gradually, we got rid of the runtime more and more, and in the end it was almost all removed, but the jemalloc remained.  We had no way to choose a user allocator, and therefore we could not completely remove jemalloc so as not to harm those who needed it. </p><br><p>  In addition, the claim that <code>jemalloc</code> was always the default <code>jemalloc</code> was primarily for the UNIX world, since it was by default only on <em>some</em> platforms.  In particular, the goal of MSVC on Windows has long been using the system allocator. </p><br><p>  Finally, although jemalloc <em>usually</em> has good performance, this is not always the case.  In addition, it adds about 300 kilobytes to each executable file.  We also have a lot of <a href="https://github.com/rust-lang/rust/issues/36963">other problems</a> with jemalloc.  And in general, it is strange that the default system language does not use the system allocator. </p><br><p>  For these reasons, as soon as <a href="https://habr.com/ru/post/419259/">Rust 1.28 provided a way to select a global allocator</a> , we began to plan the transition to the default system allocator and the provision of <code>jemalloc</code> as an external library.  In Rust 1.32, we have finally completed this work, and now by default your program will use the system allocator. </p><br><p>  If you want to continue using jemalloc, use <a href="https://crates.io/crates/jemallocator">the jemallocator library</a> .  To do this, in <code>Cargo.toml</code> specify: </p><br><pre> <code class="plaintext hljs">jemallocator = "0.1.8"</code> </pre> <br><p>  And in the root file of your project: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[global_allocator]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ALLOC: jemallocator::Jemalloc = jemallocator::Jemalloc;</code> </pre> <br><p>  That's all!  If you don't need jemalloc, you are no longer forced to use it, but if you need it, then the problem is solved with a few lines of code. </p><br><h4 id="zaklyuchitelnye-uluchsheniya-sistemy-moduley">  Final module system improvements </h4><br><p>  In the last two issues, we talked about several improvements to the module system.  In 1.32.0 and edition 2018, we added the latest change.  It is called <a href="https://github.com/rust-lang/rust/pull/56759">"uniform paths"</a> and allows you to work with import paths in the same way as with other paths that did not work correctly before.  For example: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span></span> { Red, Green, Blue } <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Color::*;</code> </pre> <br><p>  This code <em>has</em> not been compiled <em>before</em> , since the paths in <code>use</code> must have started with <code>super</code> , <code>self</code> or <code>crate</code> .  Now, thanks to the compiler support for uniform paths, this code will work and do what you expect: importing the variants of the <code>Color</code> enumeration defined above. </p><br><p>  This change completes our revision of the module system.  We hope you enjoy working with the simplified system! </p><br><h4 id="uluchsheniya-makrosov">  Macro enhancements </h4><br><p>  Rust 1.32.0 released several macro enhancements.  First, a <a href="https://github.com/rust-lang/rust/pull/56072/">new literal fragment specifier</a> was added: </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">macro_rules!</span></span> m { ($lt:literal) =&gt; {}; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { m!(<span class="hljs-string"><span class="hljs-string">"some string literal"</span></span>); }</code> </pre> <br><p>  The <code>literal</code> fragment is associated with literals of any type: string, numeric, and character. </p><br><p>  In the 2018 edition, <code>macro_rules</code> can also be used in the macro <strong><code>?</code></strong>  : </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">macro_rules!</span></span> bar { ($(a)?) =&gt; {} }</code> </pre> <br><p>  Fragment with <strong><code>?</code></strong>  a zero or one occurrence will be matched, just as a fragment with a <code>*</code> already associates a "zero or more" occurrences, and a <strong><code>+</code></strong> - a "one or more" occurrences. </p><br><h3 id="stabilizaciya-standartnoy-biblioteki">  Standard Library Stabilization </h3><br><p>  Macro <code>dbg!</code>  , which we have already described above, has become an important addition to the standard library.  In addition, 19 functions were made constant, and all numerical primitive types received conversion functions into a byte array and back with the specified byte order.  There are six functions with the names <code>to_&lt;endian&gt;_bytes</code> and <code>from_&lt;endian&gt;_bytes</code> , where <code>&lt;endian&gt;</code> is: </p><br><ul><li>  <code>ne</code> - native endianness </li><li>  <code>le</code> - order from junior to senior (little endian) </li><li>  <code>be</code> - order from older to younger (big endian) </li></ul><br><p>  See <a href="">the release notes for</a> details. </p><br><h3 id="uluchsheniya-v-cargo">  Improvements in Cargo </h3><br><p>  Cargo has been given the <a href="https://github.com/rust-lang/cargo/pull/6218/"><strong>cargo c</strong> alias for the <strong>cargo check</strong> team</a> , and now <a href="https://github.com/rust-lang/cargo/pull/6242/">allows using usernames in repository URLs</a> . </p><br><p>  See <a href="">the release notes for</a> details. </p><br><h2 id="razrabotchiki-1320">  Developers 1.32.0 </h2><br><p>  Many people co-created Rust 1.32.0.  We could not complete the work without the participation of each of you.  <a href="">Thank!</a> </p><br><p>  <em>From the translator: I express special thanks to the members of the Rustycrate community and personally <a href="https://github.com/dashadee">@dashadee</a> and <a href="https://habr.com/ru/users/ozkriff/" class="user_link">ozkriff</a> for their help with translation and proofreading.</em> </p></div><p>Source: <a href="https://habr.com/ru/post/436854/">https://habr.com/ru/post/436854/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>