<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Reflective Shadow Maps: Part 2 - Implementation</title>
  <meta name="description" content="Hi, Habr! This article presents a simple implementation of Reflective Shadow Maps (the algorithm is described in the previous article ). Next, I will ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Reflective Shadow Maps: Part 2 - Implementation</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr!  This article presents a simple implementation of <b>Reflective Shadow Maps</b> (the algorithm is described in the <a href="https://habr.com/ru/post/440488/">previous article</a> ).  Next, I will explain how I did it and what the pitfalls were.  Some possible optimizations will also be considered. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/80f/588/6da/80f5886da498099f2e9716d4c0a53e3d.png" alt="image"><br>  <i>Figure 1: From left to right: no RSM, with RSM, difference</i> <br><a name="habracut"></a><br><h2>  Result </h2><br>  In <i>Figure 1,</i> you can see the result obtained using <b>RSM</b> .  The Stanford rabbit and three multi-colored quadrangles were used to create these images.  In the image on the left, you can see the result of the render without <b>RSM</b> using only <b>spot light</b> .  Everything in the shade is completely black.  The image in the center shows the result with <b>RSM</b> .  The following differences are noticeable: brighter colors everywhere, pink color, floor and rabbit flooding, shading is not completely black.  The last image shows the difference between the first and second, and therefore the contribution of <b>RSM</b> .  On the middle image you can see tighter edges and artifacts, but this can be solved by adjusting the core size, indirect illumination intensity and the number of samples. <br><br><h2>  Implementation </h2><br>  The algorithm was implemented on its own engine.  Shaders are written in HLSL, and render on DirectX 11. I already set up <b>deferred shading</b> and <b>shadow mapping</b> for directional light (directional light source) before writing this article.  First, I implemented <b>RSM</b> for directional light and only after added support for the <b>shadow map</b> and <b>RSM</b> for the spot light. <br><br><h3>  Shadow map extension </h3><br>  Traditionally, <b>Shadow Maps</b> (SM) is nothing more than a depth map.  This means that you don't even need a pixel / fragment shader to fill SM.  However, for <b>RSM</b> you need some additional buffers.  You need to store the world-space <b>position</b> , world-space <b>normals</b> and <b>flux</b> (luminous flux).  This means that you need a pixel / fragment shader with multiple render targets.  Keep in mind that for this technique you need to cut off the back faces ( <b>face culling</b> ), not the front ones.  Using <b>face culling of</b> front faces is a widely used way to avoid shadow artifacts, but this does not work with <b>RSM</b> . <br><br>  You transfer the world-space positions and normals to the pixel shader and write them into the corresponding buffers.  If you use <b>normal mapping</b> , then also count them in a pixel shader.  <b>Flux is also</b> calculated by multiplying the albedo material by the color of the light source.  For <b>spot light</b> you need to multiply the resulting value by the angle of incidence.  For <b>directional light, a</b> non-shaded image is obtained. <br><br><h3>  Preparation for the calculation of lighting </h3><br>  For the main passage you need to do a few things.  You must bind all the buffers used in the shadow pass as textures.  You also need random numbers.  The <a href="http://www.klayge.org/material/3_12/GI/rsm.pdf">official article</a> says that you need to pre-calculate these numbers and store them in a buffer in order to reduce the number of operations in the <b>RSM</b> sampling pass.  Since the algorithm is heavy in terms of performance, I completely agree with the official article.  It also recommends adhering to temporal coherence (using the same sampling pattern for all indirect illumination calculations).  This will avoid flickering when different shadows are used in each frame. <br><br>  You need two random floating-point numbers in the range [0, 1] for each sample.  These random numbers will be used to determine the coordinates of the sample.  You will also need the same matrix that you use to convert positions from world-space (world space) to shadow-space (light source space).  You will also need such sampling parameters, which will be given in black color if sampled beyond the boundaries of the texture. <br><br><h3>  Perform aisle lighting </h3><br>  Now the hard part to understand.  I recommend counting indirect illumination after you have calculated the direct light for a particular light source.  This is because you need a full-screen quad for <b>directional light</b> .  However, for <b>spot</b> and <b>point light,</b> you usually want to use meshes of a certain shape with <b>culling</b> to fill smaller pixels. <br><br>  On the code snippet below, indirect lighting is calculated for the pixel.  Next, I will explain what is happening there. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoReflectiveShadowMapping</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 P, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> divideByW, float3 N)</span></span></span><span class="hljs-function"> </span></span>{ float4 textureSpacePosition = mul(lightViewProjectionTextureMatrix, float4(P, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (divideByW) textureSpacePosition.xyz /= textureSpacePosition.w; float3 indirectIllumination = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rMax = rsmRMax; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (uint i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; rsmSampleCount; ++i) { float2 rnd = rsmSamples[i].xy; float2 coords = textureSpacePosition.xy + rMax * rnd; float3 vplPositionWS = g_rsmPositionWsMap .Sample(g_clampedSampler, coords.xy).xyz; float3 vplNormalWS = g_rsmNormalWsMap .Sample(g_clampedSampler, coords.xy).xyz; float3 flux = g_rsmFluxMap.Sample(g_clampedSampler, coords.xy).xyz; float3 result = flux * ((max(<span class="hljs-number"><span class="hljs-number">0</span></span>, dot(vplNormalWS, P ‚Äì vplPositionWS)) * max(<span class="hljs-number"><span class="hljs-number">0</span></span>, dot(N, vplPositionWS ‚Äì P))) / <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(length(P ‚Äì vplPositionWS), <span class="hljs-number"><span class="hljs-number">4</span></span>)); result *= rnd.x * rnd.x; indirectIllumination += result; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> saturate(indirectIllumination * rsmIntensity); }</code> </pre> <br>  The first argument of the function is <b>P</b> , which is the world-space position (in world space) for a particular pixel.  <b>DivideByW is</b> used for the perspective division needed to get the correct <b>Z</b> value.  <b>N</b> is world-space normal. <br><br><pre> <code class="cpp hljs">float4 textureSpacePosition = mul(lightViewProjectionTextureMatrix, float4(P, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (divideByW) textureSpacePosition.xyz /= textureSpacePosition.w; float3 indirectIllumination = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rMax = rsmRMax;</code> </pre><br>  In this part of the code, the light-space is calculated (relative to the light source) position, the indirect illumination variable is initialized, in which the values ‚Äã‚Äãcalculated from each sample are summed, and the variable <b>rMax</b> is set from the lighting equation in the <a href="http://www.klayge.org/material/3_12/GI/rsm.pdf">official article</a> , the value of which I will explain in the next section. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (uint i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; rsmSampleCount; ++i) { float2 rnd = rsmSamples[i].xy; float2 coords = textureSpacePosition.xy + rMax * rnd; float3 vplPositionWS = g_rsmPositionWsMap .Sample(g_clampedSampler, coords.xy).xyz; float3 vplNormalWS = g_rsmNormalWsMap .Sample(g_clampedSampler, coords.xy).xyz; float3 flux = g_rsmFluxMap.Sample(g_clampedSampler, coords.xy).xyz;</code> </pre><br><br>  Here we start the cycle and prepare our variables for the equation.  In order to optimize, the random samples that I calculated already contain coordinate offsets, that is, to get UV coordinates I just need to add <b>rMax * rnd</b> to the light-space coordinates.  If the resulting UV is outside the range [0,1], the samples should be black.  Which is logical, since they go beyond the range of coverage. <br><br><pre> <code class="cpp hljs"> float3 result = flux * ((max(<span class="hljs-number"><span class="hljs-number">0</span></span>, dot(vplNormalWS, P ‚Äì vplPositionWS)) * max(<span class="hljs-number"><span class="hljs-number">0</span></span>, dot(N, vplPositionWS ‚Äì P))) / <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(length(P ‚Äì vplPositionWS), <span class="hljs-number"><span class="hljs-number">4</span></span>)); result *= rnd.x * rnd.x; indirectIllumination += result; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> saturate(indirectIllumination * rsmIntensity);</code> </pre><br>  This is the part where the indirect lighting equation is calculated ( <i>Figure 2</i> ), and is also weighted according to the distance from the light-space coordinates to the sample.  The equation looks daunting, and the code does not help to understand everything, so I will explain in more detail. <br>  The variable <b>Œ¶</b> (phi) is the luminous flux ( <b>flux</b> ), which is the radiation intensity.  <a href="https://habr.com/ru/post/440488/">The previous article</a> describes <b>flux in</b> more detail. <br><br>  <b>Flux is</b> scaled by two scalar products.  The first is between the normal of the light source (texel) and the direction from the light source to the current position.  The second is between the current normal and the direction vector from the current position to the position of the light source (texel).  In order not to get a negative contribution to the illumination (it turns out, if the pixel is not illuminated), scalar products are limited to the range [0, ‚àû].  In this equation, at the end normalization is performed, I suppose, for performance reasons.  It is equally permissible to normalize direction vectors before performing scalar products. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ab4/dd3/258/ab4dd3258620fc3bae4a044df4072cf5.png" alt="image"><br>  <i>Figure 2: Equation of illumination of a point with position <b>x</b> and normal <b>n</b> directed by a pixel light source <b>p</b></i> <br><br>  The result of this passage can be mixed with the backbuffer (direct lighting), and the result is obtained as <i>shown</i> in <i>Figure 1</i> . <br><br><h2>  Underwater rocks </h2><br>  When implementing this algorithm, I ran into some problems.  I will talk about these issues so that you do not step on the same rake. <br><br><h3>  Wrong sampler </h3><br>  I spent a considerable amount of time figuring out why my indirect lighting looked repetitive.  The Crytek Sponza textures are lined, so a sampler was needed for it.  But for <b>RSM</b> it is not very suitable. <br><div class="spoiler">  <b class="spoiler_title">Opengl</b> <div class="spoiler_text">  In OpenGL, for <b>RSM</b> textures, the GL_CLAMP_TO_BORDER parameter is set. <br></div></div><br><h3>  Custom values </h3><br>  To improve the workflow, it is important to be able to change some variables by pressing buttons.  For example, indirect illumination intensity and sampling range ( <b>rMax</b> ).  These parameters must be configured for each light source.  If you have a large sampling range, then you get indirect illumination from anywhere, which is useful for large scenes.  For more local indirect lighting, you'll need a smaller range.  <i>Figure 3</i> shows global and local indirect lighting. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a08/c98/7f7/a08c987f7a9bf46344a623bafebfc903.png" alt="image"><br>  <i>Figure 3: Demonstration of <b>rMax</b> dependencies.</i> <br><br><h3>  Separate passage </h3><br>  At first I thought I could make indirect lighting in the shader, in which I consider direct lighting.  For <b>directional light,</b> this works because you still draw a full-screen quad.  However, for <b>spot</b> and <b>point light</b> you need to optimize the calculation of indirect illumination.  Therefore, I considered indirect lighting a separate passage, which is necessary if you also want to do <b>screen-space interpolation</b> . <br><br><h3>  Cache </h3><br>  This algorithm is not at all friendly with the cache.  It is sampled at random points in multiple textures.  The number of samples without optimizations is also unacceptably large.  With a resolution of 1280 * 720 and the number of <b>RSM</b> 400 samples, you will make 1.105.920.000 samples for each light source. <br><br><h3>  Pros and cons </h3><br>  I will list the pros and cons of this indirect illumination calculation algorithm. <br><table><tbody><tr><td>  Behind </td><td>  <b>Vs</b> </td></tr><tr><td>  Easy to understand algorithm </td><td>  Not at all friendly with the cache </td></tr><tr><td>  Well integrated with deferred renderer </td><td>  Variable setting required </td></tr><tr><td>  Can be used in other algorithms ( <b>LPV</b> ) </td><td>  Forced choice between local and global indirect lighting </td></tr></tbody></table><br><h2>  Optimization </h2><br>  I made several attempts to increase the speed of this algorithm.  As described in the <a href="http://www.klayge.org/material/3_12/GI/rsm.pdf">official article</a> , you can implement <b>screen-space interpolation</b> .  I did it, and the rendering accelerated a bit.  Below I will describe some of the optimizations, and make a comparison (in frames per second) between the following implementations, using the 3-wall and rabbit scene: no <b>RSM</b> , a naive <b>RSM</b> implementation, interpolated <b>RSM</b> . <br><br><h3>  Z-check </h3><br>  One of the reasons why my <b>RSM</b> worked inefficiently was because I also counted on indirect lighting for the pixels that were part of the skybox.  Skybox definitely does not need this. <br><br><h3>  Predict random samples on CPU </h3><br>  Preliminary calculation of samples will not only give greater temporal coherence, but also eliminates the need to recalculate these samples in the shader. <br><br><h3>  Screen space interpolation </h3><br>  The <a href="http://www.klayge.org/material/3_12/GI/rsm.pdf">official article</a> proposes using low-resolution render target to calculate indirect illumination.  For scenes with a lot of smooth normals and straight walls, the lighting information can be easily interpolated between points with lower resolution.  I will not describe the interpolation in detail so that this article is a bit shorter. <br><br><h2>  Conclusion </h2><br>  Below are the results for different number of samples.  I have a few comments about these results: <br><br><ul><li>  Logically, the FPS is about 700 for different number of samples when the <b>RSM</b> calculation is not performed. </li><li>  Interpolation gives some overhead and is not very useful with a small number of samples. </li><li>  Even with 100 samples, the final image looked quite good.  This may be due to interpolation, which ‚Äúblurs‚Äù indirect illumination. </li></ul><br><table><tbody><tr><td>  Sample count </td><td>  FPS for No RSM </td><td>  FPS for Naive RSM </td><td>  FPS for Interpolated RSM </td></tr><tr><td>  100 </td><td>  ~ 700 </td><td>  152 </td><td>  264 </td></tr><tr><td>  200 </td><td>  ~ 700 </td><td>  89 </td><td>  179 </td></tr><tr><td>  300 </td><td>  ~ 700 </td><td>  62 </td><td>  138 </td></tr><tr><td>  400 </td><td>  ~ 700 </td><td>  44 </td><td>  116 </td></tr></tbody></table></div><p>Source: <a href="https://habr.com/ru/post/440570/">https://habr.com/ru/post/440570/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>