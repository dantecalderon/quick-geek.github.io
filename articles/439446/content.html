<div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/qo/zx/ss/qozxssedwxgcrteo4wnodfixdmy.png" alt="Logo of the third version of JavaScript Engine Switcher"></p><br><p>  <a href="https://github.com/Taritsyn/JavaScriptEngineSwitcher">JavaScript Engine Switcher</a> was originally created as a supporting library and its development was largely determined by the needs of the libraries that used it.  In fact, each major version of it solved one or several major tasks necessary for the further development of other libraries: </p><br><ol><li>  In the first version, the task was to add as many adapter modules as possible for the popular JS engines that support the .NET platform.  And this gave <a href="https://github.com/Taritsyn/BundleTransformer">Bundle Transformer</a> users some flexibility: on development computers they could use the <a href="https://github.com/Taritsyn/JavaScriptEngineSwitcher/wiki/MSIE">MSIE</a> module, which supports debugging of JS code using Visual Studio, and on servers that did not have a modern version of Internet Explorer or it was not installed at all, they could <a href="https://github.com/Taritsyn/JavaScriptEngineSwitcher/wiki/V8">V8</a> module.  Some even managed to run the Bundle Transformer in Mono on Linux and Mac using the <a href="https://github.com/Taritsyn/JavaScriptEngineSwitcher/wiki/Jurassic">Jurassic</a> and <a href="https://github.com/Taritsyn/JavaScriptEngineSwitcher/wiki/Jint">Jint</a> modules. </li><li>  The main objective of the second version was the implementation of .NET Core support, which was required for the new version of the <a href="">ReactJS.NET</a> library.  Another important task was to create a cross-platform module capable of quickly processing large volumes of JS code (the Jurassic and Jint modules were not suitable for this), and such a module, after a number of improvements, was the <a href="https://github.com/Taritsyn/JavaScriptEngineSwitcher/wiki/ChakraCore">ChakraCore</a> module. </li><li>  In the third version, the main focus was on improving integration with the ReactJS.NET library and increasing productivity. </li></ol><br><p> In this article, we will look at some of the innovations of the third version, which for many turned out to be not obvious even after reading the <a href="">release text</a> and the <a href="">“How to upgrade applications to version 3.X”</a> section of the documentation: changes in the <code>JsEngineSwitcher</code> class, reorganization of exceptions, more informative error messages, interruption and pre-compiling scripts, the ability to change the maximum stack size in the modules ChakraCore and MSIE, as well as a new module based on NiL.JS. </p><a name="habracut"></a><br><h2>  JsEngineSwitcher class changes </h2><br><p>  In the new version, the <code>JsEngineSwitcher</code> class implements the <code>IJsEngineSwitcher</code> interface and is no longer a singleton (its instance can be created using the <code>new</code> operator).  To get a global instance, use the <code>Current</code> property instead of the <code>Instance</code> property.  The <code>Current</code> property, unlike the obsolete <code>Instance</code> property, has the return type <code>IJsEngineSwitcher</code> .  Also, the <code>Current</code> property has a setter, with which you can replace the standard implementation with your own: </p><br><pre> <code class="cs hljs">JsEngineSwitcher.Current = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyJsEngineSwitcher();</code> </pre> <br><p>  In ASP.NET Core web applications where the <a href="http://nuget.org/packages/JavaScriptEngineSwitcher.Extensions.MsDependencyInjection/">JavaScriptEngineSwitcher.Extensions.MsDependencyInjection</a> package is installed, the implementation is replaced using the <code>AddJsEngineSwitcher</code> extension <code>AddJsEngineSwitcher</code> : </p><br><pre> <code class="cs hljs">… <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> JavaScriptEngineSwitcher.Extensions.MsDependencyInjection; … <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Startup</span></span> { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConfigureServices</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IServiceCollection services</span></span></span><span class="hljs-function">)</span></span> { … services.AddJsEngineSwitcher(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyJsEngineSwitcher(), options =&gt; … ) … ; … } … } …</code> </pre> <br><p>  These changes almost always “break” applications or libraries that use the previous version of JavaScript Engine Switcher.  Therefore, you need to make the following changes to your code: </p><br><ol><li>  Change the type of variables, parameters, or properties from <code>JsEngineSwitcher</code> to <code>IJsEngineSwitcher</code> . </li><li>  Instead of using the <code>Instance</code> property, use the <code>Current</code> property everywhere. </li></ol><br><p>  It is also worth noting that for most developers, these changes will not be particularly useful, because their main goal was to simplify unit tests (for example, <a href="">blocking was</a> used in the unit tests of the ReactJS.NET library, and now you can <a href="">do without them</a> ). </p><br><h2>  Reorganization of exceptions </h2><br><p>  Prior to the third version, most of the errors of JS engines turned into exceptions of the <code>JsRuntimeException</code> type, and only errors that occurred during the engine initialization process turned into a <code>JsEngineLoadException</code> .  There was also a base class <code>JsException</code> , from which the two types of exceptions listed above inherited, which allowed to intercept absolutely all the errors that occurred during the work of JS engines.  Despite obvious shortcomings, such an organization of exceptions fit well into the concept of a unified interface for accessing the basic features of JS engines. </p><br><p>  But when realizing the possibilities of interruption and preliminary compilation of scripts (I will talk about them in the next sections), a need arose for a new approach to the organization of exceptions.  The first thing to do was to add a new exception type - <code>JsInterruptedException</code> , which was necessary to notify the user about the interruption of script execution.  Then it was necessary to explicitly divide all errors that occurred while processing scripts into two groups: compilation errors (syntax analysis) and runtime errors.  Also required to separate all sorts of specific errors Chakra and V8, which were not associated with the processing of scripts.  It was also necessary to take into account the presence in the Jint engine of an exception that occurs when the script execution timeout (timeout) expires.  As a result, a new approach to the organization of exceptions was formed, which can be represented as the following hierarchical structure: </p><br><ul><li> <code>JsException</code> <br> <ul><li> <code>JsEngineException</code> <br> <ul><li> <code>JsEngineLoadException</code> </li> </ul></li><li> <code>JsFatalException</code> </li> <li> <code>JsScriptException</code> <br> <ul><li> <code>JsCompilationException</code> </li> <li> <code>JsRuntimeException</code> <br> <ul><li> <code>JsInterruptedException</code> </li> <li> <code>JsTimeoutException</code> </li> </ul></li></ul></li><li> <code>JsUsageException</code> </li> </ul></li><li>  <code>JsEngineNotFoundException</code> <sup>*</sup> </li></ul><br><p>  * - this exception occurs not at the level of the JS engine, but at the level of JavaScript Engine Switcher. </p><br><p>  I think that the hierarchy of exceptions presented above does not need comments, because the names of the exceptions speak for themselves.  With this approach, we get not only more information about the causes of the error, but we can more flexibly handle certain types of exceptions. </p><br><h2>  Unified error message format </h2><br><p>  Another problem with previous versions of JavaScript Engine Switcher was the difficulty in locating errors that occurred during script processing.  It was difficult to understand exactly where the error occurred from the <code>Message</code> exception property, so we had to analyze other exception properties, which was not always convenient.  In addition, a set of existing properties was also insufficient. </p><br><p>  Therefore, 2 new properties have been added to the <code>JsScriptException</code> class: </p><br><ol><li>  <strong>Type</strong> - type of JavaScript error (for example, <code>SyntaxError</code> or <code>TypeError</code> ); </li><li>  <strong>DocumentName</strong> is the name of the document (usually derived from the values ​​of the following parameters: <code>documentName</code> of the <code>Execute</code> and <code>Evaluate</code> methods, <code>path</code> the <code>ExecuteFile</code> method, <code>resourceName</code> the <code>ExecuteResource</code> method, etc.); </li></ol><br><p>  One new property has also been added to the <code>JsRuntimeException</code> class - <strong>CallStack</strong> , which contains a string representation of the call stack. </p><br><p>  Previously, the <code>Message</code> property simply copied a value from a similar property of the original .NET exception or a string representation of a JavaScript error.  Often, error messages in different JS engines differed not only in the format, but also in the amount of useful information presented in them.  For example, due to the lack of information about the row and column numbers in some error messages, the developers of the ReactJS.NET library were forced to override the <a href="">exceptions</a> obtained from the JavaScript Engine Switcher. </p><br><p>  Therefore, I decided to generate my own error messages at the level of adapter modules that would have a single (unified) format.  This format uses all available error information: type, description, document name, line number, column number, code fragment, and call stack.  As a basis for the new format, I took the error format from the <a href="https://github.com/Microsoft/ClearScript">Microsoft ClearScript</a> library. </p><br><p>  Below are the messages about the same compilation error that were generated by different adapter modules: </p><br><pre> <code class="plaintext hljs">ChakraCore ========== SyntaxError: Unexpected identifier after numeric literal at declinationOfSeconds.js:12:23 -&gt; caseIndex = number % 1O &lt; 5 ? number % 10 : 5; Jint ==== SyntaxError: Unexpected token ILLEGAL at declinationOfSeconds.js:12:25 Jurassic ======== SyntaxError: Expected operator but found 'O' at declinationOfSeconds.js:12 MSIE в режиме Classic ===================== SyntaxError: Expected ';' at declinationOfSeconds.js:12:25 -&gt; caseIndex = number % 1O &lt; 5 ? number % 10 : 5; MSIE в режиме Chakra ActiveScript ================================= SyntaxError: Expected ';' at declinationOfSeconds.js:12:25 -&gt; caseIndex = number % 1O &lt; 5 ? number % 10 : 5; MSIE в режиме Chakra IE JsRT ============================ SyntaxError: Expected ';' at 12:25 -&gt; caseIndex = number % 1O &lt; 5 ? number % 10 : 5; MSIE в режиме Chakra Edge JsRT ============================== SyntaxError: Unexpected identifier after numeric literal at declinationOfSeconds.js:12:23 -&gt; caseIndex = number % 1O &lt; 5 ? number % 10 : 5; NiL === SyntaxError: Unexpected token 'O' at 12:25 V8 == SyntaxError: Invalid or unexpected token at declinationOfSeconds.js:12:24 -&gt; caseIndex = number % 1O &lt; 5 ? number % 10 : 5; Vroom ===== SyntaxError: Unexpected token ILLEGAL at declinationOfSeconds.js:12:24</code> </pre> <br><p>  A similar example for a runtime error: </p><br><pre> <code class="plaintext hljs">ChakraCore ========== TypeError: Unable to get property 'Ч' of undefined or null reference at transliterate (russian-translit.js:929:4) -&gt; newCharValue = typeof charMapping[charValue] !== 'undefined' ? at Global code (Script Document:1:1) Jint ==== TypeError: charMapping is undefined at russian-translit.js:929:26 Jurassic ======== TypeError: undefined cannot be converted to an object at transliterate (russian-translit.js:929) at Global code (Script Document:1) MSIE в режиме Classic ===================== TypeError: 'undefined' is null or not an object at russian-translit.js:929:4 MSIE в режиме Chakra ActiveScript ================================= TypeError: Unable to get property 'Ч' of undefined or null reference at russian-translit.js:929:4 MSIE в режиме Chakra IE JsRT ============================ TypeError: Unable to get property 'Ч' of undefined or null reference at transliterate (russian-translit.js:929:4) at Global code (Script Document:1:1) MSIE в режиме Chakra Edge JsRT ============================== TypeError: Unable to get property 'Ч' of undefined or null reference at transliterate (russian-translit.js:929:4) at Global code (Script Document:1:1) NiL === TypeError: Can't get property "Ч" of "undefined" V8 == TypeError: Cannot read property 'Ч' of undefined at transliterate (russian-translit.js:929:37) -&gt; newCharValue = typeof charMapping[charValue] !== 'undefined' ? at Script Document:1:1 Vroom ===== TypeError: Cannot read property 'Ч' of undefined at russian-translit.js:929:37</code> </pre> <br><p>  From the examples it can be seen that some JS engines give us completely different error descriptions and column numbers, and not always we can get a complete set of error data, but even despite these shortcomings, the unified format gives us more information about the location of the error than original error messages. </p><br><h2>  Tips for deploying native builds </h2><br><p>  The main cause of errors when working with the second version of JavaScript Engine Switcher was that many developers forgot to install NuGet packages containing native assemblies for ChakraCore and V8 modules.  At one time, this <a href="https://github.com/reactjs/React.NET/issues/409">post</a> was even devoted to a <a href="https://github.com/reactjs/React.NET/issues/409">post in the ReactJS.NET bugtracker</a> (a <a href="https://habr.com/ru/post/339440/">Russian translation</a> is also available).  Now, this is mostly a bug for newbies who, for some reason, have not read the documentation. </p><br><p>  The authors of ReactJS.NET tried to minimize the number of such errors with the help of hints inside error messages, but the <a href="">not very successful implementation of</a> this approach led to <a href="https://github.com/reactjs/React.NET/issues/379">even more confusion</a> .  The idea of ​​the prompts was good, but it required a fundamentally different implementation, namely, the implementation of JS engines at the level of adapter modules.  In the new version of JavaScript Engine Switcher, such hints are added to the error message when wrapping <code>DllNotFoundException</code> and <code>TypeLoadException</code> exceptions into a <code>JsEngineLoadException</code> exception (see the implementation examples for <a href="">ChakraCore</a> , <a href="">V8,</a> and <a href="">Vroom</a> modules).  Moreover, these tips are intelligent, because  their generation takes into account a number of factors: the type of operating system, processor architecture and runtime (.NET Framework, .NET Core or Mono). </p><br><p>  For example, if you use the ChakraCore module without a native build in a 64-bit process on the Windows operating system, the error message will look like this: </p><br><blockquote>  Failed to create an instance of the ChakraCoreJsEngine.  Most likely it happened, because the dependencies were not found.  Try to install the JavaScriptEngineSwitcher.ChakraCore.Native.win-x64 package via NuGet.  In addition, you still need to install the Microsoft Visual C ++ Redistributable for Visual Studio 2017 ( <a href="https://www.visualstudio.com/downloads/">https://www.visualstudio.com/downloads/#microsoft-visual-c-redistributable-for-visual-studio-2017</a> ). </blockquote><br><p>  The error message prompts you to install the NuGet package JavaScriptEngineSwitcher.ChakraCore.Native.win-x64, and also mentions that ChakraCore for Windows requires a Microsoft Visual C ++ redistributable component for Visual Studio 2017 to work. If this error will occur in a 32-bit process, the user will be prompted to install the JavaScriptEngineSwitcher.ChakraCore.Native.win-x86 package. </p><br><p>  A similar error message on Linux in the .NET Core environment will look like this: </p><br><blockquote>  Failed to create an instance of the ChakraCoreJsEngine.  Most likely it happened, because of its dependencies was not found.  Try to install the JavaScriptEngineSwitcher.ChakraCore.Native.linux-x64 package via NuGet. </blockquote><br><p>  In this case, you will be prompted to install the JavaScriptEngineSwitcher.ChakraCore.Native.linux-x64 package. </p><br><p>  When launched in Mono, another hint will be displayed: </p><br><blockquote>  ... JavaScriptEngineSwitcher.ChakraCore.Native.linux- * package </blockquote><br><p>  Since the JavaScriptEngineSwitcher.ChakraCore.Native.linux-x64 package is only compatible with .NET Core, the prompt will link to instructions for manually deploying the native build in Linux. </p><br><p>  You can still give many examples, but this makes no sense. </p><br><h2>  Interrupting Script Execution </h2><br><p>  When we give users the ability to execute arbitrary JS code on the server, we face one very serious problem - we don’t know how long it will take to execute this code.  This may be a large amount of non-optimal code or a code that starts an infinite loop.  In any case, this will be code that we cannot control, which will consume our server resources indefinitely.  In order to somehow control this process, we need the ability to interrupt the execution of scripts.  When using engines written in pure .NET (for example, Jint, Jurassic or NiL.JS), we can always start executing JS-code as a task with the possibility of cancellation, but this approach will not work for other engines.  Fortunately for us, the engines written in C ++ have built-in mechanisms for interrupting scripts. </p><br><p>  To provide access to these mechanisms, the <code>SupportsScriptInterruption</code> property and the <code>Interrupt</code> method <code>IJsEngine</code> been added to the <code>IJsEngine</code> interface.  Since not all engines support this feature, you should always check the value of the <code>SupportsScriptInterruption</code> property before calling the <code>Interrupt</code> method (if you had to manually start the garbage collector in previous versions of JavaScript Engine Switcher, you will immediately understand what I am talking about): </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (engine.SupportsScriptInterruption) { engine.Interrupt(); }</code> </pre> <br><p>  Moreover, it is necessary to call this method in a separate thread other than the one in which the scripts are executed.  After calling the <code>Interrupt</code> method, all previously run <code>Evaluate</code> , <code>Execute*</code> and <code>CallFunction</code> will be completed by throwing a <code>JsInterruptedException</code> exception. </p><br><p>  Since this API is low-level, for the tasks described in the beginning of the section it is recommended to use extension methods like this: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> !NET40 using System.Runtime.ExceptionServices; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> using System.Threading; using System.Threading.Tasks; using JavaScriptEngineSwitcher.Core; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> NET40 using JavaScriptEngineSwitcher.Core.Extensions; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> using JavaScriptEngineSwitcher.Core.Resources; … /// &lt;summary&gt; /// Extension methods for &lt;see cref="IJsEngine"/&gt; /// &lt;/summary&gt; public static class JsEngineExtensions { /// &lt;summary&gt; /// Evaluates an expression within a specified time interval /// &lt;/summary&gt; /// &lt;typeparam name="T"&gt;Type of result&lt;/typeparam&gt; /// &lt;param name="engine"&gt;JS engine&lt;/param&gt; /// &lt;param name="expression"&gt;JS expression&lt;/param&gt; /// &lt;param name="timeoutInterval"&gt;Interval to wait before the /// script execution times out&lt;/param&gt; /// &lt;param name="documentName"&gt;Document name&lt;/param&gt; /// &lt;returns&gt;Result of the expression&lt;/returns&gt; /// &lt;exception cref="ObjectDisposedException"/&gt; /// &lt;exception cref="ArgumentNullException"/&gt; /// &lt;exception cref="ArgumentException"/&gt; /// &lt;exception cref="JsCompilationException"/&gt; /// &lt;exception cref="JsTimeoutException"/&gt; /// &lt;exception cref="JsRuntimeException"/&gt; /// &lt;exception cref="JsException"/&gt; public static T Evaluate&lt;T&gt;(this IJsEngine engine, string expression, TimeSpan timeoutInterval, string documentName) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (engine == null) { throw new ArgumentNullException(nameof(engine)); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (engine.SupportsScriptInterruption) { using (var timer = new Timer(state =&gt; engine.Interrupt(), null, timeoutInterval, #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> NET40 new TimeSpan(0, 0, 0, 0, -1))) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> Timeout.InfiniteTimeSpan)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> { try { return engine.Evaluate&lt;T&gt;(expression, documentName); } catch (JsInterruptedException e) { throw new JsTimeoutException( Strings.Runtime_ScriptTimeoutExceeded, e.EngineName, e.EngineVersion, e ); } } } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> NET40 Task&lt;T&gt; task = Task.Factory.StartNew(() =&gt; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> Task&lt;T&gt; task = Task.Run(() =&gt; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> { return engine.Evaluate&lt;T&gt;(expression, documentName); }); bool isCompletedSuccessfully = false; try { isCompletedSuccessfully = task.Wait(timeoutInterval); } catch (AggregateException e) { Exception innerException = e.InnerException; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (innerException != null) { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> NET40 innerException.PreserveStackTrace(); throw innerException; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> ExceptionDispatchInfo.Capture(innerException).Throw(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { throw; } } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (isCompletedSuccessfully) { return task.Result; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { throw new JsTimeoutException( Strings.Runtime_ScriptTimeoutExceeded, engine.Name, engine.Version ); } } } … } …</span></span></code> </pre> <br><p>  This method is an add-on over the <code>Evaluate&lt;T&gt;</code> engine method, which allows setting the timeout for the script execution using the <code>timeoutInterval</code> parameter.  The principle of this extension method is very simple.  First, we check if our engine supports the built-in interrupt mechanism.  If it <code>timeoutInterval</code> , then we create an instance of the <code>Timer</code> class, which, through the <code>timeoutInterval</code> parameter, starts the <code>Interrupt</code> method, then we call the <code>Evaluate&lt;T&gt;</code> engine method, and in case of an error, we catch the <code>JsInterruptedException</code> exception and wrap it in a <code>JsTimeoutException</code> .  If the engine does not support interrupts, then create an instance of the <code>Task</code> class that runs the <code>Evaluate&lt;T&gt;</code> engine method, then set the task timeout interval equal to the value from the <code>timeoutInterval</code> parameter, and if the task timed out, then throw an exception of type <code>JsTimeoutException</code> .  The following is an example of using this extension method: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; … <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> JavaScriptEngineSwitcher.Core; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> JavaScriptEngineSwitcher.Core.Helpers; … <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> expression = <span class="hljs-string"><span class="hljs-string">@"function getRandomInt(minValue, maxValue) { minValue = Math.ceil(minValue); maxValue = Math.floor(maxValue); return Math.floor(Math.random() * (maxValue - minValue + 1)) + minValue; } function sleep(millisecondsTimeout) { var totalMilliseconds = new Date().getTime() + millisecondsTimeout; while (new Date().getTime() &lt; totalMilliseconds) { } } var randomNumber = getRandomInt(1, 10); sleep(randomNumber * 1000); randomNumber;"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (IJsEngine engine = JsEngineSwitcher.Current.CreateDefaultEngine()) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = engine.Evaluate&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(expression, TimeSpan.FromSeconds(<span class="hljs-number"><span class="hljs-number">3</span></span>), <span class="hljs-string"><span class="hljs-string">"randomNumber.js"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"результат = {0}"</span></span>, result); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (JsTimeoutException) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Во время вычисления выражения JavaScript "</span></span> + <span class="hljs-string"><span class="hljs-string">"было превышено время ожидания!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (JsException e) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Во время работы JavaScript-движка произошла "</span></span> + <span class="hljs-string"><span class="hljs-string">"ошибка!"</span></span>); Console.WriteLine(); Console.WriteLine(JsErrorHelpers.GenerateErrorDetails(e)); } } } … } …</code> </pre> <br><p>  Using the extension method, we calculate the result of a JS expression.  The result of the expression is a random integer, and this number is also the number of seconds by which the execution of this expression is delayed.  Also, when calling the extension method, we specify a wait interval of 3 seconds.  Since the time to calculate the expression varies from 1 to 10 seconds, in one case the result of the expression will be displayed on the console, and in the other the message about waiting time is displayed. </p><br><p>  It should be easy for you to remake this extension method to call other methods of the engine (for example, under the <code>Execute*</code> , <code>CallFunction</code> or other overloaded versions of the <code>Evaluate</code> method).  While I have not yet decided whether I will add such extension methods to the library itself, because it is not yet clear how much they will be in demand. </p><br><h2>  Pre-compiling scripts </h2><br><p>  I was <a href="https://github.com/Taritsyn/JavaScriptEngineSwitcher/issues/10">asked to</a> add support for pre-compiling scripts <a href="https://github.com/Taritsyn/JavaScriptEngineSwitcher/issues/10">back in 2015</a> .  At that moment, it was not clear how such a function could fit into the concept of a unified interface.  But as time went on, support for special features such as garbage collection and script interruption began to appear in JavaScript Engine Switcher.  At the last stages of work on the third version, the turn reached the preliminary compilation. </p><br><p>  Using precompilation, you can compile the script once, and then use it many times to initialize the JS engines.  Due to the fact that the pre-compiled script does not require syntactic analysis, the initialization of the engines will be faster. </p><br><p>  At the moment, 5 modules-adapters support preliminary compilation: ChakraCore, Jint, Jurassic, MSIE (only in JsRT-modes) and V8.  To provide access to the corresponding engine mechanisms, the <code>SupportsScriptPrecompilation</code> property and 3 new methods were added to the <code>IJsEngine</code> interface: <code>Precompile</code> , <code>PrecompileFile</code> and <code>PrecompileResource</code> .  <code>Precompile*</code> methods return an instance of an object that implements the <code>IPrecompiledScript</code> interface.  This object is a pre-compiled script that can be used by different instances of engines (for these purposes serves as an overloaded version of the <code>Execute</code> method).  Consider a simple example of using this API: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; … <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> JavaScriptEngineSwitcher.Core; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> JavaScriptEngineSwitcher.Core.Helpers; … <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> sourceCode = <span class="hljs-string"><span class="hljs-string">@"function declinationOfSeconds(number) { var result, titles = ['секунда', 'секунды', 'секунд'], titleIndex, cases = [2, 0, 1, 1, 1, 2], caseIndex ; if (number % 100 &gt; 4 &amp;&amp; number % 100 &lt; 20) { titleIndex = 2; } else { caseIndex = number % 10 &lt; 5 ? number % 10 : 5; titleIndex = cases[caseIndex]; } result = number + ' ' + titles[titleIndex]; return result; }"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> functionName = <span class="hljs-string"><span class="hljs-string">"declinationOfSeconds"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> itemCount = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] inputSeconds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[itemCount] { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-number"><span class="hljs-number">600</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] outputStrings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[itemCount]; IJsEngineSwitcher engineSwitcher = JsEngineSwitcher.Current; IPrecompiledScript precompiledCode = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> engine = engineSwitcher.CreateDefaultEngine()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!engine.SupportsScriptPrecompilation) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"{0} версии {1} не поддерживает "</span></span> + <span class="hljs-string"><span class="hljs-string">"предварительную компиляцию скриптов!"</span></span>, engine.Name, engine.Version); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { precompiledCode = engine.Precompile(sourceCode, <span class="hljs-string"><span class="hljs-string">"declinationOfSeconds.js"</span></span>); engine.Execute(precompiledCode); outputStrings[<span class="hljs-number"><span class="hljs-number">0</span></span>] = engine.CallFunction&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(functionName, inputSeconds[<span class="hljs-number"><span class="hljs-number">0</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (JsCompilationException e) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Во время предварительной компиляции скрипта "</span></span> + <span class="hljs-string"><span class="hljs-string">"произошла ошибка!"</span></span>); Console.WriteLine(); Console.WriteLine(JsErrorHelpers.GenerateErrorDetails(e)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (JsException e) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Во время работы JavaScript-движка произошла "</span></span> + <span class="hljs-string"><span class="hljs-string">"ошибка!"</span></span>); Console.WriteLine(); Console.WriteLine(JsErrorHelpers.GenerateErrorDetails(e)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> itemIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; itemIndex &lt; itemCount; itemIndex++) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> engine = engineSwitcher.CreateDefaultEngine()) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { engine.Execute(precompiledCode); outputStrings[itemIndex] = engine.CallFunction&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;( functionName, inputSeconds[itemIndex]); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (JsException e) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Во время работы JavaScript-движка "</span></span> + <span class="hljs-string"><span class="hljs-string">"произошла ошибка!"</span></span>); Console.WriteLine(); Console.WriteLine(JsErrorHelpers.GenerateErrorDetails(e)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> itemIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; itemIndex &lt; itemCount; itemIndex++) { Console.WriteLine(outputStrings[itemIndex]); } } … } …</code> </pre> <br><p> Сначала мы создаем движок, с помощью которого скомпилируем код функции для склонения числительных. После чего используем свойство <code>SupportsScriptPrecompilation</code> для того, чтобы проверить поддерживает ли движок предварительную компиляцию, если нет, то информируем об этом пользователя. Затем с помощью метода <code>Precompile</code> компилируем скрипт, если код скрипта содержит синтаксические ошибки, то будет выброшено исключения типа <code>JsCompilationException</code> . C помощью метода <code>Execute</code> загружаем скомпилированный скрипт в память движка, т.е. производим его инициализацию. Затем с помощью метода <code>CallFunction</code> вызываем функцию <code>declinationOfSeconds</code> и сохраняем полученный результат в массив. После чего происходит уничтожение движка. Несмотря на то, что движок был уничтожен, скомпилированный им скрипт продолжает существовать и может быть использован другими движками. Далее мы создаем еще 3 движка и каждый из них инициализируем скомпилированным скриптом. После инициализации, как и в случае с самым первым движком, вызываем функцию и сохраняем ее результат в массив. В конце примера выводим содержимое этого массива на экран, чтобы удостовериться в том, что инициализация движков прошла без ошибок. </p><br><p> Предыдущий пример хоть и наглядно показывает, как можно использовать предварительную компиляцию, но является немного искусственным. В реальных проектах, скорее всего, вы будете использовать пулинг движков и хранить скомпилированные скрипты в кэше. Именно такой подход используется в проекте ReactJS.NET. Пулинг движков там реализован с помощью библиотеки <a href="https://github.com/Daniel15/JSPool">JSPool</a> , а выбор реализации кэша зависит от используемого фреймворка ( <code>System.Runtime.Caching.MemoryCache</code> для .NET Framework 4.X, <code>System.Web.Caching.Cache</code> для ASP.NET 4.X и <code>Microsoft.Extensions.Caching.Memory.IMemoryCache</code> для ASP.NET Core). Не буду вдаваться в детали реализации, потому что это займет слишком много времени (при желании вы всегда можете ознакомиться с <a href="">исходным кодом</a> ). Лучше вместо этого рассмотрим, как использовать предварительную компиляцию скриптов в ReactJS.NET. </p><br><p> По умолчанию предварительная компиляция в ReactJS.NET отключена. Поскольку эта возможность пока считается экспериментальный и еще не применялась на реальных высоконагруженных сайтах. Чтобы ее включить нужно присвоить конфигурационному свойству <code>AllowJavaScriptPrecompilation</code> значение равное <code>true</code> . </p><br><p> В ASP.NET 4.X для этого вам нужно отредактировать файл <code>App_Start/ReactConfig.cs</code> : </p><br><pre> <code class="cs hljs">… <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ReactConfig</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configure</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ReactSiteConfiguration.Configuration … .SetAllowJavaScriptPrecompilation(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) … ; … } } …</code> </pre> <br><p> В ASP.NET Core эта настройка производится в файле <code>Startup.cs</code> : </p><br><pre> <code class="cs hljs">… <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Startup</span></span> { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configure</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IApplicationBuilder app, IHostingEnvironment env</span></span></span><span class="hljs-function">)</span></span> { … app.UseReact(config =&gt; { config … .SetAllowJavaScriptPrecompilation(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) … ; }); app.UseStaticFiles(); … } } …</code> </pre> <br><p> В конце раздела я хочу показать вам, как предварительная компиляция влияет на производительность. В качестве примера рассмотрим результаты бенчмарка <a href="">JsExecutionBenchmark</a> , реализованного средствами библиотеки <a href="https://github.com/dotnet/BenchmarkDotNet">BenchmarkDotNet</a> . В качестве исполняемого скрипта здесь используется небольшая JS-библиотека для транслитерации русского текста латиницей. Весит она всего 14,9 Кбайт, но этого нам будет достаточно, чтобы увидеть эффект от применения предварительной компиляции. Во время тестирования использовалась последняя на текущий момент версия JavaScript Engine Switcher (версия 3.0.4). </p><br><p> Начнем с результатов, полученных при запуске в среде .NET Framework 4.7.2: </p><br><table><thead><tr><th align="left"> <sup>Название модуля</sup> </th><th align="left"> <sup>Предварит. компиляция</sup> </th><th align="left"> <sup>Средняя продолжит. выполнения</sup> </th><th align="left"> <sup>Gen 0 на тыс. опер.</sup> </th><th align="left"> <sup>Gen 1 на тыс. опер.</sup> </th><th align="left"> <sup>Gen 2 на тыс. опер.</sup> </th><th align="left"> <sup>Выделение памяти на одну опер.</sup> </th></tr></thead><tbody><tr><td rowspan="2"> <sup>ChakraCore</sup> </td><td>  <sup>Not</sup> </td><td align="right"> <sup>41,72 мс</sup> </td><td align="center">  <sup>-</sup> </td><td align="center">  <sup>-</sup> </td><td align="center">  <sup>-</sup> </td><td align="right"> <sup>74,46 Кб</sup> </td></tr><tr><td>  <sup>Yes</sup> </td><td align="right"> <sup>35,07 мс</sup> </td><td align="center">  <sup>-</sup> </td><td align="center">  <sup>-</sup> </td><td align="center">  <sup>-</sup> </td><td align="right"> <sup>91,79 Кб</sup> </td></tr><tr><td rowspan="2"> <sup>Jint</sup> </td><td>  <sup>Not</sup> </td><td align="right"> <sup>27,19 мс</sup> </td><td align="right"> <sup>2 812,50</sup> </td><td align="right"> <sup>1 343,75</sup> </td><td align="center">  <sup>-</sup> </td><td align="right"> <sup>16 374,58 Кб</sup> </td></tr><tr><td>  <sup>Yes</sup> </td><td align="right"> <sup>15,54 мс</sup> </td><td align="right"> <sup>1 296,88</sup> </td><td align="right"> <sup>640,63</sup> </td><td align="right"> <sup>31,25</sup> </td><td align="right"> <sup>7 521,49 Кб</sup> </td></tr><tr><td rowspan="2"> <sup>Jurassic</sup> </td><td>  <sup>Not</sup> </td><td align="right"> <sup>455,70 мс</sup> </td><td align="right"> <sup>2 000,00</sup> </td><td align="right"> <sup>1 000,00</sup> </td><td align="center">  <sup>-</sup> </td><td align="right"> <sup>15 575,28 Кб</sup> </td></tr><tr><td>  <sup>Yes</sup> </td><td align="right"> <sup>78,70 мс</sup> </td><td align="right"> <sup>1 000,00</sup> </td><td align="center">  <sup>-</sup> </td><td align="center">  <sup>-</sup> </td><td align="right"> <sup>7 892,94 Кб</sup> </td></tr><tr><td rowspan="2"> <sup>MSIE в режиме Chakra IE JsRT</sup> </td><td>  <sup>Not</sup> </td><td align="right"> <sup>30,97 мс</sup> </td><td align="center">  <sup>-</sup> </td><td align="center">  <sup>-</sup> </td><td align="center">  <sup>-</sup> </td><td align="right"> <sup>77,75 Кб</sup> </td></tr><tr><td>  <sup>Yes</sup> </td><td align="right"> <sup>24,40 мс</sup> </td><td align="center">  <sup>-</sup> </td><td align="center">  <sup>-</sup> </td><td align="center">  <sup>-</sup> </td><td align="right"> <sup>90,58 Кб</sup> </td></tr><tr><td rowspan="2"> <sup>MSIE в режиме Chakra Edge JsRT</sup> </td><td>  <sup>Not</sup> </td><td align="right"> <sup>33,14 мс</sup> </td><td align="center">  <sup>-</sup> </td><td align="center">  <sup>-</sup> </td><td align="center">  <sup>-</sup> </td><td align="right"> <sup>78,40 Кб</sup> </td></tr><tr><td>  <sup>Yes</sup> </td><td align="right"> <sup>32,86 мс</sup> </td><td align="center">  <sup>-</sup> </td><td align="center">  <sup>-</sup> </td><td align="center">  <sup>-</sup> </td><td align="right"> <sup>95,48 Кб</sup> </td></tr><tr><td rowspan="2"> <sup>V8</sup> </td><td>  <sup>Not</sup> </td><td align="right"> <sup>41,10 мс</sup> </td><td align="center">  <sup>-</sup> </td><td align="center">  <sup>-</sup> </td><td align="center">  <sup>-</sup> </td><td align="right"> <sup>79,33 Кб</sup> </td></tr><tr><td>  <sup>Yes</sup> </td><td align="right"> <sup>39,25 мс</sup> </td><td align="center">  <sup>-</sup> </td><td align="center">  <sup>-</sup> </td><td align="center">  <sup>-</sup> </td><td align="right"> <sup>96,17 Кб</sup> </td></tr></tbody></table><br><p> Наибольший выигрыш в процентном выражении мы получаем для движков, написанных на чистом .NET — скорость выполнения скрипта на Jurassic вырастает 5,79 раз, а на Jint в 1,75 разa. При работе этих движков в 2 раза сокращается объем выделяемой памяти, и соответственно более чем в 2 раза сокращается количество операций по сборке мусора. За счет снижения количества операций по сборке мусора мы получаем частичный прирост в скорости выполнения скрипта. Главная причина прироста скорости в Jurassic, также является и причиной его наихудшего результата в этом тесте: Jurassic всегда компилирует JS-код в IL-код средствами Reflection.Emit, а затем исполняет его. Именно на этапе компиляции происходит основная потеря производительности, а поскольку при предварительной компиляции это происходит всего один раз, мы и получаем выигрыш в производительности. Jint же наоборот является интерпретатором и в результате предварительной компиляции возвращает .NET-объект, представляющий абстрактное синтаксическое дерево. В случае с Jint мы экономим ресурс за счет того, что производим всего одну операцию синтаксического разбора и храним в памяти одно АСД. По результатам данного теста можно подумать, что Jint является самым быстрым движком, но это не так, потому что по мере роста объема выполняемого кода его производительность будет падать. Вообще Jint и Jurassic показывают наихудшие результаты при обработке больших объемов кода. </p><br><p> Лучший результат среди оберток над движками, написанными на C++, показывает MSIE в режиме Chakra IE JsRT — скорость выполнения увеличивается на 26,93%. После него идет ChakraCore (18,96%), потом V8 (4,71%) и MSIE в режиме Chakra Edge JsRT показывает худший результат (0,85%). Для меня до сих пор остается загадкой почему движок из Internet Explorer оказался быстрее движка Edge. Вообще столь скромные результаты для данного типа движков можно объяснить следующим образом. Мы получаем скомпилированный скрипт от движка в сериализованном виде (в виде массива байт) и сохраняем его в управляемой памяти. Вы можете заметить, что в последнем столбце таблицы из-за появления этого массива увеличился объем выделяемой памяти на 12-17 Кбайт (в этом тесте мы измеряем только управляемую память). При инициализации движка скомпилированным скриптом производится десериализация этого массива. Также добавьте к этому затраты на маршалинг. Тем не менее выигрыш в производительности все равно ощутим. </p><br><p> Запуск тестов в среде .NET Core 2.0 дает следующие результаты (модуль V8 отсутствует, потому что библиотека Microsoft ClearScript, на которой он основан, не поддерживает .NET Core): </p><br><table><thead><tr><th align="left"> <sup>Название модуля</sup> </th><th align="left"> <sup>Предварит. компиляция</sup> </th><th align="left"> <sup>Средняя продолжит. выполнения</sup> </th><th align="left"> <sup>Gen 0 на тыс. опер.</sup> </th><th align="left"> <sup>Gen 1 на тыс. опер.</sup> </th><th align="left"> <sup>Gen 2 на тыс. опер.</sup> </th><th align="left"> <sup>Выделение памяти на одну опер.</sup> </th></tr></thead><tbody><tr><td rowspan="2"> <sup>ChakraCore</sup> </td><td>  <sup>Not</sup> </td><td align="right"> <sup>43,65 мс</sup> </td><td align="center">  <sup>-</sup> </td><td align="center">  <sup>-</sup> </td><td align="center">  <sup>-</sup> </td><td align="right"> <sup>18,07 Кб</sup> </td></tr><tr><td>  <sup>Yes</sup> </td><td align="right"> <sup>36,37 мс</sup> </td><td align="center">  <sup>-</sup> </td><td align="center">  <sup>-</sup> </td><td align="center">  <sup>-</sup> </td><td align="right"> <sup>16,59 Кб</sup> </td></tr><tr><td rowspan="2"> <sup>Jint</sup> </td><td>  <sup>Not</sup> </td><td align="right"> <sup>24,87 мс</sup> </td><td align="right"> <sup>2 750,00</sup> </td><td align="right"> <sup>1 375,00</sup> </td><td align="center">  <sup>-</sup> </td><td align="right"> <sup>16 300,25 Кб</sup> </td></tr><tr><td>  <sup>Yes</sup> </td><td align="right"> <sup>15,25 мс</sup> </td><td align="right"> <sup>1 281,25</sup> </td><td align="right"> <sup>593,75</sup> </td><td align="right"> <sup>62,50</sup> </td><td align="right"> <sup>7 447,44 Кб</sup> </td></tr><tr><td rowspan="2"> <sup>Jurassic</sup> </td><td>  <sup>Not</sup> </td><td align="right"> <sup>469,97 мс</sup> </td><td align="right"> <sup>2 000,00</sup> </td><td align="right"> <sup>1 000,00</sup> </td><td align="center">  <sup>-</sup> </td><td align="right"> <sup>15 511,70 Кб</sup> </td></tr><tr><td>  <sup>Yes</sup> </td><td align="right"> <sup>80,72 мс</sup> </td><td align="right"> <sup>1 000,00</sup> </td><td align="center">  <sup>-</sup> </td><td align="center">  <sup>-</sup> </td><td align="right"> <sup>7 845,98 Кб</sup> </td></tr><tr><td rowspan="2"> <sup>MSIE в режиме Chakra IE JsRT</sup> </td><td>  <sup>Not</sup> </td><td align="right"> <sup>31,50 мс</sup> </td><td align="center">  <sup>-</sup> </td><td align="center">  <sup>-</sup> </td><td align="center">  <sup>-</sup> </td><td align="right"> <sup>20,28 Кб</sup> </td></tr><tr><td>  <sup>Yes</sup> </td><td align="right"> <sup>24,52 мс</sup> </td><td align="center">  <sup>-</sup> </td><td align="center">  <sup>-</sup> </td><td align="center">  <sup>-</sup> </td><td align="right"> <sup>18,78 Кб</sup> </td></tr><tr><td rowspan="2"> <sup>MSIE в режиме Chakra Edge JsRT</sup> </td><td>  <sup>Not</sup> </td><td align="right"> <sup>35,54 мс</sup> </td><td align="center">  <sup>-</sup> </td><td align="center">  <sup>-</sup> </td><td align="center">  <sup>-</sup> </td><td align="right"> <sup>20,45 Кб</sup> </td></tr><tr><td>  <sup>Yes</sup> </td><td align="right"> <sup>31,44 мс</sup> </td><td align="center">  <sup>-</sup> </td><td align="center">  <sup>-</sup> </td><td align="center">  <sup>-</sup> </td><td align="right"> <sup>18,99 Кб</sup> </td></tr></tbody></table><br><p> В целом мы получили похожие результаты. Единственное, что бросается в глаза — результат MSIE в режиме Chakra Edge JsRT улучшился (7,69%). Также в данном случае при использовании предварительной компиляции движками семейства Chakra снижается потребление управляемой памяти. </p><br><h2> Возможность изменения максимального размера стека в модулях ChakraCore и MSIE </h2><br><p> Размер стека в движках, разработанных Microsoft, ограничивается размером стека потока, в котором выполняется движок. Поскольку в современных версиях IIS он достаточно мал (256 Кбайт для 32-разрядной версии и 512 Кбайт для 64-разрядной), то при запуске в ASP.NET больших JS-библиотек (например, компилятора TypeScript) происходит переполнение стека. Эта проблема уже давно решается в JavaScript Engine Switcher путем создания отдельного потока для выполнения этих движков. Раньше при создании таких потоков размер стека был жестко закодирован в исходном коде, и совпадал с максимальным размером стека в Node.js (492 Кбайт для 32-разрядного процесса и 984 Кбайт для 64-разрядного). Со временем выяснилось, что не всем хватает такого размера, а кто-то наоборот хочет его уменьшить. Поэтому в третьей версии в настройки модулей ChakraCore и MSIE была добавлена опция <code>MaxStackSize</code> , с помощью которой вы можете задать размер стека в байтах. По умолчанию используется то же значение в стиле Node.js. Если присвоить этому свойству значение равное нулю, то в качестве максимального размера стека будет использоваться значение из заголовка исполняемого файла. </p><br><h2> Новый модуль на основе NiL.JS </h2><br><p> В третьей версии появился новый модуль-адаптер <a href="https://github.com/Taritsyn/JavaScriptEngineSwitcher/wiki/NiL">NiL</a> , который создан на основе движка <a href="">NiL.JS</a> . NiL.JS — это еще один JS-движок, написанный на чистом .NET. Его первая версии вышла в 2014 году, но он не получил такую популярность как Jurassic и Jint. Его основное достоинство — это производительность. В качестве примера можно привести результаты того же бенчмарка, что использовался в разделе про предварительную компиляцию. </p><br><p> При запуске в среде .NET Framework 4.7.2 мы получим следующие результаты: </p><br><table><thead><tr><th align="left"> <sup>Название модуля</sup> </th><th align="left"> <sup>Средняя продолжит. выполнения</sup> </th><th align="left"> <sup>Gen 0 на тыс. опер.</sup> </th><th align="left"> <sup>Gen 1 на тыс. опер.</sup> </th><th align="left"> <sup>Gen 2 на тыс. опер.</sup> </th><th align="left"> <sup>Выделение памяти на одну опер.</sup> </th></tr></thead><tbody><tr><td> <sup>Jint</sup> </td><td align="right"> <sup>27,19 мс</sup> </td><td align="right"> <sup>2 812,50</sup> </td><td align="right"> <sup>1 343,75</sup> </td><td align="center">  <sup>-</sup> </td><td align="right"> <sup>16 374,58 Кб</sup> </td></tr><tr><td> <sup>Jurassic</sup> </td><td align="right"> <sup>455,70 мс</sup> </td><td align="right"> <sup>2 000,00</sup> </td><td align="right"> <sup>1 000,00</sup> </td><td align="center">  <sup>-</sup> </td><td align="right"> <sup>15 575,28 Кб</sup> </td></tr><tr><td> <sup>NiL</sup> </td><td align="right"> <sup>17,80 мс</sup> </td><td align="right"> <sup>1 000,00</sup> </td><td align="center">  <sup>-</sup> </td><td align="center">  <sup>-</sup> </td><td align="right"> <sup>4 424,09 Кб</sup> </td></tr></tbody></table><br><p> Результаты запуска в среде .NET Core 2.0 отличаются незначительно: </p><br><table><thead><tr><th align="left"> <sup>Название модуля</sup> </th><th align="left"> <sup>Средняя продолжит. выполнения</sup> </th><th align="left"> <sup>Gen 0 на тыс. опер.</sup> </th><th align="left"> <sup>Gen 1 на тыс. опер.</sup> </th><th align="left"> <sup>Gen 2 на тыс. опер.</sup> </th><th align="left"> <sup>Выделение памяти на одну опер.</sup> </th></tr></thead><tbody><tr><td> <sup>Jint</sup> </td><td align="right"> <sup>24,87 мс</sup> </td><td align="right"> <sup>2 750,00</sup> </td><td align="right"> <sup>1 375,00</sup> </td><td align="center">  <sup>-</sup> </td><td align="right"> <sup>16 300,25 Кб</sup> </td></tr><tr><td> <sup>Jurassic</sup> </td><td align="right"> <sup>469,97 мс</sup> </td><td align="right"> <sup>2 000,00</sup> </td><td align="right"> <sup>1 000,00</sup> </td><td align="center">  <sup>-</sup> </td><td align="right"> <sup>15 511,70 Кб</sup> </td></tr><tr><td> <sup>NiL</sup> </td><td align="right"> <sup>19,67 мс</sup> </td><td align="right"> <sup>1 000,00</sup> </td><td align="center">  <sup>-</sup> </td><td align="center">  <sup>-</sup> </td><td align="right"> <sup>4 419,95 Кб</sup> </td></tr></tbody></table><br><p> Результаты этих тестов можно даже не комментировать. Такие впечатляющие результаты были получены благодаря нестандартным решениям, которые использовал его автор (подробности вы можете узнать из <a href="https://habr.com/ru/users/iaiojek/posts/">его статей на Хабре</a> ). Стоит также заметить, что авторы Jint тоже не сидели сложа руки и с 2016 года работают над третьей версией своего движка, одной из задач которой является повышение производительности. Если верить <a href="">бенчмарку для версии 3.0.0 Beta 1353</a> , то предварительная версия Jint выполняет скрипты в 2,4 раза быстрее, чем NiL.JS версии 2.5.1200, и показатели использования памяти у них практически совпадают. </p><br><p> Есть у NiL.JS и недостатки. Все идет хорошо пока мы выполняем на нем какой-то простой код, но когда мы пытаемся запустить какие-нибудь популярные библиотеки, то начинают возникать ошибки. Из всех модулей Bundle Transformer, использующих JavaScript Engine Switcher, мне удалось запустить только Hogan и Handlebars, та же ситуация и с ReactJS.NET. В ближайшее время я собираюсь задокументировать все эти ошибки и передать их автору NiL.JS. </p><br><h2>  Links </h2><br><ol><li> Страница проекта <a href="https://github.com/Taritsyn/JavaScriptEngineSwitcher">JavaScript Engine Switcher</a> на GitHub </li><li> <a href="https://github.com/Taritsyn/JavaScriptEngineSwitcher/wiki">Документация JavaScript Engine Switcher</a> </li><li> Перевод моего поста <a href="https://habr.com/ru/post/339440/">«Заблуждения о JavaScript Engine Switcher 2.X»</a> </li><li> Страница проекта <a href="https://github.com/Daniel15/JSPool">JSPool</a> на GitHub </li><li> <a href="https://reactjs.net/">Сайт проекта ReactJS.NET</a> </li><li> Страница проекта <a href="">ReactJS.NET</a> на GitHub </li></ol><br></div>