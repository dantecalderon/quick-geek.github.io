<div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/px/9h/mg/px9hmgqrpebneeamcitvv8b_wkw.jpeg"><br><br>  Six months ago, we presented one of the most impressive features of Badoo - <a href="http://badoo.live/">live broadcasts</a> .  Among other things, it allows users to express gratitude to their favorite streamers in the form of gifts.  We wanted to make these gifts as bright and attractive as possible, so we decided to animate them - in other words, to animate.  And to make it even more interesting, we planned to update the gifts and animations every few weeks. <br><br>  iOS engineers have probably guessed how much work we are talking about: to remove old ones and add new animations, you need to perform a lot of actions from the client side.  To do this, each release must have Android and iOS commands involved, and together with the time required to approve the update in the App Store, this means that each release with updated animations can take several days to launch.  However, we managed to solve this problem, and now I will tell you how. <br><br><h1>  Solution Architecture </h1><br>  By that time, we were already able to <a href="https://badootech.badoo.com/behind-the-scenes-with-importing-adobe-after-effects-animation-into-badoo-ios-app-45a21e2ba1e4">export Adobe After Effects animations (hereinafter referred to as AAE) in a format that our iOS application can understand</a> using the Lottie library.  This time we went a little further: we decided to keep all the current animations on the server and download them as needed. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/wq/tz/6w/wqtz6w0lgzbjm1eq5bvcshngnxw.png"><br><br>  An example of a real animation in our application, obtained in this way: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pe/3s/qo/pe3sqoahuswtkbfqd4wl-opzv8m.gif" width="250"></div><br><br>  However, in this post, as an example, I will take a simple animation that I created myself.  It is not as creative as in Badoo, but it is quite suitable for demonstrating our approach. <br><br><h1>  Export animations </h1><br>  The AAE project that I use can be found along with <a href="https://github.com/chupakabr/server-provided-animations">other sources on GitHub</a> .  So, opening a project located at <code>_raw/animations/Fancy/Fancy.aep</code> , you will see a window: <br><br><img src="https://habrastorage.org/webt/_k/hz/os/_khzosjwwyiiysdwfdon6iqjz10.png"><br><br>  Now I’ll talk not about the process of creating animations in AAE, but about how to import existing animations from AAE into a suitable format for an iOS application using the <a href="https://airbnb.io/lottie/after-effects/bodymovin-installation.html">Bodymovin</a> plugin. <br><br>  After installing the plugin, open it by selecting <i>Window / Extensions / Bodymovin from the menu</i> : <br><br><img src="https://habrastorage.org/webt/jq/3d/rw/jq3drw28ghwylkqidrecb78r9p4.png"><br><br>  The Bodymovin window will appear, in which you can select an animation for export, a folder for saving the resulting file and open the export settings: <br><br><img src="https://habrastorage.org/webt/iy/th/yl/iythylsx8lylzanrfavxmtn7u64.png"><br><br>  In the animation settings, we can ask Bodymovin to include resources in the JSON file by selecting <i>Assets / Include in json</i> : <br><br><img src="https://habrastorage.org/webt/c8/8v/od/c88vodmi3cksysyvdfg-89qqwby.png"><br><br>  Finally, by pressing the <i>Render</i> button, we export and save the selected animated composition to a file. <br><br><h1>  Storing animations on the server </h1><br>  Suppose we upload JSON-files of rendered animations to a web server.  In our case, for simplicity, I put them in a project repository on GitHub.  Animations are available here: <br><br><ul><li>  <a href="">Clouds</a> </li><li>  <a href="">Fireworks</a> </li></ul><br><br>  Basic link <a href="https://raw.githubusercontent.com/chupakabr/server-provided-animations/master/_raw/rendered-animations/">https://raw.githubusercontent.com/chupakabr/server-provided-animations/master/_raw/rendered-animations/</a> <br><br>  Animation IDs: <br><br><ul><li> <code>clouds.json</code> <br> </li><li> <code>fireworks.json</code> <br> </li></ul><br><br><blockquote>  Note: Looking for a Swift-written web server for animations?  The solution is available <a href="https://github.com/chupakabr/server-provided-animations/tree/master/Server">here</a> , and a detailed explanation is <a href="https://medium.com/%40myltik/rest-api-with-swift-on-vapor-fca5ea6667f">in this article</a> . </blockquote><br><br>  So, we have a working server with animations, and therefore it's time to go to the most exciting part: rendering animations on the screen. <br><br><h1>  Display animations </h1><br>  Now I advise you to open a <a href="https://github.com/chupakabr/server-provided-animations/tree/master/Client">demo</a> project for <a href="https://github.com/chupakabr/server-provided-animations/tree/master/Client">our iOS application</a> , as it contains all the necessary code and settings. <br><br><h2>  Loading animations </h2><br>  Considering that the REST API for getting data is already ready, it's time to enter the data provider protocol and add its implementation, which downloads data from the server: <br><br><pre> <code class="plaintext hljs">import Lottie protocol AnimationsProviderProtocol {   typealias Completion = (_ animation: LOTComposition?) -&gt; Void   func loadAnimation(byId id: String, completion: @escaping Completion) } final class ServerAnimationProvider: AnimationsProviderProtocol {   private let endpoint: URL   init(endpoint: URL) {       self.endpoint = endpoint   }   func loadAnimation(byId id: String, completion: @escaping Completion) {       let path = "/\(id).json"       guard let animationUrl = URL(string: path, relativeTo: self.endpoint) else {           completion(nil)           return       }       URLSession.shared.invalidateAndCancel()       let task = URLSession.shared.dataTask(with: animationUrl) { (data, response, error) in           guard error == nil, let data = data, let json = self.parseJson(from: data) else {               completion(nil)               return           }           let animation = LOTComposition(json: json)           completion(animation)       }       task.resume()   }   private func parseJson(from data: Data?) -&gt; [AnyHashable : Any]? {       guard let data = data else { return nil }       do {           let json = try JSONSerialization.jsonObject(with: data, options: []) as? [AnyHashable : Any]           return json       } catch {           return nil       }   } }</code> </pre> <br><br>  This data provider class allows us to load animations in JSON format from a server on demand and store them in memory for drawing on the UI.  Suppose we follow the MVVM pattern, then it is easy to use it in the <code>ViewModel</code> entity as follows: <br><br><pre> <code class="plaintext hljs"> // ... private let animationProvider: AnimationsProviderProtocol private(set) var animationModel: LOTComposition? // … func loadAnimation(byId animationId: String) {     self.animationProvider.loadAnimation(byId: animationId) { [weak self] (animationModel) in         self?.animationModel = animationModel     } } // ...</code> </pre> <br><br>  <code>ViewModel</code> updates the property of the selected animation when it receives a valid HTTP response from a server with a non-empty JSON object.  This data is used by the presentation layer to render the animation. <br><br><h2>  Presentation layer </h2><br>  Now we can use the <code>ViewModel</code> to access the animation data and display it on the UI using the on tap built-in handler attached to the button: <br><br><pre> <code class="plaintext hljs">class ViewController: UIViewController {   // ...   @IBOutlet weak var animationContainer: UIView!   override func viewDidLoad() {       super.viewDidLoad()       // ...       self.animationView = {           let view = LOTAnimationView(frame: self.animationContainer.bounds)           self.animationContainer.addSubview(view)           return view       }()   }   @IBAction func onPlayAnimationAction(_ sender: Any) {       self.animationView.stop()       self.animationView.sceneModel = self.viewModel.animationModel       self.animationView.play()   } }</code> </pre> <br><br>  When you click on a button, the LOTAnimationView instance is updated with the latest data from the <code>ViewModel</code> . <br><br>  Here's what it looks like: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rn/3d/qq/rn3dqqo6ueg3tfye-tmh9rlhove.png" width="250"></div><br><br>  That's all.  The application now displays animation loaded from our REST API. <br>  (from server). <br><br><h1>  Tips and limitations </h1><br>  Tricks: <br><br><ul><li>  AAE supports most types of objects, including raster and vector images; </li><li>  Bodymovin allows you to embed all resources into the final JSON file using Base64, and thus you can avoid loading resources separately on the client side; </li><li>  You can either draw directly into AAE vector or simply import Adobe Illustrator vector images. </li></ul><br>  Unfortunately, I could not import SVG files into AAE (I tried!). <br><br>  You can learn more about tricks and solving possible problems from this <a href="https://badootech.badoo.com/behind-the-scenes-with-importing-adobe-after-effects-animation-into-badoo-ios-app-45a21e2ba1e4">interesting article by</a> my colleague <a href="https://badootech.badoo.com/behind-the-scenes-with-importing-adobe-after-effects-animation-into-badoo-ios-app-45a21e2ba1e4">Radoslaw Sesiva</a> . <br><br><h1>  Conclusion </h1><br>  So, what gives us the download animations from the server?  The most obvious advantage of this approach is the ability to separate all participants in the animation update process.  In other words, in order to release a new cool animation, designers simply need to provide the server team with the appropriate JSON file.  To remove the animation on the client, simply remove it from the server.  Easy and fast. <br><br>  It is also very cool that the same functions can be implemented on all supported platforms (iOS, Android, Web) without making changes to the client-server protocol, server code and animation files directly on the client. <br><br>  That's all.  Thanks for attention! <br><hr><br><h3>  useful links </h3><br><ul><li>  " <a href="https://badootech.badoo.com/behind-the-scenes-with-importing-adobe-after-effects-animation-into-badoo-ios-app-45a21e2ba1e4">Behind the scenes with the Adobe Adobe</a> <a href="https://medium.com/%40radekcieciwa">Flash</a> <a href="https://badootech.badoo.com/behind-the-scenes-with-importing-adobe-after-effects-animation-into-badoo-ios-app-45a21e2ba1e4">After Effects animation into the Badoo iOS app</a> " by <a href="https://medium.com/%40radekcieciwa">Radoslaw Cieciwa</a> ; </li><li>  <a href="">Bodymovin plugin for AAE</a> by <a href="https://medium.com/%40airbnbeng">AirbnbEng</a> ; </li><li>  The project is entirely available <a href="https://github.com/chupakabr/server-provided-animations">here on GitHub</a> ; </li><li>  <a href="https://airbnb.io/lottie/after-effects/bodymovin-installation.html">Installing bodymovin plugin for AAE</a> by <a href="https://medium.com/%40airbnbeng">AirbnbEng</a> ; </li><li>  <a href="https://github.com/airbnb/lottie-ios">Lottie iOS library</a> <a href="https://medium.com/%40airbnbeng">AirbnbEng</a> ; </li><li>  " <a href="https://medium.com/%40myltik/rest-api-with-swift-on-vapor-fca5ea6667f">REST API with Swift on Vapor</a> " <a href="https://github.com/chupakabr">Valery Chevtaev</a> <br>  <a href="http://aescripts.com/learn/zxp-installer/">ZXP plugin installer</a> for AAE. <br></li></ul></div>