<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Healthy people cortege</title>
  <meta name="description" content="This article is about one of the best inventions of Python: the named tuple (namedtuple). We look at its nice features, from well-known to non-obvious...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Healthy people cortege</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/ou/ec/1d/ouec1dsywtxqia_uzzqonhvnrty.png" alt="Named tuple"><br>  This article is about one of the best inventions of Python: the named tuple (namedtuple).  We look at its nice features, from well-known to non-obvious.  The level of immersion in the topic will increase gradually, so I hope everyone will find something interesting for themselves.  Go! </p><a name="habracut"></a><br><h2 id="vvedenie">  Introduction </h2><br><p>  Surely you are faced with a situation where you need to pass several properties of an object in one piece.  For example, information about a pet: type, nickname and age. </p><br><p>  Often create a separate class for this case laziness, and use tuples: </p><br><pre><code class="python hljs">(<span class="hljs-string"><span class="hljs-string">"pigeon"</span></span>, <span class="hljs-string"><span class="hljs-string">"–§—Ä–µ–Ω–∫"</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) (<span class="hljs-string"><span class="hljs-string">"fox"</span></span>, <span class="hljs-string"><span class="hljs-string">"–ö–ª–µ—Ä"</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>) (<span class="hljs-string"><span class="hljs-string">"parrot"</span></span>, <span class="hljs-string"><span class="hljs-string">"–ü–∏—Ç–µ—Ä"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  For greater clarity, a named tuple - <code>collections.namedtuple</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> namedtuple Pet = namedtuple(<span class="hljs-string"><span class="hljs-string">"Pet"</span></span>, <span class="hljs-string"><span class="hljs-string">"type name age"</span></span>) frank = Pet(type=<span class="hljs-string"><span class="hljs-string">"pigeon"</span></span>, name=<span class="hljs-string"><span class="hljs-string">"–§—Ä–µ–Ω–∫"</span></span>, age=<span class="hljs-number"><span class="hljs-number">3</span></span>) &gt;&gt;&gt; frank.age <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><p>  Everyone knows this. –í–æ—Ç Here are some of the lesser-known features: </p><br><h2 id="bystroe-izmenenie-poley">  Quick field change </h2><br><p>  What if one of the properties needs to be changed?  Frank is aging, and the tuple is immutable.  In order not to re-create it entirely, the <code>_replace()</code> method was <code>_replace()</code> : </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>frank._replace(age=<span class="hljs-number"><span class="hljs-number">4</span></span>) Pet(type=<span class="hljs-string"><span class="hljs-string">'pigeon'</span></span>, name=<span class="hljs-string"><span class="hljs-string">'–§—Ä–µ–Ω–∫'</span></span>, age=<span class="hljs-number"><span class="hljs-number">4</span></span>)</code> </pre> <br><p>  And if you want to make the whole structure changeable - <code>_asdict()</code> : </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>frank._asdict() OrderedDict([(<span class="hljs-string"><span class="hljs-string">'type'</span></span>, <span class="hljs-string"><span class="hljs-string">'pigeon'</span></span>), (<span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-string"><span class="hljs-string">'–§—Ä–µ–Ω–∫'</span></span>), (<span class="hljs-string"><span class="hljs-string">'age'</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)])</code> </pre> <br><h2 id="avtomaticheskaya-zamena-nazvaniy">  Automatic name replacement </h2><br><p>  Suppose you import data from CSV and turn each line into a tuple.  The field names were taken from the header of the CSV file.  But something goes wrong: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># headers = ("name", "age", "with") &gt;&gt;&gt; Pet = namedtuple("Pet", headers) ValueError: Type names and field names cannot be a keyword: 'with' # headers = ("name", "age", "name") &gt;&gt;&gt; Pet = namedtuple("Pet", headers) ValueError: Encountered duplicate field name: 'name'</span></span></code> </pre> <br><p>  The solution is the argument <code>rename=True</code> in the constructor: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># headers = ("name", "age", "with", "color", "name", "food") Pet = namedtuple("Pet", headers, rename=True) &gt;&gt;&gt; Pet._fields ('name', 'age', '_2', 'color', '_4', 'food')</span></span></code> </pre> <br><p>  "Unsuccessful" names were renamed in accordance with the sequence numbers. </p><br><h2 id="znacheniya-po-umolchaniyu">  Default values </h2><br><p>  If a tuple has a bunch of optional fields, you still have to list them every time you create an object: </p><br><pre> <code class="python hljs">Pet = namedtuple(<span class="hljs-string"><span class="hljs-string">"Pet"</span></span>, <span class="hljs-string"><span class="hljs-string">"type name alt_name"</span></span>) &gt;&gt;&gt; Pet(<span class="hljs-string"><span class="hljs-string">"pigeon"</span></span>, <span class="hljs-string"><span class="hljs-string">"–§—Ä–µ–Ω–∫"</span></span>) TypeError: __new__() missing <span class="hljs-number"><span class="hljs-number">1</span></span> required positional argument: <span class="hljs-string"><span class="hljs-string">'alt_name'</span></span> &gt;&gt;&gt; Pet(<span class="hljs-string"><span class="hljs-string">"pigeon"</span></span>, <span class="hljs-string"><span class="hljs-string">"–§—Ä–µ–Ω–∫"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>) Pet(type=<span class="hljs-string"><span class="hljs-string">'pigeon'</span></span>, name=<span class="hljs-string"><span class="hljs-string">'–§—Ä–µ–Ω–∫'</span></span>, alt_name=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>)</code> </pre> <br><p>  To avoid this, specify the <code>defaults</code> argument in the constructor: </p><br><pre> <code class="python hljs">Pet = namedtuple(<span class="hljs-string"><span class="hljs-string">"Pet"</span></span>, <span class="hljs-string"><span class="hljs-string">"type name alt_name"</span></span>, defaults=(<span class="hljs-string"><span class="hljs-string">"–Ω–µ—Ç"</span></span>,)) &gt;&gt;&gt; Pet(<span class="hljs-string"><span class="hljs-string">"pigeon"</span></span>, <span class="hljs-string"><span class="hljs-string">"–§—Ä–µ–Ω–∫"</span></span>) Pet(type=<span class="hljs-string"><span class="hljs-string">'pigeon'</span></span>, name=<span class="hljs-string"><span class="hljs-string">'–§—Ä–µ–Ω–∫'</span></span>, alt_name=<span class="hljs-string"><span class="hljs-string">'–Ω–µ—Ç'</span></span>)</code> </pre> <br><p>  <code>defaults</code> sets default values ‚Äã‚Äãfrom tail.  Works in python 3.7+ </p><br><p>  For older versions, you can more clumsily achieve the same result through a prototype: </p><br><pre> <code class="python hljs">Pet = namedtuple(<span class="hljs-string"><span class="hljs-string">"Pet"</span></span>, <span class="hljs-string"><span class="hljs-string">"type name alt_name"</span></span>) default_pet = Pet(<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-string"><span class="hljs-string">"–Ω–µ—Ç"</span></span>) &gt;&gt;&gt; default_pet._replace(type=<span class="hljs-string"><span class="hljs-string">"pigeon"</span></span>, name=<span class="hljs-string"><span class="hljs-string">"–§—Ä–µ–Ω–∫"</span></span>) Pet(type=<span class="hljs-string"><span class="hljs-string">'pigeon'</span></span>, name=<span class="hljs-string"><span class="hljs-string">'–§—Ä–µ–Ω–∫'</span></span>, alt_name=<span class="hljs-string"><span class="hljs-string">'–Ω–µ—Ç'</span></span>) &gt;&gt;&gt; default_pet._replace(type=<span class="hljs-string"><span class="hljs-string">"fox"</span></span>, name=<span class="hljs-string"><span class="hljs-string">"–ö–ª–µ—Ä"</span></span>) Pet(type=<span class="hljs-string"><span class="hljs-string">'fox'</span></span>, name=<span class="hljs-string"><span class="hljs-string">'–ö–ª–µ—Ä'</span></span>, alt_name=<span class="hljs-string"><span class="hljs-string">'–Ω–µ—Ç'</span></span>)</code> </pre> <br><p>  But with <code>defaults</code> , of course, much nicer. </p><br><h2 id="neobychaynaya-lyogkost">  Extraordinary lightness </h2><br><p>  One of the advantages of a named tuple is lightness.  An army of one hundred thousand pigeons will take only 10 megabytes: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> namedtuple <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> objsize <span class="hljs-comment"><span class="hljs-comment"># 3rd party Pet = namedtuple("Pet", "type name age") frank = Pet(type="pigeon", name="–§—Ä–µ–Ω–∫", age=None) pigeons = [frank._replace(age=idx) for idx in range(100000)] &gt;&gt;&gt; round(objsize.get_deep_size(pigeons)/(1024**2), 2) 10.3</span></span></code> </pre> <br><p>  For comparison, if you make Pet a regular class, the same list will take up 19 megabytes. </p><br><p>  This happens because ordinary objects in the python carry with them a weighty dander <code>__dict__</code> , in which the names and values ‚Äã‚Äãof all the attributes of the object lie: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PetObj</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, type, name, age)</span></span></span><span class="hljs-function">:</span></span> self.type = type self.name = name self.age = age frank_obj = PetObj(type=<span class="hljs-string"><span class="hljs-string">"pigeon"</span></span>, name=<span class="hljs-string"><span class="hljs-string">"–§—Ä–µ–Ω–∫"</span></span>, age=<span class="hljs-number"><span class="hljs-number">3</span></span>) &gt;&gt;&gt; frank_obj.__dict__ {<span class="hljs-string"><span class="hljs-string">'type'</span></span>: <span class="hljs-string"><span class="hljs-string">'pigeon'</span></span>, <span class="hljs-string"><span class="hljs-string">'name'</span></span>: <span class="hljs-string"><span class="hljs-string">'–§—Ä–µ–Ω–∫'</span></span>, <span class="hljs-string"><span class="hljs-string">'age'</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>}</code> </pre> <br><p>  Namedupup objects are deprived of this dictionary, and therefore occupy less memory: </p><br><pre> <code class="python hljs">frank = Pet(type=<span class="hljs-string"><span class="hljs-string">"pigeon"</span></span>, name=<span class="hljs-string"><span class="hljs-string">"–§—Ä–µ–Ω–∫"</span></span>, age=<span class="hljs-number"><span class="hljs-number">3</span></span>) &gt;&gt;&gt; frank.__dict__ AttributeError: <span class="hljs-string"><span class="hljs-string">'Pet'</span></span> object has no attribute <span class="hljs-string"><span class="hljs-string">'__dict__'</span></span> &gt;&gt;&gt; objsize.get_deep_size(frank_obj) <span class="hljs-number"><span class="hljs-number">335</span></span> &gt;&gt;&gt; objsize.get_deep_size(frank) <span class="hljs-number"><span class="hljs-number">239</span></span></code> </pre> <br><p>  But how could a named tuple get rid of <code>__dict__</code> ?  Read on „ÉÑ </p><br><h2 id="bogatyy-vnutrenniy-mir">  Rich inner world </h2><br><p>  If you have been working with python for a long time, then you probably know: you can create a lightweight object through the __slots__ <code>__slots__</code> : </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PetSlots</span></span></span><span class="hljs-class">:</span></span> __slots__ = (<span class="hljs-string"><span class="hljs-string">"type"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-string"><span class="hljs-string">"age"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, type, name, age)</span></span></span><span class="hljs-function">:</span></span> self.type = type self.name = name self.age = age frank_slots = PetSlots(type=<span class="hljs-string"><span class="hljs-string">"pigeon"</span></span>, name=<span class="hljs-string"><span class="hljs-string">"–§—Ä–µ–Ω–∫"</span></span>, age=<span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br><p>  Slot objects do not have a dictionary with attributes, so they take up little memory.  ‚ÄúFrank on slots‚Äù is as light as ‚ÄúFrank on a tuple‚Äù, see: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>objsize.get_deep_size(frank) <span class="hljs-number"><span class="hljs-number">239</span></span> &gt;&gt;&gt; objsize.get_deep_size(frank_slots) <span class="hljs-number"><span class="hljs-number">231</span></span></code> </pre> <br><p>  If you decide that namedtuple also uses slots, this is not far from the truth.  As you remember, concrete tuple classes are declared dynamically: </p><br><pre> <code class="python hljs">Pet = namedtuple(<span class="hljs-string"><span class="hljs-string">"Pet"</span></span>, <span class="hljs-string"><span class="hljs-string">"type name age"</span></span>)</code> </pre> <br><p>  The namedtuple constructor uses different dark magic and generates something like this class (I greatly simplify): </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pet</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(tuple)</span></span></span><span class="hljs-class">:</span></span> __slots__ = () type = property(operator.itemgetter(<span class="hljs-number"><span class="hljs-number">0</span></span>)) name = property(operator.itemgetter(<span class="hljs-number"><span class="hljs-number">1</span></span>)) age = property(operator.itemgetter(<span class="hljs-number"><span class="hljs-number">2</span></span>)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__new__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls, type, name, age)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tuple.__new__(cls, (type, name, age))</code> </pre> <br><p>  That is, our Pet is an ordinary <code>tuple</code> , to which three properties-methods were nailed: </p><br><ul><li>  <code>type</code> returns the zero element of the tuple </li><li>  <code>name</code> - the first element of the tuple </li><li>  <code>age</code> is the second element of the tuple </li></ul><br><p>  And <code>__slots__</code> needed only to make the objects light.  As a result, Pet and takes up little space, and can be used as a normal tuple: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>frank.index(<span class="hljs-string"><span class="hljs-string">"–§—Ä–µ–Ω–∫"</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt;&gt; type, _, _ = frank &gt;&gt;&gt; type <span class="hljs-string"><span class="hljs-string">'pigeon'</span></span></code> </pre> <br><p>  Slyly invented, eh? </p><br><h2 id="neustupaet-data-klassam">  Not inferior to data classes </h2><br><p>  Since we are talking about code generation.  In Python 3.7, an uber code generator appeared that has no equal - data classes (dataclasses). </p><br><p>  When you first see the data class, you want to switch to a new version of the language just for the sake of it: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dataclasses <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> dataclass @dataclass <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PetData</span></span></span><span class="hljs-class">:</span></span> type: str name: str age: int</code> </pre> <br><p>  A miracle is so good!  But there is a nuance - it is fat: </p><br><pre> <code class="python hljs">frank_data = PetData(type=<span class="hljs-string"><span class="hljs-string">"pigeon"</span></span>, name=<span class="hljs-string"><span class="hljs-string">"–§—Ä–µ–Ω–∫"</span></span>, age=<span class="hljs-number"><span class="hljs-number">3</span></span>) &gt;&gt;&gt; objsize.get_deep_size(frank_data) <span class="hljs-number"><span class="hljs-number">335</span></span> &gt;&gt;&gt; objsize.get_deep_size(frank) <span class="hljs-number"><span class="hljs-number">239</span></span></code> </pre> <br><p>  The data class generates the usual python class, the objects of which are exhausted under the weight of <code>__dict__</code> .  So if you read a car of lines from the base and turn them into objects, data classes are not the best choice. </p><br><p>  But wait, the data class can be ‚Äúfrozen‚Äù like a tuple.  Maybe then it will be easier? </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@dataclass(frozen=True) class PetFrozen: type: str name: str age: int frank_frozen = PetFrozen(type="pigeon", name="–§—Ä–µ–Ω–∫", age=3) &gt;&gt;&gt; objsize.get_deep_size(frank_frozen) 335</span></span></code> </pre> <br><p>  Alas.  Even frozen, it remained an ordinary weighty object with a dictionary of attributes.  So if you need light immutable objects (which can also be used as regular tuples) - namedtuple is still the best choice. </p><br><p>  ‚åò ‚åò </p><br><p>  I really like the named tuple: </p><br><ul><li>  honest iterable, </li><li>  dynamic type declaration </li><li>  named access to attributes </li><li>  easy and unchangeable. </li></ul><br><p>  And it is implemented in 150 lines of code.  What else is needed for happiness „ÉÑ </p><br><p>  <em>If you want to learn more about the standard Python library, subscribe to the <a href="https://t.me/ohmypy">@ohmypy</a> channel</em> </p></div><p>Source: <a href="https://habr.com/ru/post/438162/">https://habr.com/ru/post/438162/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>