<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Courier: Dropbox to gRPC migration</title>
  <meta name="description" content="Translator's Note 
 Most modern software products are not monolithic, but consist of many parts that interact with each other. In this state of affair...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Courier: Dropbox to gRPC migration</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/eu/p8/y-/eup8y-m8hpxc9w2qhvo1qofrmog.jpeg"><br><br><h1>  Translator's Note </h1><br>  Most modern software products are not monolithic, but consist of many parts that interact with each other.  In this state of affairs, it is necessary that the interaction of interacting parts of the system take place in the same language (despite the fact that the parts themselves can be written in different programming languages ‚Äã‚Äãand executed on different machines).  GRPC, an open-source framework from Google, released in 2015, helps simplify the solution of this problem.  He immediately solves a number of problems, allowing: <br><br><ul><li>  use the language Protocol Buffers to describe the interaction of services; <br></li><li>  generate software code based on the described protocol for 11 different languages ‚Äã‚Äãfor both the client and server parts; <br></li><li>  implement authorization between interacting components; <br></li><li>  use both synchronous and asynchronous interaction. <br></li></ul><br>  gRPC seemed to be quite an interesting framework, and I was interested to learn about the actual experience of Dropbox in building a system based on it.  The article has a lot of details related to the use of encryption, building a reliable, observable and productive system, the migration process from the old RPC solution to the new one. <br><br><div class="spoiler">  <b class="spoiler_title">Disclaimer</b> <div class="spoiler_text">  The original article does not contain a description of gRPC, and some points may seem incomprehensible to you.  If you are not familiar with gRPC or other similar frameworks (for example, Apache Thrift), I recommend you to familiarize yourself with the basic ideas (you just need to read two small articles from the official site: <a href="https://grpc.io/docs/guides/index.html">"What is gRPC?"</a> And <a href="https://grpc.io/docs/guides/concepts.html">"gRPC Concepts"</a> ). <br><br>  Thanks to Alexey Ivanov aka <a href="https://habr.com/ru/users/savetherbtz/" class="user_link">SaveTheRbtz</a> for writing the original article and helping with the translation of difficult places. <br></div></div><a name="habracut"></a><br>  Dropbox manages a variety of services written in different languages ‚Äã‚Äãand serving millions of requests per second.  At the heart of our service-oriented architecture is Courier, a gRPC-based RPC framework.  In the process of its development, we learned a lot about gRPC extensibility, speed optimization and transition from the previous RPC system. <br><br>  <i>Note: The post contains code snippets in Python and Go.</i>  <i>We also use Rust and Java.</i> <br><br><h1>  Road to gRPC </h1><br>  Courier is not the first Dropbox RPC framework.  Even before we started splitting up the monolithic Python system into separate services, we needed a reliable basis for data exchange between services - especially since the choice of the framework will have remote consequences. <br><br>  Prior to that, Dropbox experimented with different RPC frameworks.  At first we had an individual protocol for manual serialization and deserialization.  Some services, such as <a href="https://blogs.dropbox.com/tech/2015/05/how-to-write-a-better-scribe/">Scribe-based logging tools</a> , used <a href="https://github.com/apache/thrift">Apache Thrift</a> .  At the same time, our main RPC framework was the HTTP / 1.1 protocol with messages serialized using Protobuf. <br><br>  Creating a framework, we chose from several options.  We could introduce Swagger (now known as <a href="https://github.com/OAI/OpenAPI-Specification">OpenAPI</a> ) into the old RPC framework, <a href="https://xkcd.com/927/">introduce a new standard</a> or build a framework based on Thrift or gRPC.  The main argument in favor of gRPC was the ability to use pre-existing protobufs.  Also, multiplex HTTP / 2 and two-way data transfer were useful for our tasks. <br><br>  <i>Note: if fbthrift existed at that time, we might have looked more closely at the Thrift solutions.</i> <br><br><h1>  What Courier brings to gRPC </h1><br>  Courier is not an RPC protocol;  it is a means of integrating gRPC into the existing infrastructure.  The framework was supposed to be compatible with our tools for authentication, authorization and discovery of the service, as well as collecting statistics, logging and tracking.  So we created Courier. <br><br>  <i>Although in some cases we use <a href="https://blogs.dropbox.com/tech/2018/03/meet-bandaid-the-dropbox-service-proxy/">Bandaid</a> as a gRPC proxy, most of our services interact with each other directly to minimize the effect of RPC on latency.</i> <br><br>  For us it was important to reduce the amount of routine code that needs to be written.  Since Courier serves as a general framework for developing services, it contains the features necessary for everyone.  Most of them are enabled by default and can be controlled by command line arguments, and some are ticked by a flag. <br><br><h2>  Security: Service Identification and TLS Mutual Authentication </h2><br>  Courier implements our standard service identification mechanism.  Each server and client is assigned an individual TLS certificate issued by our own certification authority.  The certificate encodes a personal identifier that is used for mutual authentication ‚Äî the server verifies the client, the client verifies the server. <br><br>  In TLS, where we control both sides of the connection, we have imposed tight restrictions.  All internal RPCs require <a href="https://scotthelme.co.uk/perfect-forward-secrecy/">PFS</a> encryption.  The required TLS version is 1.2 and higher.  We also limited the number of symmetric and asymmetric algorithms, preferring <i>ECDHE-ECDSA-AES128-GCM-SHA256</i> . <br><br>  After passing the authentication and decrypting the request, the server checks if the client has the necessary permissions.  Access control lists (ACLs) and speed limits can be configured for services as a whole or for individual methods.  Their parameters can also be changed through our distributed file system (AFS).  Due to this, service owners can relieve the load in seconds, even without restarting the processes.  Courier will take care of the notification subscription and configuration updates. <br><br>  <i>Service Identity is a global identifier for ACL, speed limits, statistics, etc. Plus, it is cryptographically secure.</i> <br><br>  Here is an example of the configuration of the ACL and the speed limit used in our <a href="https://blogs.dropbox.com/tech/2018/10/using-machine-learning-to-index-text-from-billions-of-images/">optical image recognition service</a> : <br><br><pre><code class="plaintext hljs">limits:  dropbox_engine_ocr:    # All RPC methods.    default:      max_concurrency: 32      queue_timeout_ms: 1000      rate_acls:        # OCR clients are unlimited.        ocr: -1        # Nobody else gets to talk to us.        authenticated: 0        unauthenticated: 0</code> </pre> <br><img src="https://habrastorage.org/webt/ll/as/l_/llasl_0osxrxbboxrbjqaalb8ti.png"><br><br>  <i>We are considering the possibility of switching to the SVID format ( <a href="https://spiffe.io/">SPIFFE</a> cryptographically verifiable document), which will help to combine our framework with many open source projects.</i> <br><br><h2>  Observability: statistics and tracking </h2><br>  With just one identifier, you can easily find logs, statistics, trace files and other data about Courier. <br><br><img src="https://habrastorage.org/webt/t_/25/3o/t_253ogfq1bizretdswvdrb_7g0.png"><br><br>  When code generation, statistics collection is added for each service and each method both on the client side and on the server side.  Server-side statistics are divided by client ID.  In the standard configuration, you will receive detailed load, error, and delay data for each service using Courier. <br><br><img src="https://habrastorage.org/webt/g1/6g/_1/g16g_1z72oxaxwwvasrjhznfltk.png"><br><br>  Courier statistics include data on availability and latency on the client‚Äôs side, as well as on the number of requests and queue size on the server side.  There are other useful graphs, in particular histograms of response time for each method and TLS handshakes for each client. <br><br>  <i>One of the advantages of our code generation is the possibility of static initialization of data structures such as histograms and trace graphs.</i>  <i>This minimizes the impact on performance.</i> <br><br><img src="https://habrastorage.org/webt/p7/6-/fv/p76-fvobtszsgtu2g2tlmwfwlyk.png"><br><br>  The former RPC system only distributed the <i>request_id</i> via API.  This made it possible to combine data from the logs of different services.  In Courier, we presented an API based on a subset of the <a href="https://opentracing.io/">OpenTracing</a> specifications.  We wrote our own libraries on the client side, and on the server side implemented a solution based on Cassandra and <a href="https://github.com/jaegertracing/jaeger">Jaeger</a> . <br><br><img src="https://habrastorage.org/webt/dk/hv/iq/dkhviqgdiem3itipi7x87tri_i8.png"><br><br>  Tracing allows us to generate service dependency diagrams at runtime.  This helps engineers to see all the transitive dependencies of a particular service.  In addition, the feature is useful for tracking unwanted dependencies after deployment. <br><br><h2>  Reliability: deadlines and disconnection </h2><br>  Courier provides a central place for implementing common client functions (for example, time-outs) in different languages.  We gradually added various possibilities, often based on the results of a ‚Äúpost-mortem‚Äù analysis of emerging problems. <br><br><h3>  Deadlines </h3><br>  <a href="https://grpc.io/blog/deadlines">Each gRPC request has a deadline</a> indicating client waiting time.  Since Courier stubs automatically distribute known metadata, the deadline for the query is even passed outside the API.  Inside the process, deadlines get a native mapping.  For example, in Go, they are represented by the <i>context.Context</i> result from the <i>WithDeadline</i> method. <br><br>  In fact, we were able to fix whole classes of reliability problems, forcing engineers to set deadlines in determining the corresponding services. <br><br>  This approach goes even beyond RPC.  For example, our ORM MySQL serializes the RPC context along with the deadline in the SQL query comment.  Our SQL proxy can parse comments and ‚Äúkill‚Äù requests when deadline occurs.  And as a bonus when debugging database access, we have a SQL query binding to a specific RPC query. <br><br><h3>  Disconnection </h3><br>  Another common problem faced by customers of the previous RPC system is the implementation of an algorithm for individual exponential delay and oscillations when re-requesting. <br><br>  We tried to find an intelligent solution to the problem of disconnecting in Courier, starting with the implementation of the LIFO buffer (last in, first out) between the service and the task pool. <br><br><img src="https://habrastorage.org/webt/th/sr/t0/thsrt0kbgxgnexrr9figp9ymg_a.png"><br><br>  In the event of an overload, the LIFO will automatically break the connection.  The queue, which is important, is limited not only in size, but also <b>in time</b> (the request can only spend a certain time in the queue). <br><br>  <i>Minus LIFO - change the order of processing requests.</i>  <i>If you want to keep the original order, use <a href="https://queue.acm.org/detail.cfm%3Fid%3D2209336">CoDel</a> .</i>  <i>There is also the possibility of breaking the connection, and the order of processing requests will remain the same.</i> <br><br><img src="https://habrastorage.org/webt/7g/w_/ud/7gw_udkbrsesseak2xrxaucw7fi.png"><br><br><h2>  Introspection: debug endpoints </h2><br>  Although debug endpoints are not directly part of Courier, they are widely used throughout Dropbox and are too useful not to mention. <br><br>  <i>In order to ensure security, you can open them on a separate port or in a Unix-socket (to control access using file permissions).</i>  <i>You should also consider mutual TLS authentication, with which developers will have to provide their certificates for access to endpoints (primarily not only readable).</i> <br><br><h3>  Execution </h3><br>  The ability to analyze the status of the service during its operation is very useful for debugging.  For example, <a href="http/pprof/">dynamic memory and CPU profiles can be accessed via HTTP or gRPC endpoints</a> . <br><br>  <i>We plan to use this feature in the canary verification procedure - to automate the search for the difference between the old and new versions of the code.</i> <br><br>  Endpoints make it possible to modify the state of the service during execution.  In particular, Golang-based services can dynamically configure <a href="https://golang.org/pkg/runtime/debug/">GCPercent</a> . <br><br><h3>  Library </h3><br>  The function of automatically exporting data related to a specific library in the form of an RPC endpoint may be useful for library developers.  For example, the <a href="http://jemalloc.net/jemalloc.3.html">malloc</a> library <a href="http://jemalloc.net/jemalloc.3.html">can dump internal statistics into a dump</a> .  Another example: a debug endpoint can change the level of service logging on the fly. <br><br><h3>  RPC </h3><br>  Of course, troubleshooting the encrypted and encrypted protocols is not easy.  Therefore, implementing as many tools as possible at the RPC level is a good idea.  One example of this introspective API <a href="">is Channelz</a> . <br><br><h3>  Application level </h3><br>  The ability to examine application-level settings can also be useful.  A good example is endpoint with general information about the application (with the hash of the source or build files, the command line, etc.).  It can be used by the orchestration system to check the integrity when deploying a service. <br><br><h1>  Performance optimization </h1><br>  By expanding our gRPC framework to the required scale, we found several bottlenecks specific to Dropbox. <br><br><h3>  Resource Consumption TLS-handshakes </h3><br>  In services that serve many interconnections, as a result of TLS handshakes, the cumulative CPU load can be quite serious (especially when reloading a popular service). <br><br>  In order to improve the performance in the implementation of the signature, we replaced the RSA-2048 key pairs with ECDSA P-256.  Here are examples of their performance (note: signature verification is faster with RSA). <br><br>  <b>RSA:</b> <br><br><pre> <code class="plaintext hljs">~/c0d3/boringssl bazel run -- //:bssl speed -filter 'RSA 2048' Did ... RSA 2048 signing operations in ..............  (1527.9 ops/sec) Did ... RSA 2048 verify (same key) operations in .... (37066.4 ops/sec) Did ... RSA 2048 verify (fresh key) operations in ... (25887.6 ops/sec)</code> </pre> <br>  <b>ECDSA:</b> <br><br><pre> <code class="plaintext hljs">~/c0d3/boringssl bazel run -- //:bssl speed -filter 'ECDSA P-256' Did ... ECDSA P-256 signing operations in ... (40410.9 ops/sec) Did ... ECDSA P-256 verify operations in .... (17037.5 ops/sec)</code> </pre><br>  Since verification with RSA-2048 is about three times faster than with ECDSA P-256, you can choose RSA for root and end certificates for increased performance.  But from a security point of view, things are not so simple: you will build chains of various cryptographic primitives, and therefore the level of the resulting security parameters will be the lowest.  And if you want to improve speed, we do not recommend using certificates of version RSA-4096 (and higher) as root and end. <br><br>  We also found that the choice of the TLS library (and the compilation flags) has a significant impact on both performance and security.  Compare, for example, the LibreSSL build on macOS X Mojave with a self-written OpenSSL on the same hardware. <br><br>  <b>LibreSSL 2.6.4:</b> <br><br><pre> <code class="plaintext hljs">~ openssl speed rsa2048 LibreSSL 2.6.4 ...                 sign verify sign/s verify/s rsa 2048 bits 0.032491s 0.001505s     30.8 664.3</code> </pre> <br>  <b>OpenSSL 1.1.1a:</b> <br><br><pre> <code class="plaintext hljs"> ~ openssl speed rsa2048 OpenSSL 1.1.1a  20 Nov 2018 ...                 sign verify sign/s verify/s rsa 2048 bits 0.000992s 0.000029s   1208.0 34454.8</code> </pre> <br>  However, the fastest way to create a TLS handshake is not to create it at all!  We have included support for resuming the session in gRPC-core and gRPC-python, thereby reducing the load on the CPU during deployment. <br><br><h3>  Encryption is inexpensive </h3><br>  Many people mistakenly believe that encryption is expensive.  In fact, even the most simple modern computers implement symmetric encryption almost at lightning speed.  A standard processor is able to encrypt and authenticate data at a speed of 40 Gb / s per core: <br><br><pre> <code class="plaintext hljs">~/c0d3/boringssl bazel run -- //:bssl speed -filter 'AES' Did ... AES-128-GCM (8192 bytes) seal operations in ... 4534.4 MB/s</code> </pre> <br>  Nevertheless, we still had to configure gRPC for our memory blocks operating at 50 Gb / s.  We found that if the encryption speed is approximately equal to the copy speed, then it is important to minimize the number of <i>memcpy</i> operations <i>.</i>  In addition, we made some changes to gRPC itself. <br><br>  <i>Authenticated and encrypted protocols avoided many unpleasant problems (for example, data corruption by the processor, DMA or network).</i>  <i>Even if you do not use gRPC, we recommend using TLS for internal contacts.</i> <br><br><h2>  High latency data links (BDP) </h2><br>  Translator's note: in the original subtitle, the term <a href="https://en.wikipedia.org/wiki/Bandwidth-delay_product">bandwidth-delay product was used</a> , which does not have a well-established Russian translation. <br><br>  <a href="https://blogs.dropbox.com/tech/2017/09/infrastructure-update-evolution-of-the-dropbox-backbone-network/">Dropbox's core network includes many data centers</a> .  Sometimes nodes located in different regions have to be communicated via RPC, for example, for replication.  When using TCP, the system core is responsible for limiting the amount of data transmitted on a particular connection (within / <i>proc / sys / net / ipv4 / tcp_ {r, w} mem</i> ), although the gRPC based on HTTP / 2 also has its own flow control.  The upper limit of the BDP <a href="https://github.com/grpc/grpc-go/issues/2400">in grpc-go is strictly limited to 16 MB</a> , which can provoke a bottleneck. <br><br><h2>  net.Server Golang or grpc.Server </h2><br>  Initially, in our Go code, we supported HTTP / 1.1 and gRPC using one <a href="http/">net.Server</a> .  The solution made sense in terms of maintaining the program code, but it didn‚Äôt work perfectly.  The distribution of HTTP / 1.1 and gRPC across different servers and the transition of gRPC to grpc.Server have significantly improved throughput and memory utilization by Courier services. <br><br><h2>  golang / protobuf or gogo / protobuf </h2><br>  Switching to gRPC may increase the cost of marshaling and unmarshaling.  For the Go code, we were able to significantly reduce the CPU load on the Courier servers by going to <a href="https://github.com/gogo/protobuf">gogo / protobuf</a> . <br><br>  <i>As always, the <a href="https://jbrandhorst.com/post/gogoproto/">transition to gogo / protobuf was accompanied by some concerns</a> , but if you reasonably limit the functionality, there should be no problems.</i> <br><br><h1>  Implementation details </h1><br>  In this section, we will penetrate deeper into the Courier device, consider protobuf schemes and examples of stubs from various languages.  All examples are taken from the Test service that we used during Courier integration testing. <br><br><h2>  Service Description </h2><br>  Take a look at an excerpt from the definition of the Test service: <br><br><pre> <code class="plaintext hljs">service Test {   option (rpc_core.service_default_deadline_ms) = 1000;   rpc UnaryUnary(TestRequest) returns (TestResponse) {       option (rpc_core.method_default_deadline_ms) = 5000;   }   rpc UnaryStream(TestRequest) returns (stream TestResponse) {       option (rpc_core.method_no_deadline) = true;   }   ... }</code> </pre> <br>  As stated above, the presence of deadline is mandatory for all Courier methods.  With the following option you can set a deadline for the entire service: <br><br><pre> <code class="plaintext hljs">option (rpc_core.service_default_deadline_ms) = 1000;</code> </pre> <br>  At the same time, each method can have its own deadline, which cancels the deadline of the entire service (if there is one): <br><br><pre> <code class="plaintext hljs">option (rpc_core.method_default_deadline_ms) = 5000;</code> </pre> <br>  In rare cases, when the deadline does not make sense (for example, when tracking a resource), the developer can turn it off: <br><br><pre> <code class="plaintext hljs">option (rpc_core.method_no_deadline) = true;</code> </pre> <br>  In addition to this, the service description should contain detailed API documentation, possibly with examples of use. <br><br><h2>  Generation stubs </h2><br>  To provide greater flexibility, Courier generates its own stubs, without relying on the interceptor functionality provided by gRPC (with the exception of Java, in which the interceptor API has sufficient power).  Let's compare our stubs with standard Golang stubs. <br><br>  This is how the default stubs of the gRPC server look like: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test_UnaryUnary_Handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(srv </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, ctx context.Context, dec </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interceptor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grpc</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnaryServerInterceptor</span></span></span><span class="hljs-function">) </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> {       in := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(TestRequest)       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := dec(in); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {               <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err       }       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> interceptor == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {               <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> srv.(TestServer).UnaryUnary(ctx, in)       }       info := &amp;grpc.UnaryServerInfo{               Server: srv,               FullMethod: <span class="hljs-string"><span class="hljs-string">"/test.Test/UnaryUnary"</span></span>,       }       handler := <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, req </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> {               <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> srv.(TestServer).UnaryUnary(ctx, req.(*TestRequest))       }       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> interceptor(ctx, in, info, handler) }</code> </pre> <br>  All processing takes place inside: decoding protobuf, launching interceptors (see the <code>interceptor</code> variable in the code), launching the UnaryUnary handler. <br><br>  Now look at the Courier stubs: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test_UnaryUnary_dbxHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(       srv </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{},       ctx context.Context,       dec </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function">,       </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interceptor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grpc</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnaryServerInterceptor</span></span></span><span class="hljs-function">) </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(       </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{},       error)</span></span></span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> processor.PanicHandler()       impl := srv.(*dbxTestServerImpl)       metadata := impl.testUnaryUnaryMetadata       ctx = metadata.SetupContext(ctx)       clientId = client_info.ClientId(ctx)       stats := metadata.StatsMap.GetOrCreatePerClientStats(clientId)       stats.TotalCount.Inc()       req := &amp;processor.UnaryUnaryRequest{               Srv: srv,               Ctx: ctx,               Dec: dec,               Interceptor: interceptor,               RpcStats: stats,               Metadata: metadata,               FullMethodPath: <span class="hljs-string"><span class="hljs-string">"/test.Test/UnaryUnary"</span></span>,               Req: &amp;test.TestRequest{},               Handler: impl._UnaryUnary_internalHandler,               ClientId: clientId,               EnqueueTime: time.Now(),       }       metadata.WorkPool.Process(req).Wait()       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> req.Resp, req.Err }</code> </pre> <br>  There's a lot of code here, so let's break it down. <br><br>  First, we postpone the call to the panic handler, which is responsible for automatically collecting errors.  This will allow us to collect all uncaught exceptions in the central repository for subsequent aggregation and reporting: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> processor.PanicHandler()</code> </pre><br>  Another reason why we run our own panic handler is to make sure that in case of an error, the application will crash.  The standard golang / net HTTP handler will then ignore the problem and continue to serve new requests (even those that are corrupted and mismatched). <br><br>  Then we pass the context further, redefining the values ‚Äã‚Äãbased on the incoming request metadata: <br><br><pre> <code class="go hljs">ctx = metadata.SetupContext(ctx) clientId = client_info.ClientId(ctx)</code> </pre> <br>  We also create (and cache for greater efficiency) server-side client statistics for more detailed aggregation: <br><br><pre> <code class="go hljs">stats := metadata.StatsMap.GetOrCreatePerClientStats(clientId)</code> </pre><br>  This line creates statistics for each client (i.e. TLS-identifier) ‚Äã‚Äãduring execution.  We also have statistics on all methods for each service.  Since the stub generator has access to all methods during code generation, we can pre-statically create them, thereby avoiding deceleration of program execution. <br><br>  After that we create the request structure, transfer it to the task pool and wait for the execution: <br><br><pre> <code class="go hljs">req := &amp;processor.UnaryUnaryRequest{       Srv:        srv,       Ctx:        ctx,       Dec:        dec,       Interceptor:    interceptor,       RpcStats:       stats,       Metadata:       metadata,       ... } metadata.WorkPool.Process(req).Wait()</code> </pre> <br>  Note that by this time we have not done the decoding of the protobuf, nor the launch of the interceptor.  Before this, access checks, prioritization and limiting the number of queries to be performed must be passed inside the task pool. <br><br>  <i>Note that the gRPC library supports the TAP interface, which allows you to intercept requests with great speed.</i>  <i>The interface provides the infrastructure for building effective speed limiters with minimal resource consumption.</i> <br><br><h2>  Specific error codes for different applications </h2><br>  Our stub generator also allows developers to assign application-specific error codes using special options: <br><br><pre> <code class="plaintext hljs">enum ErrorCode { option (rpc_core.rpc_error) = true; UNKNOWN = 0; NOT_FOUND = 1 [(rpc_core.grpc_code)="NOT_FOUND"]; ALREADY_EXISTS = 2 [(rpc_core.grpc_code)="ALREADY_EXISTS"]; ... STALE_READ = 7 [(rpc_core.grpc_code)="UNAVAILABLE"]; SHUTTING_DOWN = 8 [(rpc_core.grpc_code)="CANCELLED"]; }</code> </pre> <br>  Within the service, both gRPC and application errors are propagated, and on the API boundary all errors are replaced with UNKNOWN.  Due to this, we can avoid transferring the problem to other services, which may result in a change in their semantics. <br><br><h2>  Changes regarding Python </h2><br>  Python stubs add an explicit context parameter to all Courier handlers: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dropbox.context <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Context <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dropbox.proto.test.service_pb2 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> (       TestRequest,       TestResponse, ) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typing_extensions <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Protocol <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCourierClient</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Protocol)</span></span></span><span class="hljs-class">:</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnaryUnary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(           self,           ctx, # type: Context           request, # type: TestRequest           )</span></span></span><span class="hljs-function">:</span></span>       <span class="hljs-comment"><span class="hljs-comment"># type: (...) -&gt; TestResponse       ...</span></span></code> </pre> <br>  At first it looked weird, but over time, the developers got used to the explicit <i>ctx</i> just as they used to <i>self</i> . <br><br>  Please note that our stubs are fully typed for <a href="https://mypy.readthedocs.io/en/latest/introduction.html">mypy</a> , which is compensated during major refactoring.  In addition, integration with some IDEs (eg, PyCharm) is simplified. <br><br>  Continuing to follow the trend for static typing, we add mypy annotations to the protocols themselves: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestMessage</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Message)</span></span></span><span class="hljs-class">:</span></span>   field: int   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self,       field : Optional[int] = ...,       )</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> ...   @staticmethod   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: bytes)</span></span></span><span class="hljs-function"> -&gt; TestMessage:</span></span> ...</code> </pre> <br>  These annotations will allow you to avoid many common bugs, such as assigning a value of <i>None</i> to a <i>string</i> type, for example <i>.</i> <br><br>  This code <a href="https://github.com/dropbox/mypy-protobuf">is available by reference</a> . <br><br><h1>  Migration process </h1><br>  Creating a new RPC stack is not an easy task, but it is not even close to the process of a full transition to it, when viewed from the point of view of operating complexity.  Therefore, we have tried to simplify for developers the transition from the old RPC to the Courier.  Since migrations are often accompanied by errors, we decided to implement it in stages. <br><br><h2>  Step 0: Freeze Old RPC </h2><br>  First of all, we froze the old RPC so as not to shoot at a moving target.  This also pushed people to move to Courier, because all new features like tracing were available only in services on Courier. <br><br><h2>  Step 1: Common Interface for Old RPC and Courier </h2><br>  We started by setting a common interface for the old RPC and Courier.  Our code generation had to ensure that both versions of stubs match this interface: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TestServer <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> {  UnaryUnary(     ctx context.Context,     req *test.TestRequest) (     *test.TestResponse,     error)  ... }</code> </pre><br><h2>  Step 2: Migrate to New Interface </h2><br>  After that, we began to switch each service to a new interface, while continuing to use the old RPC.  Often the code changes represented a huge diff affecting all the methods of the service and its clients.  Since this stage is the most problematic, we wanted to completely eliminate the risk, changing only one thing at a time. <br><br>  <i>Simple services with a small number of methods and the <a href="https://landing.google.com/sre/sre-book/chapters/embracing-risk/">right to error</a> can be migrated simultaneously, without paying attention to our warnings.</i> <br><br><h2>  Step 3: Migrate Clients to RPC Courier </h2><br>  During the migration process, we started simultaneously launching both old and new servers on different ports of the same machine.  Switching the RPC implementation on the client side was done by changing one line: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClient</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> -   self.client = LegacyRPCClient(<span class="hljs-string"><span class="hljs-string">'myservice'</span></span>) +   self.client = CourierRPCClient(<span class="hljs-string"><span class="hljs-string">'myservice'</span></span>)</code> </pre> <br>  Please note that with this model you can transfer one client at a time, starting with those who have a lower SLA level. <br><br><h2>  Step 4: Cleaning </h2><br> –ü–æ—Å–ª–µ —Ç–æ–≥–æ –∫–∞–∫ –≤—Å–µ –∫–ª–∏–µ–Ω—Ç—ã –±—ã–ª–∏ –ø–µ—Ä–µ–Ω–µ—Å–µ–Ω—ã, –ø—Ä–∏—à–ª–æ –≤—Ä–µ–º—è —É–¥–æ—Å—Ç–æ–≤–µ—Ä–∏—Ç—å—Å—è, —á—Ç–æ —Å—Ç–∞—Ä—ã–π RPC –±–æ–ª—å—à–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è (—ç—Ç–æ –º–æ–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏ —Å –ø–æ–º–æ—â—å—é –∏–Ω—Å–ø–µ–∫—Ü–∏–∏ –∫–æ–¥–∞ –∏ –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Å –ø–æ–º–æ—â—å—é —Å–µ—Ä–≤–µ—Ä–Ω–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏). –ü–æ—Å–ª–µ —ç—Ç–æ–≥–æ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∏ –º–æ–≥—É—Ç –Ω–∞—á–∞—Ç—å —á–∏—Å—Ç–∫—É ‚Äî —É–¥–∞–ª–µ–Ω–∏–µ —É—Å—Ç–∞—Ä–µ–≤—à–µ–≥–æ –∫–æ–¥–∞. <br><br><h1>  findings </h1><br> –ò—Ç–∞–∫, Courier ‚Äî —É–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–π RPC-—Ñ—Ä–µ–π–º–≤–æ—Ä–∫, —É—Å–∫–æ—Ä—è—é—â–∏–π —Ä–∞–∑—Ä–∞–±–æ—Ç–∫—É —Å–µ—Ä–≤–∏—Å–æ–≤, —É–ø—Ä–æ—â–∞—é—â–∏–π —ç–∫—Å–ø–ª—É–∞—Ç–∞—Ü–∏—é –∏ –ø–æ–≤—ã—à–∞—é—â–∏–π –Ω–∞–¥—ë–∂–Ω–æ—Å—Ç—å Dropbox. <br><br> –í–æ—Ç –∫–∞–∫–∏–µ –≤—ã–≤–æ–¥—ã –º—ã —Å–¥–µ–ª–∞–ª–∏, —Ä–∞–∑—Ä–∞–±–∞—Ç—ã–≤–∞—è –∏ —Ä–∞–∑–≤—ë—Ä—Ç—ã–≤–∞—è Courier: <br><br><ol><li> –ù–∞–±–ª—é–¥–∞–µ–º–æ—Å—Ç—å ‚Äî –æ–≥—Ä–æ–º–Ω—ã–π –ø–ª—é—Å. –ù–∞–ª–∏—á–∏–µ –≤—Å–µ–π –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –æ–∫–∞–∂–µ—Ç—Å—è –Ω–µ–∑–∞–º–µ–Ω–∏–º—ã–º –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏ –∏ —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è –Ω–µ–ø–æ–ª–∞–¥–æ–∫. <br></li><li> –°—Ç–∞–Ω–¥–∞—Ä—Ç–∏–∑–∞—Ü–∏—è –∏ –æ–¥–Ω–æ—Ä–æ–¥–Ω–æ—Å—Ç—å –æ—á–µ–Ω—å –≤–∞–∂–Ω—ã ‚Äî –æ–Ω–∏ —Å–Ω–∏–∂–∞—é—Ç –∫–æ–≥–Ω–∏—Ç–∏–≤–Ω—É—é –Ω–∞–≥—Ä—É–∑–∫—É, —É–ø—Ä–æ—â–∞—é—Ç —ç–∫—Å–ø–ª—É–∞—Ç–∞—Ü–∏—é –∏ —Å–æ–ø—Ä–æ–≤–æ–∂–¥–µ–Ω–∏–µ –∫–æ–¥–∞. <br></li><li> –ü–æ—Å—Ç–∞—Ä–∞–π—Ç–µ—Å—å –º–∏–Ω–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä—É—Ç–∏–Ω–Ω–æ–≥–æ –∫–æ–¥–∞, —Å–æ–∑–¥–∞–≤–∞–µ–º–æ–≥–æ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞–º–∏. –í —ç—Ç–æ–º –≤–∞–º –ø–æ–º–æ–∂–µ—Ç Codegen. <br></li><li> –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ —É–ø—Ä–æ—Å—Ç–∏—Ç–µ –ø—Ä–æ—Ü–µ—Å—Å –º–∏–≥—Ä–∞—Ü–∏–∏. –í–æ–∑–º–æ–∂–Ω–æ, –æ–Ω –∑–∞–π–º—ë—Ç –±–æ–ª—å—à–µ –≤—Ä–µ–º–µ–Ω–∏, —á–µ–º —Å–∞–º–∞ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∞. –ö—Ä–æ–º–µ —Ç–æ–≥–æ, –∑–∞–ø–æ–º–Ω–∏—Ç–µ: –º–∏–≥—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è –ø–æ—Å–ª–µ –æ–∫–æ–Ω—á–∞–Ω–∏—è —É–¥–∞–ª–µ–Ω–∏—è —Å—Ç–∞—Ä–æ–≥–æ –∫–æ–¥–∞. <br></li><li> –í RPC-—Ñ—Ä–µ–π–º–≤–æ—Ä–∫ –º–æ–∂–Ω–æ –≤–∫–ª—é—á–∏—Ç—å —É–ª—É—á—à–µ–Ω–∏—è –¥–ª—è –≤—Å–µ–π –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä—ã ‚Äî –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –¥–µ–¥–ª–∞–π–Ω—ã, –∑–∞—â–∏—Ç—É –æ—Ç –ø–µ—Ä–µ–≥—Ä—É–∑–∫–∏ –∏ —Ç. –¥. –û–±—â–∏–µ –ø—Ä–æ–±–ª–µ–º—ã —Å –Ω–∞–¥—ë–∂–Ω–æ—Å—Ç—å—é –º–æ–∂–Ω–æ –≤—ã—è–≤–∏—Ç—å –≤ —Ö–æ–¥–µ –∏–∑—É—á–µ–Ω–∏—è –∫–≤–∞—Ä—Ç–∞–ª—å–Ω—ã—Ö –æ—Ç—á—ë—Ç–æ–≤. <br></li></ol><br><h1> –ë—É–¥—É—â–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è </h1><br> Courier, –∫–∞–∫ –∏ gRPC –≤ —Ü–µ–ª–æ–º, –Ω–µ —Å—Ç–æ–∏—Ç –Ω–∞ –º–µ—Å—Ç–µ, –ø–æ—ç—Ç–æ–º—É –º—ã –∑–∞–∫–æ–Ω—á–∏–º —Å—Ç–∞—Ç—å—é –ø–ª–∞–Ω–∞–º–∏ –∫–æ–º–∞–Ω–¥, –æ—Ç–≤–µ—á–∞—é—â–∏—Ö –∑–∞ —Å—Ä–µ–¥—É –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∏ –Ω–∞–¥—ë–∂–Ω–æ—Å—Ç—å. <br><br> –í –±–ª–∏–∂–∞–π—à–µ–º –±—É–¥—É—â–µ–º –º—ã —Ö–æ—Ç–∏–º –≤–Ω–µ–¥—Ä–∏—Ç—å –≤ –∫–æ–¥ gRPC –Ω–∞ Python –º–µ—Ö–∞–Ω–∏–∑–º —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤, –ø–µ—Ä–µ–π—Ç–∏ –Ω–∞ —Å–≤—è–∑—ã–≤–∞–Ω–∏—è –Ω–∞ C++ –≤ Python –∏ Rust –∏ –¥–æ–±–∞–≤–∏—Ç—å –ø–æ–ª–Ω—É—é –ø–æ–¥–¥–µ—Ä–∂–∫—É —à–∞–±–ª–æ–Ω–∞ —Ä–∞–∑—Ä—ã–≤–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –∏ –≤–Ω–µ—Å–µ–Ω–∏—è –Ω–µ–∏—Å–ø—Ä–∞–≤–Ω–æ—Å—Ç–µ–π. –ë–ª–∏–∂–µ –∫ –∫–æ–Ω—Ü—É –≥–æ–¥–∞ –º—ã –ø–ª–∞–Ω–∏—Ä—É–µ–º –∏–∑—É—á–∏—Ç—å –ø—Ä–æ—Ç–æ–∫–æ–ª ALTS –∏ –≤—ã–Ω–µ—Å—Ç–∏ TLS-—Ä—É–∫–æ–ø–æ–∂–∞—Ç–∏–µ –≤ –æ—Ç–¥–µ–ª—å–Ω—ã–π –ø—Ä–æ—Ü–µ—Å—Å (–≤–æ–∑–º–æ–∂–Ω–æ, –¥–∞–∂–µ –∑–∞ –ø—Ä–µ–¥–µ–ª—ã –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ —Å–µ—Ä–≤–∏—Å–æ–≤). </div><p>Source: <a href="https://habr.com/ru/post/438474/">https://habr.com/ru/post/438474/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>