<div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/ac/om/m5/acomm5x6os3ra7c0uew3upys2tm.jpeg"><br><br>  On Geektimes I often meet and enjoy reading posts from the DIY series.  Having decided to make a small contribution to the treasury of valuable experience gathered here, I am going to describe in detail the process of creating a client for the web based on the Line servers. <br><br>  <a href="https://devline.ru/sistema_videonabljudenija/">The video surveillance system "Line"</a> provides an open API, and the developers claim that based on it, you can write your own client to view the video archive and cameras online.  Also, if you wish, you can implement such functions as adding events to the archive, OSD overlaying video.  A description of all the features presented in the <a href="https://devline.ru/aboutweb/">specification on the official site</a> . <br><br>  This article is a real example, as I, a user with basic knowledge of JS, HTML, wrote my own application that implements the basic principles of working with Line servers through the embedded web server. <br><a name="habracut"></a><br>  Input data <br><br>  <b>The author</b> is a newcomer to the development of an HTML client, and is related to the development of the Liniya video surveillance system. <br>  <b>The level of knowledge of JS, HTML</b> - the initial. <br>  <b>The task</b> is to write an HTML client for working with devices based on Line software using the specifications from the site. <br><br>  I will reveal the main intrigue immediately - I came to two conclusions: <br><br><ol><li>  The specification is real, described quite clearly, you can write a client using C ++, PHP. </li><li>  A full-fledged HTML client, using only JS, cannot be written - only online observation is up to the RPC specification. </li></ol><br>  The first conclusion is quite natural, given the large number of integrations with third-party programs.  All of them are described on the website: there are <a href="https://devline.ru/skud/">access control systems</a> , <a href="https://devline.ru/vesovie/">weighing</a> , <a href="https://devline.ru/pos/">POS-systems</a> , programs for <a href="https://devline.ru/auto-numbers/">determining license plates</a> and <a href="https://devline.ru/1C/">1C</a> . <br><br>  The second conclusion is more interesting, consider it below. <br><br><h2>  Why it is impossible to create a full-fledged client on HTML + JS? </h2><br>  Answer: cross-domain requests. <br><br>  At the moment, the Lines web server is limited, and by simply copying the code into the www folder, access cannot be obtained.  However, the developers promise that in the new version for Linux and in “Line 8.0” the web server will work as standard: in case of a request, if there is a file, it will return it. <br><br>  Now we are creating a new project and starting to code.  Like all newbies in web programming, specifying that the Line server responds with "*" in the Access-Control-Allow-Origin header, I began to work hard on the code, checking the result on Firefox 57.0.4 (64-bit).  Requests to the server sent XMLHttpRequest. <br><br>  Initially it would be useful to study the information on <a href="https://learn.javascript.ru/xhr-crossdomain">this resource</a> .  Everything was described there in great detail, but I really wanted to complete the task as quickly as possible.  And, unfortunately, due to the lack of information, half a day was lost on beating his head against the wall of security policies of modern browsers. <br><br>  At the time of this writing, four main modern browsers do not allow to read the headers received from the server.  According to the specification, it is necessary to implement Digest-authorization, which is impossible without headers. <br><br>  By the end of the first day, I realized that without adding OPTIONS processing to the “Lines” web server, the browser does a OPTIONS pre-request for requests with a “hard” method or special headers, specifying them in the Access-Control-Request-Method and Access-Control-Request-Headers.  Therefore, I began to look for other authorization options, but the real Basic or Digest did not take off. <br><br>  An alternative method has already been described in the specification, it remained to spend some time in correspondence with the program department of "Line".  Since such difficulties arise not for the first time, there is already a crutch for authorization, and it is even mentioned in the specification: <br><blockquote>  On clients where it is impossible to authorize the request by standard means (HTTP Digest / Basic Authentication), the Authorization header can be transmitted by one of the request parameters, for example <br>  /kfd3ado1sdrms/streaming/main.flv?authorization=Basic%20d2ViOg== </blockquote><br>  After all the manipulations, the standard cross-domain query was correctly executed!  You must also add the Accept header with the correct type to the request - I decided to use JSON. <br><br>  Request Code: <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_request_url</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">method,current_server_data, resource, additional</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = current_server_data.server_ip + <span class="hljs-string"><span class="hljs-string">':'</span></span> +current_server_data.port +resource+<span class="hljs-string"><span class="hljs-string">'?authorization=Basic '</span></span>+ utf8_to_b64(current_server_data.user+<span class="hljs-string"><span class="hljs-string">':'</span></span>+current_server_data.password); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (additional != <span class="hljs-string"><span class="hljs-string">''</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> additional != <span class="hljs-string"><span class="hljs-string">"undefined"</span></span>) { request += <span class="hljs-string"><span class="hljs-string">'&amp;'</span></span> + additional; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http_request_of_resource</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">server_index , resource, auth_attempt</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = get_request_url(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, servers_array[server_index], resource,<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> req_ = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); req_.open(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'http://'</span></span>+ request, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">//req_.timeout = 9000; // выполнить код, когда придёт ответ req_.onreadystatechange = function() { if (this.readyState == 2) { if (this.status == 401) { //console.log('---unauthorized'); hideModal(); update_nessecary_structure(resource, 'unauthorized', server_index); } } else if (this.readyState === 4) { if (this.status === 0) { hideModal(); update_nessecary_structure(resource, 'server_down',server_index) } if (this.status == 200) { if (auth_attempt) hideModal(); else resource =(resource =='/cameras') ? resource+'_update_info': resource; //console.log('200' + this.responseText); update_nessecary_structure(resource, this.responseText, server_index); } else if (this.status == 404) { //console.log('404'); update_nessecary_structure(resource, '404', server_index); } } }; // Оправка запроса req_.setRequestHeader('Content-type', 'text/plain; charset=utf-8'); req_.setRequestHeader('Accept', 'application/json'); req_.send(); }</span></span></code> </pre> <br>  We change the resource to the one we need according to the specification and get some data.  The variable additional contains additional parameters for the query, if any.  At this, mastering the first half of the specification, namely receiving / sending text data through GET requests, can be considered closed. <br><br>  Next, I was faced with the fact that the IMG tag in IE does not play the MJPEG stream and I need to independently implement the update of the images from the cameras.  The code is open, it can be viewed and changed if desired.  In the current implementation, simultaneous playback of a maximum of six MJPEG streams is available, so work with the view that displays more cameras will have to be done by ourselves.  All this is in the <a href="">example</a> , if you want, you can find and understand, but if you have any questions, be sure to ask in the comments. <br><br><h2>  RPC specification </h2><br>  We are offered to send and receive data either in JSON (server version "Lines 7.1.1" and higher) or MessagePack (version "Line 7.0" and higher).  It is mentioned that MessagePack weighs less and works faster, but, honestly, I would choose JSON (it is already built in JS), if not for one thing but in the specification: getting frames from the archive is possible only in MessagePack.  I had to go to their <a href="https://msgpack.org/">official website</a> and download the JS-file, which has onboard methods encode and decode. <br><br>  The request sending function is ready!  But it is too early to celebrate victory: when you try to change the request header of the Content-type, the browser swears and does not send data to the server.  The fact is that the Lines server analyzes this field and performs parsing, depending on the type.  On my own I could not do further. <br><br>  I sent a request to the program department, and after the discussion I was added a crutch, as in the case of authorization, the Content-type will be transmitted in the url request: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rpc_request_of_resource</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">current_server_data , rpc_method, rpc_request</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = get_request_url(<span class="hljs-string"><span class="hljs-string">'POST'</span></span>, current_server_data, <span class="hljs-string"><span class="hljs-string">'/rpc'</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-comment"><span class="hljs-comment">//console.log("i'm here request = " + request + ' '+ current_server_data.user); request += "&amp;content-type='application/x-msgpack'"; var req_ = new XMLHttpRequest(); req_.open('POST', 'http://'+ request, true); // выполнить код, когда придёт ответ req_.responseType = 'arraybuffer'; req_.onreadystatechange = function() { if (this.readyState == 2) { if (this.status == 401) { //console.log('401' + this.getAllResponseHeaders()); console.log('unauthorized'); } } else if (this.readyState == 4) { if (this.status == 200) { //if (auth_attempt) hideModal(); //console.log('200' + this.responseText); rpc_update_nessecary_method(rpc_method, this.response); } else if (this.status == 404) { console.log('404'); } else if (this.status == 500) { //console.log('500'); rpc_update_nessecary_method(rpc_method, '500'); } } }; // Оправка запроса //req_.setRequestHeader('Content-type', 'text/plain; charset=utf-8'); //req_.setRequestHeader('Content-type', 'application/x-msgpack'); req_.setRequestHeader('Accept', 'application/x-msgpack'); req_.send(rpc_request); }</span></span></code> </pre> <br>  This change will work from the version "Line 7.4.1" and higher.  For all servers below this version, working with the resource / rpc will be unavailable. <br><br>  In the end, I want to thank all the clients who sent us questions / suggestions related to the implementation of applications based on our API.  Thanks to you, a study was conducted in which some shortcomings were identified and corrected. <br><br>  The example described in this article will gradually grow into the full-fledged HTML-client of the Line.  All code will be readable, you can change it or use it as a basis for building your own solutions.  API will eventually be filled with even more opportunities, which we will definitely inform. </div>