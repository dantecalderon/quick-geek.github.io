<div class="post__text post__text-html js-mediator-article">  Operating systems (OS) is an extensive topic.  For decades, one approach has dominated here: Unix.  Indeed, most modern systems, including most GNU / Linux distributions, * BSD and macOS, adhere to the Unix architecture.  (Windows is not, but there is almost nothing interesting on this topic). <br><br>  In 2000, Rob Pike made a presentation on why <a href="http://doc.cat-v.org/bell_labs/utah2000/utah2000.html">system software research is not relevant</a> .  Due to pessimism or neglect of the community, he seems to have completely ignored the complaints collected by many Unix-users in <a href="https://web.mit.edu/~simsong/www/ugh.pdf">The Unix-Haters Handbook</a> (1994).  The book is intentionally sarcastic, but it points to some critical problems of Unix systems — and they have not been solved yet. <br><br>  In 2006, Elko Dositra published his thesis <a href="https://nixos.org/~eelco/pubs/phd-thesis.pdf">“A fully functional model of software deployment,”</a> which describes the functional package manager Nix.  In 2008, the author published <a href="https://nixos.org/~eelco/pubs/nixos-icfp2008-final.pdf">NixOS: a fully functional distribution of Linux</a> .  While NixOS reuses a lot of free software for Unix systems, it is so far away from the design and philosophy of Unix that it can hardly be called a "Unix system." <br><a name="habracut"></a><br>  Nix - a giant step forward in system development.  This OS not only solved many Unix problems (including criticism from the aforementioned collection), but also opened the way for many other functions and research that can play a very important role in our time, when reliability and security have become the main theme of many scientific, public and political debates. <br><br>  Pike was wrong.  And this proves another more general point: it is probably wiser to refrain from declaring the irrelevance of any research if you cannot prove the impossibility of further development.  And the mentioned report can hardly be considered a mathematical proof.  He only reinforced the idea that Unix is ​​“good enough” and that one should come to terms with its features and problems. <br><br>  Fortunately, this unnecessary pessimism was short-sighted and did not survive for long: just a couple of years later, the Nix system proved him wrong. <br><br><h1>  Guix appearance </h1><br>  <a href="https://guix.info/">Guix</a> is the package manager on Nix, and GuixSD is the operating system, the equivalent of NixOS, which aims to be a “fully programmable OS.”  Indeed, almost everything here is written and configured in <a href="https://gnu.org/software/guile/">Guile Scheme</a> : from Guix package management to the <a href="https://www.gnu.org/software/shepherd/">GNU shepherd</a> initialization system. <br><br>  Guix is ​​significantly different from Unix operating systems.  You can view the documentation and assess the degree of change: <br><br><ul><li>  <a href="https://www.gnu.org/software/guix/manual/">Official Guide</a> and <a href="https://www.gnu.org/software/guix/manual/en/html_node/Features.html">Feature List</a> </li><li>  <a href="https://www.gnu.org/software/guix/blog/2018/a-packaging-tutorial-for-guix/">Guix package guide</a> is a technical introduction (copy <a href="https://ambrevar.xyz/guix-packaging/index.html">here</a> ). </li></ul><br><h1>  Guix Benefits </h1><br>  The advantages of Guix are revolutionary to such an extent that the rest of the operating systems look outdated compared to it. <br><br>  My personal favorite features: <br><br><ul><li>  System Invulnerability: Guix keeps a history of all changes at both the system and user levels.  If the update breaks something, you can always roll back.  This makes the system virtually <i>invulnerable</i> . <br></li><li>  Integrity: since the configuration is declarative, it gives the user or system administrator complete control.  On other versions, Unix is ​​much more difficult to tell when a random configuration file changes. <br></li><li>  Fully programmable OS: program system configurations and use version control system.  Many system services can be configured in Guile Scheme: from udev rules to Xorg, PAM, etc. Thanks to Guile, the configuration can be driven by hardware or even by the host name! <br></li><li>  Direct replacement to other (not so good) package managers: why manage Emacs, Python or TeXlive packages separately, if there is a single interface for everyone (see <a href="https://habr.com/ru/post/436938/">below</a> )!  It's easier to write and maintain declarations for user profiles. <br></li><li>  Package definitions with Guile: It’s much more efficient to develop package definitions in <i>bulk</i> .  It favorably replaces concepts such as the Portage USE flags (see <a href="https://habr.com/ru/post/436938/">below</a> ). <br></li><li>  Several ways of issuing packages: A Guix package may have several “ways of issuing”, which serve to separate various components (libraries, additional tools, documentation, etc.).  On other operating systems (usually Debian), it is more difficult to guess which packages are suitable for each other. <br></li><li> Non-propagated inputs: In Guix terminology, “inputs” are package dependencies.  The user profile and environment contain only explicitly installed user packages and not necessarily their dependencies.  For example, see <a href="https://smxi.org/docs/inxi.htm">inxi</a> - a system information reporting tool: if I’m only interested in inxi system / hardware reports, it’s not necessary to add two or three dozen additional command line tools to the <code>PATH</code> .  Guix allows you to display only what you really need in your user profile. <br></li><li>  Guix Environments: When you run <code>guix environment SOME-PACKAGES</code> Guix sets up a temporary environment where all the requirements for <code>SOME-PACKAGES</code> .  This can be used to easily set up the build environment for a project, as well as for other purposes (see below).  One remarkable quality - they allow you to run programs without setting them in the user profile. <br></li><li>  Partial updates: 100% supported.  This is probably the main reason for breakdowns in floating releases like Arch Linux and Gentoo: since there are only a few versions supported at the same time (usually only one), the whole system should be updated as a whole.  This means more traffic with each update.  With Guix, any package is updated separately. <br></li><li>  Continuous integration or why Guix can work without package maintainers: thanks to <a href="https://reproducible-builds.org/">reproducible builds</a> and support for partial updates, if a package works in Guix, it will work “always” and will not break with the next update of some dependency (more precisely, if the dependency breaks the package, then it is trivially corrected to use the correct version of the library).  Thus, work with packages can be transferred to “assembly farms” (one to <a href="https://hydra.gnu.org/jobset/gnu/master">Hydra</a> from the Nix project, the other to <a href="https://ci.guix.info/">Cuirass</a> ).  Compare this with most other GNU / Linux communities, which require dozens of maintainers to update thousands of packages.  This approach does not scale: as a result, these distributions stagnate on a couple of thousand packages.  In Guix, the number of packages can easily grow without fear of collapse.  At the same time, contributors can be used more efficiently. <br><br>  Guix is ​​just as easy to build from source.  In fact, this is not so important for the end user: Guix can easily go back to building from source if the complete package is not available. <br></li><li>  <code>guix import</code> and <code>guix refresh</code> : automatic and recursive creation or updating of package definitions.  Hundreds of definitions are processed simultaneously.  Such functions emphasize the advantages of a real programming language in the OS.  What is a difficult task in most operating systems is relatively easy to implement in Guix. <br></li><li>  Guix channels: one of my favorite features!  In Arch Linux or Gentoo, you need to create a local repository.  Since they do not support partial updates, the user must do some maintenance from time to time (i.e., make sure that dependency updates do not break packages).  Guix feeds take advantage of AUR from Arch Linux and Gentoo overlays, allowing anyone to distribute their package definitions, for example, from Git repositories.  Again, this guarantees full transparency (kickbacks, history, etc.). <br></li><li>  <a href="https://emacs-guix.gitlab.io/website/">Emacs-Guix</a> : as far as I know, Guix is ​​the only distribution that comes with the most powerful Emacs user interface! <br></li><li>  <a href="https://www.gnu.org/software/guix/blog/2018/tarballs-the-ultimate-container-image-format/">Guix packs</a> : a real alternative to containers like Docker.  Most container systems suffer from critical issues: they are not reproducible and in reality are opaque binaries, which is <a href="https://lwn.net/Articles/752982/">totally unacceptable</a> for users who care about trust, security and privacy.  In contrast, Guix packs are absolutely clear, reproducible and transparent. <br></li><li>  <code>guix system vm</code> and <code>guix system disk-image</code> : Guix makes it trivial to play the entire current system as a live USB, inside a VM or on a remote machine. </li></ul><br><h1>  Guix compared to competitors </h1><br><h3>  Debian, Arch Linux, and most other GNU / Linux distributions </h3><br>  GNU / Linux distributions usually lack the above-mentioned Guix benefits.  The most critical shortcomings: <br><br><ul><li>  Lack of support for multiple package versions or “dependency hell”.  Let's say the last mpv requires a new ffmpeg, but updating ffmpeg breaks most other programs.  We are stuck in a dilemma: either we break some packages, or we keep old versions.  Worse, it may not be the right package at all or there is no OS support.  This problem is inherent in most distributions that cannot guarantee the performance of their main task: a package for <i>any</i> program. <br></li><li>  Critical dependence on maintainers.  Non-functional package management means that all packages need to be constantly tested for compatibility.  This is a lot of hard work for those who have shouldered this task.  In practice, this means that the quality of package management is highly dependent on people.  A distribution without sufficient number of maintainers will inevitably suffer and possibly die.  This labor requirement does not normally scale and as the number of packages increases, it leads to an increase in complexity (both in the code base and in management). </li></ul><br><a name="2"></a><h3>  Gentoo, * BSD </h3><br>  <a href="https://www.gentoo.org/">Gentoo</a> and other distributions with <a href="https://wiki.gentoo.org/wiki/Project:Portage">Portage's</a> package manager have a famous feature: <a href="https://wiki.gentoo.org/wiki/Project:Portage">USE flags</a> to activate features throughout the system (for example, mute, enable GUI support, etc.). <br><br>  USE flags make it trivial to enable and disable features from the package author (and the advantage is that they are tested).  Portage, on the other hand, does not allow functions that are not thought out in advance.  For example, if the package has an additional sound, but the author has not set the corresponding flag, the user will not be able to do anything about it (except for creating a new package definition). <br><br>  By comparison, Guix allows full customization of everything, albeit with a little more Scheme code.  In pseudocode, it looks like this: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">loop-over</span></span> (<span class="hljs-name"><span class="hljs-name">TARGET-PACKAGES</span></span>) (<span class="hljs-name"><span class="hljs-name">package</span></span> (<span class="hljs-name"><span class="hljs-name">inherit</span></span> TARGET) (<span class="hljs-name"><span class="hljs-name">changes-here</span></span>... including patches, build options, etc.))</code> </pre> <br>  This code batch sets the definitions for <code>TARGET-PACKAGES</code> with your changes.  None of the changes need to be made to the package definition.  At any time, the user retains full control over the changes that can be made to the packages. <br><br>  I loved Gentoo, but after switching to Guix, the limitations of Portage became apparent. <br><br><ul><li>  The USE flags system does not allow customizing unplanned arbitrary functions. <br></li><li>  The use of flags adds a whole class of complexity (see the rather complex <a href="https://dev.gentoo.org/~zmedico/portage/doc/man/ebuild.5.html">semantics of atom</a> ) to describe and manage the relationship of functions between packages.  Guix completely removes this level of complexity using Guile Scheme to program relationships. </li></ul><br>  In addition, Portage suffers from the same problem with the lack of proper support for multiple versions, and the flags significantly increase the scale of the problem (a frequent complaint about Portage): when incompatible USE flags are applied to some dependencies, the user has to manually search for a solution.  Sometimes this means that the required function is not applicable (at least without substantial work on package definitions). <br><br>  In practice, Guix provides precompiled packages - a huge time saving compared to Gentoo (although Portage supports the distribution of binary packages). <br><br>  * BSD systems (for example, FreeBSD) suffer from similar problems in <code>make config</code> . <br><br><h3>  Nix </h3><br>  Nix was a historic breakthrough in operating system research, and Guix borrowed almost all of its ideas from there.  Today, Nix is ​​still one of the best active OSes.  Probably, Guix would not exist if it were not for one drawback. <br><br>  In my opinion, Guix solves the basic problem of Nix: instead of its own <a href="https://en.wikipedia.org/wiki/Domain-specific_language">domain-specific language</a> (DSL), the full-fledged Lisp <a href="https://en.wikipedia.org/wiki/Domain-specific_language">-based programming language</a> is used here. <br><br>  “Implementing your own programming language” is a very common misconception in software development.  This hit hard on many projects where the configuration or programming language suffered from the following flaws: <br><br><ul><li>  limited expressiveness and possibilities; <br></li><li>  another language to learn (but not something very useful and universal) that requires some effort from the user and thus creates an entry barrier; <br></li><li>  less readable code (at least at first); <br></li><li>  often poor performance. </li></ul><br>  There are a huge number of projects in homegrown or too limited languages: <br><br><ul><li>  XML, HTML (even better: <a href="https://en.wikipedia.org/wiki/SXML">S-XML</a> ) </li><li>  Make, Autoconf, Automake, Cmake, etc. </li><li>  Bash, Zsh, Fish (even better: Eshell or <a href="https://github.com/scheme/scsh">scsh</a> ) </li><li>  JSON, TOML, YAML </li><li>  <a href="https://wiki.gentoo.org/wiki/Ebuild">Ebuilds</a> from Portage to Nix and many other syntax rules for defining OS packages </li><li>  Firefox when using XUL (since Mozilla refused it) and most other homegrown languages ​​for extensions </li><li>  SQL </li><li>  Octave, R, PARI / GP, most scientific programs (for example, Common Lisp, Racket, and other Scheme) </li><li>  Regular expressions ( <a href="http://francismurillo.github.io/2017-03-30-Exploring-Emacs-rx-Macro/">rx in Emacs</a> , <a href="https://docs.racket-lang.org/peg/index.html">PEG in Racket</a> , etc.) </li><li>  sed, awk and others </li><li>  Most configurations for init, including systemd (even better: <a href="https://www.gnu.org/software/shepherd/">GNU Shepherd</a> ) </li><li>  cron (even better: <a href="https://www.gnu.org/software/mcron/">mcron</a> ) </li><li>  conky (not fully programmable, although it should be the most expected feature of a similar program) </li><li>  TeX, LaTeX (and all derivatives), Asymptote (even better: <a href="https://docs.racket-lang.org/scribble/index.html">scribble</a> , <a href="http://www.nongnu.org/skribilo/">skribilo</a> - still in development; as of January 2019, TeX / LaTeX is still used as an intermediate step in preparing the PDF) </li><li>  Most programs with configurations that do not use a general-purpose programming language. </li></ul><br>  Reinventing a wheel is usually not a good idea.  When it comes to such important tools as programming languages, this has very dramatic consequences.  Requires unnecessary extra effort, errors occur.  The community is dissipating.  More consolidated communities are more efficient and use their time better if they improve existing, well-developed programming languages. <br><br><h1>  Not just for the desktop </h1><br>  Guix supports several architectures (i686, x86_64, ARMv7, and AArch64 as of January 2019), and plans to support more kernels outside the Linux ecosystem (say, * BSD, <a href="https://www.gnu.org/software/hurd/index.html">GNU Hurd,</a> or maybe your own system!). <br><br>  This makes Guix a great tool for deploying (reproducible) servers and other specialized systems.  I think that in embedded systems Guix can compete very well with <a href="https://openwrt.org/">OpenWRT</a> (although it will take some work on porting to embedded systems). <br><br><h1>  Self-reproducible live USB </h1><br>  Above, I mentioned the <code>guix system disk-image</code> : for example, it allows you to recreate the current system on a USB flash drive. <br><br>  Thus, a clone of the current system is easy to connect anywhere and replicate the exact current environment (minus the hardware).  There you can include user data: PGP keys, email.  Everything is available immediately after the download. <br><br>  Obviously, the cloning works further with the machine on which the clone is installed: instead of the “naked” Guix, a full-fledged OS is deployed, ready for work. <br><br><a name="1"></a><h1>  Replacing other package managers </h1><br><h3>  Emacs, Python, Ruby ... and the power of the <code>guix environment</code> </h3><br>  Guix can replace any package manager, including programming language package managers.  It has several advantages: <br><br><ul><li>  Ubiquitous reproducibility. <br></li><li>  Ubiquitous kickbacks. <br></li><li>  No need to learn another package manager. </li></ul><br>  At this point, you should mention the <code>guix environment</code> .  This command only sets up a temporary environment with a specific set of packages, like <code>virtualenv</code> .  Killer feature is that it is universal for all languages ​​and their combinations. <br><br><h3>  Texlive </h3><br>  (Disclaimer: as of January 2019, the TeXlive assembly system for Guix is ​​being modified). <br><br>  TeXlive received a special mention, because it is especially awful :), which once again confirms the saving role of Guix! <br><br>  Most Unix-based operating systems typically distribute TeXlive as part of a set of packages.  For example, in Arch Linux there are a dozen of these.  If you need some TeX packages from different sets, then Arch Linux leaves no choice but to install thousands (possibly unnecessary) packages, and TeXlive takes up a <i>lot of</i> space: hundreds of megabytes. <br><br>  Alternatively, you can install TeXlive manually, but let's face it: <code>tlmgr</code> is just a bad batch manager, and it requires tedious additional work. <br><br>  Using Guix, TeXlive packages are installed separately, like everything else that helps you keep your own set of TeXlive packages or even create virtual environment specifications for compiling specific documents. <br><br><h1>  Core </h1><br>  Many operating systems offer only limited support for non-standard kernels.  If users want to move away from the default kernel, the non-standard kernel has to be manually maintained. <br><br>  Gentoo is known to "require" a custom kernel as a recommended (required?) Installation step.  However, this is hardly a mandatory requirement, and users themselves must support the configuration of the kernel. <br><br>  In Guix, the kernel is a fully customizable regular package, just like any other.  You can customize everything and transfer the kernel configuration file to the package definition. <br><br>  For example, the following are the definitions of a non-free Linux kernel with the <code>iwlwifi</code> driver (warning: I strongly advise against using proprietary drivers, as they pose a serious threat to your privacy and freedom): <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define-module</span></span> (<span class="hljs-name"><span class="hljs-name">ambrevar</span></span> linux-custom) #<span class="hljs-symbol"><span class="hljs-symbol">:use-module</span></span> (<span class="hljs-name"><span class="hljs-name">guix</span></span> gexp) #<span class="hljs-symbol"><span class="hljs-symbol">:use-module</span></span> (<span class="hljs-name"><span class="hljs-name">guix</span></span> packages) #<span class="hljs-symbol"><span class="hljs-symbol">:use-module</span></span> (<span class="hljs-name"><span class="hljs-name">guix</span></span> download) #<span class="hljs-symbol"><span class="hljs-symbol">:use-module</span></span> (<span class="hljs-name"><span class="hljs-name">guix</span></span> git-download) #<span class="hljs-symbol"><span class="hljs-symbol">:use-module</span></span> (<span class="hljs-name"><span class="hljs-name">guix</span></span> build-system trivial) #<span class="hljs-symbol"><span class="hljs-symbol">:use-module</span></span> ((<span class="hljs-name"><span class="hljs-name">guix</span></span> licenses) #<span class="hljs-symbol"><span class="hljs-symbol">:prefix</span></span> license:) #<span class="hljs-symbol"><span class="hljs-symbol">:use-module</span></span> (<span class="hljs-name"><span class="hljs-name">gnu</span></span> packages linux) #<span class="hljs-symbol"><span class="hljs-symbol">:use-module</span></span> (<span class="hljs-name"><span class="hljs-name">srfi</span></span> srfi-1)) (<span class="hljs-name"><span class="hljs-name">define-public</span></span> linux-nonfree (<span class="hljs-name"><span class="hljs-name">package</span></span> (<span class="hljs-name"><span class="hljs-name">inherit</span></span> linux-libre) (<span class="hljs-name"><span class="hljs-name">name</span></span> <span class="hljs-string"><span class="hljs-string">"linux-nonfree"</span></span>) (<span class="hljs-name"><span class="hljs-name">version</span></span> (<span class="hljs-name"><span class="hljs-name">package-version</span></span> linux-libre)) (<span class="hljs-name"><span class="hljs-name">source</span></span> (<span class="hljs-name"><span class="hljs-name">origin</span></span> (<span class="hljs-name"><span class="hljs-name">method</span></span> url-fetch) (<span class="hljs-name"><span class="hljs-name">uri</span></span> (<span class="hljs-name"><span class="hljs-name">string-append</span></span> <span class="hljs-string"><span class="hljs-string">"https://www.kernel.org/pub/linux/kernel/v4.x/"</span></span> <span class="hljs-string"><span class="hljs-string">"linux-"</span></span> version <span class="hljs-string"><span class="hljs-string">".tar.xz"</span></span>)) (<span class="hljs-name"><span class="hljs-name">sha256</span></span> (<span class="hljs-name"><span class="hljs-name">base32</span></span> <span class="hljs-string"><span class="hljs-string">"1lm2s9yhzyqra1f16jrjwd66m3jl43n5k7av2r9hns8hdr1smmw4"</span></span>)))) (<span class="hljs-name"><span class="hljs-name">native-inputs</span></span> `((<span class="hljs-string"><span class="hljs-string">"kconfig"</span></span> ,(local-file <span class="hljs-string"><span class="hljs-string">"./linux-custom.conf"</span></span>)) ,@(alist-delete <span class="hljs-string"><span class="hljs-string">"kconfig"</span></span> (package-native-inputs linux-libre)))))) (<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">linux-firmware-version</span></span>) <span class="hljs-string"><span class="hljs-string">"9d40a17beaf271e6ad47a5e714a296100eef4692"</span></span>) (<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">linux-firmware-source</span></span> version) (<span class="hljs-name"><span class="hljs-name">origin</span></span> (<span class="hljs-name"><span class="hljs-name">method</span></span> git-fetch) (<span class="hljs-name"><span class="hljs-name">uri</span></span> (<span class="hljs-name"><span class="hljs-name">git-reference</span></span> (<span class="hljs-name"><span class="hljs-name">url</span></span> (<span class="hljs-name"><span class="hljs-name">string-append</span></span> <span class="hljs-string"><span class="hljs-string">"https://git.kernel.org/pub/scm/linux/kernel"</span></span> <span class="hljs-string"><span class="hljs-string">"/git/firmware/linux-firmware.git"</span></span>)) (<span class="hljs-name"><span class="hljs-name">commit</span></span> version))) (<span class="hljs-name"><span class="hljs-name">file-name</span></span> (<span class="hljs-name"><span class="hljs-name">string-append</span></span> <span class="hljs-string"><span class="hljs-string">"linux-firmware-"</span></span> version <span class="hljs-string"><span class="hljs-string">"-checkout"</span></span>)) (<span class="hljs-name"><span class="hljs-name">sha256</span></span> (<span class="hljs-name"><span class="hljs-name">base32</span></span> <span class="hljs-string"><span class="hljs-string">"099kll2n1zvps5qawnbm6c75khgn81j8ns0widiw0lnwm8s9q6ch"</span></span>)))) (<span class="hljs-name"><span class="hljs-name">define-public</span></span> linux-firmware-iwlwifi (<span class="hljs-name"><span class="hljs-name">package</span></span> (<span class="hljs-name"><span class="hljs-name">name</span></span> <span class="hljs-string"><span class="hljs-string">"linux-firmware-iwlwifi"</span></span>) (<span class="hljs-name"><span class="hljs-name">version</span></span> (<span class="hljs-name"><span class="hljs-name">linux-firmware-version</span></span>)) (<span class="hljs-name"><span class="hljs-name">source</span></span> (<span class="hljs-name"><span class="hljs-name">linux-firmware-source</span></span> version)) (<span class="hljs-name"><span class="hljs-name">build-system</span></span> trivial-build-system) (<span class="hljs-name"><span class="hljs-name">arguments</span></span> `(#<span class="hljs-symbol"><span class="hljs-symbol">:modules</span></span> ((guix build utils)) #<span class="hljs-symbol"><span class="hljs-symbol">:builder</span></span> (begin (use-modules (guix build utils)) (let ((source (assoc-ref %build-inputs <span class="hljs-string"><span class="hljs-string">"source"</span></span>)) (fw-dir (string-append %output <span class="hljs-string"><span class="hljs-string">"/lib/firmware/"</span></span>))) (mkdir-p fw-dir) (for-each (lambda (file) (copy-file file (string-append fw-dir (basename file)))) (find-files source <span class="hljs-string"><span class="hljs-string">"iwlwifi-.*\\.ucode$|LICENSE\\.iwlwifi_firmware$"</span></span>)) #t)))) (<span class="hljs-name"><span class="hljs-name">home-page</span></span> <span class="hljs-string"><span class="hljs-string">"https://wireless.wiki.kernel.org/en/users/drivers/iwlwifi"</span></span>) (<span class="hljs-name"><span class="hljs-name">synopsis</span></span> <span class="hljs-string"><span class="hljs-string">"Non-free firmware for Intel wifi chips"</span></span>) (<span class="hljs-name"><span class="hljs-name">description</span></span> <span class="hljs-string"><span class="hljs-string">"Non-free iwlwifi firmware"</span></span>) (<span class="hljs-name"><span class="hljs-name">license</span></span> (<span class="hljs-name"><span class="hljs-name">license</span></span><span class="hljs-symbol"><span class="hljs-symbol">:non-copyleft</span></span> <span class="hljs-string"><span class="hljs-string">"https://git.kernel.org/cgit/linux/kernel/git/firmware/linux-firmware.git/tree/LICENCE.iwlwifi_firmware?id=HEAD"</span></span>))))</code> </pre> <br>  Custom kernel and firmware can be conditionally included in the current system configuration (some file <code>config.scm</code> ): <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> *lspci* (<span class="hljs-name"><span class="hljs-name">let*</span></span> ((<span class="hljs-name"><span class="hljs-name">port</span></span> (<span class="hljs-name"><span class="hljs-name">open-pipe*</span></span> OPEN_READ <span class="hljs-string"><span class="hljs-string">"lspci"</span></span>)) (<span class="hljs-name"><span class="hljs-name">str</span></span> (<span class="hljs-name"><span class="hljs-name">get-string-all</span></span> port))) (<span class="hljs-name"><span class="hljs-name">close-pipe</span></span> port) str)) (<span class="hljs-name"><span class="hljs-name">operating-system</span></span> (<span class="hljs-name"><span class="hljs-name">host-name</span></span> <span class="hljs-string"><span class="hljs-string">"..."</span></span>) <span class="hljs-comment"><span class="hljs-comment">;;... (kernel (cond ((string-match "Network controller: Intel Corporation Wireless 8888" *lspci*) linux-nonfree) (#t linux-libre))) (firmware (append (list linux-firmware-iwlwifi) %base-firmware))</span></span></code> </pre> <br>  Then follow these steps to install the new system configuration: <br><br><pre> <code class="bash hljs">sudo -E guix system reconfigure config.scm</code> </pre> <br>  Without even installing a new kernel, you can directly create an image ready for booting from a USB drive. <br><br><h1>  Games </h1><br>  Since Guix packages use advanced technologies (for example, the latest versions of Mesa) and allow full kernel tuning, this is an ideal platform for games and, in particular, for <i>packaging</i> games! <br><br>  Unfortunately, the game industry is still far from the free software philosophy, and very few games are packaged as part of the official Guix project. <br><br>  Although Guix stands for free software and doesn’t accept any proprietary rights in its repository, ironically, many advanced features make Guix an ideal package manager for non-free software. <br><br>  Some of the benefits are: <br><br><ul><li>  <code>guix environment</code> allows you to run any application in an isolated container that restricts network access, hides the file system (there is no risk that a proprietary program will steal any of your files, say, a bitcoin wallet or PGP keys) and even system-level information such as as username.  This is necessary to run any unreliable closed source program. <br></li><li>  Functional package management: closed source programs usually do not stand the test of time and break down when a library dependency changes its API.  Because Guix detects packages on top of any version of any dependency (without conflicts with the current system), Guix allows you to create packages for closed-source games that work forever. <br></li><li>  Reproducible environment: closed source programs are usually poorly tolerated and can behave differently in systems with slightly different dependencies.  The reproducibility feature of Guix implies that if we make the Guix package work once, it will always work (except for hardware breakdown or a change in hardware configuration). </li></ul><br>  For these reasons, Guix is ​​the perfect tool for packaging and distributing closed source games. <br><br>  However, this is a large separate topic, which is best left for another article. <br><br><h1>  Tips and Tips </h1><br><h3>  Emacs-guix </h3><br>  One of the amazing benefits of Guix is ​​the <a href="https://emacs-guix.gitlab.io/website/">Emacs-Guix interface</a> , which allows you to install and remove packages, selectively update, search, go to package definition, manage generations, print "differences" between them, and much more. <br><br>  It has design modes for assembly and programming, as well as a special interactive environment Scheme <a href="https://en.wikipedia.org/wiki/Read%25E2%2580%2593eval%25E2%2580%2593print_loop">REPL</a> .  This is a unique user interface for the operating system. <br><br>  There is also the <a href="https://github.com/emacs-helm/helm-system-packages">Helm System Packages</a> interface, which partially overlaps with Emacs-Guix, but it seems to me more pleasant for quick package searching and quick operations. <br><br><h3>  Data storage </h3><br>  Since Guix saves several generations of system configurations (including the entire package history), it requires more disk space than other operating systems. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In my experience, in 2018, section 25 GB had to be cleaned about once a month (taking into account that I have large requests for the number of packages), and the section 50 GB can not be touched for a whole year. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is convenient to use the command to clear the storage </font></font><code>guix gc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but it can remove “too many packages”, that is, packages that will be needed immediately upon the next update. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Emacs-Guix has a command </font></font><code>mx guix-store-dead-item</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that sorts dead packets by size and allows you to delete them individually. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you need to analyze dependencies, look at </font></font><code>guix gc --references</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>guix gc --requisites</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This can be combined with the output result </font></font><code>guix build ...</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to see the different elements of the dependency graph.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For example, to view the code for one of the build scripts, open the file returned by the following command: </font></font><br><br><pre> <code class="bash hljs">$ guix gc --references $(guix build -d coreutils) | grep builder /gnu/store/v02xky6f5rvjywd7ficzi5pyibbmk6cq-coreutils-8.29-guile-builder</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Manifest generation </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is often useful to generate a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">manifest of</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> all packages installed in a profile. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This can be done using the following Guile script:</font></font><br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">use-modules</span></span> (<span class="hljs-name"><span class="hljs-name">guix</span></span> profiles) (<span class="hljs-name"><span class="hljs-name">ice-9</span></span> match) (<span class="hljs-name"><span class="hljs-name">ice-9</span></span> pretty-print)) (<span class="hljs-name"><span class="hljs-name">match</span></span> (<span class="hljs-name"><span class="hljs-name">command-line</span></span>) ((<span class="hljs-name"><span class="hljs-name">_</span></span> where) (<span class="hljs-name"><span class="hljs-name">pretty-print</span></span> `(specifications-&gt;manifest ',(map manifest-entry-name (manifest-entries (profile-manifest where)))))) (<span class="hljs-name"><span class="hljs-name">_</span></span> (<span class="hljs-name"><span class="hljs-name">error</span></span> <span class="hljs-string"><span class="hljs-string">"Please provide the path to a Guix profile."</span></span>)))</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, run it on the profile </font></font><code>~/.guix-profile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="bash hljs">$ guile -s manifest-to-manifest.scm ~/.guix-profile</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">My </font></font><a href="https://gitlab.com/ambrevar/dotfiles"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dotfiles</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> track the history of installed packages. </font><font style="vertical-align: inherit;">Since I also save the Guix version, I can return to the exact state of my system at any time in the past.</font></font><br><br><h1>  Links </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Some web interfaces: </font></font><br><br><ul><li> <a href="https://guix-hpc.bordeaux.inria.fr/browse%3F"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Guix Package List</font></font></a> <br></li><li> <a href="https://issues.guix.info/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Error message tracker</font></font></a> <br></li><li>  <a href="https://libreplanet.org/wiki/Group:Guix/Wishlist">Wishes</a> </li></ul><br>  Documents: <br><br><ul><li> <a href="https://arxiv.org/abs/1709.00833"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNU Guix "staging code"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (why Lisp played an important role in development)</font></font><br></li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peter's Notes</font></font></a> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Informal packages: </font></font><br><br><ul><li> <a href="https://gitlab.com/mbakke/guix-chromium"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chromium Packet Channel</font></font></a> <br></li><li> <a href="https://notabug.org/wigust/guix-wigust/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oleg Pykhalov's packages</font></font></a> </li></ul></div>