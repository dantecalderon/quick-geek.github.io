<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Transferring 30,000 lines of code from Flow to TypeScript</title>
  <meta name="description" content="We recently moved 30 thousand lines of JavaScript from our MemSQL Studio system from Flow to TypeScript. In this article I will explain why we ported ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Transferring 30,000 lines of code from Flow to TypeScript</h1><div class="post__text post__text-html js-mediator-article">  We recently moved 30 thousand lines of JavaScript from our <a href="https://www.memsql.com/manage/">MemSQL Studio</a> system from Flow to TypeScript.  In this article I will explain why we ported the code base, how it happened and what happened. <br><br>  <i>Disclaimer: my goal is not a criticism of Flow at all.</i>  <i>I admire the project and think that there is enough room in the JavaScript community for both types of type checking.</i>  <i>In the end, everyone will choose what suits him best.</i>  <i>I sincerely hope that the article will help in this choice.</i> <br><br>  First I will bring you up to date.  We at <a href="https://www.memsql.com/">MemSQL are</a> big fans of static and strong JavaScript typing to avoid common problems with dynamic and weak typing. <br><a name="habracut"></a><br>  Speech about common problems: <br><br><ol><li>  Errors of type in runtime due to the fact that different parts of the code are not consistent with implicit types. </li><li>  Too much time is spent writing tests for such trivial things as checking type parameters (checking in runtime also increases the size of the package). </li><li>  There is not enough editor / IDE integration, because without static typing it is much more difficult to implement the Jump to Definition function, mechanical refactoring and other functions. </li><li>  There is no possibility to write code around data models, that is, first to design data types, and then the code basically ‚Äúwrites itself‚Äù. </li></ol><br>  These are just some of the benefits of static typing, even more listed in a <a href="https://davidgom.es/what-i-wish-i-had-known-before-starting-to-use-flow/">recent article on Flow</a> . <br><br>  At the beginning of 2016, we implemented <a href="https://github.com/gcanti/tcomb">tcomb</a> to implement some type security in the runtime of one of our internal JavaScript projects (a disclaimer: I was not involved in this project).  Although runtime checking is sometimes useful, it doesn‚Äôt even offer all the advantages of static typing (combining static typing with type checking in runtime may be suitable for certain cases, <a href="https://github.com/gcanti/io-ts">io-ts</a> allows you to do this using tcomb and TypeScript, although I have never tried ).  Understanding this, we decided to implement Flow for another project that we started in 2016.  At that time, Flow seemed like a great choice: <br><br><ul><li>  Support for Facebook, which did an amazing job of developing React and growing the community (they also developed React <i>using</i> Flow). </li><li>  Approximately the same ecosystem of JavaScript-development.  It was scary to refuse <a href="https://babeljs.io/">Babel</a> for tsc (TypeScript compiler), because we lost the flexibility of switching to another type check (obviously, the situation has changed since then). </li><li>  You do not need to typify the entire code base (we wanted to get an idea of ‚Äã‚Äãstatically typed javascript before going all-in), but only part of the files.  Pay attention that now both Flow and TypeScript allow it. </li><li>  TypeScript (at that time) lacked some basic functions that now exist, these <a href="https://blog.mariusschulz.com/2017/01/06/typescript-2-1-keyof-and-lookup-types">are lookup types</a> , <a href="https://blog.mariusschulz.com/2017/06/02/typescript-2-3-generic-parameter-defaults">default parameters for generic types</a> , etc. </li></ul><br>  When we started working on <a href="https://docs.memsql.com/memsql-studio/latest/memsql-studio-overview/">MemSQL Studio</a> at the end of 2017, we were going to cover the entire application with types (it is written entirely in JavaScript: both the frontend and the backend are executed in the browser).  We took Flow as a tool that was successfully used in the past. <br><br>  But my attention was attracted by <a href="">Babel 7 with TypeScript support</a> .  This release meant that switching to TypeScript no longer requires switching to the entire TypeScript ecosystem and you can continue to use Babel for JavaScript.  More importantly, we could <b>use TypeScript only for type checking</b> , and not as a full-fledged "language". <br><br>  Personally, I think that separating type checking from code generator is a more elegant way to use static (and strong) typing in JavaScript, because: <br><br><ol><li>  We share the problems of code and typing.  This reduces the stops on type checking and speeds up development: if for some reason type checking is slow, the code will still be generated correctly (if you use tsc with Babel, you can adjust it to the same behavior). </li><li>  Babel has great plugins and functions that the TypeScript generator doesn't have.  For example, Babel allows you to specify supported browsers and automatically generate a code for them.  This is a very complex function and it makes no sense to support it in parallel in two different projects. </li><li>  I like JavaScript as a programming language (apart from the lack of static typing), and I have no idea how long TypeScript will exist while I believe in ECMAScript for many years.  Therefore, I prefer to write and ‚Äúthink‚Äù in JavaScript (note that I say ‚Äúuse Flow‚Äù or ‚Äúuse TypeScript‚Äù instead of ‚Äúwrite on Flow‚Äù or ‚Äúon TypeScript‚Äù, because I always present them with tools, not programming languages). </li></ol><br>  Of course, this approach has some drawbacks: <br><br><ol><li>  The TypeScript compiler can theoretically perform type-based optimizations, but here we lose this opportunity. </li><li>  The configuration of the project is a little more complicated with an increase in the number of tools and dependencies.  I think this is a relatively weak argument: a bunch of Babel and Flow never let us down. </li></ol><br><h1>  TypeScript as an alternative to Flow </h1><br>  I noticed a growing interest in TypeScript in the JavaScript community: both online and with other developers.  Therefore, as soon as I learned that Babel 7 supports TypeScript, I immediately began to explore potential transition options.  In addition, we encountered some flaws in Flow: <br><br><ol><li>  Lower quality of the integration of the editor / IDE (compared to TypeScript).  Nuclide - Facebook's own IDE with the best integration - is outdated. </li><li>  There is a smaller community, which means fewer type definitions for different libraries, and they are of lower quality (at the moment the GitHub has a DefinitelyTyped 19,682 stars, and only 3070 has a type <a href="https://github.com/flow-typed/flow-typed/">typed</a> repository). </li><li>  Lack of a public development plan and poor interaction between Flow Team on Facebook and the community.  You can read <a href="https://github.com/facebook/flow/issues/6833">this</a> employee <a href="https://github.com/facebook/flow/issues/6833">comment on</a> Facebook to understand the situation. </li><li>  Large memory consumption and frequent leaks ‚Äî at some of our developers, Flow sometimes took up almost 10 GB of RAM. </li></ol><br>  Of course, we had to study how TypeScript suits us.  This is a very difficult question: studying the topic involved thorough reading of the documentation, which helped to understand that for every Flow function there is an equivalent of TypeScript.  Then I explored the open-source TypeScript development plan, and I really liked the features that are planned for the future (for example, partial derivation of the type arguments that we used in Flow). <br><br><h1>  Transfer of more than 30 thousand lines of code from Flow to TypeScript </h1><br>  To begin with, Babel had to be updated from 6 to 7. This simple task took 16 man-hours, because we decided to upgrade Webpack 3 to 4 at the same time. The task was complicated by some outdated dependencies in our code.  The vast majority of JavaScript projects will not have such problems. <br><br>  After that, we replaced Babel's Flow settings set with a new TypeScript settings set, and then for the first time launched the TypeScript compiler on all our source codes written with Flow.  The result is <b>8245 syntax errors</b> (tsc CLI does not show real errors for the project until all syntax errors have been corrected). <br><br>  At first, this number frightened us (very), but we quickly realized that most of the errors are due to the fact that TypeScript does not support .js files.  After studying the topic, I learned that TypeScript files must end with either .ts or .tsx (if they have JSX).  It seems to me a clear inconvenience.  In order not to think about the presence / absence of JSX, I simply renamed all the files to .tsx. <br><br>  There are about 4,000 syntax errors left.  Most of them are related to the <a href="https://flow.org/blog/2015/02/18/Import-Types/">type of import</a> , which with the help of TypeScript can be replaced simply with import, as well as the difference in the designation of objects ( <code>{||}</code> instead of <code>{}</code> ).  Quickly applying a pair of regular expressions, we left 414 syntax errors.  Everything else had to be corrected manually: <br><br><ul><li>  <a href="https://flow.org/en/docs/types/utilities/">The existential type</a> , which we use to partially deduce the arguments of a generic type, should be replaced with explicit arguments or <a href="https://stackoverflow.com/a/53849968/996056">the unknown type</a> to tell TypeScript that some arguments are unimportant. </li><li>  The type of <a href="https://flow.org/en/docs/types/utilities/">$ Keys</a> and other advanced types of Flow have a different syntax in TypeScript (for example, <code>$Shape‚Äú‚Äù</code> corresponds to <code>Partial‚Äú‚Äù</code> in TypeScript). </li></ul><br>  After correcting all the syntax errors, tsc finally said how many real type errors in our code base are about 1300 in total. Now we had to sit down and decide whether to continue or not.  In the end, if the migration takes weeks, then it is better to stay on Flow.  However, we decided that transferring the code would require less than one week of one engineer‚Äôs work, which is quite acceptable. <br><br>  Please note that at the time of the migration, we had to stop all the work on this code base.  Nevertheless, in parallel, you can start new projects - but you have to keep in mind potentially hundreds of type errors in the existing code, which is not easy. <br><br><h1>  What kind of mistakes? </h1><br>  TypeScript and Flow in many ways handle JavaScript code differently.  So, Flow is stricter with respect to some things, and TypeScript - with respect to others.  A deep comparison of the two systems will be very long, so let's just study some examples. <br><br>  Note: all references to the <a href="http://www.typescriptlang.org/play/">TypeScript sandbox</a> assume "strict" parameters.  Unfortunately, when you share a link, these parameters are not stored in the URL.  Therefore, they must be set manually after opening any link to the sandbox from this article. <br><br><h3>  invariant.js </h3><br>  The <code>invariant</code> function turned out to be very common in our source code.  Just to quote the documentation: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> invariant = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'invariant'</span></span>); invariant(someTruthyVal, <span class="hljs-string"><span class="hljs-string">'This will not throw'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// No errors invariant(someFalseyVal, 'This will throw an error with this message'); // Error raised: Invariant Violation: This will throw an error with this message</span></span></code> </pre> <br>  The idea is clear: a simple function that gives an error on some condition.  Let's see how to <a href="https://flow.org/try/">implement and use it</a> on Flow: <br><br><pre> <code class="javascript hljs">type Maybe&lt;T&gt; = T | <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invariant</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">condition: boolean, message: string</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!condition) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(message); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x: Maybe&lt;number&gt;, c: number</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { invariant(x !== <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>, <span class="hljs-string"><span class="hljs-string">"When c is positive, x should never be undefined"</span></span>); (x + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// works because x has been refined to "number" } }</span></span></code> </pre> <br>  Now <a href="http://www.typescriptlang.org/play/">load the same snippet into TypeScript</a> .  As you can see from the link, TypeScript gives an error, because it cannot understand that <code>x</code> guaranteed not to remain <code>undefined</code> after the last line.  This is actually a <a href="https://github.com/Microsoft/TypeScript/issues/19066">known problem</a> - TypeScript (so far) does not know how to do such an inference through a function.  However, this is a very common pattern in our code base, so we had to manually replace each invariant instance (over 150 pieces) with another code, which immediately gives an error: <br><br><pre> <code class="javascript hljs">type Maybe&lt;T&gt; = T | <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x: Maybe&lt;number&gt;, c: number</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x === <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"When c is positive, x should never be undefined"</span></span>); } (x + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// works because x has been refined to "number" } }</span></span></code> </pre> <br>  Not much compared to the <code>invariant</code> , but not such an important issue. <br><br><h3>  $ ExpectError vs. @ ts-ignore </h3><br>  Flow has a very interesting function, similar to <code>@ts-ignore</code> , except that it gives an error if the next line is <b>not</b> an error.  This is very useful for writing ‚Äútests for types‚Äù that ensure that type checking (whether TypeScript or Flow) finds certain type errors. <br><br>  Unfortunately, there is no such function in TypeScript, so our tests have lost some value.  I look forward to <a href="https://github.com/Microsoft/TypeScript/issues/29394">implementing this function on TypeScript</a> . <br><br><h3>  Common type errors and type inference </h3><br>  Often TypeScript allows more explicit code than Flow, as in this example: <br><br><pre> <code class="javascript hljs">type Leaf = { <span class="hljs-attr"><span class="hljs-attr">host</span></span>: string; port: number; type: <span class="hljs-string"><span class="hljs-string">"LEAF"</span></span>; }; type Aggregator = { <span class="hljs-attr"><span class="hljs-attr">host</span></span>: string; port: number; type: <span class="hljs-string"><span class="hljs-string">"AGGREGATOR"</span></span>; } type MemsqlNode = Leaf | Aggregator; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">leaves: Array&lt;Leaf&gt;, aggregators: Array&lt;Aggregator&gt;</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Array</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MemsqlNode</span></span></span><span class="hljs-function">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// The next line errors because you cannot concat aggregators to leaves. return leaves.concat(aggregators); }</span></span></code> </pre> <br>  Flow <a href="https://flow.org/try/">prints the leaves.concat (aggregators) type as an Array &lt;Leaf |</a>  <a href="https://flow.org/try/">Aggregator&gt;</a> , which can then be <code>Array&lt;MemsqlNode&gt;</code> to <code>Array&lt;MemsqlNode&gt;</code> .  I think this is a good example where Flow is a little smarter, and TypeScript needs a little help: in this case we can apply a type assertion, but this is dangerous and should be done very carefully. <br><br>  Although I have no formal evidence, but I believe that Flow is far superior to TypeScript in the derivation of types.  I really hope that TypeScript will reach Flow level, since the language is developing very actively, and many recent improvements have been made in this particular area.  In many places our code had to help TypeScript a little through annotations or type statements, although we <a href="https://basarat.gitbooks.io/typescript/docs/types/type-assertion.html">avoided the latter</a> as much as possible).  Consider <a href="http://www.typescriptlang.org/play/">another example</a> (we had more than 200 such errors): <br><br><pre> <code class="javascript hljs">type Player = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: string; age: number; position: <span class="hljs-string"><span class="hljs-string">"STRIKER"</span></span> | <span class="hljs-string"><span class="hljs-string">"GOALKEEPER"</span></span>, }; type F = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>&lt;Player&gt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> f1: F = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([ { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"David Gomes"</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">23</span></span>, <span class="hljs-attr"><span class="hljs-attr">position</span></span>: <span class="hljs-string"><span class="hljs-string">"GOALKEEPER"</span></span>, }, { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Cristiano Ronaldo"</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">33</span></span>, <span class="hljs-attr"><span class="hljs-attr">position</span></span>: <span class="hljs-string"><span class="hljs-string">"STRIKER"</span></span>, } ]); };</code> </pre> <br>  TypeScript will not allow you to write this, because it will not allow to declare <code>{ name: "David Gomes", age: 23, type: "GOALKEEPER" }</code> as an object of type <code>Player</code> (see the exact sandbox for an exact error).  This is another case where I find TypeScript not smart enough (at least compared to Flow, which understands this code). <br><br>  There are several options for fixing this: <br><br><ul><li>  Declare <code>"STRIKER"</code> as <code>"STRIKER"</code> so that TypeScript understands that the string is a valid listing of type <code>"STRIKER" | "GOALKEEPER"</code>  <code>"STRIKER" | "GOALKEEPER"</code> . </li><li>  Declare all objects as <code>Player</code> . </li><li>  Or what I think is the best solution: just help TypeScript, without using any type statements, by writing <code>Promise.all&lt;Player&gt;(...)</code> . </li></ul><br>  Here is <a href="http://www.typescriptlang.org/play/">another example</a> (TypeScript), where <a href="https://flow.org/try/">Flow is again better in type deduction</a> : <br><br><pre> <code class="javascript hljs">type Connection = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: number }; declare <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getConnection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Connection</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolveConnection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> resolve(getConnection()); }) } resolveConnection().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">conn</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// TypeScript errors in the next line because it does not understand // that conn is of type Connection. We have to manually annotate // resolveConnection as Promise&lt;Connection&gt;. (conn.id); });</span></span></code> </pre> <br>  A very small, but interesting example: Flow considers <code>Array&lt;T&gt;.pop()</code> type <code>T</code> , and TypeScript considers it to be <code>T | void</code>  <code>T | void</code> .  A point in favor of TypeScript, because it forces double-checking the existence of an element (if the array is empty, then <code>Array.pop</code> returns <code>undefined</code> ).  There are several other small examples like this where TypeScript is superior to Flow. <br><br><h3>  TypeScript definitions for third-party dependencies </h3><br>  Of course, when writing any JavaScript application, you will have at least a few dependencies.  They should be typed, otherwise you will lose most of the static type analysis capabilities (as described at the beginning of the article). <br><br>  Libraries from npm can be supplied with a Flow or TypeScript type definition, with or without both.  Very often (small) libraries are not supplied with either one or the other, so you have to write your own type definitions or borrow them from the community.  Both Flow and TypeScript support standard definition repositories for third-party JavaScript packages: it is <a href="https://github.com/flow-typed/flow-typed">flow-typed</a> and <a href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped</a> . <br><br>  I must say that DefinitelyTyped we liked much more.  With flow-typed, I had to use the CLI tool to introduce type definitions for various dependencies into a project.  DefinitelyTyped integrates this function with the npm CLI tool, sending <code>@types/package-name</code> packages to the npm package repository.  This is very cool and has greatly simplified the input of type definitions for our dependencies (jest, react, lodash, react-redux, these are just a few). <br><br>  In addition, I had a great time replenishing the DefinitelyTyped database (don't think that type definitions are equivalent when porting code from Flow to TypeScript).  I <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/pull/31867">have already</a> <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/pull/31607">sent</a> <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/pull/31722">several</a> <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/pull/32061">pull requests</a> , and there were no problems anywhere.  Just clone the repository, edit the type definitions, add tests - and send a pull request.  The GitHub-bot DefinitelyTyped marks the authors of the definitions you edited.  If none of them provides a review within 7 days, then the pull-request comes to the consideration of the maintainer.  After merging with the main branch, a new version of the dependency package is sent to npm.  For example, when I first updated the @ types / redux-form package, version 7.4.14 was automatically sent to npm.  so updating package.json is enough to get new type definitions.  If you can‚Äôt wait for the pull-request, you can always change the type definitions that are used in your project, as described <a href="https://davidgom.es/maintaining-overridden-typescript-definitions-for-dependencies/">in one of the previous articles</a> . <br><br>  In general, the quality of type definitions in DefinitelyTyped is much better due to the larger and more prosperous TypeScript community.  In fact, after transferring the project to TypeScript <b>, our type coverage increased from 88% to 96%</b> mainly due to better definitions of third-party dependency types, with fewer <code>any</code> types. <br><br><h1>  Lintting and tests </h1><br><ol><li>  We switched from eslint <a href="https://eslint.org/">linter</a> to <a href="https://palantir.github.io/tslint/">tslint</a> (with eslint for TypeScript it seemed harder to get started). </li><li>  For tests on TypeScript <a href="https://github.com/kulshekhar/ts-jest">ts-jest is used</a> .  Some of the tests are typed, while others are not (if you type too long, we save them as .js files). </li></ol><br><h1>  What happened after fixing all typing errors? </h1><br>  After 40 man-hours of work, we reached the last typing error, postponing it for a while using <code>@ts-ignore</code> . <br><br>  After reviewing the code review comments and fixing a couple of bugs (unfortunately, we had to slightly change the runtime code to correct the logic that TypeScript could not understand) the pull request was gone, and since then we have been using TypeScript.  (And yes, we fixed that last <code>@ts-ignore</code> in the next pull request). <br><br>  In addition to integrating with the editor, working with TypeScript is very similar to working with Flow.  Flow server performance is slightly higher, but this is not a big problem, because they issue errors for the current file equally quickly.  The only difference in performance is that TypeScript a little later (0.5‚àí1 s) reports new errors after saving the file.  The server startup time is about the same (about 2 minutes), but this is not so important.  Until now, we have not had any problems with memory consumption.  It seems that tsc constantly uses about 600 MB. <br><br>  It may seem that the type inference function gives a great advantage to Flow, but there are two reasons why this does not really matter: <br><br><ol><li>  We converted Flow code base to TypeScript.  Obviously, we only got code that Flow can express, but TypeScript is not.  If the migration was happening in the opposite direction, I am sure that there would be things that TypeScript better displays / expresses. </li><li>  Type inference is important in helping to write more concise code.  But still, other things are more important, such as a strong community and the availability of type definitions, because weak type inference can be fixed by spending a little more time on typing. </li></ol><br><h3>  Code statistics </h3><br><pre> <code class="bash hljs">$ npm run <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>-coverage <span class="hljs-comment"><span class="hljs-comment"># https://github.com/plantain-00/type-coverage 43330 / 45047 96.19% $ cloc # ignoring tests and dependencies -------------------------------------------------------------------------------- Language files blank comment code -------------------------------------------------------------------------------- TypeScript 330 5179 1405 31463</span></span></code> </pre> <br><h1>  What's next? </h1><br>  We are not finished with improving static type analysis.  There are other projects in MemSQL that will eventually switch from Flow to TypeScript (and some JavaScript projects that will start using TypeScript), and we want to make our TypeScript configuration more restrictive.  Currently, we have the <a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html">strictNullChecks</a> option <a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html">enabled</a> , but <a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html">noImplicitAny is</a> still disabled.  We will also remove a <a href="https://basarat.gitbooks.io/typescript/docs/types/type-assertion.html">couple of dangerous type assertions</a> from the code. <br><br>  I am glad to share with you all that I learned during the adventures with JavaScript typing.  If any particular topic is interesting, please <a href="https://davidgom.es/about-me/">let me know</a> . </div><p>Source: <a href="https://habr.com/ru/post/436554/">https://habr.com/ru/post/436554/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>