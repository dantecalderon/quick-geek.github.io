<div class="post__text post__text-html js-mediator-article">  Hi, Habr!  I present to you the translation of the article <a href="https://blog.bitsrc.io/understanding-asynchronous-javascript-the-event-loop-74cd408419ff">"Understanding Asynchronous JavaScript"</a> by Sukhjinder Arora. <br><br><img src="https://habrastorage.org/webt/78/ss/a1/78ssa15sg7wxe0nukoyfnjgopao.jpeg"><br><a name="habracut"></a><br>  <i>From the author of translation: I hope the translation of this article will help you to get acquainted with something new and useful.</i>  <i>If the article helped you, do not be lazy and thank the author of the original.</i>  <i>I do not pretend to be a professional translator, I am just starting to translate articles and will be happy with any meaningful feedback.</i> <br><br>  JavaScript is a single-threaded programming language in which only one thing at a time can be executed.  That is, in one stream, the JavaScript engine can process only 1 operator at a time. <br><br>  Although single-threaded languages ​​simplify coding, since you can not worry about concurrency issues, it also means that you cannot perform long operations such as accessing the network without blocking the main stream. <br><br>  Submit an API request to get some data.  Depending on the situation, the server may take some time to process your request, and the execution of the main stream will be blocked, which will cause your web page to stop responding to requests for it. <br><br>  This is where the asynchronous JavaScript comes into play.  Using JavaScript asynchrony (callbacks, promises, and async / await) you can perform long network requests without blocking the main thread. <br><br>  Although it is not necessary to study all these concepts in order to be a good JavaScript developer, it is helpful to know them. <br><br>  So, without further ado, let's begin. <br><br><h2>  How does synchronous javascript work? </h2><br>  Before we delve into the work of asynchronous JavaScript, let's first understand how to run synchronous code inside the JavaScript engine.  For example: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> second = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello there!'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> first = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hi there!'</span></span>); second(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'The End'</span></span>); } first();</code> </pre> <br>  In order to understand how the code above runs inside the JavaScript engine, we need to understand the concept of the execution context and the call stack (also known as the execution stack). <br><br><h3>  Execution context </h3><br>  The execution context is an abstract concept of the environment in which code is evaluated and executed.  Whenever any code is executed in JavaScript, it is run in the execution context. <br><br>  The function code is executed inside the function execution context, and the global code, in turn, is executed within the global execution context.  Each function has its own execution context. <br><br><h3>  Call stack </h3><br>  Call stack refers to a stack with a LIFO structure (Last in, First Out, Last In, First Out), which is used to store all execution contexts created during the execution of the code. <br><br>  There is only one call stack in JavaScript, since it is a single-threaded programming language.  The LIFO structure means that items can be added and removed only from the top of the stack. <br><br>  Let's now go back to the code snippet above and try to understand how the JavaScript engine performs it. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> second = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello there!'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> first = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hi there!'</span></span>); second(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'The End'</span></span>); } first();</code> </pre> <br><img src="https://habrastorage.org/webt/mq/bn/_d/mqbn_dfda1fmgpqrdq48jk7zhcy.png"><br><br><h3>  And so, what happened here? </h3><br>  When the code started to run, a global execution context was created (represented as <i>main ()</i> ) and added to the top of the call stack.  When a call to the <i>first ()</i> function is encountered, it is also added to the top of the stack. <br><br>  Next, <i>console.log ('Hi there!') Is</i> placed at the top of the call stack, after execution it is removed from the stack.  After that we call the <i>second ()</i> function, so it is placed on top of the stack. <br><br>  <i>console.log ('Hello there!') is</i> added to the top of the stack and is removed from it upon completion.  The <i>second ()</i> function is complete; it is also removed from the stack. <br><br>  <i>console.log ('The End') is</i> added to the top of the stack and removed upon completion.  After that, the <i>first ()</i> function ends and is also removed from the stack. <br><br>  Program execution ends, so the global calling context ( <i>main ()</i> ) is removed from the stack. <br><br><h2>  How does asynchronous javascript work? </h2><br>  Now that we have a general understanding of the call stack and how synchronous JavaScript works, let's go back to asynchronous JavaScript. <br><br><h3>  What is blocking? </h3><br>  Let's assume that we perform image processing or a network request synchronously.  For example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processImage = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">image</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">/** * Выполняем обработку изображения **/</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Image processed'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> networkRequest = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">/** * Обращаемся к некоторому сетевому ресурсу **/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> someData; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> greeting = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello World'</span></span>); } processImage(logo.jpg); networkRequest(<span class="hljs-string"><span class="hljs-string">'www.somerandomurl.com'</span></span>); greeting();</code> </pre> <br>  Image processing and network request takes time.  When the <i>processImage ()</i> function is called, its execution will take some time, depending on the size of the image. <br><br>  When the <i>processImage ()</i> function is executed, it is removed from the stack.  After it, the <i>networkRequest ()</i> function is called and added to the stack.  This will again take some time before completing the execution. <br><br>  Finally, when the <i>networkRequest ()</i> function is executed, the <i>greeting ()</i> function is called, since it only contains the <i>console.log</i> method, and this method is usually executed quickly, the <i>greeting ()</i> function will execute and end instantly. <br><br>  As you can see, we need to wait until the function (such as <i>processImage ()</i> or <i>networkRequest ()</i> ) is completed.  This means that such functions block the call stack or main thread.  As a result, we cannot perform other operations until the code above is executed. <br><br><h3>  So what is the solution? </h3><br>  The simplest solution is asynchronous callback functions.  We use them to make our code non-blocking.  For example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> networkRequest = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Async Code'</span></span>); }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello World'</span></span>); networkRequest();</code> </pre> <br>  Here I used the <i>setTimeout</i> method to simulate a network request.  Please remember that <i>setTimeout is</i> not part of the JavaScript engine, it is part of the so-called web API (in the browser) and C / C ++ APIs (in node.js). <br><br>  In order to understand how this code is executed, we need to deal with a few more concepts, such as an event loop and a callback queue (also known as a task queue or message queue). <br><br><img src="https://habrastorage.org/webt/fd/u7/jx/fdu7jxtawrvjmrptsnumrtidceg.png"><br><br>  The event loop, the web API and the message queue / task queue are not part of the JavaScript engine, it is part of the browser-based JavaScript runtime or the JavaScript runtime in Nodejs (in the case of Nodejs).  In Nodejs, the web APIs are replaced with C / C ++ APIs. <br><br>  Now let's go back to the code above, and see what happens in the case of asynchronous execution. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> networkRequest = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Async Code'</span></span>); }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello World'</span></span>); networkRequest(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'The End'</span></span>);</code> </pre> <br><img src="https://habrastorage.org/webt/pc/zt/e5/pczte5tqprl18tltgiurc75m50g.gif"><br><br>  When the code above is loaded into the browser <i>console.log ('Hello World') is</i> added to the stack and removed from it upon completion of execution.  Next, a call to the <i>networkRequest ()</i> function is <i>encountered</i> , it is added to the top of the stack. <br><br>  The next function is called <i>setTimeout ()</i> and placed on top of the stack.  The <i>setTimeout ()</i> function has 2 arguments: 1) a callback function and 2) time in milliseconds. <br><br>  <i>setTimeout ()</i> starts a timer for 2 seconds in the web API environment.  At this stage, <i>setTimeout () is</i> completed and removed from the stack.  After that, <i>console.log ('The End')</i> is added to the stack, executed and removed from it upon completion. <br><br>  Meanwhile, the timer has expired, now the callback is added to the message queue.  But the callback cannot be executed immediately, and it is here that the event loop enters the process. <br><br><h3>  Event loop </h3><br>  The task of the event loop is to monitor the call stack and determine whether it is empty or not.  If the call stack is empty, the event loop looks into the message queue to see if there are callbacks that are waiting to be executed. <br><br>  In our case, the message queue contains one callback, and the execution stack is empty.  Therefore, the event loop adds a callback to the top of the stack. <br><br>  After <i>console.log ('Async Code') is</i> added to the top of the stack, executed and removed from it.  At this point, the callback is made and removed from the stack, and the program is completely completed. <br><br><h3>  DOM events </h3><br>  The message queue also contains callbacks from DOM events, such as clicks and “keyboard” events.  For example: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'.btn'</span></span>).addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>,(event) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Button Clicked'</span></span>); });</code> </pre> <br>  In the case of DOM events, the event handler is in the web API environment, waiting for a specific event (in this case, a click), and when this event occurs, the callback function is placed in the message queue, waiting for its execution. <br><br>  We learned how asynchronous callbacks and DOM events are performed that use a message queue to store callbacks waiting to be executed. <br><br><h3>  ES6 Microtouch Queue </h3><br>  <i>Note</i>  <i>author of the translation: In the article, the author used the message / task queue and the job / micro-taks queue, but if you translate the task queue and the job queue, then in theory it turns out the same thing.</i>  <i>I talked to the author of the translation and decided to simply omit the notion of job queue.</i>  <i>If you have any thoughts on this, I am waiting for you in the comments.</i> <i><br><br></i>  <i><a href="https://habr.com/ru/post/439746/">Link to the translation of the article on promises from the same author</a></i> <i><br></i> <br><br>  ES6 introduced the concept of a queue of microtasks, which are used by “promises” in JavaScript.  The difference between the message queue and the microtask queue is that the microtouch queue has a higher priority than the message queue, which means that promises within the microtouch queue will be executed earlier than callbacks in the message queue. <br><br>  For example: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Script start'</span></span>); setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'setTimeout'</span></span>); }, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise resolved'</span></span>); }).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res)) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Script End'</span></span>);</code> </pre> <br>  Conclusion: <br><br><pre> <code class="javascript hljs">Script start Script End <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> resolved setTimeout</code> </pre> <br>  As you can see, the “promise” was completed before <i>setTimeout</i> , all because the promise response is stored within the queue of microtasks, which has a higher priority than the message queue. <br><br>  Let's look at the following example, this time 2 “promises” and 2 <i>setTimeout</i> : <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Script start'</span></span>); setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'setTimeout 1'</span></span>); }, <span class="hljs-number"><span class="hljs-number">0</span></span>); setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'setTimeout 2'</span></span>); }, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise 1 resolved'</span></span>); }).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res)) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err)); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise 2 resolved'</span></span>); }).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res)) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Script End'</span></span>);</code> </pre> <br>  Conclusion: <br><br><pre> <code class="javascript hljs">Script start Script End <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> resolved <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> resolved setTimeout <span class="hljs-number"><span class="hljs-number">1</span></span> setTimeout <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  And again, both of our “promises” were executed before the callbacks inside <i>setTimeout</i> , since the event loop considers the tasks from the microtasks queue more important than the tasks from the message queue / task queue. <br><br>  If another “promise” appears during the execution of tasks from the microtwist queue, it will be added to the end of this queue and executed before the callbacks from the message queue, and it doesn’t matter how long they wait for their execution. <br><br>  For example: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Script start'</span></span>); setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'setTimeout'</span></span>); }, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise 1 resolved'</span></span>); }).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res)); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise 2 resolved'</span></span>); }).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise 3 resolved'</span></span>); }) }).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Script End'</span></span>);</code> </pre> <br>  Conclusion: <br><br><pre> <code class="javascript hljs">Script start Script End <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> resolved <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> resolved <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> resolved setTimeout</code> </pre> <br>  Thus, all tasks from the microtroke queue will be completed before tasks from the message queue.  That is, the event processing cycle will first clear the queue of microtasks, and only after that will it start performing callbacks from the message queue. <br><br><h2>  Conclusion </h2><br>  So, we learned how asynchronous JavaScript and concepts work: call stack, event loop, message queue / task queue, and microtask queue that make up the JavaScript runtime </div>