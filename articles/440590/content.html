<div class="post__text post__text-html js-mediator-article">  Modern hardware and compilers are ready to turn our code upside down so that it works faster.  And their manufacturers carefully hide their inner kitchen.  And everything is fine, while the code is executed in one thread. <br><br>  In a multithreaded environment, you can perforce observe interesting things.  For example, the execution of program instructions is not in the order as written in the source code.  You must admit that it is frustrating to realize that the execution of the source code line by line is just our imagination. <br><br>  But everyone has already realized, because it is necessary to live with it somehow.  And Java programmers even live quite well.  Because Java has a memory model - the Java Memory Model (JMM), which provides fairly simple rules for writing correct multi-threaded code. <br><br>  And these rules are enough for most programs.  If you do not know them, but write or want to write multi-threaded programs in Java, it is better to get acquainted with <a href="https://youtu.be/C6b_dFtujKo">them</a> as soon as possible.  And if you know, but you do not have enough context or it is interesting to find out where your JMM legs grow from, then the article can help you. <br><a name="habracut"></a><br><h2>  And abstraction chases </h2><br>  In my view, there is a pie, or more appropriately an iceberg.  JMM is the tip of the iceberg.  Under the water iceberg itself - the theory of multi-threaded programming.  Under the iceberg - Hell. <br><br><img src="https://habrastorage.org/webt/ub/jg/rf/ubjgrfe8bec3-ix9qgnkik3avoy.png"><br><br>  An iceberg is an abstraction, if it leaks, then Hell we will certainly see.  Although there is a lot of interesting things going on, in a review article we will not get to that. <br><br>  In the article I am more interested in the following topics: <br><br><ul><li>  Theory and terminology </li><li>  How multithreaded programming theory affects JMM </li><li>  Competitive programming models </li></ul><br>  The theory of multi-threaded programming allows you to get away from the complexity of modern processors and compilers, it allows you to simulate the execution of multi-threaded programs and study their properties.  Roman Elizarov made an excellent <a href="https://elizarov.livejournal.com/33610.html">report</a> , the purpose of which is to provide a theoretical basis for understanding JMM.  I recommend the report to anyone interested in this topic. <br><br>  Why is it so important to know the theory?  In my opinion, I hope only for mine, some programmers have the opinion that JMM is a complication of the language and patching some platform problems with multithreading.  The theory shows that in Java they did not complicate, but they simplified and made very complex multi-threaded programming more predictable. <br><br><h2>  Competition and concurrency </h2><br>  First, let's look at the terminology.  Unfortunately, there is no consensus in terminology - by studying different materials, you can meet different definitions of competition and concurrency. <br><br>  The problem is that even if we get to the bottom of the truth and find exact definitions of these concepts, it’s still hardly necessary to expect that everyone will mean the same thing by these concepts.  There are no ends here. <br><br>  Roman Elizarov, in the report on the theory of parallel programming for practitioners, says that sometimes these concepts are confused.  Sometimes parallel programming is distinguished as a general concept, which is divided into competitive and distributed. <br><br>  It seems to me that in the context of JMM, one should still separate competition and concurrency, or rather even understand that there are two different paradigms, whatever they are called. <br><br>  Often cited by Rob Pike, who distinguishes the concepts as follows: <br><br><ul><li>  Competition is a way to solve multiple problems simultaneously. </li><li>  Parallelism is a way to perform different parts of the same task. </li></ul><br>  The opinion of Rob Pike is not a benchmark, but in my opinion, it is convenient to make a start from him to further study the issue.  You can read more about the differences <a href="https://habr.com/ru/company/piter/blog/274569/">here</a> . <br><br>  Most likely, more understanding in the question will appear if we highlight the main features of a competitive and parallel program.  There are a lot of signs, consider the most significant. <br><br>  Signs of competition. <br><br><ul><li>  The presence of several control threads (for example, Thread in Java, Korutin in Kotlin), if the control flow is one, then there can be no competitive execution </li><li>  Nondeterministic output.  The result depends on random events, implementation, and how synchronization was performed.  Even if each stream is fully deterministic, the final result will be non-deterministic. </li></ul><br>  A parallel program will have a different set of features. <br><br><ul><li>  Optionally has multiple control threads </li><li>  It can lead to a deterministic result, for example, the result of multiplying each element of the array by a number will not change if multiplied in parallel </li></ul><br>  Oddly enough, parallel execution is possible on a single control thread, and even on a single-core architecture.  The fact is that parallelism at the level of tasks (or control flows) to which we are used to is not the only way to perform computations in parallel. <br><br>  Parallelism is possible at the level of: <br><br><ul><li>  bits (for example, in 32-bit machines, addition occurs in one action, processing all 4 bytes of a 32-bit number in parallel) </li><li>  instructions (on one core, in one thread, the processor can execute instructions in parallel, despite the fact that the code is sequential) </li><li>  data (there are architectures with parallel data processing (Single Instruction Multiple Data) that can execute one instruction on a large data set) </li><li>  tasks (implies the presence of multiple processors or cores) </li></ul><br>  Parallelism at the instruction level is one of the examples of optimizations that occur with the execution of the code, and which are hidden from the programmer. <br><br>  It is guaranteed that the optimized code will be equivalent to the source code within a single thread, because it is impossible to write adequate and predictable code if it does not do what the programmer meant. <br><br>  Not everything that runs in parallel matters to JMM.  Parallel execution at the instruction level within a single thread is not covered in the JMM. <br><br>  The terminology is very shaky, in Roman Elizarov the report is called “Theory of <b>parallel</b> programming for practitioners”, although there it’s more about competitive programming, if we stick to the above. <br><br>  In the context of JMM in the article, I will stick to the term competition, since competition is often about general condition.  But here one must be careful not to cling to the terms, but understand that there are different paradigms. <br><br><h2>  Models with a common state: “alternation of operations” and “occurred before” </h2><br>  In his <a href="https://cs.brown.edu/~mph/HerlihyW90/p463-herlihy.pdf">article,</a> Maurice Hurlihi (author of The Art Of Multiprocessor programming) writes that the competitive system contains a collection of sequential processes (in theoretical works means the same thing as a stream), which communicate through common memory. <br><br>  A shared state model includes computations with message passing, where the shared state is a message queue and shared memory calculations, where the common state is structures in memory. <br><br>  Each of the calculations can be modeled. <br><br>  The model is based on a state machine.  The model focuses solely on the shared state and completely ignores the local data of each stream.  Each action of flows over a shared state is a function of transition to a new state. <br><br>  For example, if 4 threads write data to a shared variable, then there will be 4 transition functions to the new state.  Which of these functions will be used depends on the chronology of events in the system. <br><br>  Calculations with message passing are modeled in a similar way, only the state and transition functions depend on the sending or receiving of messages. <br><br>  If the model seemed complicated to you, then in the example we will fix it.  It is really very simple and intuitive.  So much so that without knowing about the existence of this model, most people will still analyze the program as the model suggests. <br><br>  This model is called the model of <b>execution through the alternation of operations</b> (the name was heard in the report of Roman Elizarov). <br><br>  In the advantages of the model, you can safely record intuitiveness and naturalness.  In the jungle, you can go on the keyword <b>Sequential consistency</b> and the <a href="http://lamport.azurewebsites.net/pubs/time-clocks.pdf">work of</a> Leslie Lamport. <br><br>  However, there is an important clarification about this model.  The model has a limitation that all actions on the shared state must be instantaneous and at the same time actions cannot occur simultaneously.  They say that such a system has a <b>linear order</b> - all actions in the system are ordered. <br><br>  In practice, this does not happen.  The operation does not occur instantly, but is performed in the interval, on multi-core systems, these intervals may overlap.  Of course, this does not mean that the model is useless in practice, you just need to create certain conditions for its use. <br><br>  In the meantime, consider another <b>model - “happened before”</b> , which focuses not on state, but on a set of read and write operations of memory cells during execution (history) and their relationships. <br><br>  The model says that events in different streams do not pass instantly and atomically, but in parallel, and it is not possible to build order between them.  Events (writing and reading shared data) in threads on a multiprocessor or multi-core architecture actually occur in parallel.  The system lacks the concept of global time; we cannot understand when one operation ended and another began. <br><br>  In practice, this means that we can write to a variable in one stream and do it, say in the morning, and read from this variable in another stream in the evening, and we cannot say that we will read the value recorded in the morning for sure.  In theory, these operations take place in parallel and it is not clear when one operation will end and another operation will begin. <br><br>  It is difficult to imagine how it turns out that simple read and write operations done at different times of the day take place simultaneously.  But if you think about it, then we really don’t care about the time when the events of writing and reading occur, if we cannot guarantee that we will see the result of the recording. <br><br>  And we really can not see the result of the recording, i.e.  in a variable whose value is <i>0</i> in stream <i>P,</i> we write <i>1</i> , and in stream <i>Q</i> we read this variable.  No matter how much physical time passes after the recording, we can still read <i>0</i> . <br><br>  <b>This is how computers work and the model reflects this.</b> <br><br>  The model is completely abstract and needs visualization for convenient operation.  For visualization, and only for it, a model with global time is used, with reservations that the global time is not used when proving program properties.  In the visualization, each event is represented as an interval with a start and end. <br><br>  Events run in parallel, as we found out.  But still, the system has a <b>partial order</b> , as there are special pairs of events that have order, in which case they say that these events have a relationship “happened before”.  If for the first time you hear about the “happened before” attitude, then probably the knowledge of the fact that this attitude sort of organizes events will not help you much. <br><br><h2>  We try to analyze Java program </h2><br>  We have considered some theoretical minimum, let's try to move further and consider a multi-threaded program in a specific language - Java, from two streams with a common changeable state. <br><br>  Classic example. <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">0</span></span>, b = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { a = <span class="hljs-number"><span class="hljs-number">0</span></span>; b = <span class="hljs-number"><span class="hljs-number">0</span></span>; x = <span class="hljs-number"><span class="hljs-number">0</span></span>; y = <span class="hljs-number"><span class="hljs-number">0</span></span>; } Thread p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() -&gt; { a = <span class="hljs-number"><span class="hljs-number">1</span></span>; x = b; }); Thread q = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() -&gt; { b = <span class="hljs-number"><span class="hljs-number">1</span></span>; y = a; }); p.start(); q.start(); p.join(); q.join(); System.out.println(<span class="hljs-string"><span class="hljs-string">"x="</span></span> + x + <span class="hljs-string"><span class="hljs-string">", y="</span></span> + y);</code> </pre> <br>  We need to simulate the execution of this program and get all the possible results - the values ​​of the variables x and y.  There will be several results, as we remember from the theory, such a program is non-deterministic. <br><br>  How are we going to model?  Just want to use the model of alternation of operations.  But the “happened before” model tells us that events in one stream are parallel to events from another stream.  Therefore, the model of alternation of operations is not appropriate here, if there is no relationship between “operations before” between operations. <br><br>  The result of executing each thread is always deterministic, since events in one thread are always ordered, consider that they get the relation “happened before” as a gift.  But how events in different streams can get the attitude “happened before” is not entirely obvious.  Of course, this relationship is formalized in the model, the whole model is written in mathematical language.  But what to do with this in practice, in a specific language, cannot be immediately disassembled. <br><br>  What are the options? <br><br>  Ignore constraints and simulate interlacing.  You can try something, maybe nothing terrible will happen. <br><br>  To understand what kind of results you can get, let's simply iterate through all possible execution options. <br><br>  All possible program performances can be represented as a finite state machine. <br><br><img src="https://habrastorage.org/webt/z_/nb/a4/z_nba4dq4_xlfkdvw7vypddxo3s.jpeg"><br><br>  Each circle is the state of the system, in our case the variables <i>a, b, x, y</i> .  The transition function is an action on a state that takes the system to a new state.  Since two streams can perform actions on a general state, there will be two transitions from each state.  Double circles are the final and initial states of the system. <br><br>  A total of 6 different designs are possible, which result in pairs of x, y values: <br> <code>(1, 1), (1, 0), (0, 1) <br></code> <br><img src="https://habrastorage.org/webt/uu/dn/ev/uudnevagixnomxjnrydhfgrph4i.png"><br><br>  We can run the program and check the results.  As befits a competitive program, it will have a non-deterministic result. <br><br>  To test competitive programs it is better to use special tools ( <a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">tool</a> , <a href="https://youtu.be/uZfK-9ixxec">report</a> ). <br><br>  But you can try to run the program several million times, or even better, write a cycle that will do it for us. <br><br>  If we run the code on a single-core or single-processor architecture, then we must get the result from the set that we expect.  The rotation pattern will work just fine.  On a multi-core architecture, such as x86, a surprise may await us - we can get a result (0,0), which cannot be according to our modeling. <br><br>  The explanation for this can be searched on the Internet by keyword - <b>reordering</b> .  Now it is important to understand that the <b>alternation modeling is really not suitable in a situation where we cannot determine the order of access to the shared state</b> . <br><br><h2>  Theory of Competitive Programming and JMM </h2><br>  The time has come to consider the relationship “happened before” and how it is friendly with the JMM.  The original definition of the relation “happened before” can be found in the <a href="http://lamport.azurewebsites.net/pubs/time-clocks.pdf">document</a> Time, Clocks, and the Distributed System. <br><br>  The memory model of a language helps in writing a competitive code, since it determines which operations have a relation “happened before”.  The list of such operations is presented in the <a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html">specification</a> in the section Happens-before Order.  In fact, this section answers the question - under what conditions will we see the result of a recording in another stream. <br><br>  There are different orders in JMM.  Alexey Shipilev tells very cheerfully about the order in one of his <a href="https://youtu.be/C6b_dFtujKo%3Ft%3D926">reports</a> . <br><br>  In a model with global time, all operations in one thread have order.  For example, events of writing and reading a variable can be represented as two intervals, then the model ensures that these intervals never intersect within the same flow.  In JMM, this order is called Program Order ( <i>PO</i> ). <br><br>  <i>PO</i> connects actions in one thread and says nothing about the order of execution, says only about the order in the source code.  This is quite enough to guarantee <b>determinism for each stream separately</b> .  <i>PO</i> can be viewed as raw data.  <i>PO is</i> always easy to place in the program - all operations (linear order) in the source code within one stream will have a <i>PO</i> . <br><br>  In our example, we get something like this: <br><br>  <code>P: a = 1 PO x = b</code> - write to a and read b has PO order <br>  <code>Q: b = 1 PO y = a</code> - writing to b and reading a has PO order <br><br>  Peeped this form of the record <i>w (a, 1) PO r (b): 0.</i> I really hope that no one patented it for reports.  However, the specification has a similar form. <br><br>  But each stream separately is not particularly interesting to us, since the flows have a common state, we are more interested in the interaction of the flows.  All we want is to be sure that we will see the recording of variables in other threads. <br><br>  Let me remind you that this did not work out for us, because the operations of writing and reading variables in different streams are not instantaneous (these are segments that intersect), so it’s impossible to make out where the beginning and end of operations is. <br><br>  The idea is simple - at the moment when we read the variable a in the stream <i>Q</i> , writing this variable itself in the stream <i>P</i> might not end yet.  And no matter how much physical time these events share - nanosecond or a few hours. <br><br>  To streamline the events we need the relationship “happened before”.  JMM defines this attitude.  The specification is fixed order in one thread: <br><br>  <i>If operation x and y take place in the same stream and x first occurs in <i>PO</i> , and then y, then x occurs before y.</i> <i><br></i> <br><br>  Looking ahead, we can say that we can replace all <i>POs</i> with Happens-before ( <i>HB</i> ): <br><br><pre> <code class="plaintext hljs">P: w(a, 1) HB r(b) Q: w(b, 1) HB r(a)</code> </pre> <br>  But again we are spinning under one thread.  <i>HB is</i> possible between operations occurring in different streams, in order to deal with these cases, we will get acquainted with other orders. <br><br>  Synchronization Order ( <i>SO</i> ) - links Synchronization Actions ( <i>SA</i> ), the full list of <i>SA is</i> given in the specification, in section 17.4.2.  Actions.  Here are some of them: <br><br><ul><li>  Read volatile variable </li><li>  Record volatile variable </li><li>  Monitor lock </li><li>  Unlock monitor </li></ul><br>  <i>SO</i> is interesting to us, because it has the property that all readings in <i>SO</i> order see the last entries in <i>SO</i> .  And I remind you, we are just trying to achieve this. <br><br>  At this point I will repeat what we are trying to achieve.  We have a multi-threaded program, we want to simulate all possible performances and get all the results that it can give.  There are models that allow you to do this quite simply.  But they require that all actions on the shared state be ordered. <br><br>  According to the property of <i>SO</i> - if all actions in the program are <i>SA</i> then we will achieve our goal.  Those.  we can arrange the <i>volatile modifier</i> for all variables and we can use the alternation model.  If intuition tells you not to do this, then you are absolutely right.  By these actions we simply forbid optimizing the code, of course, sometimes it is a good option, but this is definitely not a general case. <br><br>  Consider another Synchronizes-With Order ( <i>SW</i> ) order - SO for specific unlock / lock pairs, write / read volatile.  It does not matter in which flows these actions will take place, the main thing is that they are over one monitor, a volatile variable.  <i>SW</i> gives a “bridge” between threads. <br><br>  And now we come to the most interesting order - Happens-before ( <i>HB</i> ). <br>  <i>HB</i> is a transitive closure of <i>SW</i> and <i>PO</i> unions.  <i>PO</i> gives a linear order within the stream, and <i>SW</i> “bridge” between the streams.  <i>HB is</i> transitive, i.e.  if a <br><br><pre> <code class="plaintext hljs">x HB y и y HB z, тогда x HB z</code> </pre> <br>  In the specification there is a list of <i>HB</i> relations, you can read more about it, here are some of the list: <br><br>  Within one thread, any operation happens-before any operation following it in the source code. <br><br>  Exit from synchronized block / method happens-before enter synchronized block / method on the same monitor. <br><br>  Writing a <i>volatile</i> field happens-before reading the same <i>volatile</i> field. <br><br>  Let's return to our example: <br><br><pre> <code class="plaintext hljs">P: a = 1 PO x = b Q: b = 1 PO y = a</code> </pre> <br>  Let's return to our example and try to analyze the program, taking into account the orders. <br><br>  Analysis of the program with the help of JMM is based on putting forward any hypotheses and their confirmation or denial. <br><br><img src="https://habrastorage.org/webt/pu/hy/nz/puhynztfclug7afvnbpfht54wsg.png"><br><br>  We begin the analysis with the hypothesis that no execution of the program gives the result (0, 0).  The absence of a (0, 0) result on all executions is an expected property of the program. <br><br>  We check the hypothesis by building different executions. <br><br>  The nomenclature has peeped <a href="https://shipilev.net/blog/2016/close-encounters-of-jmm-kind/">here</a> (sometimes it appears instead of <code>…</code> word <code>race</code> with an arrow, Alexey himself uses the arrow and the word race in reports, but warns that there is no such order in the JMM and uses such a designation for clarity). <br><br>  We make a small reservation. <br><br>  Since all actions over common variables are important to us, and in the example common variables are <i>a, b, x, y</i> .  Then, for example, the operation x = b should be considered as r (b) and w (x, b), with <code>r(b) HB w(x,b)</code> (based on <i>PO</i> ).  But since the variable x in threads is not readable anywhere (reading in print at the end of the code is not interesting, since after the join operation on the stream we will see the value x), we can not consider the action w (x, b). <br><br>  Check the first performance. <br><br><pre> <code class="plaintext hljs">w(a, 1) HB r(b): 0 … w(b, 1) HB r(a): 0</code> </pre> <br>  In the flow <i>Q,</i> we read the variable a, which we write to this variable in the flow <i>P.</i>  There is no order between writing and reading <i>(PO, SW, HB)</i> . <br><br>  If the variable is written in one stream and the reading is in another stream and there is no <i>HB</i> relationship between the operations, then the variable is said to read under the race.  And under the race according to JMM, we can read either the last recorded value in <i>HB</i> , or any other value. <br><br>  Such a performance is possible.  Execution <b>does not violate the JMM</b> .  When reading the variable a, you can see any value, since the reading takes place under the race and there is no guarantee that we will see the action w (a, 1).  This does not mean that the program is working correctly, it just means that we expect such a result. <br><br>  There is no sense to consider the rest of the execution, since the <b>hypothesis is already destroyed</b> . <br><br>  JMM says that if a program does not have data races, then all executions can be viewed as sequential.  Let's get rid of the race, for this we need to streamline read and write operations in different threads.  It is important to understand that a multi-threaded program, as opposed to a sequential one, has several versions.  And in order to say that a program has any property, it is required to prove that the program has this property not on one of the performances, but on all the performances. <br><br>  To prove that the program is non-racing, you need to do this for all performances.  Let's try to make an <i>SA</i> and mark the variable a with the <i>volatile modifier</i> .  <i>Volatile</i> variables will be marked with the prefix v. <br><br>  We put <b>forward a new hypothesis</b> .  If the variable a is made <i>volatile</i> , then no execution of the program will give the result (0, 0). <br><br><pre> <code class="plaintext hljs">w(va, 1) HB r(b): 0 … w(b, 1) HB r(va): 0</code> </pre> <br>  Execution <b>does not violate the JMM</b> .  Reading va takes place under the race.  Any race destroys the transitivity of HB. <br><br>  We put <b>forward another hypothesis</b> .  If the variable b is made <i>volatile</i> , then no execution of the program will give the result (0, 0). <br><br><pre> <code class="plaintext hljs">w(a, 1) HB r(vb): 0 … w(vb, 1) HB r(a): 0</code> </pre> <br>  Execution does not violate the JMM.  Reading a takes place under the race. <br><br>  Let's <b>test the hypothesis</b> that if the variables a and b are <i>volatile</i> , then no execution of the program will give the result (0, 0). <br><br>  Check the first performance. <br><br><pre> <code class="plaintext hljs">w(va, 1) SO r(vb): 0 SO w(vb, 1) SO r(va): 0</code> </pre> <br>  Since all actions in the <i>SA</i> program (specifically reading or writing a <i>volatile</i> variable), we get the full <i>SO</i> order between all actions.  This means that r (va) should see w (va, 1).  This <b>execution violates JMM</b> . <br><br>  It is necessary to proceed to the next execution to confirm the hypothesis.  But since, for any execution, there will be <i>SO</i> , it is possible to abandon the formalism - it is obvious that the result (0, 0) violates the JMM for any execution. <br><br>  To use the interleaving model, you need to add <i>volatile</i> for the variables a and b.  Such a program will give results (1.1), (1.0) or (0.1). <br><br>  As a result, it can be said that very simple programs are quite simple to analyze. <br><br>  But complex programs with a large number of executions and shared data are quite difficult to analyze, since you need to check all performances. <br><br><h2>  Other competitive performance models </h2><br>  Why consider other competitive programming models? <br><br>  With the help of threads and synchronization primitives, all problems can be solved.  This is all true, but the problem is that we looked at an example of a dozen lines of code, where 4 lines of code do useful work. <br><br>  And we ran into a bunch of questions there, to the extent that we couldn’t correctly calculate all possible results without specification.  Synchronization flows and primitives are a very complicated thing, the use of which is certainly justified in some cases.  These cases are mainly related to performance. <br><br>  Sorry, I refer a lot to Elizarov, but what to do if a person really has experience in this area.  So, he has another great <a href="https://www.youtube.com/watch%3Fv%3DQ-7y1u9kZV0">report</a> “Millions of quotations per second on pure Java”, in which he says that the immutable state is good, but I will not copy my millions of quotes into each stream, sorry.  But not all millions of quotations, many of course the task is more modest.  Are there any competitive programming models that allow you to forget about JMM and still write a safe competitive code? <br><br>  If this question is really very interesting to you, I highly recommend Paul Butcher’s book “Seven models of competition in seven weeks.  Reveal the secrets of the flow. "  Unfortunately, it was not possible to find enough information about the author, but the book should open your eyes to new paradigms.  I, unfortunately, have no experience with many other models of competition, so I got a review from this book. <br><br>  Answering the question above.  As far as I understand, there are competitive programming models that at least greatly reduce the need for knowledge of the nuances of JMM.  However, if there is a changeable state and flows, then what abstractions above them are not wrapped around, all the same there will be a place where these threads should synchronize access to the state.  Another question is that you may not have to synchronize access yourself, for example, the framework may be responsible.  But as we have said, sooner or later, abstraction can flow. <br><br>  You can exclude a changeable state at all.  In the world of functional programming, this is normal practice.  If there are no mutable structures, then there probably won't be any problems with shared memory either.  The JVM has representatives of functional languages, for example Clojure.  Clojure is a hybrid functional language, because it still allows you to change data structures, but provides more efficient and safe tools for this. <br><br>  Functional languages ​​are an excellent tool for working with competitive code.  Personally, I do not use it, because my field of activity is mobile development, and there it is simply not the mainstream.  Although certain approaches can be adopted. <br><br>  Another way to work with editable data is to eliminate data sharing.  Such a programming model is actors.  Actors simplify programming by not allowing simultaneous access to data.  This is achieved by the fact that a function that performs work at a time can work only in one thread. <br><br>  However, the actor can change the internal state.  Considering that at the next time point, the same actor can be executed on another thread, this can be a problem.  The problem can be solved in different ways, in programming languages ​​such as Erlang or Elixir, where the model of actors is an integral part of the language, recursion can be used to call the actor with a new state. <br><br>  In Java, recursion can be too expensive.  But in Java there are frameworks for convenient work with this model, probably the most popular one is Akka.  The Akka developers have taken care of everything; you can go to the <a href="https://doc.akka.io/docs/akka/2.5/general/jmm.html">Akka and the Java Memory Model</a> documentation section and read about two cases in which access to a shared state from different threads may occur.  But more importantly, the documentation says which events are related to “what happened before.”  Those.  this means that we can change the state of the actor as many times as necessary, but when we accept the following message and possibly process it in another thread, we are guaranteed to see all the changes made in another thread. <br><br><h2>  Why is the threading model so popular? </h2><br>  We considered two models of competitive programming, in fact, even more of them, which make competitive programming easier and safer. <br><br>  But why then are threads and locks still so popular? <br><br>  It seems to me that the reason is the simplicity of the approach, of course, on the one hand with the flows, it is easy to make many unobvious mistakes, shoot one’s leg, etc.  But on the other hand there <b>is nothing complicated in the flows, especially if you do not think about the consequences</b> . <br><br>  At one point in time, the kernel can execute one instruction (in fact, no, parallelism exists at the instruction level, but this is not important now), but thanks to multitasking, even on single-core machines, several programs can be executed simultaneously (of course, pseudo simultaneously). <br><br>  For multitasking to work, competition is needed.  As we have already figured out the competition is impossible without several control flows. <br><br>  How do you think how many threads need a program that runs on a quad-core mobile phone processor to be as fast and responsive as possible? <br><br>  There may be several dozen.  Now the question is, why do you need so many threads for a program that runs on hardware that allows you to perform only 2-4 threads at the same time? <br><br>  To try to answer this question, suppose that only our program is running on the device and nothing else.  How would we manage the resources provided to us? <br><br>  You can give one core for the user interface, the rest of the core for any other tasks.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If one of the threads is blocked, for example, the thread can access the memory controller and wait for a response, then we will get a blocked kernel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What technologies are there to solve the problem? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are threads in Java, we can create multiple threads, and then other threads will be able to perform operations while a thread is blocked. </font><font style="vertical-align: inherit;">Having a tool like streams, we can simplify our lives. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The approach with threads is not free, creating threads usually takes time (decided by thread pools), memory is allocated for them, switching between threads is an expensive operation. </font><font style="vertical-align: inherit;">But it is relatively easy to program with them, so this is a mass technology that is so widely used in general purpose languages, such as Java.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Java, they generally like threads, it is not necessary to create for each action in a stream, there are higher-level things, such as Executors, that allow you to work with pools and write more scalable and flexible code. The streams are really convenient; you can make a blocking request to the network and write the processing of the result in the next line. Even if we wait for the result for a few seconds, we will still be able to perform other tasks, since the operating system takes care of the allocation of processor time between threads. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Threads are popular not only in backend development, in mobile development it is considered quite normal to create dozens of threads so that you can block a stream for a couple of seconds while waiting for data to load over the network or data from a socket.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Languages ​​like Erlang or Clojure are still niche, and accordingly competitive programming models that they use are not so popular. </font><font style="vertical-align: inherit;">However, the forecasts for them are the most optimistic.</font></font><br><br><h2>  findings </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you are developing on the JVM platform, then you need to accept the rules of the game, indicated by the platform. </font><font style="vertical-align: inherit;">This is the only way to write normal multi-threaded code. </font><font style="vertical-align: inherit;">It is very desirable to understand the context of everything that happens, it will be easier to accept the rules of the game. </font><font style="vertical-align: inherit;">It is even better to look around and familiarize yourself with other paradigms, even though there is no way out of a submarine, but you can discover new approaches and tools.</font></font><br><br><h2>  Additional materials </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I tried to place in the text of the article links to sources from which I scooped information. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, JMM material is easy to find on the Internet. </font><font style="vertical-align: inherit;">Here I will post links to some additional material that is associated with the JMM and may not immediately catch my eye. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reading</font></font></b> <br><br><ul><li> <a href="https://shipilev.net/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexey Shipilyov's blog</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - I know what is obvious, but just a sin not to mention</font></font></li><li> <a href="https://dev.cheremin.info/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cheremin Ruslan's blog</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - he hasn’t been actively writing lately, you need to search his old posts in a blog, believe me it is worth it - there is a storehouse</font></font></li><li> <a href="https://habr.com/ru/users/gvsmirnov/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habr Gleb Smirnov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - there are excellent articles about multithreading and memory model</font></font></li><li> <a href="https://elizarov.livejournal.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The blog of Roman Elizarov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is abandoned, but archaeological excavations should be carried out. </font><font style="vertical-align: inherit;">In general, Roman has done a lot for the enlightenment of the people in the field of the theory of multi-threaded programming, look for it in the media.</font></font></li></ul><br>  <b>Podcasts</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Issues that seemed to me especially interesting. </font><font style="vertical-align: inherit;">They are not about JMM, they are about Hell, which is created in the gland. </font><font style="vertical-align: inherit;">But after listening to them, I want to kiss the hands of the creators of JMM, who protected us from all this.</font></font><br><br><ul><li> <a href="https://sdcast.ksdaemon.ru/2017/09/sdcast-62/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDCast # 62</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : visiting Alexander Titov and Amir Ayupov, engineers from Intel and Alexey Markin, programmer from MCST</font></font></li><li> <a href="https://sdcast.ksdaemon.ru/2017/10/sdcast-63/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDCast # 63</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Away Alexey Markin, a programmer from the MCST</font></font></li><li> <a href="http://razborpoletov.com/2016/04/episode-107.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debriefing: # 107 Stories climbers</font></font></a> <br></li><li> <a href="http://razborpoletov.com/2018/02/episode-154.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debriefing: # 154 Intestines - Attack on New Year</font></font></a> <br></li></ul><br>  <b>Video</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In addition to the speeches of the above-mentioned people, pay attention to the academic video. </font></font><br><br><ul><li> <a href="https://youtu.be/ZgHz8nEFkfY">Computer Science Center — Лекция 11. Модели памяти и проблемы видимости</a> <br></li><li> <a href="https://www.youtube.com/playlist%3Flist%3DPLDrmKwRSNx7JSmqq0Dj2WtOKqJy6b81TR">Теория и практика многопоточного программирования</a> <br></li></ul></div>