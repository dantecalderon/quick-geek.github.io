<div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/hh/qv/5o/hhqv5okcynxdjke-qqhtmvokjsw.jpeg"></p><br><p>  There are quite a few introductions to the basics of working with Three.js, but you may notice a shortage of materials on more advanced topics.  And one of these themes is the combination of shaders and scenes with three-dimensional models.  In the eyes of many novice developers, it is as if incompatible things from different worlds.  Today, using a simple example of a “plasma sphere”, we will look at what ShaderMaterial is and what it is eaten with, as well as what EffectComposer is and how quickly you can postprocess for a rendered scene. </p><a name="habracut"></a><br><p>  It is assumed that the reader is familiar with the basics of working with Three.js and understands how shaders work.  If you have not come across this before, then I highly recommend reading: </p><br><ul><li>  <a href="https://habr.com/ru/post/420847/">An introduction to programming shaders for web designers</a> </li><li>  <a href="https://habr.com/ru/post/421821/">We apply Voronoi mosaic and geometric masks in shaders</a> </li><li>  <a href="https://habr.com/ru/post/433876/">Three-dimensional presentation of products on Three.js for the smallest</a> </li></ul><br><p>  But let's get started ... </p><br><h2 id="shadermaterial--chto-eto">  ShaderMaterial - what is it? </h2><br><p>  We have already seen how a flat texture is used and how it is stretched onto a three-dimensional object.  As this texture was an ordinary picture.  When we analyzed the writing of fragment shaders - everything was flat there too.  So: if we can generate a flat image using a shader, then why not use it as a texture? </p><br><p>  It is this thought that forms the basis for the shader material.  By creating material for a three-dimensional object, instead of a texture, we specify shaders for it.  In its basic form, it looks like this: </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shaderMaterial = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.ShaderMaterial({ <span class="hljs-attr"><span class="hljs-attr">uniforms</span></span>: { <span class="hljs-comment"><span class="hljs-comment">// ... }, vertexShader: '...', fragmentShader: '...' });</span></span></code> </pre> <br><p>  The fragment shader will be used to create the texture of the material, and you, of course, ask, what will the vertex shader do?  Will he again do the banal coordinate recalculation?  Yes, we will start with this simple option, but we can also set an offset or produce other manipulations for each vertex of a three-dimensional object - now there are no restrictions on the plane.  But it's better to look at it all with an example.  In words, little is clear.  Create a scene and make one sphere in the center. </p><br><p><img src="https://habrastorage.org/webt/ot/0n/zj/ot0nzjfc89iiwsqqdc2isam_woo.jpeg"></p><br><p>  We will use ShaderMaterial as a material for a sphere: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geometry = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.SphereBufferGeometry(<span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shaderMaterial = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.ShaderMaterial({ <span class="hljs-attr"><span class="hljs-attr">uniforms</span></span>: { <span class="hljs-comment"><span class="hljs-comment">// . . . }, vertexShader: document.getElementById('sphere-vertex-shader').textContent, fragmentShader: document.getElementById('sphere-fragment-shader').textContent }); const sphere = new THREE.Mesh(geometry, shaderMaterial); SCENE.add(sphere);</span></span></code> </pre> <br><p>  Vertex shader will be neutral: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ gl_Position = projectionMatrix * modelViewMatrix * vec4(position, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  Please note that Three.js passes its uniform variables.  We do not have to do anything, they are implied.  In themselves, they contain all sorts of matrices to which we already have access from JS, as well as the camera position.  Imagine that at the beginning of the shaders themselves something is inserted: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// = object.matrixWorld uniform mat4 modelMatrix; // = camera.matrixWorldInverse * object.matrixWorld uniform mat4 modelViewMatrix; // = camera.projectionMatrix uniform mat4 projectionMatrix; // = camera.matrixWorldInverse uniform mat4 viewMatrix; // = inverse transpose of modelViewMatrix uniform mat3 normalMatrix; // = camera position in world space uniform vec3 cameraPosition;</span></span></code> </pre> <br><p>  In addition, several attribute variables are passed to the vertex shader: </p><br><pre> <code class="cpp hljs">attribute vec3 position; attribute vec3 normal; attribute vec2 uv;</code> </pre> <br><p>  By name it is clear what it is - the position of the current vertex, the normal to the surface at this point and the coordinates on the texture with which the vertex corresponds. </p><br><p>  Traditionally, coordinates in space are designated as (x, y, z), and coordinates on the texture plane as (u, v).  Hence the name of the variable.  You will often meet him in various examples.  In theory, we need to transfer these coordinates to the fragment shader in order to work with them there.  This will do. </p><br><pre> <code class="cpp hljs">varying vec2 vUv; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  Fragment shader to begin with, let it be something like this: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EPSILON 0.02 varying vec2 vUv; void main() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((fract(vUv.x * 10.0) &lt; EPSILON) || (fract(vUv.y * 10.0) &lt; EPSILON)) { gl_FragColor = vec4(vec3(0.0), 1.0); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { gl_FragColor = vec4(1.0); } }</span></span></code> </pre> <br><p>  Just create a mesh.  If you think a little, then on the plane it will be just a grid of squares, but since we impose it on the sphere, it is distorted, turning into a globe.  On Wikipedia there is a good picture illustrating what is happening: </p><br><p><img src="https://habrastorage.org/webt/uc/uq/us/ucuqusdhqwfubpgtrpujvwq7uww.png"></p><br><p>  That is, in a fragmentary shader we make a flat texture, as in the center in this illustration, and Three.js then pulls it onto a sphere.  Very comfortably. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/sfi0zy/embed/preview/EGzKOd" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Of course, for more complex models, the sweep will be more complex.  But usually, when creating various design sites, we work with simple geometric shapes and it’s easy to imagine a sweep in your head. </p><br><h2 id="ok-a-chto-s-etim-mozhno-delat">  Ok, what can you do about it? </h2><br><p>  The main feature is that the shader material may change over time.  This is not a static thing that we painted once and forgot, we can animate it.  And both in color (in the fragment shader) and in form (in the vertex).  This is a very powerful tool. </p><br><p>  In our example, we will make a fire enveloping the sphere.  There will be two spheres - one ordinary (inside), and the second of shader material (outside, with a large radius).  Adding another sphere will not comment. </p><br><p><img src="https://habrastorage.org/webt/ti/_q/4m/ti_q4mo843ywt0fbjdmd8nmrcmy.jpeg"></p><br><p>  To begin, add time as a uniform variable for shaders in our material.  Without time, nowhere.  We have already done this on pure JS, but in Three.js it’s still as simple as that.  Let the time in the shaders be called uTime, and be stored in the variable TIME: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateUniforms</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ SCENE.traverse(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">child</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (child <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> THREE.Mesh &amp;&amp; child.material.type === <span class="hljs-string"><span class="hljs-string">'ShaderMaterial'</span></span>) { child.material.uniforms.uTime.value = TIME; child.material.needsUpdate = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }); }</code> </pre> <br><p>  Update everything every time the animate function is called: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">animate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ requestAnimationFrame(animate); TIME += <span class="hljs-number"><span class="hljs-number">0.005</span></span>; updateUniforms(); render(); }</code> </pre> <br><h2 id="ogon">  the fire </h2><br><p>  Creating a fire is in fact very similar to the generation of a landscape, only instead of heights it is color.  Or transparency, as in our case. </p><br><p>  Functions for random and noise, we have already seen, we will not analyze them in detail.  We only need to impose noise at different frequencies to add diversity, and make each of these noises shift at different speeds.  Something like flames will turn out, the big ones move slowly, the small ones move faster: </p><br><pre> <code class="cpp hljs">uniform <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> uTime; varying vec2 vUv; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec2)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec2)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vec2 position1 = vec2(vUv.x * <span class="hljs-number"><span class="hljs-number">4.0</span></span>, vUv.y - uTime); vec2 position2 = vec2(vUv.x * <span class="hljs-number"><span class="hljs-number">4.0</span></span>, vUv.y - uTime * <span class="hljs-number"><span class="hljs-number">2.0</span></span>); vec2 position3 = vec2(vUv.x * <span class="hljs-number"><span class="hljs-number">4.0</span></span>, vUv.y - uTime * <span class="hljs-number"><span class="hljs-number">3.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> color = ( noise(position1 * <span class="hljs-number"><span class="hljs-number">5.0</span></span>) + noise(position2 * <span class="hljs-number"><span class="hljs-number">10.0</span></span>) + noise(position3 * <span class="hljs-number"><span class="hljs-number">15.0</span></span>)) / <span class="hljs-number"><span class="hljs-number">3.0</span></span>; gl_FragColor = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, color - smoothstep(<span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-number"><span class="hljs-number">1.3</span></span>, vUv.y)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec2 seed)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fract(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(dot(seed, vec2(<span class="hljs-number"><span class="hljs-number">12.9898</span></span>,<span class="hljs-number"><span class="hljs-number">78.233</span></span>))) * <span class="hljs-number"><span class="hljs-number">43758.5453123</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec2 position)</span></span></span><span class="hljs-function"> </span></span>{ vec2 blockPosition = <span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> topLeftValue = rand(blockPosition); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> topRightValue = rand(blockPosition + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bottomLeftValue = rand(blockPosition + vec2(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bottomRightValue = rand(blockPosition + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); vec2 computedValue = smoothstep(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, fract(position)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mix(topLeftValue, topRightValue, computedValue.x) + (bottomLeftValue - topLeftValue) * computedValue.y * (<span class="hljs-number"><span class="hljs-number">1.0</span></span> - computedValue.x) + (bottomRightValue - topRightValue) * computedValue.x * computedValue.y; }</code> </pre> <br><p>  So that the flame does not cover the entire sphere, we play with the fourth color parameter - transparency - and bind it to the y coordinate.  In our case, this option is very convenient.  More generally, we impose a gradient with transparency on noise. </p><br><blockquote>  At such moments it is useful to recall the function smoothstep </blockquote><p>  In general, this approach to creating fire using shaders is a classic.  You will often meet him in various places.  It will be useful to play with magic numbers - they are put in an example at random and at the same time how the plasma will look will depend on them. </p><br><p>  In order to make the fire more interesting, let's move on to the vertex shader and get a little poshamanim ... </p><br><p>  How to make the flame “flow” a little in space?  For beginners, this question can cause great difficulties, despite its simplicity.  I have seen very complex approaches to solving this issue, but in fact - we need to smoothly move the vertices on the sphere along the lines “from its center”.  Here and there, here and there.  Three.js already gave us the current position of the vertex and the normal - we will use them.  For “back and forth,” some limited function will fit, for example, sine.  You can experiment, of course, but sine is the default option. </p><br><blockquote>  You do not know what to take - take a sine.  Better yet, the amount of sines with different frequency. </blockquote><p>  We shift the coordinates along the normal to the obtained value and recalculate according to the previously known formula. </p><br><pre> <code class="cpp hljs">uniform <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> uTime; varying vec2 vUv; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vUv = uv; vec3 delta = normal * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(position.x * position.y * uTime / <span class="hljs-number"><span class="hljs-number">10.0</span></span>); vec3 newPosition = position + delta; gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  What we get is no longer a sphere.  That ... I don't even know if this one has a name.  But, again, do not forget to play with the coefficients - they affect a lot.  When creating such effects, something is often selected by trial and error and it is very useful to develop a “mathematical intuition” - the ability to more or less understand how a particular function behaves, how it depends on which variables. </p><br><p>  At this stage, we have an interesting but slightly clumsy image.  So at first we will look a little at post-processing, and then we will pass to a live example. </p><br><h2 id="postobrabotka">  Post processing </h2><br><p>  The ability to do something with a rendered Three.js image is a very useful thing, while undeservedly forgotten in numerous series of lessons.  Technically, this is implemented as follows: the image that the renderer gave us is sent to the EffectComposer (as long as it is a black box), which shamanizes something in itself and outputs the final image to the canvas.  That is, after the renderer another module is added.  In this composer, we pass the parameters - what to do with the resulting image.  One such parameter is called pass.  In a sense, the composer works like some kind of Gulp - it does nothing, we give it plugins that are already doing the work.  Perhaps it’s not quite correct to say so, but the idea should be clear. </p><br><p>  Everything that we will use further is not included in the basic composition of Three.js, so we include few dependencies and dependencies of the dependencies themselves: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://unpkg.com/three@0.99.0/examples/js/postprocessing/EffectComposer.js'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://unpkg.com/three@0.99.0/examples/js/postprocessing/RenderPass.js'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://unpkg.com/three@0.99.0/examples/js/postprocessing/ShaderPass.js'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://unpkg.com/three@0.99.0/examples/js/shaders/CopyShader.js'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://unpkg.com/three@0.99.0/examples/js/shaders/LuminosityHighPassShader.js'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://unpkg.com/three@0.99.0/examples/js/postprocessing/UnrealBloomPass.js'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><blockquote>  Remember that these scripts are included in the package three and you can collect all this into a single bundle with the help of webpacks or analogues. </blockquote><p>  In the base view, a composer is created like this: </p><br><pre> <code class="javascript hljs">COMPOSER = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.EffectComposer(RENDERER); COMPOSER.setSize(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerWidth, <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerHeight); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> renderPass = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.RenderPass(SCENE, CAMERA); renderPass.renderToScreen = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; COMPOSER.addPass(renderPass);</code> </pre> <br><p>  RenderPass does virtually nothing new.  It simply renders what we used to receive from a regular renderer.  In fact, if you look at the source RenderPass, then there you can find a standard renderer.  Since now the rendering takes place there, we need to replace the renderer with a composite in our script: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// RENDERER.render(SCENE, CAMERA); COMPOSER.render(SCENE, CAMERA); }</span></span></code> </pre> <br><p>  This approach using RenderPass as a first pass is a standard practice when working with an EffectComposer.  Usually we need to first get a rendered image of the scene, then to do something with it. </p><br><p>  In the examples from Three.js, in the postprocessing section, you can find a thing called UnrealBloomPass.  This is a ported script from the Unreal engine.  It adds a slight glow that can be used to create more beautiful lighting.  Often this will be the first step to image improvement. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bloomPass = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.UnrealBloomPass( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.Vector2(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerWidth, <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerHeight), <span class="hljs-number"><span class="hljs-number">1.5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>); bloomPass.renderToScreen = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; COMPOSER.addPass(bloomPass);</code> </pre> <br><p>  Note: the renderToScreen option is set only to the last Pass, which we passed to the composer. </p><br><p>  But let's see what kind of glow this bloomPass gave us and how it goes with the sphere: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/sfi0zy/embed/preview/MZdegG" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Agree, this is much more interesting than just a sphere and an ordinary source of light, as they are usually shown in the initial lessons on Three.js. </p><br><p>  But we will go even further ... </p><br><h2 id="bolshe-sheyderov-bogu-sheyderov">  More shaders to god shaders! </h2><br><p><img src="https://habrastorage.org/webt/kk/ap/ks/kkapksi_a_secwfoh81jjxkgtx4.jpeg"></p><br><p>  It is very useful to use console.log and look at the structure of the composer.  In it you can find some elements with the names renderTarget1, renderTarget2, etc., where the numbers correspond to the indexes of the passed passes.  And here it becomes clear why the EffectComposer is so called.  It works on the principle of filters in SVG.  Remember, there you can use the result of the implementation of some filters in others?  Here is the same thing - you can combine effects. </p><br><blockquote>  Using console.log to understand the internal structure of Three.js objects and many other libraries is very useful.  Use this approach frequently to better understand what is what. </blockquote><p>  Add another pass.  This time it will be ShaderPass. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shader = { <span class="hljs-attr"><span class="hljs-attr">uniforms</span></span>: { <span class="hljs-attr"><span class="hljs-attr">uRender</span></span>: { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: COMPOSER.renderTarget2 }, <span class="hljs-attr"><span class="hljs-attr">uTime</span></span>: { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: TIME } }, <span class="hljs-attr"><span class="hljs-attr">vertexShader</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'postprocessing-vertex-shader'</span></span>).textContent, <span class="hljs-attr"><span class="hljs-attr">fragmentShader</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'postprocessing-fragment-shader'</span></span>).textContent }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shaderPass = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.ShaderPass(shader); shaderPass.renderToScreen = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; COMPOSER.addPass(shaderPass);</code> </pre> <br><p>  In renderTarget2, the result of executing the previous pass is bloomPass (it was the second in a row), we use it as a texture (this is in fact a flat, rendered image) and pass as a uniform variable to the new shader. </p><br><p>  Perhaps it is worth slowing down and realize all the magic ... </p><br><p>  Next we create a simple vertex shader.  In most cases at this stage we don’t need to do anything with the vertices, we only transfer the coordinates (u, v) to the fragment shader: </p><br><pre> <code class="cpp hljs">varying vec2 vUv; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  And in the fragment we can be entertained by your own taste and color.  For example, we can add a light glitch effect, make everything black and white and play around with brightness / contrast: </p><br><pre> <code class="cpp hljs">uniform sampler2D uRender; uniform <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> uTime; varying vec2 vUv; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec2)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> randomValue = rand(vec2(<span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(vUv.y * <span class="hljs-number"><span class="hljs-number">7.0</span></span>), uTime / <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); vec4 color; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (randomValue &lt; <span class="hljs-number"><span class="hljs-number">0.02</span></span>) { color = texture2D(uRender, vec2(vUv.x + randomValue - <span class="hljs-number"><span class="hljs-number">0.01</span></span>, vUv.y)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { color = texture2D(uRender, vUv); } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lightness = (color.r + color.g + color.b) / <span class="hljs-number"><span class="hljs-number">3.0</span></span>; color.rgb = vec3(smoothstep(<span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, lightness)); gl_FragColor = color; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec2 seed)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fract(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(dot(seed, vec2(<span class="hljs-number"><span class="hljs-number">12.9898</span></span>,<span class="hljs-number"><span class="hljs-number">78.233</span></span>))) * <span class="hljs-number"><span class="hljs-number">43758.5453123</span></span>); }</code> </pre> <br><p>  Let's look at the result: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/sfi0zy/embed/preview/MZdeKB" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  As you can see, filters are superimposed on the sphere.  It is still three-dimensional, nothing is broken, but on the canvas we have the processed image. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  Shader materials and post-processing in Three.js are two small, but very powerful tools that are definitely worth adopting.  There are lots of options for their use - everything is limited by your imagination.  Even the simplest scenes with their help can be changed beyond recognition. </p></div>