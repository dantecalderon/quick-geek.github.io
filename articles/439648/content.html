<div class="post__text post__text-html js-mediator-article">  <b>Hello dear readers Habra</b> <br><br>  <b>Java internal and nested classes</b> <br><br>  03/02/2017 - 2019 <br><br>  <b>Part 1. Start</b> <br><br>  <b>Purpose of the article: To</b> tell about internal, nested, local, anonymous classes.  Show examples of their use.  Write and test classes in java code.  Tell about the properties of these classes. <br><br><a name="habracut"></a>  A little introduction.  I suggest you heed a cycle of three articles. <br>  In them, I talk about internal, nested, local, anonymous classes.  It's about terminology and application.  For these articles, I wrote quite a lot of code. <br>  This is a training code, not a guide to action.  That is, I wrote the code for better understanding.  I also tried to explain the work of the training code.  It took quite a long time to write the publication.  Please treat with understanding. <cut></cut><br><br>  To begin with, what is the inner and nested classes.  Let's look at the terminology found in the documentation <a href="https://ru.wikipedia.org/">&gt;&gt;&gt;</a> : <br><br><blockquote>  In Java, there are 4 types of nested (nested) classes: <br><ol><li>  Static nested classes </li><li>  Inner classes </li><li>  Local Classes </li><li>  Anonymous (unnamed) classes </li></ol><br></blockquote>  Joshua Bloch: <br><blockquote>  “There are four categories of nested classes: <br><br><ul><li>  static member class </li><li>  nonstatic member class, </li><li>  anonymous class (anonymous class) </li><li>  and local class. </li></ul>  " </blockquote>  Let's try to figure out what it is. <br><br>  Let's start a bit remotely, since all this is directly related to our questions.  Recall object-oriented programming.  Relationship composition and inheritance. <br><br>  In his book “Java 2 Developer Guide,” Michael Morgan very well and describes in detail the relationships between classes and objects.  We will look at some of them.  The “this is - that” relationship is expressed by inheritance, and the “has a part” relationship is described by composition. <br><br>  In our examples, we mainly consider composition.  Since nested classes are part of something.  That is, we have a wrapper class and a nested class defined within the wrapper class.  Composition example: the car has an engine, a door, 4 wheels, a housing.  And we can describe the car using internal (Inner) classes. <br><br>  An example of this use can be found in Bruce Ekkel’s book, The Java Philosophy. <br><cut></cut><br><pre><code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/* Пример №1 */</span></span> <span class="hljs-comment"><span class="hljs-comment">//: c06:Car.java // композиция с использованием открытых объектов // двигатель class Engine{ public void start(){} public void rev(){} public void stop(){} } class Wheel{ public void inflare(int psi){}// накачать } // окно class Window{ public void rollup(){}// приоткрыть public void rolldown(){}// опустить } // дверь class Door{ public Window window=new Window(); public void open(){}//открыть public void close(){}// закрыть } // машина public class Car{ public Engine engine = new Engine(); public Wheel[] wheel = new Wheel[4]; public Door left = new Door(), right = new Door();//две двери public Car(){ for(int i = 0; i&lt;4; i++) wheel[i]= new Wheel(); } public static void main(String[] args){ Car car= new Car(); car.left.window.rollup(); car.wheel[0].inflare(72); } }</span></span></code> </pre> <br>  There is some author warning about using the code in this form: <br><blockquote>  "Since the composition of the object is part of the analysis of the task (and not <br>  just part of the class implementation), declaring class members open, helps the client programmer understand how to use the class, and makes it easier for the creator to write code.  However, it must be remembered that the described case is special, and basically the fields of the class must be declared private. " </blockquote>  <b>Static nested classes</b> <br><br>  <i>Defining nested classes:</i> <br><blockquote>  A class is called nested if it is defined inside another class.  That is, a class is simply defined inside another, not even important statically defined or not statically.  A nested class is created to serve the class around it.  If the nested class is useful in some other context, it should become a top-level class. </blockquote>  <i>Application</i> <br><br>  Nested classes are used in cases when you need to write a small auxiliary code for another class.  A nested class is also created to hide its variables and methods from the outside world.  Thus, the nested class is another elegant way to limit the scope.  It also makes sense to use inner classes if it is assumed that they will use parent elements in order not to pass on too much in constructors. <br><br>  You can see an example of a nested class in the Orakle documentation: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/* Пример №2 */</span></span> <span class="hljs-comment"><span class="hljs-comment">// class OuterClass { ... class NestedClass { ... } }</span></span></code> </pre><br>  We do not have, so far, any context for the use of this construct.  With the same success, we can name the nested class instead of: “Nested class” (NestedClass) - “Inner class” InnerClass.  Further we will understand what the differences are and in what contexts the classes are used.  Bruce Ekkel writes in his book The Java Philosophy: <br><blockquote>  A class is called nested if it is defined inside another class " </blockquote>  Oracle documentation can be viewed at this link: <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html">&gt;&gt;&gt;</a> <br><br>  <b>Terminology:</b> <br><br>  There are four categories of nested classes: <br><br><ol><li>  Static nested classes and non-static nested classes.  Nested classes declared statically are called nested static classes. </li><li>  Inner classes - when an object of the inner class is associated with an object of the framing class.  Non-static nested classes are called inner classes if they are associated with an outer class. </li><li>  Local classes are declared inside a block of code and are not a member of the framing class.  In this case, you can consider the class as a local variable of type class. </li><li>  Anonymous classes are inheritable from any class in which the class name is not specified when declaring. </li></ol><br>  <b>Reasons for using nested classes (Nesred Classes)</b> <b><br></b>  <b>Why use nested classes?</b> <br><br>  The reasons for using nested classes are as follows.  If a class is only useful for one other class, then it is logical to embed it in this class and store them together.  Using nested classes increases encapsulation.  Consider two top-level classes, A and B, where B needs access to members that would otherwise be declared closed. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/* Пример №3 */</span></span> <span class="hljs-comment"><span class="hljs-comment">// class A{ ... class B { ... } }</span></span></code> </pre><br><br>  By hiding class “B” within class “A”, members of class “A” can be declared closed, and “B” can access them.  In addition, the "B" itself can be hidden from the outside world. <br><br>  Let's demonstrate it in the code: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/* Учебный пример №4 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">package</span></span> innernested; <span class="hljs-comment"><span class="hljs-comment">/** * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@author</span></span></span><span class="hljs-comment"> Ar20L80 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iPrivVar; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPrivateOfA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ A.iPrivVar = <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>; } } }</code> </pre><br>  Using nested classes results in more readable and supported code: <br>  Placing the class closer to where it will be used makes the code more readable. <br><br>  <b>Static Nested Classes</b> <b><br></b>  <b>Static Nested Classes</b> <br><br>  The reasons for using static nested classes are as follows. <br><br>  For the case when the relationship between the object of the nested class and the object of the external class is not needed, you can make the nested class static. <br><br>  Since the inner class is associated with an instance, it cannot define any static members in itself. <br><br>  Static nested classes have no restrictions on declaring their data and fields as static. <br><br>  From the nested static class, we do not have access to the external non-static variable of the external class. <br><br>  The code below demonstrates this: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/* Учебный пример №5 Статические вложенные классы Попытка доступа к нестатической переменной внешнего класса Outer2 через обращение из вложенного статического класса Nested2 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">package</span></span> nested; <span class="hljs-comment"><span class="hljs-comment">/** * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@author</span></span></span><span class="hljs-comment"> Ar20L80 * 20.03.2016 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer2</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pubOutVar; <span class="hljs-comment"><span class="hljs-comment">// переменная не статическая и мы не имеем к ней доступа // из внутреннего статического класса private int prOutVar; public Outer2(){} static class Nested2{ public static int pub_innVar; // тут все в порядке public Nested2() {} int getOuterPublicVariable() { return Outer2.this.pubOutVar; // ошибка return Outer2.pubOutVar; // ошибка } int getOuterPrivateVariable() { return Outer2.this.prOutVar; // ошибка return Outer2.prOutVar; // ошибка } } } /* вывод программы: программа не компилируется */</span></span></code> </pre><br>  <i>Conclusion:</i> We do not have access to the non-static field of the outer class through the static context of the nested class. <br><br>  But we have access to the private static fields of the outer class from the nested static class. <br><br>  The following code snippet demonstrates this: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/* Учебный пример №6 Статические вложенные классы Демонстрация доступа к «приватной» статической переменной внешнего класса из внутреннего статического класса 20.03.2016 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">package</span></span> nested; <span class="hljs-comment"><span class="hljs-comment">/** * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@author</span></span></span><span class="hljs-comment"> Ar20L80 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer3</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> prStOuterVar; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Outer3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Nested3</span></span></span><span class="hljs-class"> // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Nested</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getStaticOuterVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Outer3.prStOuterVar; <span class="hljs-comment"><span class="hljs-comment">// ok } void setStaticOuterVariable(int var) { Outer3.prStOuterVar = var; // ok } } public static void main(String[] args) { Outer3.Nested3 nestedObj = new Outer3.Nested3(); // экземпляр класса внутренний Outer3.prStOuterVar = 19; System.out.println("nestedObj.getStaticOuterVar() = "+nestedObj.getStaticOuterVar());//статическая переменная внешнего класса из экземпляра внутреннего // устанавливаем через экземпляр внутреннего класса nestedObj.setStaticOuterVariable(77); System.out.println("Outer3.prStOuterVar = "+ Outer3.prStOuterVar); } } /* Вывод программы: nestedObj.getStaticOuterVar() = 19 Outer3.prStOuterVar = 77 */</span></span></code> </pre> <br>  In this sample code, we created an instance of the inner class with the name "nestedObj". <br>  That is, we get access to a private static variable of the outer class, through an instance of the inner class.  In the context of the instance associated with the outer class, we have an inner class. <br><br>  <b>Literature</b> <br><br>  Michael Morgan.  "Java 2. Developer Guide" ISBN 5-8459-0046-8 <br>  Bruce Ekkel.  "The Philosophy of Java." ISBN 5-272-00250-4 <br>  Herbert Shieldt “Java.  Complete guide.  8th edition. "ISBN: 978-5-8459-1759-1 <br><br>  <b>References:</b> <br><br>  <a href="https://ru.wikipedia.org/">ru.wikipedia.org</a> <br>  <a href="http://src-code.net/lokalnye-vnutrennie-klassy-java/">src-code.net/lokalnye-vnutrennie-klassy-java</a> <br><br>  <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html">Oracle documentation</a> <br><br>  All questions, comments, additions, criticism are welcome. <br><br>  To be continued… <br>  Part 2 <a href="https://habr.com/ru/post/439666/">&gt;&gt;</a> </div>