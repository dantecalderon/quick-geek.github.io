<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Interrupts from external devices in the x86 system. Part 3. Setting up interrupt routing in the chipset using the example of coreboot</title>
  <meta name="description" content="We continue to consider setting interrupts from external devices on the x86 system. 
 In Part 1 ( Evolution of Interrupt Controllers ), we looked at t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Interrupts from external devices in the x86 system. Part 3. Setting up interrupt routing in the chipset using the example of coreboot</h1><div class="post__text post__text-html js-mediator-article">  We continue to consider setting interrupts from external devices on the x86 system. <br>  In Part 1 ( <a href="https://habr.com/ru/post/430548/">Evolution of Interrupt Controllers</a> ), we looked at the theoretical foundations of interrupt controllers and general terms, and in Part 2 ( <a href="https://habr.com/ru/post/431372/">Linux kernel boot options</a> ), we looked at how the OS chooses between controllers in practice.  In this part we will look at how the BIOS configures IRQ routing to the interrupt controllers in the chipset. <br><br>  No modern BIOS development companies (AwardBIOS / AMIBIOS / Insyde) disclose the source code of their programs.  But fortunately there is a <a href="https://www.coreboot.org/">Coreboot</a> - a project to replace proprietary BIOS with free software.  In its code, we will see how the routing of interrupts in the chipset is configured. <br><br><img src="https://habrastorage.org/webt/mx/vi/wu/mxviwuisp5rglec_kgsk872hmy8.png"><br><br><a name="habracut"></a><br><h2>  Theory </h2><br>  To start refresh and supplement their theoretical knowledge.  In <a href="https://habr.com/ru/post/430548/">Part 1,</a> we have identified a common interrupt path for the PIC and APIC case. <br><br>  <b>PIC:</b> <br><br><img src="https://habrastorage.org/webt/u_/jr/u9/u_jru9pemdeda2xvvbqihvgtp3y.png"><br><br>  <b>APIC:</b> <br><br><img src="https://habrastorage.org/webt/mc/ra/hj/mcrahjn-owk9qrcmyiixcmhomcq.png"><br><br>  In these figures, the mapping of the PCI device ‚Üí PIR is depicted in the abstract, in fact it is somewhat more complicated.  In reality, each PCI device has 4 interrupt lines (INTA #, INTB #, INTC #, INTD #).  Each PCI device (device) can have up to 8 functions (functions), and each function already has one INTx # interrupt.  Which line of INTx # each function of the device will pull is either fixed in the hardware or determined by the configuration of the device. <br><br><img src="https://habrastorage.org/webt/dk/ny/gh/dknyghwfo8gktn5l_lmmqb5awz0.png"><br><br>  In essence, functions are separate logical blocks.  For example, in one PCI device there may be the Smbus controller function, the SATA controller function, the LPC bridge function.  On the OS side, each function is as a separate device with its own PCI Config configuration space. <br><br>  In the simplest (and most common) case in a PCI device, there is only one function, the interruption from which goes along the INTA # line.  But in general, the device can even have more than 4 functions (as we said before 8), then some of them will have to be planted on one INTx line # (PCI interrupts can divide the line).  Also, for PCI devices included in the chipset, writing to special registers often makes it possible to specify which functions use which INTx # lines (and whether they use it at all). <br><br>  By systematizing our knowledge, we denote the path (routing) of interruptions from any PCI function through INTx # ‚Üí PIRQy ‚Üí IRQz, where: <br><br><ul><li>  INTx # - INT # line (INTA #, INTB #, INTC #, INTD #) PCI device that the function will use </li><li>  PIRQy - the PIRQ line (PIRQA, PIRQB, ...) from the PIR to which the INTx line is connected # </li><li>  IRQz - IRQ line (0, 1, 2, ...) on the interrupt controller (APIC / PIC), which is connected to the PIRQy line </li></ul><br><h3>  Why can't we just connect INTA # ‚Üí PIRQA, INTB # ‚Üí PIRQB, ... everywhere? </h3><br>  Why bother with setting up routing at all?  Suppose we decided not to bother and get all the interrupt lines from all PCI devices to the same PIRQ lines.  So to speak: <br><br><ul><li>  INTA # ‚Üí PIRQA </li><li>  INTB # ‚Üí PIRQB </li><li>  INTC # ‚Üí PIRQC </li><li>  INTD # ‚Üí PIRQD </li></ul><br>  As we have said above, the most common case is when a PCI device has one function, and its interruption is initiated on the INTA # line (because why should the device developer start it differently?).  So if we suddenly decide to start all the lines as we wrote, then almost all interrupts from the devices will be divided into PIRQA lines.  Suppose she wound up on IRQ16.  Then, each time the processor is informed that an interrupt has occurred on the IRQ16 line, it will have to interrogate the drivers of all devices connected to the IRQ16 (PIRQA) line to see if they have an interrupt for it.  If there are many such devices, this naturally does not speed up the response of the system to an interrupt.  And the lines PIRQB-PIRQD in this case will be mostly idle.  For clarity, the figure illustrates the problem: <br><br><img src="https://habrastorage.org/webt/cz/dv/bf/czdvbfsnymw5xyyqujavawdcv_m.png"><br><br>  But everything could have been done like this: <br><br><img src="https://habrastorage.org/webt/dk/3e/x6/dk3ex67xjmm_9h0q3miq2djqnti.png"><br><br>  The picture was a bit confusing, but the point is that we simply connect the INTx lines here with PIRQy by round-robin (PIRQA, PIRQB, PIRQC, PIRQD, PIRQA, PIRQB, PIRQC, PIRQD, PIRQA, PIRQB, PIRQC, PIRQD,. ..) <br><br>  It should be noted that here it is necessary to take into account not only the fact that the same number of PCI functions are loaded on each PIRQ line.  After all, some functions can create interrupts very rarely, and some constantly (for example, an Ethernet controller).  In this case, even the allocation of a separate PIRQ line for interruptions from such a function can be quite justified. <br><br>  Based on the foregoing, the BIOS developer, among other things, has the task of making the PIRQ lines evenly loaded with interrupts. <br><br><h3>  What should the BIOS do? </h3><br>  Systematized in the picture: <br><br><img src="https://habrastorage.org/webt/pm/rq/xg/pmrqxgkdu0nkjz6yb44vdn79a8q.png"><br><br><ul><li>  <b>1) Specify which line of INTx # pulls each of the functions of PCI devices</b> <br>  For external PCI devices, this item is not made, but for the functions of PCI devices included in the chipset, it may well be. </li><li>  <b>2) Configure the mapping INTx # ‚Üí PIRQy for each of the PCI devices</b> <br>  It is worth noting that the PIRQy signals may be larger than the standard four (PIRQA, PIRQB, PIRQC, PIRQD).  For example 8: PIRQA-PIRQH. </li></ul><br>  PIRQy signals go on the IRQz line of the selected interrupt controller (APIC / PIC).  Since we want to support all possible methods of loading (see <a href="https://habr.com/ru/post/431372/">part 2</a> ), we need to fill in both mappings: <br><br><ul><li>  <b>3a) Fill in the PIRQy ‚Üí IRQz1 mapping for PIR ‚Üí I / O APIC communications</b> <br>  But usually it is not necessary to do this, since the PIRQy lines are fixed on the APIC line.  A common solution is PIRQA ‚Üí IRQ16, PIRQB ‚Üí IRQ17, ... The simplest solution is because  Putting the PIRQy lines on the controller lines ‚â•16 you can not worry about conflicts with inseparable interrupts from ISA devices. </li><li>  <b>3b) Fill in PIRQy ‚Üí IRQz2 mapping for PIR ‚Üí PIC communication</b> <br>  This must be provided in case we use routing through the PIC controller.  There is no such unambiguous solution as in the case of APIC, because in the case of PIC, one should remember about the possibility of conflicts with unshareable interruptions from ISA devices. </li></ul><br>  The last fourth point is necessary to help the OS in determining the routing interrupts.  These registers are usually not used by the device itself. <br><br><ul><li>  <b>4) Fill in the Interrupt Line / Interrupt Pin registers for each PCI function</b> <br>  In general, the Interrupt Pin register is filled automatically and is usually Read-Only, so you will most likely only need to fill the Interrupt Line register.  This should be provided in case we use routing through the PIC controller without providing the OS with any table about interrupt routing (see again <a href="https://habr.com/ru/post/431372/">part 2</a> ).  If the tables are provided and this mapping is consistent with the routing tables ($ PIR / ACPI), then the OS often leaves it. </li></ul><br>  It should be noted that we do not touch the $ PIR / MPtable / ACPI tables yet and consider how to configure the registers of the chipset in terms of routing interrupts before transferring control to the system loader.  Interrupt tables are a topic for a separate article (possibly a future one). <br><br>  So, the theoretical foundations have been studied, let's finally start practicing! <br><br><h2>  Practice </h2><br>  As an example, for articles in this series I use a customized motherboard with an Intel Haswell i7 processor and a LynxPoint-LP chipset.  On this board, I launched the coreboot in conjunction with SeaBIOS.  Coreboot provides hardware-dependent initialization, and the load (payload) SeaBIOS for it provides a BIOS interface for operating systems.  In this article, I will not describe the process of configuring coreboot, but will only try to show with an example what kind of BIOS settings should I make in the chipset for routing IRQ interrupts from external devices. <br><br>  Since the coreboot project is being actively developed so that the article is always relevant, we will consider the code using the example of the latest fixed version <a href="https://review.coreboot.org/cgit/coreboot.git/tree/%3Fh%3D4.9">4.9</a> (release 2018-12-20). <br><br>  The closest motherboard to mine is the Google Beltino with the Panther variation.  The main folder for this motherboard is the folder <a href="https://review.coreboot.org/cgit/coreboot.git/tree/src/mainboard/google/beltino%3Fh%3D4.9">‚Äúsrc \ mainboard \ google \ beltino‚Äù</a> .  All settings and code specific to this board are concentrated here. <br><br>  So, let's begin to understand where the above items are configured: <br><br><h4>  1) Specify which line of INTx # pulls each of the functions of PCI devices </h4><br>  This information is defined in the file <a href="">‚Äúsrc / mainboard / google / beltino / romstage.c‚Äù</a> in the rcba_config structure via the DxxIP (Device xx Interrupt Pin Register (IP)) registers.  This register shows which pin INTx # (A / B / C / D) each of the functions of the device displays an interrupt. <br><br>  Possible options (see the file <a href="">‚Äúsrc / southbridge / intel / lynxpoint / pch.h‚Äù</a> ): <br><br><pre><code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0</span></span>h = No interrupt <span class="hljs-number"><span class="hljs-number">1</span></span>h = INTA# <span class="hljs-number"><span class="hljs-number">2</span></span>h = INTB# <span class="hljs-number"><span class="hljs-number">3</span></span>h = INTC# <span class="hljs-number"><span class="hljs-number">4</span></span>h = INTD#</code> </pre> <br>  It is assumed that several functions use the same pin. <br><br>  It is assumed that functions may not use a pin for interrupts (No interrupt). <br>  Everything as we saw in the figure at the beginning of the article. <br><br>  The full code is responsible for the item indicated by us: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Device interrupt pin register (board specific) */</span></span> RCBA_SET_REG_32(D31IP, (INTC &lt;&lt; D31IP_TTIP) | (NOINT &lt;&lt; D31IP_SIP2) | (INTB &lt;&lt; D31IP_SMIP) | (INTA &lt;&lt; D31IP_SIP)), RCBA_SET_REG_32(D29IP, (INTA &lt;&lt; D29IP_E1P)), RCBA_SET_REG_32(D28IP, (INTA &lt;&lt; D28IP_P1IP) | (INTC &lt;&lt; D28IP_P3IP) | (INTB &lt;&lt; D28IP_P4IP)), RCBA_SET_REG_32(D27IP, (INTA &lt;&lt; D27IP_ZIP)), RCBA_SET_REG_32(D26IP, (INTA &lt;&lt; D26IP_E2P)), RCBA_SET_REG_32(D22IP, (NOINT &lt;&lt; D22IP_MEI1IP)), RCBA_SET_REG_32(D20IP, (INTA &lt;&lt; D20IP_XHCI)),</code> </pre> <br>  For a better understanding, consider a few examples: <br><br>  <b>Example 1:</b> <br><br>  In the device 0x1d (29 decimal) one function (EHCI controller). <br><br>  In this case, assign an interrupt to INTA #. <br><br>  00: 1d.0 - INTA # <br><br><pre> <code class="cpp hljs">RCBA_SET_REG_32(D29IP, (INTA &lt;&lt; D29IP_E1P)),</code> </pre> <br>  <b>Example 2:</b> <br>  The device 0x1f (31 in the decimal system) has the functions Thermal Sensor Controller (00: 1f.6), SATA controller 2 (00: 1f.2), SMBus controller (00: 1f.3), SATA controller 1 (00: 1f .2).  We want to use only SMBus controller, SATA controller 1 and Thermal Sensor controller. <br><br>  00: 1f.2 - INTA # (SATA controller 1) <br>  00: 1f.3 - INTB # (SMBus controller) <br>  00: 1f.2 - No interrupt (SATA controller 2 is not used) <br>  00: 1f.6 - INTC # (Thermal Sensor Controller) <br><br>  For such a configuration should write: <br><br><pre> <code class="cpp hljs">RCBA_SET_REG_32(D31IP, (INTC &lt;&lt; D31IP_TTIP) | (NOINT &lt;&lt; D31IP_SIP2) | (INTB &lt;&lt; D31IP_SMIP) | (INTA &lt;&lt; D31IP_SIP)),</code> </pre> <br>  <b>Example 3:</b> <br><br>  In one Device, the number of functions we need is more than 4. In the 0x1c device, each function is responsible for the PCI Express port.  In order for ports 0-5 to work, and the interrupts are evenly distributed between the lines, you can make the following setting: <br><br>  00: 1c.0 - INTA # (PCI Express Port 0) <br>  00.1c.1 - INTB # (PCI Express Port 1) <br>  00.1c.2 - INTC # (PCI Express Port 2) <br>  00.1c.3 - INTD # (PCI Express Port 3) <br>  00.1c.4 - INTA # (PCI Express Port 4) <br>  00.1c.5 - INTB # (PCI Express Port 5) <br>  00.1c.6 - No interrupt (port not used) <br>  00.1c.7 - No interrupt (port not used) <br><br><pre> <code class="cpp hljs">RCBA_SET_REG_32(D28IP, (INTA &lt;&lt; D28IP_P1IP) | (INTB &lt;&lt; D28IP_P2IP) | (INTC &lt;&lt; D28IP_P3IP) | (INTD &lt;&lt; D28IP_P4IP) | (INTA &lt;&lt; D28IP_P5IP) | (INTB &lt;&lt; D28IP_P6IP) | (NOINT &lt;&lt; D28IP_P7IP) | (NOINT &lt;&lt; D28IP_P8IP)),</code> </pre> <br><h4>  2) Configure the mapping INTx # ‚Üí PIRQy for each of the PCI devices </h4><br>  This information is also defined in the file <a href="">‚Äúsrc \ mainboard \ google \ beltino \ romstage.c‚Äù</a> <br>  in the rcba_config structure, but through the DxxIR (Device xx Interrupt Route Register) registers. <br><br>  The information in this register shows to which PIRQx line (A / B / C / D / E / F / G / H) each of the INTx # interrupt lines is connected. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Device interrupt route registers */</span></span> RCBA_SET_REG_32(D31IR, DIR_ROUTE(PIRQG, PIRQC, PIRQB, PIRQA)),<span class="hljs-comment"><span class="hljs-comment">/* LPC */</span></span> RCBA_SET_REG_32(D29IR, DIR_ROUTE(PIRQD, PIRQD, PIRQD, PIRQD)),<span class="hljs-comment"><span class="hljs-comment">/* EHCI */</span></span> RCBA_SET_REG_32(D28IR, DIR_ROUTE(PIRQA, PIRQB, PIRQC, PIRQD)),<span class="hljs-comment"><span class="hljs-comment">/* PCIE */</span></span> RCBA_SET_REG_32(D27IR, DIR_ROUTE(PIRQG, PIRQG, PIRQG, PIRQG)),<span class="hljs-comment"><span class="hljs-comment">/* HDA */</span></span> RCBA_SET_REG_32(D22IR, DIR_ROUTE(PIRQA, PIRQA, PIRQA, PIRQA)),<span class="hljs-comment"><span class="hljs-comment">/* ME */</span></span> RCBA_SET_REG_32(D21IR, DIR_ROUTE(PIRQE, PIRQF, PIRQF, PIRQF)),<span class="hljs-comment"><span class="hljs-comment">/* SIO */</span></span> RCBA_SET_REG_32(D20IR, DIR_ROUTE(PIRQC, PIRQC, PIRQC, PIRQC)),<span class="hljs-comment"><span class="hljs-comment">/* XHCI */</span></span> RCBA_SET_REG_32(D23IR, DIR_ROUTE(PIRQH, PIRQH, PIRQH, PIRQH)),<span class="hljs-comment"><span class="hljs-comment">/* SDIO */</span></span></code> </pre> <br>  <b>Example 1:</b> <br><br>  The device 0x1c (28 in decimal) are PCIe ports, as we have already seen. <br><br>  We produce a ‚Äúdirect‚Äù connection: <br><br><ul><li>  INTA # ‚Üí PIRQA </li><li>  INTB # ‚Üí PIRQB </li><li>  INTC # ‚Üí PIRQC </li><li>  INTD # ‚Üí PIRQD </li></ul><br><pre> <code class="cpp hljs">RCBA_SET_REG_32(D28IR, DIR_ROUTE(PIRQA, PIRQB, PIRQC, PIRQD))</code> </pre> <br>  <b>Example 2:</b> <br><br>  Device 0x1d (29 in decimal) - one function (EHCI controller) on INTA #, the rest of the lines are not used. <br><br>  Connect the INTA # line with the PIRQD: <br><br><pre> <code class="cpp hljs">RCBA_SET_REG_32(D29IR, DIR_ROUTE(PIRQD, PIRQD, PIRQD, PIRQD))</code> </pre> <br>  In this case, only the first PIRQD entry (for INTA #) makes sense, the others do not make sense. <br><br><h4>  3a) Fill in the mapping PIRQy ‚Üí IRQz1 (PIR ‚Üí APIC) </h4><br>  As we have said, the mapping is often fixed here, and this case is no exception. <br><br><ul><li>  PIRQA ‚Üí IRQ16 </li><li>  PIRQB ‚Üí IRQ17 </li><li>  ... </li><li>  PIRQH ‚Üí IRQ23 </li></ul><br><h4>  3b) Fill in the mapping PIRQy ‚Üí IRQz2 (PIR ‚Üí PIC) </h4><br>  In coreboot, the content for filling these registers is defined in the <a href="">devicetree.cb</a> file in the motherboard folder "src \ mainboard \ google \ beltino \". <br><br>  devicetree.cb (the name devicetree is for communication with a similar concept in the Linux kernel, and ‚Äúcb‚Äù is an abbreviation of coreboot) is a special file that reflects the configuration of this motherboard: which processor, chipset are used, which devices are on them, which off, etc.  In addition, this file may also specify specific information for the configuration of the chipset.  This is exactly the case we need: <br><br><pre> <code class="python hljs">register <span class="hljs-string"><span class="hljs-string">"pirqa_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x8b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqb_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x8a"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqc_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x8b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqd_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x8b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqe_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x80"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqf_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x80"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqg_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x80"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqh_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x80"</span></span></code> </pre> <br>  These lines set the mapping PIRQy ‚Üí IRQz2.  In the code after parsing the devicetree.cb file, they are transformed into the variables ‚Äúconfig-&gt; pirqX_routing‚Äù. <br><br>  The variable ‚Äúconfig-&gt; pirqa_routing = 0x8b‚Äù will mean that the PIRQA is connected to the IRQ11 interrupt line (0x0b = 11) of the PIC controller, but the most severe bit (which is 0x80) means that the interrupt routing is not performed.  Honestly speaking in my experience, this is a mistake, by default it is necessary to enable routing to the PIC, the operating system itself will be able to switch to I / O APIC by setting this bit to 1 if needed. <br><br>  That is, in this case it would be better to write: <br><br><pre> <code class="python hljs">register <span class="hljs-string"><span class="hljs-string">"pirqa_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqb_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0a"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqc_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqd_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqe_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x80"</span></span> <span class="hljs-comment"><span class="hljs-comment"># not used register "pirqf_routing" = "0x80" # not used register "pirqg_routing" = "0x80" # not used register "pirqh_routing" = "0x80" # not used</span></span></code> </pre><br>  We did not enable the last 4 interrupts, since  IRQ0 interrupt is always used under the system timer and is clearly inaccessible (see <a href="https://wiki.osdev.org/Interrupts">General IBM-PC Compatible Interrupt Information</a> ). <br><br>  But if we take a closer look at point 2), we will see that some PCI devices use PIRQE-PIRQH lines, so leave them unconnected the right path to non-working devices. <br><br>  So it is better to write something like this: <br><pre> <code class="python hljs">register <span class="hljs-string"><span class="hljs-string">"pirqa_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x03"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqb_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x04"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqc_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x05"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqd_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x06"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqe_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0a"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqf_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqg_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0e"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqh_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0f"</span></span></code> </pre> <br><br>  The actual filling of the corresponding registers takes place in the <a href="">src \ southbridge \ intel \ lynxpoint \ lpc.c file</a> in the pch_pirq_init function. <br><br>  Fragment of code responsible for filling registers: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Get the chip configuration */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">config_t</span></span> *config = dev-&gt;chip_info; pci_write_config8(dev, PIRQA_ROUT, config-&gt;pirqa_routing); pci_write_config8(dev, PIRQB_ROUT, config-&gt;pirqb_routing); pci_write_config8(dev, PIRQC_ROUT, config-&gt;pirqc_routing); pci_write_config8(dev, PIRQD_ROUT, config-&gt;pirqd_routing); pci_write_config8(dev, PIRQE_ROUT, config-&gt;pirqe_routing); pci_write_config8(dev, PIRQF_ROUT, config-&gt;pirqf_routing); pci_write_config8(dev, PIRQG_ROUT, config-&gt;pirqg_routing); pci_write_config8(dev, PIRQH_ROUT, config-&gt;pirqh_routing);</code> </pre> <br>  Register address constants are described in the same <a href="">pch.h</a> file <a href="">.</a> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQA_ROUT 0x60 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQB_ROUT 0x61 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQC_ROUT 0x62 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQD_ROUT 0x63 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQE_ROUT 0x68 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQF_ROUT 0x69 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQG_ROUT 0x6A #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQH_ROUT 0x6B</span></span></code> </pre> <br>  Mapping PIRQy ‚Üí IRQz2 for this chipset is written to the PCI LPC device (address 00: 1f.0) in the PIRQy_ROUT registers.  It should be noted that often not all 15 IRQz2 lines on the PIC are allowed for use, but only a part (for example, 3,4,5,6,7,9,10,11,12,14,15).  In the description of these registers there should be information about which IRQs are available for assigning interrupts from PIRQ lines to them.  So the mapping proposed by us is possible only if PIRQ assignment on the IRQ3, IRQ4, IRQ5, IRQ6, IRQ10, IRQ11, IRQ14, IRQ15 lines is available.  But if we carefully look at the comment before the pch_pirq_init function, we will see that it is: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* PIRQ[n]_ROUT[3:0] - PIRQ Routing Control * 0x00 - 0000 = Reserved * 0x01 - 0001 = Reserved * 0x02 - 0010 = Reserved * 0x03 - 0011 = IRQ3 * 0x04 - 0100 = IRQ4 * 0x05 - 0101 = IRQ5 * 0x06 - 0110 = IRQ6 * 0x07 - 0111 = IRQ7 * 0x08 - 1000 = Reserved * 0x09 - 1001 = IRQ9 * 0x0A - 1010 = IRQ10 * 0x0B - 1011 = IRQ11 * 0x0C - 1100 = IRQ12 * 0x0D - 1101 = Reserved * 0x0E - 1110 = IRQ14 * 0x0F - 1111 = IRQ15 * PIRQ[n]_ROUT[7] - PIRQ Routing Control * 0x80 - The PIRQ is not routed. */</span></span></code> </pre> <br><h4>  4) Fill in the Interrupt Line / Interrupt Pin registers for each PCI function </h4><br>  In the PCI configuration space (each PCI function has a standard) there are 2 registers of interest to us: <br><br><ul><li>  3Ch: Interrupt Line - you need to write down the IRQz2 number (a number from 0 to 15), the interrupt number, which the function finally draws when using the PIC controller </li><li>  3Dh: Interrupt Pin - shows which line INTx # (A / B / C / D) function uses </li></ul><br>  Let's start with the last one.  The Interrupt Pin register will be filled automatically based on the chipset settings (DxxIP registers) made by us in step 1 and will be Read-Only. <br><br>  So it remains only to fill the Interrupt Line register with an IRQz2 interrupt for each PCI function. <br><br>  Knowing the mapping PIRQy ‚Üí IRQz2 (item 3b), and mapping INTx # ‚Üí PIRQy (item 2), you can easily fill the Interrupt Line register for each function, knowing what kind of INTx # interrupt it uses (item 1). <br><br>  In coreboot, the Interrupt Line registers are also filled in the <a href="">src \ southbridge \ intel \ lynxpoint \ lpc.c file</a> in the pch_pirq_init function: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Eric Biederman once said we should let the OS do this. * I am not so sure anymore he was right. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (irq_dev = all_devices; irq_dev; irq_dev = irq_dev-&gt;next) { u8 int_pin=<span class="hljs-number"><span class="hljs-number">0</span></span>, int_line=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!irq_dev-&gt;enabled || irq_dev-&gt;path.type != DEVICE_PATH_PCI) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; int_pin = pci_read_config8(irq_dev, PCI_INTERRUPT_PIN); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (int_pin) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* INTA# */</span></span> int_line = config-&gt;pirqa_routing; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* INTB# */</span></span> int_line = config-&gt;pirqb_routing; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* INTC# */</span></span> int_line = config-&gt;pirqc_routing; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* INTD# */</span></span> int_line = config-&gt;pirqd_routing; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!int_line) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; pci_write_config8(irq_dev, PCI_INTERRUPT_LINE, int_line); }</code> </pre> <br>  For some reason, this code assumes that the mapping is anyway INTA # ‚Üí PIRQA, INTB # ‚Üí PIRQB, INTC # ‚Üí PIRQC, INTD # ‚Üí PIRQD.  Although, in fact, we have seen that it may be different (see point 2). <br><br>  In general, "Eric Biederman once said," and we scattered everything: <br><br><pre> <code class="bash hljs">$ grep <span class="hljs-string"><span class="hljs-string">"Eric Biederman once said"</span></span> -r src/ src/southbridge/intel/fsp_bd82x6x/lpc.c: /* Eric Biederman once said we should <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> the OS <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> this. src/southbridge/intel/i82801gx/lpc.c: /* Eric Biederman once said we should <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> the OS <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> this. src/southbridge/intel/i82801ix/lpc.c: /* Eric Biederman once said we should <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> the OS <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> this. src/southbridge/intel/lynxpoint/lpc.c: /* Eric Biederman once said we should <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> the OS <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> this. src/southbridge/intel/sch/lpc.c: /* Eric Biederman once said we should <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> the OS <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> this.</code> </pre> <br>  In general, the coreboot does not care much about supporting legacy interrupt modes.  So you shouldn't be surprised at such an error.  When booting a modern OS, this will not hurt you, but if you suddenly need to boot Linux with the ‚Äúacpi = off nolapic‚Äù options, then this is unlikely to be done. <br><br><h2>  Conclusion </h2><br>  In conclusion, we will repeat the typical information that must be configured in the chipset for routing PCI interrupts: <br><br><ol><li>  Specify which line of INTx # pulls each of the functions of PCI devices </li><li>  Configure INTx # ‚Üí PIRQy mapping for each PCI device </li><li>  Fill in the PIRQy ‚Üí IRQz1 mapping (PIR ‚Üí APIC) and the PIRQy ‚Üí IRQz2 mapping (PIR ‚Üí PIC) </li><li>  Fill in the Interrupt Line / Interrupt Pin registers of the PCI configuration space for each PCI function. </li></ol></div><p>Source: <a href="https://habr.com/ru/post/440304/">https://habr.com/ru/post/440304/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>