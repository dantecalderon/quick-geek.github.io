<div class="post__text post__text-html js-mediator-article"><blockquote>  At our request, Habr created the <a href="https://habr.com/hub/kubernetes/">Kubernetes</a> hub and we are pleased to place the first publication in it.  Subscribe! </blockquote><br>  Kubernetes is easy.  Why do banks pay me for working in this area a lot of money, while anyone can master this technology in just a few hours? <br><br> <a href="https://habr.com/ru/company/ruvds/blog/438982/"><img src="https://habrastorage.org/webt/d3/4l/ic/d34licaikjsxfxisetkc9arcpdi.jpeg"></a> <br><a name="habracut"></a><br>  If you doubt that Kubernetes can be explored so quickly - I suggest you try to do it yourself.  Namely, having mastered this material, you will be able to launch an application based on microservices in the Kubernetes cluster.  I can guarantee this, since it is exactly according to the method used here that I teach our clients to work with Kubernetes.  What makes this guide different from others?  In fact - a lot of things.  So, most of these materials begin with an explanation of simple things — Kubernetes concepts and features of the kubectl command.  The authors of these materials assume that their reader is familiar with application development, with microservices and with Docker containers.  We will go the other way.  First, we will talk about how to run an application based on microservices on a computer.  Then we will consider assembly of images of containers for each microservice.  And after that we'll get to know Kubernetes and analyze the deployment of an application based on microservices in a cluster managed by Kubernetes. <br><br>  Such an approach, with a gradual approach to Kubernetes, will give a depth of understanding of what is happening, which is necessary for an ordinary person in order to understand how simple everything is in Kubernetes.  Kubernetes is, of course, a simple technology, provided that those who want to master it know where and how it is used. <br><br>  Now, without further ado, let's get to work and talk about the application with which we will work. <br><br><h2>  <font color="#3AC1EF">Experimental application</font> </h2><br>  Our application will perform only one function.  It accepts, as input, one sentence, after which, using text analysis tools, it performs a sentiment analysis of this sentence, receiving an assessment of the author’s emotional attitude towards an object. <br><br>  Here is the main window of this application. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/674/7e1/415/6747e14151585819867c880f52fa9d21.gif"></div><br>  <i><font color="#999999">Web application for analyzing the tonality of texts</font></i> <br><br>  From a technical point of view, the application consists of three microservices, each of which solves a specific set of tasks: <br><br><ul><li>  SA-Frontend is an Nginx web server that serves static React files. </li><li>  SA-WebApp is a web application written in Java that processes requests from the frontend. </li><li>  SA-Logic is a Python application that performs text tone analysis. </li></ul><br>  It is important to note that microservices do not exist in isolation.  They realize the idea of ​​“separation of duties”, but they, at the same time, need to interact with each other. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/94b/f93/0c0/94bf930c03220c1eec6957a0f7308046.gif"></div><br>  <i><font color="#999999">Data flows in the application</font></i> <br><br>  In the diagram above, you can see the numbered stages of the system, illustrating the data flows in the application.  Let's sort them out: <br><br><ol><li> The browser requests the server file <code>index.html</code> (which, in turn, downloads the package React-application). </li><li>  The user interacts with the application, this causes a call to a web application based on Spring. </li><li>  The web application redirects the text analysis request to the Python application. </li><li>  The Python application analyzes the text key and returns the result as a response to the request. </li><li>  Spring-application sends the response to the React-application (and, in turn, shows the result of the text analysis to the user). </li></ol><br>  The code for all these applications can be found <a href="https://github.com/rinormaloku/k8s-mastery">here</a> .  I recommend that you copy this repository to yourself right now, as there are many interesting experiments with it ahead of us. <br><br><h2>  <font color="#3AC1EF">Running a microservice based application on a local computer</font> </h2><br>  In order for the application to work, we need to run all three microservices.  Let's start with the cutest of them - with the frontend application. <br><br><h3>  <font color="#3AC1EF">▍Configuring React for Local Development</font> </h3><br>  In order to run the React application, you need to install the Node.js platform and NPM on your computer.  After you have installed all this, go to the <code>sa-frontend</code> project folder and use the following command: <br><br><pre> <code class="plaintext hljs">npm install</code> </pre> <br>  By executing this command, the dependencies of the React-application will be loaded into the <code>node_modules</code> folder, entries for which are in the <code>package.json</code> file.  After the dependencies are loaded in the same folder, execute the following command: <br><br><pre> <code class="plaintext hljs">npm start</code> </pre> <br>  That's all.  Now the React-application is running, you can get access to it by going to <code>localhost:3000</code> in the browser.  You can change something in his code.  You will immediately see the effect of these changes in the browser.  This is possible thanks to the so-called hot-swappable modules.  Thanks to this, front-end development turns into a simple and enjoyable experience. <br><br><h3>  <font color="#3AC1EF">▍Preparation of React-application to the conclusion in the production</font> </h3><br>  In order to actually use the React application, we need to convert it into a set of static files and give them to clients using a web server. <br><br>  To build the React application, again using the terminal, go to the <code>sa-frontend</code> folder and execute the following command: <br><br><pre> <code class="plaintext hljs">npm run build</code> </pre> <br>  This will create a <code>build</code> directory in the project folder.  It will contain all static files necessary for the operation of the React application. <br><br><h3>  <font color="#3AC1EF">▍Service static files using Nginx</font> </h3><br>  First you need to install and run the Nginx web server.  <a href="https://www.nginx.com/resources/wiki/start/topics/tutorials/install/">Here</a> you can download it and find instructions for installing and running.  Then you need to copy the contents of the <code>sa-frontend/build</code> folder to the <code>[your_nginx_installation_dir]/html</code> folder. <br><br>  With this approach, the <code>index.html</code> file generated during the assembly of the React application will be available at <code>[your_nginx_installation_dir]/html/index.html</code> .  This is the file that, by default, the Nginx server issues when accessing it.  The server is configured to listen on port <code>80</code> , but you can configure it as you need by editing the file <code>[your_nginx_installation_dir]/conf/nginx.conf</code> . <br><br>  Now open your browser and go to <code>localhost:80</code> .  You will see the React application page. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a50/b83/f39/a50b83f390ff0434ef817f357a041941.png"></div><br>  <i><font color="#999999">React-application serviced by the server Nginx</font></i> <br><br>  If you enter something now in the <code>Type your sentence</code> field and click the <code>Send</code> button, nothing will happen.  But, if you look at the console, you can see error messages there.  In order to understand exactly where these errors occur, let’s analyze the application code. <br><br><h3>  <font color="#3AC1EF">ФронтAnalysis of front-end application code</font> </h3><br>  Looking at the code of the <code>App.js</code> file, we can see that clicking on the <code>Send</code> button calls the <code>analyzeSentence()</code> method.  The code for this method is shown below.  In this case, note that for each line to which there is a comment like <code># Номер</code> , there is an explanation given below code.  In the same way, we will parse other code fragments. <br><br><pre> <code class="plaintext hljs">analyzeSentence() {   fetch('http://localhost:8080/sentiment', {  // #1       method: 'POST',       headers: {           'Content-Type': 'application/json'       },       body: JSON.stringify({                      sentence: this.textField.getValue()})// #2   })       .then(response =&gt; response.json())       .then(data =&gt; this.setState(data));  // #3 }</code> </pre> <br>  <b>1. The</b> URL for the POST request.  It is implied that at this address there is an application waiting for such requests. <br><br>  <b>2.</b> The request body sent to the application.  Here is an example of the request body: <br><br><pre> <code class="plaintext hljs">{   sentence: "I like yogobella!" }</code> </pre> <br>  <b>3.</b> Upon receiving a response to the request, the status of the component is updated.  This causes the component to be re-rendered.  If we receive data (that is, a JSON object containing the data entered and the calculated text estimate), we will derive the <code>Polarity</code> component, since the corresponding conditions will be met.  Here is how we describe the component: <br><br><pre> <code class="plaintext hljs">const polarityComponent = this.state.polarity !== undefined ?   &lt;Polarity sentence={this.state.sentence}             polarity={this.state.polarity}/&gt; :   null;</code> </pre> <br>  The code, it seems, looks quite workable.  What is wrong here, after all?  If you assume that at the address to which the application tries to send a POST request, as long as there is nothing that can accept and process this request, then you will be absolutely right.  Namely, to handle requests coming in at <code>http://localhost:8080/sentiment</code> , we need to run a web application based on Spring. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/848/f16/5a3/848f165a308f9ae73ffd3f8186b23aee.png"></div><br>  <i><font color="#999999">We need a Spring application that can accept a POST request.</font></i> <br><br><h3>  <font color="#3AC1EF">▍Set up a Spring-based Web Application</font> </h3><br>  In order to deploy the Spring application, you need JDK8 and Maven and properly configured environment variables.  After you install all this, you can continue to work on our project. <br><br><h3>  <font color="#3AC1EF">▍ Packing an application in a jar file</font> </h3><br>  Navigate to the <code>sa-webapp</code> folder using the terminal and enter the following command: <br><br><pre> <code class="plaintext hljs">mvn install</code> </pre> <br>  After executing this command, the <code>target</code> directory will be created in the <code>sa-webapp</code> folder.  There will be a Java application packed in a jar file represented by the <code>sentiment-analysis-web-0.0.1-SNAPSHOT.jar</code> file. <br><br><h3>  <font color="#3AC1EF">▍ Start Java application</font> </h3><br>  Go to the <code>target</code> folder and start the application with the following command: <br><br><pre> <code class="plaintext hljs">java -jar sentiment-analysis-web-0.0.1-SNAPSHOT.jar</code> </pre> <br>  An error will occur during the execution of this command.  In order to proceed with its correction, we can analyze the exception information in the stack trace data: <br><br><pre> <code class="plaintext hljs">Error creating bean with name 'sentimentController': Injection of autowired dependencies failed; nested exception is java.lang.IllegalArgumentException: Could not resolve placeholder 'sa.logic.api.url' in value "${sa.logic.api.url}"</code> </pre> <br>  The most important thing for us here is the mention of the impossibility of finding out the meaning of <code>sa.logic.api.url</code> .  Let's analyze the code in which the error occurs. <br><br><h3>  <font color="#3AC1EF">▍A Java Application Code Analysis</font> </h3><br>  Here is the code snippet where the error occurs. <br><br><pre> <code class="plaintext hljs">@CrossOrigin(origins = "*") @RestController public class SentimentController {   @Value("${sa.logic.api.url}")    // #1   private String saLogicApiUrl;   @PostMapping("/sentiment")   public SentimentDto sentimentAnalysis(       @RequestBody SentenceDto sentenceDto)   {       RestTemplate restTemplate = new RestTemplate();       return restTemplate.postForEntity(               saLogicApiUrl + "/analyse/sentiment",    // #2               sentenceDto, SentimentDto.class)               .getBody();   } }</code> </pre> <br><ol><li>  In S <code>entimentController</code> there is a <code>saLogicApiUrl</code> field.  Its value is set by the <code>sa.logic.api.url</code> property. </li><li>  The <code>saLogicApiUrl</code> string <code>saLogicApiUrl</code> concatenated with the value <code>/analyse/sentiment</code> .  Together they form an address for making a request to microservice that performs text analysis. </li></ol><br><h3>  <font color="#3AC1EF">▍Property value setting</font> </h3><br>  In Spring, the standard source for property values ​​is the <code>application.properties</code> file, which can be found at <code>sa-webapp/src/main/resources</code> .  But using it is not the only way to set property values.  This can be done with the help of the following command: <br><br><pre> <code class="plaintext hljs">java -jar sentiment-analysis-web-0.0.1-SNAPSHOT.jar --sa.logic.api.url=WHAT.IS.THE.SA.LOGIC.API.URL</code> </pre> <br>  The value of this property should point to the address of our Python application. <br><br>  By customizing it, we tell the Spring web application where it needs to go in order to perform text analysis requests. <br><br>  In order not to complicate your life, we decide that the Python application will be available at <code>localhost:5000</code> and try not to forget about it.  As a result, the command to start the Spring application will look like this: <br><br><pre> <code class="plaintext hljs">java -jar sentiment-analysis-web-0.0.1-SNAPSHOT.jar --sa.logic.api.url=http://localhost:5000</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30d/445/815/30d44581533865907366e867c029124e.png"></div><br>  <i><font color="#999999">Our system is missing a Python application.</font></i> <br><br>  Now we just have to start the Python application and the system will work as expected. <br><br><h3>  <font color="#3AC1EF">▍Python application setup</font> </h3><br>  In order to run a Python application, you need to have Python 3 and Pip installed, and you need to set the appropriate environment variables correctly. <br><br><h3>  <font color="#3AC1EF">▍Install dependencies</font> </h3><br>  Navigate to the <code>sa-logic/sa</code> project folder and run the following commands: <br><br><pre> <code class="plaintext hljs">python -m pip install -r requirements.txt python -m textblob.download_corpora</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Start application</font> </h3><br>  After installing the dependencies, we are ready to run the application: <br><br><pre> <code class="plaintext hljs">python sentiment_analysis.py</code> </pre> <br>  After executing this command, we will be told the following: <br><br><pre> <code class="plaintext hljs">* Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)</code> </pre> <br>  This means that the application is running and waiting for requests at <code>localhost:5000/</code> <br><br><h3>  <font color="#3AC1EF">▍ Code Investigation</font> </h3><br>  Consider the Python application code in order to understand how it responds to requests: <br><br><pre> <code class="plaintext hljs">from textblob import TextBlob from flask import Flask, request, jsonify app = Flask(__name__)                                   #1 @app.route("/analyse/sentiment", methods=['POST'])      #2 def analyse_sentiment():   sentence = request.get_json()['sentence']           #3   polarity = TextBlob(sentence).sentences[0].polarity #4   return jsonify(                                     #5       sentence=sentence,       polarity=polarity   ) if __name__ == '__main__':   app.run(host='0.0.0.0', port=5000)                #6</code> </pre> <br><ol><li>  Initializing the <code>Flask</code> object. </li><li>  Setting the address for performing POST requests to it. </li><li>  Extracting the <code>sentence</code> property from the request body. </li><li>  Initialization of an anonymous <code>TextBlob</code> object and getting the <code>polarity</code> value for the first sentence received in the request body (in our case this is the only sentence that is submitted for analysis). </li><li>  Return of the answer, the body of which contains the text of the sentence and the <code>polarity</code> index calculated for it. </li><li>  Launching a Flask application, which will be available at <code>0.0.0.0:5000</code> (you can access it using a <code>localhost:5000</code> type construction). </li></ol><br>  Now microservices of which the application consists are launched.  They are configured to interact with each other.  Here is the diagram of the application at this stage of work. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/75a/fcc/135/75afcc1352ed237efaf0a2280c2df295.png"></div><br>  <i><font color="#999999">All microservices of which the application consists are given in a healthy state.</font></i> <br><br>  Now, before continuing, open the React-application in the browser and try to analyze with the help of any proposal.  If everything is done correctly - after clicking on the <code>Send</code> button you will see the analysis results under the text field. <br><br>  In the next section, we will talk about how to run our microservices in Docker containers.  This is necessary in order to prepare the application to run in the Kubernetes cluster. <br><br><h2>  <font color="#3AC1EF">Docker Containers</font> </h2><br>  <a href="https://ru.wikipedia.org/wiki/Kubernetes">Kubernetes</a> is a system for automating the deployment, scaling, and management of containerized applications.  It is also called the “container orchestrator”.  If Kubernetes works with containers, then we need to get these containers first before using this system.  But first, let's talk about what containers are.  Perhaps the best answer to the question of what it is can be found in the Docker <a href="https://www.docker.com/resources/what-container">documentation</a> : <br><br>  <i>A container image is a lightweight, stand-alone, executable package containing an application that includes everything you need to run it: application code, runtime, system tools and libraries, settings.</i>  <i>Containerized programs can be used in Linux and Windows environments, while they will always work the same regardless of infrastructure.</i> <br><br>  This means that containers can be run on any computers, including production servers, and in any environments the applications enclosed in them will work in the same way. <br><br>  In order to explore the features of containers and compare them with other methods of launching applications, consider an example of servicing a React application using a virtual machine and a container. <br><br><h3>  <font color="#3AC1EF">▍Service of static files of a React-application by means of a virtual machine</font> </h3><br>  Trying to organize the maintenance of static files by means of virtual machines, we will encounter the following disadvantages: <br><br><ol><li>  Inefficient use of resources, since each virtual machine is a full-fledged operating system. </li><li>  Platform dependency.  What works on a local computer may well not make money on a production server. </li><li>  Slow and resource-intensive scaling solution based on virtual machines. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c26/927/523/c26927523b6072ce65bfaf8b01a1e330.png"></div><br>  <i><font color="#999999">Nginx web server serving static files running on a virtual machine</font></i> <br><br>  If, however, to solve a similar problem, use containers, then, in comparison with virtual machines, it will be possible to note the following strengths: <br><br><ol><li>  Efficient use of resources: working with the operating system using Docker. </li><li>  Platform independence.  A container that a developer can run on his computer will work anywhere. </li><li>  Lightweight deployment through the use of layers of images. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28b/593/b01/28b593b01ce003c246843d9c9f2bd05f.png"></div><br>  <i><font color="#999999">Nginx web server serving static files running in a container</font></i> <br><br>  We compared virtual machines and containers on only a few points, but even this is enough to feel the strengths of the containers.  Find out more about Docker containers here. <br><br><h3>  <font color="#3AC1EF">▍ Building a Container Image for a React Application</font> </h3><br>  The main building block of the Docker container is the <code>Dockerfile</code> file.  At the beginning of this file, make a record of the base image of the container, then there include a sequence of instructions indicating the order of creation of the container, which will meet the needs of some application. <br><br>  Before we work on the <code>Dockerfile</code> file, let’s recall what we did to prepare the React application files for display on the Nginx server: <br><br><ol><li>  Building a React-application package ( <code>npm run build</code> ). </li><li>  Starting Nginx server. </li><li>  Copying the contents of the <code>build</code> directory from the <code>sa-frontend</code> project folder to the <code>nginx/html</code> server folder. </li></ol><br>  Below you can see the parallels between the creation of the container and the above actions performed on the local computer. <br><br><h3>  <font color="#3AC1EF">▍Preparation of the Dockerfile file for the SA-Frontend application</font> </h3><br>  The instructions that will be contained in the <code>Dockerfile</code> for the <code>SA-Frontend</code> application consist of just two commands.  The fact is that the Nginx development team has prepared a basic <a href="https://hub.docker.com/_/nginx/">image</a> for Nginx, which we will use to create our image.  Here are the two steps we need to describe: <br><br><ol><li>  The basis of the image you need to make an image Nginx. </li><li>  The contents of the <code>sa-frontend/build</code> folder need to be copied to the <code>nginx/html</code> image folder. </li></ol><br>  If you move from this description to the <code>Dockerfile</code> file, then it will look like this: <br><br><pre> <code class="plaintext hljs">FROM nginx COPY build /usr/share/nginx/html</code> </pre> <br>  As you can see, everything is very simple, while the contents of the file even turns out to be quite readable and understandable.  This file tells the system that you need to take a <code>nginx</code> image with everything that already exists in it, and copy the contents of the <code>build</code> directory to the <code>nginx/html</code> directory. <br><br>  Here you may have a question regarding where I know about exactly where I need to copy files from the <code>build</code> folder, that is, where did the path <code>/usr/share/nginx/html</code> come from.  In fact, there is nothing complicated here either.  The fact is that relevant information can be found in the image <a href="https://hub.docker.com/_/nginx/">description</a> . <br><br><h3>  <font color="#3AC1EF">▍ Building the image and loading it into the repository</font> </h3><br>  Before we can work with the ready image, we need to send it to the repository of images.  To do this, we will use the free cloud platform for hosting Docker Hub images.  At this stage you need to do the following: <br><br><ol><li>  Install <a href="https://www.docker.com/community-edition">Docker</a> . </li><li>  Register on the Docker Hub website. </li><li>  Log in to your account by running the following command in the terminal: <br><br><pre> <code class="plaintext hljs">docker login -u="$DOCKER_USERNAME" -p="$DOCKER_PASSWORD"</code> </pre> </li></ol><br>  Now you need to use the terminal to go to the <code>sa-frontend</code> directory and execute a command of the following form there: <br><br><pre> <code class="plaintext hljs">docker build -f Dockerfile -t $DOCKER_USER_ID/sentiment-analysis-frontend .</code> </pre> <br>  Hereinafter in similar commands <code>$DOCKER_USER_ID</code> you need to replace your username with Docker Hub.  For example, this part of the command might look like this: <code>rinormaloku/sentiment-analysis-frontend</code> . <br><br>  At the same time, this command can be shortened by removing <code>-f Dockerfile</code> from it, since this file already exists in the folder in which we execute this command. <br><br>  In order to send the finished image to the repository, we need the following command: <br><br><pre> <code class="plaintext hljs">docker push $DOCKER_USER_ID/sentiment-analysis-frontend</code> </pre> <br>  After its execution, check the list of your repositories on the Docker Hub in order to understand whether the image has been successfully sent to the cloud storage. <br><br><h3>  <font color="#3AC1EF">▍ Container launch</font> </h3><br>  Now, anyone can download and run an image known as <code>$DOCKER_USER_ID/sentiment-analysis-frontend</code> .  In order to do this, you need to run the following sequence of commands: <br><br><pre> <code class="plaintext hljs">docker pull $DOCKER_USER_ID/sentiment-analysis-frontend docker run -d -p 80:80 $DOCKER_USER_ID/sentiment-analysis-frontend</code> </pre> <br>  Now the container is running, and we can continue to work, creating other images we need.  But, before continuing, let's deal with the <code>80:80</code> construction, which is encountered in the image launch command and may seem confusing. <br><br><ul><li>  The first <code>80</code> is the port number of the host (that is, the local computer). </li><li>  The second number <code>80</code> is the port of the container to which the request should be redirected. </li></ul><br>  Consider the following illustration. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/775/394/6cd/7753946cde3287113b82f00921ced889.png"></div><br>  <i><font color="#999999">Port Forwarding</font></i> <br><br>  The system redirects requests from the <code>&lt;hostPort&gt;</code> port to the <code>&lt;containerPort&gt;</code> port.  That is, a call to port <code>80</code> computer is redirected to port <code>80</code> container. <br><br>  Since port <code>80</code> open on the local computer, you can access the application from this computer at <code>localhost:80</code> .  If your system does not support Docker, you can run the application on the Docker virtual machine, whose address will look like <code>&lt;docker-machine ip&gt;:80</code> .  To find out the IP address of the Docker virtual machine, you can use the command <code>docker-machine ip</code> . <br><br>  At this stage, after successfully launching the frontend application container, you should be able to open its page in the browser. <br><br><h3>  <font color="#3AC1EF">.File .dockerignore</font> </h3><br>  Collecting the image of the <code>SA-Frontend</code> application, we may have noticed that this process is extremely slow.  This is because the image assembly context must be sent to the Docker daemon.  The directory that represents the build context is specified by the last argument of the <code>docker build</code> .  In our case, there is a full stop at the end of this command.  This causes the following structure to be included in the build context: <br><br><pre> <code class="plaintext hljs">sa-frontend: |   .dockerignore |   Dockerfile |   package.json |   README.md +---build +---node_modules +---public \---src</code> </pre> <br>  But of all the folders present here, we only need the <code>build</code> folder.  Downloading anything else is a waste of time.  You can speed up the build by pointing Docker to which directories you can ignore.  It is in order to do this, we need the <code>.dockerignore</code> file.  To you, if you are familiar with the <code>.gitignore</code> file, the structure of this file will surely seem familiar.  It lists the directories that the image build system can ignore.  In our case, the contents of this file look like this: <br><br><pre> <code class="plaintext hljs">node_modules src public</code> </pre> <br>  The <code>.dockerignore</code> file must be in the same folder as the <code>Dockerfile</code> file.  Now the image will be assembled in seconds. <br><br> Займёмся теперь образом для Java-приложения. <br><br><h3> <font color="#3AC1EF">▍Сборка образа контейнера для Java-приложения</font> </h3><br> Знаете что, а ведь вы уже изучили всё необходимое для создания образов контейнеров. Именно поэтому данный раздел будет весьма коротким. <br><br> Откройте файл <code>Dockerfile</code> , который находится в папке проекта <code>sa-webapp</code> . Если вы прочтёте текст этого файла, то в нём вам встретятся всего две новые конструкции, начинающиеся с ключевых слов <code>ENV</code> и <code>EXPOSE</code> : <br><br><pre> <code class="plaintext hljs">ENV SA_LOGIC_API_URL http://localhost:5000 … EXPOSE 8080</code> </pre> <br> Ключевое слово <code>ENV</code> позволяет объявлять переменные окружения внутри контейнеров Docker. В частности, в нашем случае оно позволяет задать URL для доступа к API приложения, выполняющего анализ текста. <br><br> Ключевое слово <code>EXPOSE</code> позволяет указать Docker на то, что порт нужно открыть. Мы собираемся пользоваться этим портом в ходе работы с приложением. Тут можно заметить, что в <code>Dockerfile</code> для приложения <code>SA-Frontend</code> такой команды нет. Это нужно лишь для целей документирования, другим словами, эта конструкция предназначена для того, кто будет читать <code>Dockerfile</code> . <br><br> Сборка образа и отправка его в репозиторий выглядит точно так же, как в предыдущем примере. Если же вы пока не очень уверены в своих силах — соответствующие команды можно найти в файле <code>README.md</code> в папке <code>sa-webapp</code> . <br><br><h3> <font color="#3AC1EF">▍Сборка образа контейнера для Python-приложения</font> </h3><br> Если вы взглянете на содержимое файла <code>Dockerfile</code> в папке <code>sa-logic</code> , то ничего нового для себя вы там не найдёте. Команды для сборки образа и отправки его в репозиторий тоже должны быть уже вам знакомы, но их, как и в случае с другими нашими приложениями, можно найти в файле <code>README.md</code> в папке <code>sa-logic</code> . <br><br><h3> <font color="#3AC1EF">▍Тестирование контейнеризированных приложений</font> </h3><br> Можете ли вы доверять чему-то такому, что вы не протестировали? Я тоже не могу. Испытаем наши контейнеры. <br><br><ol><li> Запустим контейнер приложения <code>sa-logic</code> и настроим его на прослушивание порта <code>5050</code> : <br><br><pre> <code class="plaintext hljs">docker run -d -p 5050:5000 $DOCKER_USER_ID/sentiment-analysis-logic</code> </pre> </li><li> Запустим контейнер приложения <code>sa-webapp</code> и настроим его на прослушивание порта <code>8080</code> . Кроме того, нам нужно настроить порт, на котором Python-приложение будет ждать запросы от Java-приложения, переназначив переменную окружения <code>SA_LOGIC_API_URL</code> : <br><br><pre> <code class="plaintext hljs">$ docker run -d -p 8080:8080 -e SA_LOGIC_API_URL='http://&lt;container_ip or docker machine ip&gt;:5000' $DOCKER_USER_ID/sentiment-analysis-web-app</code> </pre> </li></ol><br> Для того чтобы узнать о том, как выяснить IP-адрес контейнера или виртуальной машины Docker — обратитесь к файлу <a href="">README</a> . <br><br> Запустим контейнер приложения <code>sa-frontend</code> : <br><br><pre> <code class="plaintext hljs">docker run -d -p 80:80 $DOCKER_USER_ID/sentiment-analysis-frontend</code> </pre> <br> Теперь всё готово к тому, чтобы перейти в браузере по адресу <code>localhost:80</code> и испытать приложение. <br><br> Обратите внимание на то, что если вы меняли порт для <code>sa-webapp</code> , или если вы работаете с виртуальной машиной Docker, вам понадобится отредактировать файл <code>App.js</code> из папки <code>sa-frontend</code> , поменяв IP-адрес или номер порта в методе <code>analyzeSentence()</code> , подставив вместо устаревших данных актуальные сведения. После этого нужно снова собрать образ и воспользоваться им. <br><br> Вот как выглядит схема нашего приложения теперь. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/796/71e/87a/79671e87adea76c8873cac180e2fe8c0.png"></div><br> <i><font color="#999999">Микросервисы выполняются в контейнерах</font></i> <br><br><h2> <font color="#3AC1EF">Итоги: зачем нам кластер Kubernetes?</font> </h2><br> Только что мы изучили файлы <code>Dockerfile</code> , поговорили о том, как собирать образы и отправлять их в репозиторий Docker. Кроме того, мы научились ускорять сборку образов, пользуясь файлом <code>.dockerignore</code> . В итоге наши микросервисы теперь выполняются в контейнерах Docker. Тут у вас может возникнуть вполне оправданный вопрос о том, зачем нам Kubernetes. Ответу на данный вопрос будет посвящена вторая часть этого материала. А пока подумайте над следующим вопросом: <br> Предположим, что наше веб-приложение для анализа текстов стало всемирно популярным. Каждую минуту к нему приходят миллионы запросов. Это значит, что микросервисы <code>sa-webapp</code> и <code>sa-logic</code> будут находиться под огромной нагрузкой. Как масштабировать контейнеры, в которых выполняются микросервисы? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div>