<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Tyap-bang and in production? Why not</title>
  <meta name="description" content="What happens during normal automation? A technical task, functional requirements, architecture, and a lot of other papers are being compiled. It descr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Tyap-bang and in production? Why not</h1><div class="post__text post__text-html js-mediator-article"> What happens during normal automation?  A technical task, functional requirements, architecture, and a lot of other papers are being compiled.  It describes all the conditions, restrictions, operation algorithms, depending on the environment, the appearance of forms, data verification, etc.  Often, the design and coordination of these papers takes more time than the automation itself. <br><br>  A project, a schedule, a decomposition of tasks, a certain project manager, or even a few appear.  The formalities take the upper hand, i.e.  form, not content. <br><br>  It is clear that in some situations this is the way to act.  For example, if an external company is engaged in automation, it will not survive without such papers, since  only will chase for the attainment of evading demands.  Papers guarantee stability, predictability of payments and delivery of work.  But here these pieces of paper guarantee only one thing to the customer - a long, boring project that will not bring any benefit. <a name="habracut"></a><br><br>  In business programming, this approach is not suitable.  Let me remind you that business programming is a complex change, simultaneously for processes, motivation, goals, management systems, supported by automation. <br><br>  For example, you decide to change the process.  Not one that affects a thousand people - there is no solution on your knee.  The process, for example, concerns five people of one department.  All these people, like their leader, are sitting next to you - here they are, at arm's length.  And you decided, together with them, to change the process.  They sat down, talked, figured, thought, and decided.  It took you one day to change the process. <br><br>  In most cases, after changing the process, you need automation - you need to make changes to the information system.  If you say, you need a technical task, a schedule, a project with a manager, a curator and a sponsor, then that's all.  On this your changes will end.  A long automation project, hung with formalities, will nullify the process change. <br><br>  What is especially important: changes in processes are experiments.  You, even as an experienced business programmer, cannot know for sure whether your change will work or not.  The selected method could have performed well in a different process, or even in exactly the same, but in a different company, but in this context it may turn out to be inoperative. <br><br>  Since this is an experiment, it has time limits - it was invented today, launched tomorrow, we look at the week and make a decision.  If all is well, leave.  If not, we think further - either we cancel the change, or we refine and improve it. <br><br>  And what about the automation for this week?  If the traditional way is chosen, then in a week you will only have a technical task, and then at best.  Accordingly, the implementation of changes will have to be done manually, without automation.  Well, if you make such changes that do not require automation - you can check "by eye".  And if not? <br><br>  This is where the principle of fast automation is needed.  Actually, its essence lies in the title - changes to the system need to be made quickly, without coordination and requirements, exactly to the extent that is required to test the main hypothesis that you put forward, changing the process. <br><br>  You do not have to worry much about the interface, validation of the input data, code optimality, data structure, and other pillars of "proper" automation.  Your task is to quickly support change automation in the process, to check whether they work or not. <br><br>  The principle of fast automation is known to all programmers.  Only they know it not as a principle, but as a great evil - it is considered that ignoramuses, mediocrity and newcomers are engaged in such automation. <br><br>  Partly programmers are right.  But they have a fundamentally different context.  Usually how it is done.  There are some ‚Äúchangeers‚Äù - business analysts, users and their leaders.  They invented something there, and they say - so quickly make me a form / field / window.  What, how, why, why - do not explain.  More added - quickly come on, felt boots.  What remains for the programmer?  If there is an opportunity, it will start to covet - to say that it is impossible so that a technical task, a well thought-out architecture, refactoring, etc. are needed.  But, usually, there is no possibility of pobukhtet, and the programmer simply does - quickly, ‚Äúon the knee‚Äù, in the mode of extreme programming. <br><br>  Well, sort of, okay, to hell with him, right?  I suggested exactly that - quickly, without problems, just to make it work? <br><br>  The key moment arises when the ‚Äúchangeers‚Äù see the meaninglessness of change.  The business programmer simply cancels such changes and asks the programmer to remove the pieces of code that have been inserted.  And the ‚Äútreacher‚Äù?  Or, more precisely, "grief-treason"? <br><br>  He will not cancel anything.  Just leave as is, and, at best, just continue to make changes.  Do you understand?  Without canceling the previous ones, will wind down new, more and more. <br><br>  There is a political moment here, especially if the head of the department came up with the changes.  It is extremely important for him not to look stupid, therefore, no matter what nonsense he comes up with, it will not be canceled.  Moreover, if you pin it to the wall, it will protect its changes. <br><br>  Most often it happens that just no one will use the changes.  If you are a programmer, then you may be familiar with this situation.  They asked, ordered, demanded to make some kind of system, and then they did not use it.  It can even be done not ‚Äúon the knee‚Äù, but normally, in compliance with all the requirements and conditions of the ‚Äúcorrect‚Äù automation, but all the same - they do not use it.  Now you know why.  And why nobody removes this functionality from the system - now they also know. <br><br>  This is how the meaningless, patchwork automation puff cakes are made and grow.  Programmers chuckle, but do whatever they say.  The filth, non-optimality, the curve structure and architecture grow like a snowball.  And the further, the more difficult it will be to stop this process and reverse it. <br><br>  Another problem is the senselessness of the proposed changes in general. <br><br>  In business programming, any change has a goal that all participants understand.  The process should become faster, or more reliable, or more controlled.  Therefore, it is always clear how the purpose of changes, and the criteria for evaluating their effectiveness. <br><br>  But when changes are made ‚Äújust like that,‚Äù or ‚Äúso that it is more convenient for me,‚Äù or ‚Äúwell, that's just as right!‚Äù, The result cannot be assessed.  Therefore, changes, no matter how meaningless they are, remain to live - both in the process and in automation. <br><br>  Now you understand what the problem is - the gap between process change and automation.  When some people come up with changes in the process, and then set tasks to automate other people, without explaining the meaning and essence, it turns out to be an ordinary mess that does not benefit anyone. <br><br>  According to the standards of business programming, work goes on as a team - there are people from processes and people from automation.  Even better, when this work is managed by one person - a business programmer.  Even better, when he does the automation himself. <br><br>  In this case, the life cycle of temporary changes is understandable and manageable - why they are made, when they start, and, most importantly, when and under what conditions they end. <br><br>  Suppose the changes were wrong - this is normal, there is nothing wrong with that.  Then programmers have an unusual job - to delete changes in the system.  Of course, they sometimes do this kind of work themselves ‚Äî refactoring, for example.  But in the case of business programming, such work must be done periodically. <br><br>  And if the changes were correct?  Then all the skills of ‚Äúcorrect‚Äù automation come into play, which programmers are so proud of.  It is necessary to estimate the architecture, data structure, algorithms, validation of the entered data, interface, etc.  But what is the difference, see? <br><br>  The difference in the form of the problem.  Usually this is a technical task, that is, a certain piece of paper.  In our case, the task is a prototype.  Worker who showed his usefulness and effectiveness, proven, so to speak, in battle.  It is necessary only to bring it to mind.  To coordinate and discuss nothing special is necessary - just take it and make the system according to the rules and standards of the environment in which the program is created. <br><br>  If you practice fast programming all the time, you will quickly acquire the skill of doing it right away so that you can fix it less quickly.  Here the ‚Äúright laziness‚Äù of the programmer will play into our hands - he will not solve the same task twice, and he will come up with himself, like a prototype will be done quickly, and turn it into a complete solution with minimal effort.  Although, in business programming, of course, there are no complete solutions. <br><br>  Nowadays, such a practice as prototyping and modeling has become common, when, before starting a large automation project, quickly, with minimal effort, without problems with the interface, create a prototype of the future system.  As you understand, this is very similar to the principle of fast automation, although the point, of course, is not how the prototype is created, but how it will adapt to the changing environment. <br><br>  If prototyping is just a marketing move by an integrator company, and then a big piece of paper will appear, like a technical task, then this is just a trick.  It creates the illusion of the customer that "everything will be as I need it," but, alas, it will not be so in life.  The prototype will not last long and will disappear into obscurity. <br><br>  And now you understand why.  Automation is almost always a cart, not a horse.  The horse is a change of processes, and the cart goes after it.  But rides only if attached to the horse. <br><br>  The horse turned, the cart - after.  With a delay, with backlashes and drifts, but turned.  And if the horse and the cart live each their own lives, then the cart has to be haughty hapless programmers.  A large prototype of a large system created in front of a large automation project is a snapshot, snapshot of a horse harnessed to a cart.  Everything is beautiful, everyone is happy, everyone likes it, but a day passes, or a week, or even a month, and the horse throws the cart and goes where it needs to go.  A cart - beautiful, elegant, made according to all canons, is left standing alone in the field. <br><br>  Therefore, you should not get involved in ‚Äúbig‚Äù prototyping.  As well as the "big" automation.  In order to start and execute a large automation project, one must have a hell of an outstanding mind, foresight and incredible talent in management.  If these words are about you, then I sincerely congratulate you and wish you every success. <br><br>  I recommend the rest to use the principle of fast automation. <br><br>  And I remind you once again: automation goes after changing processes.  Not before the change, not instead of the change, not separately from the changes.  Changed the process, quickly automated, looked at the result.  Good - quickly bring to mind.  Not good, throwing away. </div><p>Source: <a href="https://habr.com/ru/post/440360/">https://habr.com/ru/post/440360/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>