<div class="post__text post__text-html js-mediator-article"><p>  Magento is an e-commerce solution, i.e.  more focused on the sale of products than on the accompanying sales of warehouse, logistics or financial accounting.  For a companion, other applications are better suited (for example, ERP systems).  Therefore, quite often in the practice of using Magento, the problem arises of integrating the store with these other systems (for example, with 1C). </p><br><p>  By and large, integration can be reduced to data replication by: </p><br><ul><li>  catalog (products, categories); </li><li>  inventory data (stock balances and prices); </li><li>  customers; </li><li>  orders; </li></ul><br><p>  Magento for data manipulation in the database offers a separate class of objects - <a href="https://devdocs.magento.com/guides/v2.3/extension-dev-guide/service-contracts/design-patterns.html">repositories</a> .  Due to the specifics of Magento, adding data to the database via repositories is easily encoded, but it happens, let's say, not fast.  In this publication, I look at the main stages of programmatically adding a product to Magento 2 in a “classical” way - using repo classes. </p><a name="habracut"></a><br><p>  Customers and orders are usually replicated in the other direction - from Magento to external ERP systems.  Therefore, with them easier, on the side of Magento, you just need to select the relevant data, and then - " <em>from our side the bullets flew out</em> ." </p><br><h2 id="principy-zapisi-dannyh-v-bazu">  Principles of data recording in the database </h2><br><p>  At the moment, the creation of objects stored in the database in a programmatic way in Magento is done through the <a href="https://devdocs.magento.com/guides/v2.3/extension-dev-guide/factories.html">Factory</a> : </p><br><pre><code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(\Magento\Cms\Model\BlockFactory $blockFactory)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;blockFactory = $blockFactory; } <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> \Magento\Cms\Model\Block $block */</span></span> $block = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;blockFactory-&gt;create();</code> </pre> <br><p>  and writing to the database via the <a href="https://devdocs.magento.com/guides/v2.3/extension-dev-guide/service-contracts/design-patterns.html">Repository</a> : </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(\Magento\Cms\Api\BlockRepositoryInterface $blockRepo)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;blockRepo = $blockRepo; } <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;blockRepo-&gt;save($block);</code> </pre> <br><p>  The approach using "Factory" and "Repository" can be used for all major models in the Magento 2 subject area. </p><br><h2 id="bazovaya-informaciya-o-produkte">  Basic Product Information </h2><br><p>  I am considering a data structure that corresponds to the version of Magento 2.3.  The most basic information about the product is in the <code>catalog_product_entity</code> table (product registry): </p><br><pre> <code class="plaintext hljs">entity_id attribute_set_id type_id sku has_options required_options created_at updated_at</code> </pre> <br><p>  I confine <code>type_id='simple'</code> one product type ( <code>type_id='simple'</code> ), a set of attributes by default ( <code>attribute_set_id=4</code> ) and ignore the attributes <code>has_options</code> and <code>required_options</code> .  Since the attributes <code>entity_id</code> , <code>created_at</code> and <code>updated_at</code> generated automatically, then, in essence, for us to add a new product, it is enough to set <code>sku</code> .  I do this: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> \Magento\Catalog\Api\Data\ProductInterfaceFactory $factProd */</span></span> <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> \Magento\Catalog\Api\ProductRepositoryInterface $repoProd */</span></span> <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> \Magento\Catalog\Api\Data\ProductInterface $prod */</span></span> $prod = $factProd-&gt;create(); $prod-&gt;setAttributeSetId(<span class="hljs-number"><span class="hljs-number">4</span></span>); $prod-&gt;setTypeId(<span class="hljs-string"><span class="hljs-string">'simple'</span></span>); $prod-&gt;setSku($sku); $repoProd-&gt;save($prod);</code> </pre> <br><p>  and get an exception: </p><br><pre> <code class="plaintext hljs">The "Product Name" attribute value is empty. Set the attribute and try again.</code> </pre> <br><p>  I add the product name to the request and I get a message that the <code>Price</code> attribute is missing.  After adding the price, the product falls into the base: </p><br><pre> <code class="php hljs">$prod = $factProd-&gt;create(); $prod-&gt;setAttributeSetId(<span class="hljs-number"><span class="hljs-number">4</span></span>); $prod-&gt;setTypeId(<span class="hljs-string"><span class="hljs-string">'simple'</span></span>); $prod-&gt;setSku($sku); $prod-&gt;setName($name); $prod-&gt;setPrice($price); $repoProd-&gt;save($prod);</code> </pre> <br><p>  The product name is stored in the varchar-attribute table of the product ( <code>catalog_product_entity_varchar</code> ), the price is in the <code>catalog_product_entity_decimal</code> table.  Before adding a product, it is desirable to explicitly indicate that we are using an administrative storefront to import data: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> \Magento\Store\Model\StoreManagerInterface $manStore */</span></span> $manStore-&gt;setCurrentStore(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><h3 id="dopolnitelnye-atributy">  Optional Attributes </h3><br><p>  Processing additional product attributes with Magento is a pleasure.  The EAV data model for basic entities (see table <code>eav_entity_type</code> ) is one of the key features of this platform.  Simply add the appropriate attributes to the product model: </p><br><pre> <code class="php hljs">$prodEntity-&gt;setData(<span class="hljs-string"><span class="hljs-string">'description'</span></span>, $desc); $prodEntity-&gt;setData(<span class="hljs-string"><span class="hljs-string">'short_description'</span></span>, $desc_short); <span class="hljs-comment"><span class="hljs-comment">// или $prodEntity-&gt;setDescription($desc); $prodEntity-&gt;setShortDescription($desc_short);</span></span></code> </pre> <br><p>  and while saving the model through the repo object: </p><br><pre> <code class="php hljs">$repoProd-&gt;save($prod);</code> </pre> <br><p>  additional attributes will also be saved in the corresponding database tables. </p><br><h2 id="inventarnye-dannye">  Inventory data </h2><br><p>  In a simple way - the amount of product in stock.  In Magento 2.3, the structures in the database that describe the format for storing inventory data <a href="https://devdocs.magento.com/guides/v2.3/inventory/">differ significantly</a> from what was previously.  However, adding a quantity of a product in stock through a product model is not much more difficult than adding other attributes: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> \Magento\Catalog\Model\Product $prodEntity */</span></span> <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> \Magento\Catalog\Api\ProductRepositoryInterface $repoProd */</span></span> $inventory = [ <span class="hljs-string"><span class="hljs-string">'is_in_stock'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, <span class="hljs-string"><span class="hljs-string">'qty'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1234</span></span> ]; $prodEntity-&gt;setData(<span class="hljs-string"><span class="hljs-string">'quantity_and_stock_status'</span></span>, $inventory); $repoProd-&gt;save($prodEntity);</code> </pre> <br><h2 id="media">  Media </h2><br><p>  As a rule, media support for a product for a customer in a store (e-commerce) is different from media support for the same product for an employee in an internal accounting system (ERP).  In the first case, it is desirable to show the "product face", in the second - enough to give a general idea of ​​the product.  However, transferring at least the primary product image is a fairly common <code>case</code> when importing data. </p><br><p>  When adding an image through the admin panel, the image is first stored in the temporary directory ( <code>./pub/media/tmp/catalog/product</code> ) and only when the product is saved is moved to the media catalog ( <code>./pub/media/catalog/product</code> ).  Also, when adding an image through the admin <code>small_image</code> , <code>image</code> , <code>small_image</code> , <code>thumbnail</code> , <code>swatch_image</code> . </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> \Magento\Catalog\Api\ProductRepositoryInterface $repoProd */</span></span> <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> \Magento\Catalog\Model\Product\Gallery\CreateHandler $hndlGalleryCreate */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* $imagePath = '/path/to/file.png'; $imagePathRelative = '/f/i/file.png' */</span></span> $imagePathRelative = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;imagePlaceToTmpMedia($imagePath); <span class="hljs-comment"><span class="hljs-comment">/* reload product with gallery data */</span></span> $product = $repoProd-&gt;get($sku); <span class="hljs-comment"><span class="hljs-comment">/* add image to product's gallery */</span></span> $gallery[<span class="hljs-string"><span class="hljs-string">'images'</span></span>][] = [ <span class="hljs-string"><span class="hljs-string">'file'</span></span> =&gt; $imagePathRelative, <span class="hljs-string"><span class="hljs-string">'media_type'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'image'</span></span> <span class="hljs-string"><span class="hljs-string">'label'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">''</span></span> ]; $product-&gt;setData(<span class="hljs-string"><span class="hljs-string">'media_gallery'</span></span>, $gallery); <span class="hljs-comment"><span class="hljs-comment">/* set usage areas */</span></span> $product-&gt;setData(<span class="hljs-string"><span class="hljs-string">'image'</span></span>, $imagePathRelative); $product-&gt;setData(<span class="hljs-string"><span class="hljs-string">'small_image'</span></span>, $imagePathRelative); $product-&gt;setData(<span class="hljs-string"><span class="hljs-string">'thumbnail'</span></span>, $imagePathRelative); $product-&gt;setData(<span class="hljs-string"><span class="hljs-string">'swatch_image'</span></span>, $imagePathRelative); <span class="hljs-comment"><span class="hljs-comment">/* create product's gallery */</span></span> $hndlGalleryCreate-&gt;execute($product);</code> </pre> <br><p>  For some reason, the media is tied up only after first saving the product and retrieving it from the repository again.  And you need to specify the <code>label</code> attribute when adding an entry to the media gallery of the product (otherwise we get the exception <code>Undefined index: label in .../module-catalog/Model/Product/Gallery/CreateHandler.php on line 516</code> ). </p><br><h2 id="kategorii">  Categories </h2><br><p>  Often the structure of store categories and backend applications or the placement of products in them can vary considerably.  Strategies for transferring data about categories and products in them depend on many factors.  In this example, I stick to the following: </p><br><ul><li>  categories of backend and store are matched by name; </li><li>  if a category is imported that is not in the store, then it is created under the root category ( <code>Default Category</code> ) and its further positioning in the store catalog is assumed to be manually; </li><li>  the binding of a product to a category occurs only when it is created in a store (first import); </li></ul><br><p>  Basic information about the category is in the <code>catalog_category_entity</code> table (category catalog).  Creating a category in Magento: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> \Magento\Catalog\Api\Data\CategoryInterfaceFactory $factCat */</span></span> <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> \Magento\Catalog\Api\CategoryRepositoryInterface $repoCat */</span></span> $cat = $factCat-&gt;create(); $cat-&gt;setName($name); $cat-&gt;setIsActive(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); $repoCat-&gt;save($cat);</code> </pre> <br><p>  Binding of a product to a category is carried out by category ID and product SKU: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> \Magento\Catalog\Model\CategoryProductLinkFactory $factCatProdLink */</span></span> <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> \Magento\Catalog\Api\CategoryLinkRepositoryInterface $repoCatLink */</span></span> $link = $factCatProdLink-&gt;create(); $link-&gt;setCategoryId($catMageId); $link-&gt;setSku($prodSku); $repoCatLink-&gt;save($link);</code> </pre> <br><h2 id="itogo">  Total </h2><br><p>  Writing code to add products to Magento 2 programmatically is quite easy.  All of the above, I brought in the demo module " <a href="https://github.com/flancer32/mage2_ext_demo_import">flancer32 / mage2_ext_demo_import</a> ".  There is only one <code>fl32:import:prod</code> console command in the <code>fl32:import:prod</code> that imports the products described in the " <a href="">./etc/data/products.json</a> " JSON file: </p><br><pre> <code class="json hljs">[ { <span class="hljs-attr"><span class="hljs-attr">"sku"</span></span>: <span class="hljs-string"><span class="hljs-string">"..."</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"..."</span></span>, <span class="hljs-attr"><span class="hljs-attr">"desc"</span></span>: <span class="hljs-string"><span class="hljs-string">"..."</span></span>, <span class="hljs-attr"><span class="hljs-attr">"desc_short"</span></span>: <span class="hljs-string"><span class="hljs-string">"..."</span></span>, <span class="hljs-attr"><span class="hljs-attr">"price"</span></span>: ..., <span class="hljs-attr"><span class="hljs-attr">"qty"</span></span>: ..., <span class="hljs-attr"><span class="hljs-attr">"categories"</span></span>: [<span class="hljs-string"><span class="hljs-string">"..."</span></span>], <span class="hljs-attr"><span class="hljs-attr">"image_path"</span></span>: <span class="hljs-string"><span class="hljs-string">"..."</span></span> } ]</code> </pre> <br><p>  Pictures for import are in the directory <code>./etc/data/img</code> . </p><br><p>  Import time 10 products in a similar way is about 10 seconds on my laptop.  If you develop this idea further, it is easy to come to the conclusion that about 3,600 products can be imported per hour, and it can take about 30 hours to import 100K products.  Replacing the laptop on the server allows you to smooth out the situation somewhat.  Maybe even at times.  But not by orders of magnitude.  Maybe this <del>  speed </del>  slowness is to some extent one of the reasons for the emergence of the <a href="https://github.com/magento/async-import">magento / async-import</a> project. </p><br><p>  A direct solution to the database can be a cardinal solution for increasing the speed of import, but in this case all the “bugs” related to Magento extensibility are lost - you have to do everything “extended” yourself.  However, it is worth it.  If it works out, then I will consider the approach with direct writing to the database in the next article. </p></div>