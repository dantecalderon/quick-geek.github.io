<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Can I use Redux on the server?</title>
  <meta name="description" content="Redux is an excellent tool for managing the state of complex front-end applications. The author of the material, the translation of which we are publi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Can I use Redux on the server?</h1><div class="post__text post__text-html js-mediator-article">  Redux is an excellent tool for managing the state of complex front-end applications.  The author of the material, the translation of which we are publishing today, is going to find an answer to the question of whether it is possible to use the Redux capabilities in a server environment. <br> <a href="https://habr.com/ru/company/ruvds/blog/437804/"><img src="https://habrastorage.org/getpro/habr/post_images/4ff/f8d/685/4fff8d685687bacff24db95abaadd05b.png" alt="image"></a> <a name="habracut"></a><br><h2>  <font color="#3AC1EF">Why do you need Redux library?</font> </h2><br>  The <a href="http://redux.js.org/">home page of</a> the Redux library says that this is a ‚Äúpredictable state container for JavaScript applications.‚Äù  Redux is usually referred to as an application state management tool, and, although this library is mainly used with React, it can be used in any JavaScript-based projects. <br><br>  We already mentioned that Redux is used to manage the state of an application.  Now let's talk about what ‚Äústate‚Äù is.  This concept is quite difficult to define, but we still try to describe it. <br><br>  Considering the ‚Äústate‚Äù, if we are talking about people or objects of the material world, we strive to describe, in fact, their state at the time in which we are talking about them, perhaps considering one or several parameters.  For example, we can say about the lake: ‚ÄúThe water is very hot‚Äù, or: ‚ÄúThe water is frozen‚Äù.  In these statements we describe the state of the lake in terms of its water temperature. <br><br>  When someone says about himself: ‚ÄúI am broke,‚Äù he considers the amount of money he has.  It is clear that in each of these examples we are talking only about one aspect of the state of objects.  But, in the example about money, the statement may be this, describing several parameters: "I broke, I have not eaten for a long time, but I am happy!".  It is very important to note that the state is something non-permanent.  This means that it can change.  Therefore, when we learn about the current state of an object, we understand that its real state may change in a few seconds or minutes after we have learned about it. <br><br>  When we deal with programs, the concept of "state" is associated with some features.  First, the state of the application is represented by data that is stored somewhere.  For example, this data can be stored in memory (say, as a JavaScript object), but it can be stored both in a file and in a database, and using the tools of some kind of caching mechanism like Redis.  Secondly, the state of the application is usually tied to its specific instance.  Therefore, when we talk about the state of an application, we mean a specific instance of this application, a process, a working environment, organized in an application for a specific user.  Application state may include, for example, the following information: <br><br><ul><li>  Did the user log in or not?  If so, how long does the session last and when will it expire? </li><li>  How many points did the user score?  Such a question is relevant, for example, for some kind of game. </li><li>  Where exactly did the user pause the video?  This question can be asked about the video player application. </li></ul><br>  If we talk about the state of the application at a lower level, it may include, for example, the following information: <br><br><ul><li>  Which variables are set in the current environment in which the application is running (this refers to the so-called "environment variables"). </li><li>  What files are the program currently using? </li></ul><br>  Looking at the "snapshot" (they are often called "snapshots" - from snapshot) of the application state at any time, we can find out in what conditions the application worked at that moment, and, possibly, if necessary, recreate these conditions by giving application to the state in which it was at the time of snapshot. <br><br>  The state can be modified during the execution of the user certain actions.  For example, if a user correctly moves a game character in a simple game, this may increase the number of points.  In fairly complex applications, the approach to state modification may become more complicated, and state changes may come from various sources. <br><br>  For example, in a multiplayer game, how many points the user scores depends not only on his actions, but also on the actions of those who play with him on the same team.  And if a computer-controlled character successfully attacks a game character that the user controls, the user may lose some points. <br><br>  Imagine that we are developing a frontend application like <a href="http://mobile.twitter.com/">Twitter PWA</a> .  This is a one-page application in which there are several tabs, say - Home Page, Search (Search), Notifications (Notifications) and Messages (Messages).  Each such tab has its own working area, which is intended both for displaying certain information and for its modification.  All this data forms the state of the application.  So, new tweets, notifications and messages come into the app every few seconds.  The user can work with the program and with this data.  For example, he can create a tweet or delete it, he can retweet a certain tweet, he can read notifications, send messages to someone, and so on.  Everything that was just discussed modifies the state of the application. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f01/221/468/f01221468374f7a04c099abb43513871.png"></div><br>  <i><font color="#999999">All of these tabs have their own set of user interface components used to display and modify data.</font></i>  <i><font color="#999999">The state of the application can be affected by data entering the application from the outside, and user actions</font></i> <br><br>  It is clear that in such an application, different entities can be sources of state changes, and changes initiated by different sources can occur almost simultaneously.  If we manage the state manually, it may turn out that it will be difficult for us to keep track of what is happening.  These difficulties lead to contradictions.  For example, a tweet may be deleted, but it will still be displayed in the tweet feed.  Or, say, a user may read a notification or message, but it will still be displayed in the program as unvisited. <br><br>  The user can like a tweet, a heart appears in the program's interface, but a network request that sends information about the like to the server will not work.  As a result, what the user sees will be different from what is stored on the server.  It is in order to prevent such situations, and you may need Redux. <br><br><h2>  <font color="#3AC1EF">How does redux work?</font> </h2><br>  There are three main concepts in the Redux library that are designed to make managing the state of applications simple and straightforward: <br><br><ol><li>  Storage (store).  Redux storage is a JavaScript object that represents the state of the application.  It plays the role of "the only source of reliable data."  This means that the entire application must rely on storage as the only entity responsible for the state representation. </li><li>  Actions  The state store is read only.  This means that it cannot be modified by referring to it directly.  The only way to change the contents of the repository is to use actions.  Any component that wants to change a state should use the appropriate action. </li><li>  Reducers (reducers), which are also called "converters".  A reducer is a pure function that describes how a state is modified by actions.  The reducer accepts the current state and the action, the execution of which has been requested by a certain component of the application, and then returns the transformed state. </li></ol><br>  Using these three concepts means that the application should no longer directly monitor events that are sources of state changes (user actions, API responses, the occurrence of events related to receiving some data via the WebSocket protocol, and so on) and make decisions about how these events will affect the state. <br><br>  Through the use of the Redux model, these events can trigger appropriate actions that will change state.  Components that need to use data stored in the application state can simply subscribe to state changes and receive information of interest.  Using all of these mechanisms, Redux aims to make changes in the state of an application predictable. <br><br>  Here is a schematic example that demonstrates how you can organize a simple state management system using Redux in our fictional application: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { createStore } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'redux'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// —Ä–µ–¥—å—é—Å–µ—Ä const tweets = (state = {tweets: []}, action) =&gt; {  switch (action.type) {    // –ú—ã –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ª–∏—à—å –æ–¥–Ω–æ –¥–µ–π—Å—Ç–≤–∏–µ, –≤—ã–ø–æ–ª–Ω—è–µ–º–æ–µ –ø—Ä–∏ –ø–æ—Å—Ç—É–ø–ª–µ–Ω–∏–∏ –Ω–æ–≤–æ–≥–æ —Ç–≤–∏—Ç–∞.    case 'SHOW_NEW_TWEETS':      state.numberOfNewTweets = action.count;      return state.tweets.concat([action.tweets]);    default:      return state;  } }; // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è, —Å –ø–æ–º–æ—â—å—é –∫–æ—Ç–æ—Ä–æ–π —Å–æ–∑–¥–∞—ë—Ç—Å—è –¥–µ–π—Å—Ç–≤–∏–µ. SHOW_NEW_TWEETS const newTweetsAction = (tweets) =&gt; {  return {      type: 'SHOW_NEW_TWEETS',      tweets: tweets,      count: tweets.length  }; }; const store = createStore(tweets); twitterApi.fetchTweets()  .then(response =&gt; {    // –í–º–µ—Å—Ç–æ —Ç–æ–≥–æ, —á—Ç–æ–±—ã –≤—Ä—É—á–Ω—É—é –¥–æ–±–∞–≤–ª—è—Ç—å —Ç–≤–∏—Ç –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–µ –º–µ—Å—Ç–æ –ø—Ä–æ–≥—Ä–∞–º–º—ã,    // –º—ã –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –¥–µ–π—Å—Ç–≤–∏–µ Redux.    store.dispatch(newTweetsAction(response.data));  }); // –ö—Ä–æ–º–µ —Ç–æ–≥–æ, –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –¥–µ–π—Å—Ç–≤–∏–µ SHOW_NEW_TWEETS –∫–æ–≥–¥–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å–æ–∑–¥–∞—ë—Ç —Ç–≤–∏—Ç // –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–µ —Ç–≤–∏—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Ç–æ–∂–µ –¥–æ–±–∞–≤–ª—è–µ—Ç—Å—è –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è. const postTweet = (text) =&gt; {  twitterApi.postTweet(text)  .then(response =&gt; {    store.dispatch(newTweetsAction([response.data]));  }); }; // –ü—Ä–µ–¥–ø–æ–ª–æ–∂–∏–º, –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ, –ø–æ –ø—Ä–æ—Ç–æ–∫–æ–ª—É WebSocket, –ø–æ—Å—Ç—É–ø–∏–ª–∏ –Ω–æ–≤—ã–µ —Ç–≤–∏—Ç—ã. // –ü—Ä–∏ –≤–æ–∑–Ω–∏–∫–Ω–æ–≤–µ–Ω–∏–∏ —ç—Ç–æ–≥–æ —Å–æ–±—ã—Ç–∏—è –º—ã —Ç–æ–∂–µ –º–æ–∂–µ–º –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –¥–µ–π—Å—Ç–≤–∏–µ. SHOW_NEW_TWEETS socket.on('newTweets', (tweets) =&gt; { store.dispatch(newTweetsAction(tweets)); }; // –ï—Å–ª–∏ –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –Ω–µ–∫–∏–π —Ñ—Ä–µ–π–º–≤–æ—Ä–∫, –≤—Ä–æ–¥–µ React, —Ç–æ –Ω–∞—à–∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –Ω—É–∂–Ω–æ –ø–æ–¥–∫–ª—é—á–∏—Ç—å –∫ —Ö—Ä–∞–Ω–∏–ª–∏—â—É, // –Ω—É–∂–Ω–æ, —á—Ç–æ–±—ã –æ–Ω–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–±–Ω–æ–≤–ª—è–ª–∏—Å—å –±—ã –¥–ª—è –≤—ã–≤–æ–¥–∞ –Ω–æ–≤—ã—Ö —Ç–≤–∏—Ç–æ–≤. // –í –ø—Ä–æ—Ç–∏–≤–Ω–æ–º —Å–ª—É—á–∞–µ –Ω–∞–º –Ω—É–∂–Ω–æ —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω–æ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏–µ —Å–æ–±—ã—Ç–∏–π, // –≤–æ–∑–Ω–∏–∫–∞—é—â–∏—Ö –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è. store.subscribe(() =&gt; {  const { tweets } = store.getSTate();  render(tweets); });</span></span></code> </pre> <br>  Taking this code as a basis, we can equip our state management system of the application with additional actions and send them from different places of the application without risking hopelessly confused. <br><br>  <a href="https://redux.js.org/introduction/three-principles">Here is the</a> material from which you can learn more about the three fundamental principles of Redux. <br><br>  Now let's talk about using Redux in a server environment. <br><br><h2>  <font color="#3AC1EF">Transferring Redux principles to the server environment</font> </h2><br>  We explored the Redux capabilities used in developing client applications.  But, since Redux is a JavaScript library, it can theoretically be used in a server environment.  Let us consider how the above principles can be applied on the server. <br><br>  Remember how we talked about what the state of the client application looks like?  It should be noted that there are some conceptual differences between client and server applications.  For example, client applications tend to maintain state between various events, say, between the execution of requests to the server.  Such applications are called stateful applications. <br><br>  If they did not strive for state storage, for example, when working with a certain web service that requires entering a login and password, the user would have to perform this procedure every time he goes to a new page of the corresponding web interface. <br><br>  Backend applications, on the other hand, tend to ensure that the state is not stored (they are also called stateless applications).  Here, speaking of "backend applications", we mainly mean projects based on certain APIs that are separate from front-end applications.  This means that information on the state of the system should be provided to similar applications each time they are accessed.  For example, the API does not monitor whether a user is logged in or not.  It determines its status by analyzing the authentication token in its requests to this API. <br><br>  This leads us to the important reason that Redux would hardly be used on servers in the form in which we described its capabilities above. <br><br>  The fact is that Redux was designed to store the temporary state of the application.  But the state of the application stored on the server should usually be long enough.  If you would use the Redux repository in your server-side Node.js application, then the state of this application would be cleared every time the <code>node</code> process stops.  And if we are talking about a PHP server that implements a similar state management scheme, the state would be cleared when each new request arrives at the server. <br><br>  The situation becomes even more complicated if we consider server applications from the point of view of their scalability.  If you had to scale the application horizontally, increasing the number of servers, then you would have a lot of Node.js processes running simultaneously, and each of them would have its own version of the state.  This means that if two identical requests to the backend were received simultaneously, different answers could be given to them. <br><br>  How to apply the principles of state management discussed on the server?  Take another look at the Redux concepts and see how they are commonly used in a server environment: <br><br><ol><li>  Storage.  On the back end, ‚Äúthe only source of reliable data‚Äù is usually a kind of database.  Sometimes, in order to facilitate access to data that is often required, or for some other reason, a copy of some part of this database can be made ‚Äî as a cache or as a file.  Usually such copies are read only.  The mechanisms that control them are subscribed to changes in the main repository, and, if such changes occur, update the contents of the copies. </li><li>  Actions and reduers.  They are the only mechanisms used to change a state.  In most backend applications, the code is written in an imperative style, which is not particularly conducive to the use of concepts of actions and reducers. </li></ol><br>  Consider two design patterns that, by their nature, are similar to what the Redux library is aimed at.  This is CQRS and Event Sourcing.  They, in fact, appeared before Redux, their implementation can be extremely difficult, so we will talk about them very briefly. <br><br><h2>  <font color="#3AC1EF">CQRS and Event Sourcing</font> </h2><br>  CQRS (Command Query Responsibility Segregation, division of command and query responsibility) is a design pattern that, when implemented, an application reads data from the repository only with queries, and writes only with commands. <br><br>  When using CQRS, the only way to change the state of an application is to send a command.  Commands are similar to Redux actions.  For example, in Redux, you can write code that corresponds to this scheme: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> action = { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'CREATE_NEW_USER'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: ... }; store.dispatch(action); <span class="hljs-comment"><span class="hljs-comment">// —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Ä–µ–¥—å—é—Å–µ—Ä –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –¥–µ–π—Å—Ç–≤–∏—è const createUser = (state = {}, action) =&gt; { // };</span></span></code> </pre> <br>  When using CQRS, something like this will look like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// –±–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å –∏–ª–∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –∫–æ–º–∞–Ω–¥—ã class Command { handle() { } } class CreateUserCommand extends Command { constructor(user) {   super();   this.user = user; } handle() {   // —Å–æ–∑–¥–∞—Ç—å –∑–∞–ø–∏—Å—å –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö } } const createUser = new CreateUserCommand(user); // –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∫–æ–º–∞–Ω–¥—É (—ç—Ç–æ –≤—ã–∑–æ–≤–µ—Ç –º–µ—Ç–æ–¥ handle()) dispatch(createUser); // –∏–ª–∏ –∑–¥–µ—Å—å –º–æ–∂–Ω–æ –≤–æ—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –∫–ª–∞—Å—Å–æ–º CommandHandler commandHandler.handle(createUser);</span></span></code> </pre> <br>  Queries are the mechanisms for reading data in the CQRS template.  They are equivalent to <code>store.getState()</code> .  In a simple implementation of CQRS, queries will interact directly with the database, getting records from it. <br><br>  The Event Sourcing template (event registration) is designed with a view to registering all changes in the application state as a sequence of events.  This template is best suited for applications that need to know not only about their current state, but also about its history of changes, about how the application has reached its current state.  As examples here you can cite the history of operations with bank accounts, tracking parcels, work with orders in online stores, organization of transportation, logistics. <br><br>  Here is an example of implementing the Event Sourcing pattern: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// –±–µ–∑ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —à–∞–±–ª–æ–Ω–∞ Event Sourcing function transferMoneyBetweenAccounts(amount, fromAccount, toAccount) {   BankAccount.where({ id: fromAccount.id })     .decrement({ amount });   BankAccount.where({ id: toAccount.id })     .increment({ amount }); } function makeOnlinePayment(account, amount) {   BankAccount.where({ id: account.id })     .decrement({ amount }); } // —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º —à–∞–±–ª–æ–Ω–∞ Event Sourcing function transferMoneyBetweenAccounts(amount, fromAccount, toAccount) {   dispatchEvent(new TransferFrom(fromAccount, amount, toAccount));   dispatchEvent(new TransferTo(toAccount, amount, fromAccount)); } function makeOnlinePayment(account, amount) {   dispatchEvent(new OnlinePaymentFrom(account, amount)); } class TransferFrom extends Event {   constructor(account, amount, toAccount) {     this.account = account;     this.amount = amount;     this.toAccount = toAccount;   }     handle() {     // —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –Ω–æ–≤–æ–µ —Å–æ–±—ã—Ç–∏–µ OutwardTransfer –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö     OutwardTransfer.create({ from: this.account, to: this.toAccount, amount: this.amount, date: Date.now() });         // –∏ –æ–±–Ω–æ–≤–∏—Ç—å —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å—á—ë—Ç–∞     BankAccount.where({ id: this.account.id })       .decrement({ amount: this.amount });   } } class TransferTo extends Event {   constructor(account, amount, fromAccount) {     this.account = account;     this.amount = amount;     this.fromAccount = fromAccount;   }     handle() {     // —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –Ω–æ–≤–æ–µ —Å–æ–±—ã—Ç–∏–µ InwardTransfer –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö     InwardTransfer.create({ from: this.fromAccount, to: this.account, amount: this.amount, date: Date.now() });         // –∏ –æ–±–Ω–æ–≤–∏—Ç—å —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å—á—ë—Ç–∞     BankAccount.where({ id: this.account.id })       .increment({ amount: this.amount });   } } class OnlinePaymentFrom extends Event {   constructor(account, amount) {     this.account = account;     this.amount = amount;   }     handle() {     // —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –Ω–æ–≤–æ–µ —Å–æ–±—ã—Ç–∏–µ OnlinePayment –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö     OnlinePayment.create({ from: this.account, amount: this.amount, date: Date.now() });         // –∏ –æ–±–Ω–æ–≤–∏—Ç—å —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å—á—ë—Ç–∞     BankAccount.where({ id: this.account.id })       .decrement({ amount: this.amount });   } }</span></span></code> </pre> <br>  What is happening here also reminds us of working with Redux actions. <br><br>  However, the event registration mechanism also organizes the long-term storage of information about each state change, and not just the storage of the state itself.  This allows us to reproduce these changes to the point in time we need, thus restoring the contents of the state of the application to this point in time.  For example, if we need to understand how much money was in a bank account on a certain date, we only need to reproduce the events that occurred with the bank account, until we get to the desired date.  Events in this case are represented by receipts of funds to the account and debiting them from it, writing off a bank commission and other similar operations.  In the event of errors (that is, in the event of events containing incorrect data), we can invalidate the current state of the application, correct the corresponding data and return to the current state of the application, which has already been generated without errors. <br><br>  CQRS and Event Sourcing templates are often used together.  And, interestingly, Redux is, in fact, partly based on these templates.  Commands can be written so that when they are invoked, they send events.  The events then interact with the repository (database) and update the state.  In real-time applications, query objects can also listen for events and receive updated status information from the repository. <br><br>  Using any of these templates in a simple application may unnecessarily complicate it.  However, in the case of applications built to solve complex business problems, CQRS and Event Sourcing are powerful abstractions that help better model the subject area of ‚Äã‚Äãsuch applications and improve their state management. <br><br>  Note that the CQRS and Event Sourcing templates can be implemented differently, with some of their implementations being more complex than others.  We have considered only very simple examples of their implementation.  If you are writing server applications in Node.js, take a look at <a href="https://www.wolkenkit.io/">wolkenkit</a> .  This framework, among those that have been discovered in this area, provides the developer with one of the simplest interfaces for implementing CQRS and Event Sourcing templates. <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  Redux is a great tool for managing the state of an application, in order to make state changes predictable.  In this article we talked about the key concepts of this library and found that, although using Redux in a server environment is probably not the best idea, similar principles can be applied to the server using the <a href="https://martinfowler.com/bliki/CQRS.html">CQRS</a> and <a href="https://martinfowler.com/eaaDev/EventSourcing.html">Event Sourcing</a> templates. <br><br>  <b>Dear readers!</b>  How do you organize state management of client and server applications? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/437804/">https://habr.com/ru/post/437804/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>