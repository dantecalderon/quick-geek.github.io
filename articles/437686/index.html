<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Studying go: we write p2p messenger with through enciphering</title>
  <meta name="description" content="Yet another P2P Messenger 


 Reading reviews and documentation about the language is not enough to learn how to write less useful applications. 


 I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Studying go: we write p2p messenger with through enciphering</h1><div class="post__text post__text-html js-mediator-article"><h1 id="yet-another-p2p-messenger">  Yet another P2P Messenger </h1><br><p>  Reading reviews and documentation about the language is not enough to learn how to write less useful applications. </p><br><p>  It is imperative that you need to create something interesting to consolidate, so that you can use it in other tasks. </p><br><p><img src="https://habrastorage.org/webt/kt/bm/3r/ktbm3rsivunfcdcvcyqvnm14f5u.png" alt="UI chat example on ReactJs"></p><br><p>  The article is aimed at beginners interested in the go language and peer-to-peer networks. <br>  And for professionals who can offer intelligent ideas or constructively criticize. </p><a name="habracut"></a><br><p>  I program for a long time with a different degree of immersion in java, php, js, python. <br>  And each programming language is good in its field. </p><br><p>  The main area for Go is the creation of distributed services, microservices. <br>  Most often, microservice is a small program that performs its highly specialized functionality. </p><br><p>  But microservices should still be able to communicate with each other, so the tool for creating microservices should allow you to easily and easily organize network interaction. <br>  To check this, we will write an application that organizes a decentralized network of equal participants (Peer-To-Peer), the simplest is the p2p messenger (by the way, is there a Russian synonym for this word?). </p><br><p>  In the code I actively invent bicycles and step on a rake in order to feel the golang, to receive constructive criticism and rational suggestions. </p><br><h2 id="chto-delaem">  What we do </h2><br><p>  Feast (peer) - a unique copy of the messenger. </p><br><p>  Our messenger should be able to: </p><br><ul><li>  Find nearby peers </li><li>  Connect with other peers </li><li>  Encrypt data exchange with peers </li><li>  Receive messages from user </li><li>  Show messages to user </li></ul><br><p>  To make the puzzle a little more interesting, let's make it all go through one network port. </p><br><p><img src="https://habrastorage.org/webt/5b/zo/8g/5bzo8g4eqogveeure4lzgngo5ma.png" alt="Conditional scheme of the messenger"></p><br><p>  If you pull this port via HTTP, you will get a Reakt application that pulls the same port by establishing a web socket connection. </p><br><p>  If you pull the port over HTTP from the local machine, then we show the banner. </p><br><p>  If another peer connects to this port, then a permanent connection is established with end-to-end encryption. </p><br><h2 id="opredelyaem-tip-vhodyaschego-soedineniya">  Determine the type of incoming connection </h2><br><p>  To begin, open the port to listen and wait for new connections. </p><br><pre><code class="go hljs">net.ListenTCP(<span class="hljs-string"><span class="hljs-string">"tcp"</span></span>, tcpAddr)</code> </pre> <br><p>  On the new connection we read the first 4 bytes. </p><br><p>  We take a list of HTTP verbs and compare our 4 bytes with it. </p><br><p>  Now we determine whether the connection is made from the local machine, and if not, then we answer with a banner and "hang up". </p><br><pre> <code class="go hljs"> buf, err := readWriter.Peek(<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–∫–∏ */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ItIsHttp(buf) { handleHttp(readWriter, conn, p) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { peer := proto.NewPeer(conn) p.HandleProto(readWriter, peer) } <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !strings.EqualFold(s, <span class="hljs-string"><span class="hljs-string">"127"</span></span>) &amp;&amp; !strings.EqualFold(s, <span class="hljs-string"><span class="hljs-string">"[::"</span></span>) { response.Body = ioutil.NopCloser(strings.NewReader(<span class="hljs-string"><span class="hljs-string">"Peer To Peer Messenger. see https://github.com/easmith/p2p-messenger"</span></span>)) }</code> </pre> <br><p>  If the connection is local, then we respond with a file corresponding to the request. </p><br><p>  Here I decided to write the processing myself, although I could use the handler available in the standard library. </p><br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">// —Å–≤–æ–π —Å–ø–æ—Å–æ–± func processRequest(request *http.Request, response *http.Response) {/* –º–Ω–æ–≥–æ —Å—Ç—Ä–æ—á–µ–∫ –∫–æ–¥–∞ */} // –ª–∏–±–æ –∏–∑ —Å—Ç—Ä–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ fileServer := http.FileServer(http.Dir("./front/build/")) fileServer.ServeHTTP(NewMyWriter(conn), request)</span></span></code> </pre> <br><p>  If the path <code>/ws</code> requested, then we try to establish a websocket connection. </p><br><p>  Since I‚Äôve put together a bike in handling file requests, I‚Äôll do the ws connection processing using the <a href="https://github.com/gorilla/websocket">gorilla / websocket library</a> . </p><br><p>  To do this, create <code>MyWriter</code> and implement methods in it to match the interfaces <code>http.ResponseWriter</code> and <code>http.Hijacker</code> . </p><br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">// w - MyWriter func handleWs(w http.ResponseWriter, r *http.Request, p *proto.Proto) { c, err := upgrader.Upgrade(w, r, w.Header()) /* —Ç–µ–ø–µ—Ä—å —Ä–∞–±–æ—Ç–∞–µ–º —Å —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ–º –ø–æ—á—Ç–∏ –∫–∞–∫ —Å –æ–±—ã—á–Ω—ã–º —Å–æ–∫–µ—Ç–æ–º */ }</span></span></code> </pre> <br><h2 id="obnaruzhenie-pirov">  Peer Detection </h2><br><p>  To search for peers in the local network, we use the multicast UDP. </p><br><p>  We will send packets with information about ourselves to Multicast IP address. </p><br><pre> <code class="go hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startMeow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p *proto.Proto)</span></span></span></span> { conn, err := net.DialUDP(<span class="hljs-string"><span class="hljs-string">"udp"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, addr) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { _, err := conn.Write([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"meow:%v:%v"</span></span>, hex.EncodeToString(p.PubKey), p.Port))) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> time.Sleep(<span class="hljs-number"><span class="hljs-number">1</span></span> * time.Second) } }</code> </pre> <br><p>  And separately listen to all UDP packets from Multicast IP. </p><br><pre> <code class="go hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listenMeow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p *proto.Proto, handler </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(p *proto.Proto, peerAddress </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> conn, err := net.ListenMulticastUDP(<span class="hljs-string"><span class="hljs-string">"udp"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, addr) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> _, src, err := conn.ReadFromUDP(buffer) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-comment"><span class="hljs-comment">// connectToPeer handler(p, peerAddress) }</span></span></code> </pre> <br><p>  Thus, we declare ourselves and find out about the appearance of other peers. </p><br><p>  One could organize this at the IP level and even in the <a href="https://godoc.org/golang.org/x/net/ipv4">official documentation of the IPv4 package,</a> just the multicast data packet is given as an example of the code. </p><br><h2 id="protokol-vzaimodeystviya-pirov">  Peer interaction protocol </h2><br><p>  We will pack all communication between peers in an envelope. </p><br><p>  On any envelope there is always a sender and recipient, to this we add a command (which he carries with him), an identifier (as long as it is a random number, but can be made as a hash of content), the length of the content and the contents of the envelope itself - the message or command parameters. </p><br><p><img src="https://habrastorage.org/webt/3b/yx/yc/3byxycyif222uk2jslbya9qb1bs.png" alt="Envelope bytes"></p><br><p>  The command, (or the type of content) is successfully located at the very beginning of the envelope and we define a list of commands of 4 bytes that do not intersect with the names of HTTP verbs. </p><br><p>  The entire envelope, when transmitted, is serialized into an array of bytes. </p><br><h3 id="rukopozhatie">  Handshake </h3><br><p>  When the connection is established, the banquet immediately extends a hand for a handshake, communicating its name, public key and ephemeral public key to generate a common session key. </p><br><p>  In response, the peer receives a similar set of data, registers the found peer in its list and calculates (CalcSharedSecret) the common session key. </p><br><pre> <code class="go hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handShake</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p *proto.Proto, conn net.Conn)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proto</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Peer</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> peer := proto.NewPeer(conn) <span class="hljs-comment"><span class="hljs-comment">/* –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–≤–æ–µ –∏–º—è –∏ –∫–ª—é—á*/</span></span> p.SendName(peer) <span class="hljs-comment"><span class="hljs-comment">/* –ñ–¥–µ–º –∏–º—è –∏ –∫–ª—é—á */</span></span> envelope, err := proto.ReadEnvelope(bufio.NewReader(conn)) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><h3 id="obmen-pirami">  Peer Exchange </h3><br><p>  After a handshake, peers exchange their peer lists =) </p><br><p>  To do this, an envelope is sent with the LIST command, and a JSON list of peers is put in its contents. <br>  In response, we get a similar envelope. </p><br><p>  We find in the lists of new ones and with each of them we make an attempt to connect, shake hands, exchange feasts and so on ... </p><br><h3 id="obmen-polzovatelskimi-soobscheniyami">  User Message Exchange </h3><br><p>  User messages are the most valuable for us, so we will encrypt and sign each connection. </p><br><h4 id="o-shifrovanii">  About encryption </h4><br><p>  In the standard (google) golang libraries from the crypto package, there are a lot of different algorithms implemented (no GOSTs). </p><br><p>  I find the Ed25519 curve as the most convenient for signatures.  We will use the ed25519 library to sign messages. </p><br><p>  At the very beginning, I was thinking of using a pair of keys obtained from ed25519, not only for signing, but also for generating a session key. </p><br><p>  However, the keys for the signature are not applicable to the calculation of the common (shared) key - they still need to be conjured over them: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateKeyExchangePair</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(publicKey [32]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, privateKey [32]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { pub, priv, err := ed25519.GenerateKey(<span class="hljs-literal"><span class="hljs-literal">nil</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>(publicKey[:], pub[:]) <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>(privateKey[:], priv[:]) curve25519.ScalarBaseMult(&amp;publicKey, &amp;privateKey) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p>  Therefore, it was decided to generate ephemeral keys, and generally speaking, this is the correct approach, which leaves no chance for attackers to find the common key. </p><br><p>  For mathematics lovers, here are links to the wiki: <br>  <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D1%2582%25D0%25BE%25D0%25BA%25D0%25BE%25D0%25BB_%25D0%2594%25D0%25B8%25D1%2584%25D1%2584%25D0%25B8_%25E2%2580%2594_%25D0%25A5%25D0%25B5%25D0%25BB%25D0%25BB%25D0%25BC%25D0%25B0%25D0%25BD%25D0%25B0_%25D0%25BD%25D0%25B0_%25D1%258D%25D0%25BB%25D0%25BB%25D0%25B8%25D0%25BF%25D1%2582%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D1%2585_%25D0%25BA%25D1%2580%25D0%25B8%25D0%25B2%25D1%258B%25D1%2585"><em>Diffie</em> protocol ‚Äî_Hellman_a_elliptic_curves</a> <br>  <a href="https://ru.wikipedia.org/wiki/EdDSA">EdDSA digital signature</a> </p><br><p>  The generation of a shared key is quite standard: first, for a new connection, the generation of ephemeral keys, we send an envelope with a public key to the socket. </p><br><p>  The opposite side does the same, but in a different order: it receives an envelope with a public key, generates its pair and sends the public key to the socket. </p><br><p>  Now each participant has someone else‚Äôs public and private ephemeral keys. </p><br><p>  Multiplying them we get the same key for both, which we will use to encrypt messages. </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//CalcSharedSecret Calculate shared secret func CalcSharedSecret(publicKey []byte, privateKey []byte) (secret [32]byte) { var pubKey [32]byte var privKey [32]byte copy(pubKey[:], publicKey[:]) copy(privKey[:], privateKey[:]) curve25519.ScalarMult(&amp;secret, &amp;privKey, &amp;pubKey) return }</span></span></code> </pre> <br><p>  We will encrypt messages by a piece by the long-proven AES algorithm in block coupling mode (CBC). </p><br><p>  All this implementations are easily found in the golang documentation. </p><br><p>  The only refinement is auto-filling of the message with zero bytes for the multiplicity of its length to the length of the encryption block (16 bytes). </p><br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">//Encrypt the message func Encrypt(content []byte, key []byte) []byte { padding := len(content) % aes.BlockSize if padding != 0 { repeat := bytes.Repeat([]byte("\x00"), aes.BlockSize-(padding)) content = append(content, repeat...) } /* ... */ } //Decrypt encrypted message func Decrypt(encrypted []byte, key []byte) []byte { /* ... */ encrypted = bytes.Trim(encrypted, string([]byte("\x00"))) return encrypted }</span></span></code> </pre> <br><p>  Back in 2013, he implemented AES (with a similar CBC mode) to encrypt messages in a Telegram as part of a competition from Pavel Durov. </p><br><p>  The most common <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D1%2582%25D0%25BE%25D0%25BA%25D0%25BE%25D0%25BB_%25D0%2594%25D0%25B8%25D1%2584%25D1%2584%25D0%25B8_%25E2%2580%2594_%25D0%25A5%25D0%25B5%25D0%25BB%25D0%25BB%25D0%25BC%25D0%25B0%25D0%25BD%25D0%25B0">Diffie-Hellman protocol was</a> used in the telegrams to generate an ephemeral key at that time. </p><br><p>  And in order to eliminate the load from fake connections, before each key exchange clients solved the factorization task. </p><br><h2 id="gui">  GUI </h2><br><p>  We need to show a list of peers and a list of messages with them, as well as respond to new messages by increasing the counter next to the name of the feast. </p><br><p>  Here without problems - ReactJS + websocket. </p><br><p>  A web socket message is essentially a kind of envelope, only they do not contain ciphertexts. </p><br><p>  All of them are "heirs" of the <code>WsCmd</code> type and are serialized during transmission to JSON. </p><br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">//Serializable interface to detect that can to serialised to json type Serializable interface { ToJson() []byte } func toJson(v interface{}) []byte { json, err := json.Marshal(v) /* –æ–±—Ä–∞–±–æ—Ç–∫–∞ err */ return json } /* ... */ //WsCmd WebSocket command type WsCmd struct { Cmd string `json:"cmd"` } //WsMessage WebSocket command: new Message type WsMessage struct { WsCmd From string `json:"from"` To string `json:"to"` Content string `json:"content"` } //ToJson convert to JSON bytes func (v WsMessage) ToJson() []byte { return toJson(v) } /* ... */</span></span></code> </pre> <br><p>  So, HTTP request comes to root ("/"), now to display the front we look in the ‚Äúfront / build‚Äù directory and give it to index.html </p><br><p>  Well, the interface is set up, now the choice for users: run it in a browser or in a separate window - WebView. </p><br><p>  For the latter option used <a href="https://github.com/zserge/webview">zserge / webview</a> </p><br><pre> <code class="go hljs"> e := webview.Open(<span class="hljs-string"><span class="hljs-string">"Peer To Peer Messenger"</span></span>, fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"http://localhost:%v"</span></span>, initParams.Port), <span class="hljs-number"><span class="hljs-number">800</span></span>, <span class="hljs-number"><span class="hljs-number">600</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre> <br><p>  To build an application with it, you need to install another lib in the system. </p><br><pre> <code class="bash hljs"> sudo apt install libwebkit2gtk-4.0-dev</code> </pre> <br><p>  During my thoughts on the GUI I found a lot of libraries for GTK, QT, and the console interface would look very geeky - <a href="https://github.com/jroimartin/gocui">https://github.com/jroimartin/gocui</a> - in my opinion a very interesting idea. </p><br><h2 id="zapusk-messendzhera">  Launch messenger </h2><br><h3 id="ustanovka-golang">  Install golang </h3><br><p>  Of course, you first need to install go. <br>  For this, I strongly recommend using the <a href="https://golang.org/doc/install">golang.org/doc/install</a> instructions. </p><br><p>  Simplified instructions to <a href="https://gist.github.com/easmith/e88ab51d8a228e8945a6b636f4024d45">bash script</a> </p><br><h3 id="zagruzka-prilozheniya-v-gopath">  Download the application to GOPATH </h3><br><p>  That's the way go is, that all libraries and even your projects should be in the so-called GOPATH. </p><br><p>  The default is $ HOME / go.  Go allows you to pull the source code from the public repository with a simple command: </p><br><pre> <code class="bash hljs"> go get github.com/easmith/p2p-messenger</code> </pre> <br><p>  Now in your <code>$HOME/go/src/github.com/easmith/p2p-messenger</code> source from the master branch will appear </p><br><h3 id="ustanovka-npm-i-sborka-fronta">  Npm installation and front assembly </h3><br><p>  As I wrote above, our GUI is a web application with a front on ReactJs, so the front still needs to be built. </p><br><p>  Nodejs + npm - as usual here. </p><br><p>  Just in case, here is the <a href="https://www.digitalocean.com/community/tutorials/node-js-ubuntu-18-04-ru">instruction for ubuntu</a> </p><br><p>  Now we run the front assembly as standard </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> front npm update npm run build</code> </pre> <br><p>  Front ready! </p><br><h3 id="zapusk">  Launch </h3><br><p>  Go back to the root and run the feast of our messenger. </p><br><p>  When starting, we can specify the name of our peer, a port, a file with addresses of other peers and a flag indicating whether to launch WebView. </p><br><p>  By default, <code>$USER@$HOSTNAME</code> is used as the <code>$USER@$HOSTNAME</code> name and port 35035. </p><br><p>  So, we start and chat with friends on the local network. </p><br><pre> <code class="bash hljs"> go run app.go -name Snowden</code> </pre> <br><h2 id="otzyv-o-programmirovanii-na-golang">  Feedback on programming on golang </h2><br><ul><li>  The most important thing I would like to note is: <strong>on go, it immediately turns out to realize what I had in mind</strong> . <br>  Almost everything you need is in the standard library. </li><li>  However, there was a difficulty when I started a project in a directory other than GOPATH. <br>  For writing code used GoLand.  And at first, the automatic formatting of the code with the auto-import of libraries confused. </li><li>  The <strong>IDE has a lot of code generators</strong> , which allowed us to focus on development, not on typing code. </li><li>  You quickly <strong>get used</strong> to frequent error handling, but hand-to-face happens when you realize that for go there is a normal situation, when the essence of the error is analyzed by its string representation. <br><pre> <code class="go hljs">err != io.EOF</code> </pre> </li><li>  Slightly better things are with the os library.  They help to understand the essence of the problem. <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> os.IsNotExist(err) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> </li><li>  Out of the box go teaches us to properly document the code and write tests. <br>  And there is its own but.  We have described the interface with the <code>ToJson()</code> method. <br>  So, the documentation generator does not inherit the description of this method on the methods that implement it, so in order to remove unnecessary versions, you have to copy the documentation into each implemented method (proto / mtypes.go). </li><li>  Recently, I got used to the power of log4j in java, so there is not enough good logger in go. <br>  It is probably worth looking for a beautiful logging with appenders and formatters in the githab open spaces. </li><li>  Unusual work with arrays. <br>  For example, concatenation occurs through the function <code>append</code> , and the conversion of an array of arbitrary length into an array of fixed length through <code>copy</code> . </li><li>  <code>switch-case</code> works like an <code>if-elseif-else</code> - and this is an interesting approach, but again a hand-face: <br>  if you want the usual <code>switch-case</code> behavior, you need to put <code>fallthrough</code> on each case. <br>  And you can also use <code>goto</code> , but let's not please! </li><li>  There is no ternary operator and often this is not convenient. </li></ul><br><h2 id="chto-dalshe">  What's next? </h2><br><p>  Here is the simplest Peer-To-Peer messenger. </p><br><p>  There are bumps, you can further improve the user functionality: sending files, pictures, audio, emoticons, etc., etc. </p><br><p>  And you can not invent your protocol, and use the google Protocol Buffers, <br>  connect the blockchain and protect against spam using smart contracts Ethereum. </p><br><p>  On smart contracts, organize group chats, channels, name system, avatars and user profiles. </p><br><p>  It is also necessary to start seed peers, implement a NAT traversal and transfer messages from feast to feast. </p><br><p>  In the end, you get a good telegram / VTS replacement, all you have to do is to transfer all friends there =) </p><br><h2 id="poleznosti">  Utility </h2><br><div class="spoiler">  <b class="spoiler_title">Few links</b> <div class="spoiler_text"><p>  In the course of work on the messenger, I found pages that were interesting for a beginner go developer. <br>  I share them with you: </p><br><p>  <a href="https://golang.org/doc/">golang.org/doc/</a> - language documentation, everything is simple, understandable, and with examples.  The same documentation can be run locally with the command </p><br><pre> <code class="bash hljs">godoc -HTTP=:6060</code> </pre> <br><p>  <a href="https://gobyexample.com/">gobyexample.com</a> - a collection of simple examples </p><br><p>  <a href="http://golang-book.ru/">golang-book.ru</a> is a good book in Russian </p><br><p>  <a href="https://github.com/dariubs/GoBooks">github.com/dariubs/GoBooks</a> - a collection of books about Go. </p><br><p>  <a href="https://awesome-go.com/">awesome-go.com</a> is a list of interesting libraries, frameworks, and go applications.  The categorization is less, but the description of many of them is very scarce, which does not help the search by Ctrl + F </p></div></div></div><p>Source: <a href="https://habr.com/ru/post/437686/">https://habr.com/ru/post/437686/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>