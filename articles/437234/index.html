<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Begin to study microcontrollers on the example of STM32F030f4p6</title>
  <meta name="description" content="0. Before reading the article 
 This article has the following objectives: 



1. show how to work specifically with this board; 
2. show the approach...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Begin to study microcontrollers on the example of STM32F030f4p6</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/ex/dh/0-/exdh0-6tdd7sj-4usxbip9chsz0.jpeg"><br><br><h1>  0. Before reading the article </h1><br>  This article has the following objectives: <br><br><ol><li>  show how to work specifically with this board; </li><li>  show the approach with which you can write a program flashing LED, relying solely on the documentation and logic; </li><li>  present the material in a language understandable to a person poorly familiar with microcontrollers. </li></ol><br>  The code will turn out to be minimalist from the point of view of using additional files - we will not include any file, except for those that are needed to build an empty, but valid, firmware.  Those.  based on the firmware code that works, but does not do anything useful. <br><a name="habracut"></a><br>  We will need the following documentation: <br><br><ol><li>  Datasheet STM32F030x4 (I use the document from January 2017 DocID024849 Rev 3); </li><li>  RM0360 Reference manual STM32F030x4 / x6 / x8 / xC (I use the document from April 2017 DocID025023 Rev 4); </li><li>  circuit board. </li></ol><br>  You can download these documents from the <a href="https://cloud.mail.ru/public/5zeo/u7gymaQrx">cloud</a> . <br>  The timer in the article will <i>not</i> be considered and will <i>not</i> be involved in the code. <br>  The ST-LINK programmer was <i>not</i> used.  A USB-COM adapter (RS232 based on PL2303HX) was used to work with the board, which emulates a COM port. <br><br><div class="spoiler">  <b class="spoiler_title">Photo adapter</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/wp/em/u8/wpemu8n1juvbuipavxu-mzfa2eq.jpeg"></div></div><br>  Everything was going to a Windows XP Professional 2002 SP3 virtual machine running through VirtualBox version 5.2.22r126460 on a Windows X host. <br><br><h1>  1. Installing the driver for the USB-COM adapter </h1><br>  Windows does not help, download from the <a href="http://www.prolific.com.tw/US/ShowProduct.aspx%3Fp_id%3D225%26pcid%3D41">Prolific</a> website (the first link to the ‚Äúprolific driver‚Äù request in Google) is a USB to UART / Serial / Printer <b>PL2303 Windows Driver driver</b> (we need the one that is <i>Standard Driver</i> ).  Or you can download from my <a href="https://cloud.mail.ru/public/5zeo/u7gymaQrx">cloud</a> . <br><br>  Install the driver, reboot and see the new COM port. <br><br><div class="spoiler">  <b class="spoiler_title">Screenshot with the name of the installer and the new COM port</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/tq/tt/dh/tqttdhvov6eiov75df-pqcycz0s.png"></div></div><br>  Port settings left standard.  You can change the COM port number at your discretion.  In my experience, only once in my life I saw that the program saw only the first 4 COM ports, if I am not mistaken, it was some kind of Bluetooth terminal under Windows. <br><br><div class="spoiler">  <b class="spoiler_title">COM port settings</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ak/ad/ep/akadepan2w3tldshsr6sys69jo4.png"><br></div></div><br><h1>  2. Fill firmware to and from the board </h1><br><h2>  2.0 Downloading the utility for working with the board </h2><br>  We download <b>FLASHER-STM32 utility</b> (of STM32 Flash loader demonstrator (UM0462) in the description) from the <a href="https://www.st.com/content/st_com/en/products/development-tools/software-development-tools/stm32-software-development-tools/stm32-programmers/flasher-stm32.html">STM</a> off <b>-</b> site, for this we will have to register, but it's not scary - as a result, we will drop the zip-archive with the installer;  Next-&gt; Next-&gt; Next ... and everything is set.  For convenience, I create a shortcut to this application in the working folder. <br><br><div class="spoiler">  <b class="spoiler_title">Here is this utility (screenshot of the site)</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/oa/4a/xz/oa4axzxm4eljcbpzubyspqghcbe.png"><br></div></div><br>  By default, the path to the <i>C: Program Files \ STMicroelectronics \ Software \ Flash Loader Demo \ STMFlashLoader Demo.exe utility</i> . <br><br><h2>  2.1 BOOT-nuance </h2><br>  The board has a jumper (jumper) BOOT. <br><br><ul><li>  When the jumper is <b>closed</b> , the microcontroller will load instructions from its memory (that is, a program written by the programmer). </li><li>  When the jumper is <b>open</b> , the microcontroller will receive information along the RX and TX lines, i.e.  It will be flashed from the COM port (from the adapter in my case). </li></ul><br><h2>  2.2 Configuring the utility </h2><br><img src="https://habrastorage.org/webt/pu/oc/h3/puoch3mqjkqfryjvcnxfg9zeycq.png"><br><br>  Run this application, it is actually the simplest (contains a minimum of settings).  On the first window, select: <br><br><ol><li>  interface (I have it COM-3); </li><li>  the speed with which the computer and the microcontroller will communicate (IMHO, 9600 is normal); </li><li>  the number of data bits (for some reason this window is not available to me, but so far it does not matter); </li><li>  parity (I have no parity, i.e. None); </li><li> echo (I have OFF); </li><li>  waiting time (I have 10 seconds). </li></ol><br>  Click Next, and if everything is in order, then we will see a green light and ‚ÄúTarget is readable‚Äù;  if we see a red light, the computer could not connect. <br><br><div class="spoiler">  <b class="spoiler_title">Target is readable if the microcontroller is successfully determined</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/gd/9y/hw/gd9yhwnpu15asiupizayeozvsfo.png"><br></div></div><br>  The order of steps that always help: <br><br><ol><li>  First, you need to check if the BOOT jumper is closed on the board. </li><li>  Secondly, in any case, turn off the power of the microcontroller and preferably the TX and RX lines going from the adapter to the board (the ground can not be disconnected). </li><li>  Thirdly, in the program to press Back to the end, i.e.  before the first page, or even close it and start it again (generally speaking, it sometimes hangs).  It is important to always start from the first page before each connection to the board through this program. </li><li>  Fourth, pick up the wires from the adapter to the board and try again to connect to the program (always from the first page!). </li></ol><br>  If nothing helped, you can try to disable everything, restart the computer, and try to reconnect to the board. <br><br>  Since  I work through a virtual machine, I have to reconnect the USB-COM adapter several times so that it is detected by the virtual machine and the host machine does not have time to install non-working drivers. <br><br>  Another option that I found a worker at the time of writing this article is to press a button on the board instead of constantly jerking the wires.  However, the BOOT jumper will be closed and opened in any case.  This option works because the button is connected to the foot of the external reset <abbr title="exterNal ReSeT">NRST</abbr> . <br><br>  On the next window, select the target device Target.  By the way, sometimes you can see (perhaps this is a bug) in general, the left device, for example instead of STM32, see STM8 - somewhere there was some kind of failure, the order of treatment is described above.  Therefore, in this step, you cannot rush to press Next, but always pay attention to the fact that the desired device is selected in Target. <br><br><div class="spoiler">  <b class="spoiler_title">Target Device Selection</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/zz/p8/83/zzp88341ayrb95ymtn1bf3-elvq.png"><br></div></div><br>  How to determine what our device?  - look at the chip and rewrite everything that is written on it.  We open the <i>Datasheet</i> on our chip, in the <i>Ordering information</i> section it is described which letter is responsible for what.  In my case it is: <br><br><img src="https://habrastorage.org/webt/pa/kn/ga/pakngat6l5tahlk-y75nledccuy.png"><img src="https://habrastorage.org/webt/f0/fb/jk/f0fbjkrbe8a-g5uqbjdovxzr_fc.png"><br><br><div class="spoiler">  <b class="spoiler_title">I choose my chip (16K) in Target and move on.</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/qs/u4/v2/qsu4v2uhtvft1sj1uhp2bnount4.png"><br></div></div><br>  There are a choice of 4 actions with a chip: <br><br><ol><li>  erase memory (whole or select a specific area); </li><li>  write firmware to the device; </li><li>  read the firmware from the device; </li><li>  enable / disable write protect or read protection. </li></ol><br><h2>  2.3 Read firmware from board </h2><br>  At the very first connection of my board I decided to keep the original firmware, a sort of backup - we will do it now.  You will need to specify where to save this firmware and which memory pages to save, you can also choose to use the <i>hex</i> , <i>bin</i> or <i>s19</i> file format. <br><br><div class="spoiler">  <b class="spoiler_title">Select memory pages to read</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/b_/vs/yq/b_vsyqyslqo1sib02nymmymvy_m.png"><br></div></div><br>  If you only upload to the board or read the firmware from the board, then there is no difference between these file formats.  Next comes the progress page, where I sometimes hang the process for 99% for a long time (not necessarily just 99), but after a few seconds it supposedly successfully completes - in fact, after that, the board did not show the behavior that would correspond to the loaded firmware.  Simply put, you need to reconnect everything and re-fill the firmware, nothing critical in this. <br><br>  The firmware file is preserved, and in the future it can be uploaded to the board. <br><br>  However, if read protection is installed, the firmware will not work. <br><br><div class="spoiler">  <b class="spoiler_title">Progress window</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/nb/ta/rs/nbtarsmjtb1-ylmcxaesykldlv0.png"><br></div></div><br><h2>  2.4 Flashing Board </h2><br>  Now we will upload the firmware file, the writing of the source code of which is given below.  Looking ahead, I‚Äôll say that we‚Äôll upload <i>bin</i> and <i>hex</i> files, because  it will be them that will be issued by the development environment.  Additional settings for <i>s19</i> and <i>hex</i> files are identical;  Unlike them, in the <i>bin</i> file, you can select the address from which the firmware will be recorded, by default in the utility it is equal to 8000000 (it suits us). <br><br><div class="spoiler">  <b class="spoiler_title">Preparing to record</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/1k/u8/cf/1ku8cfxnzt_bjob1szyix3u2xpw.png"><br></div></div><br>  Before recording, you can clear the microcontroller's flash memory by selecting one of three options: <br><br><ul><li>  Erase necessary pages; </li><li>  No Erase (without cleaning); </li><li>  Global Erase (full cleaning). </li></ul><br>  In fact, cleaning is the process of writing zeros to memory. <br><br>  There are still optional bytes, but for now you can leave them alone.  Click Next, wait for the completion of the process and everything is ready. <br><br>  In case you want to write down my firmware, you can find it in the cloud, the file <i><a href="https://cloud.mail.ru/public/6MGA/pF7MiTXCV">blink.bin</a></i> .  When using this firmware, the built-in LED powered by the PA4 leg should flash. <br><br><h1>  3. Writing code </h1><br><h2>  3.0 Installing CooCox CoIDE Development Environment </h2><br>  The IDE can be downloaded from the <a href="https://www.softpedia.com/get/Programming/Coding-languages-Compilers/CooCox-CoIDE.shtml">SoftPedia.com</a> site, previously it was possible to download from the STM site and from the IDE site itself, but since the IDE was no longer supported, this has become impossible.  There is nothing critical in the fact that the IDE stopped supporting, no, because  for writing code, the main thing is the compiler.  I downloaded both versions, but I use version 1.7.8. <br>  The first launch of the environment is well described <a href="http://cxem.net/mc/mc172.php">here</a> , Next-&gt; Next-&gt; Next ... and nothing complicated.  I will add only that first it is better to create a project, and then everything else. <br><br>  And yet, if you lost the Repository tab, you can find it in the menu <i>View -&gt; Repository</i> . <br>  Download the tools (compiler) for the environment <a href="https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads">here</a> or ask Google ‚Äúgnu tools for arm‚Äù;  I downloaded the option that has sha1.exe at the end. <br><br><h2>  3.1 Source Framework </h2><br>  So, the project has been created, the chip has been selected, now we will add to the project a minimal set of sources, without which it cannot live at all. <br><br><div class="spoiler">  <b class="spoiler_title">This is how a project should look like when it is first created, i.e.</b>  <b class="spoiler_title">there is only the main file main.c and nothing more</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/db/rf/qh/dbrfqhef0pg7j3perjtzm3b3okc.png"><br></div></div><br>  <b>Highlight CMSIS BOOT</b> and the environment will automatically <b>highlight M0 Cmsis Core</b> , because  dependencies require it. <br><br><div class="spoiler">  <b class="spoiler_title">Now we get the minimum set of sources</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/fk/u8/qt/fku8qtl8uhcttxq_xswbovf-10c.png"><br></div></div><br>  Build the project (Build icon, or F7 key).  For reasons I do not understand, the hex file is not collected (there is a warning in the console);  I reinstalled the IDE and compiler several times, re-created the project, but for some reason this result was on the virtual machine;  on another computer (not virtual, but real) everything is one-to-one and the output is a working hex.  Fortunately, there is a bin. <br><br><div class="spoiler">  <b class="spoiler_title">Project successfully assembled</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ap/zn/ct/apznctscxqdbgullp11rzqxtyj4.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">I advise you to pay attention to the file size, you can see it at the end of the output in the console, or you can see it with standard tools (here, by the way, you can see that hex is empty);</b>  <b class="spoiler_title">At the same time on this screenshot you can see that the firmware files are in the project folder, then Debug / bin /</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ho/ue/wd/houewdyn-cyjvmn-js5sbah-yru.png"><br></div></div><br>  Although the code does not do anything, I upload it to the board in order to make sure that it is possible to fill in (which, for example, the utility does not discard).  I advise you to do this and the reader.  If it fails, try again and again, as well as write comments. <br><br><h2>  3.2 Finger algorithm </h2><br>  To begin with we will outline algorithm as from the point of view of the person the microcontroller will blink a LED.  And for this, a little reasoning. <br><br>  Each equipment works at the expense of stored energy, for example, some engines can run on different types of fuel, but for this purpose the engine needs to be adjusted to the type of fuel we are going to feed it with.  Similarly, the microcontroller needs to be adjusted (customized) for an energy source - this will be the <i>first block of the</i> algorithm. <br>  We reason further.  The desktop computer has a monitor, speakers, keyboard, mouse ... and you can see that some devices provide us with information, and with the help of others we provide information to the computer, but all of them are connected to a common box for all of them (the system unit).  You can guess that the microcontroller can receive and give information, which means that its legs can receive a signal or give a signal - this will be the <i>next block of the</i> algorithm. <br><br>  Next, the microcontroller should turn on the LED, wait for some time, turn off the LED, wait for some time and re-enable-wait-off ... <br><br>  As a result, the algorithm will look something like this. <br><br><img src="https://habrastorage.org/webt/h1/m4/oo/h1m4oou5txdafrybbwobj69vahm.png" height="361" width="192"><br><br>  The purpose of this flowchart is to visually show what the algorithm is doing;  First of all, the scheme is written for itself, so everyone is free to write / draw it as he wants (for himself).  I believe that the scheme should aim to be as simple as possible, readable and visual, and have a high level of abstraction. <br><br>  In accordance with this algorithm, we will write code. <br><br><h2>  3.3 Work with documentation </h2><br>  I recommend reading this part of the article with the open file <i>stm32f0xx.h</i> , which lies in the <i>cmsis_boot</i> folder of our project, and with open documentation. <br><br><h3>  3.3.1 Choice of clock source </h3><br>  First, you need to provide power to the microcontroller.  The microcontroller receives from the adapter 5 volts (measured with a multimeter), but the question arises ‚Äúat what frequency does the microcontroller work‚Äù, because it is known that the electronics operate at different frequencies.  First open the <i>datasheet</i> , in the content you can see two sections that are relevant in meaning: <i>Power management</i> , <i>Clocks and startup</i> .  The first one deals with voltage and low-power modes.  The second section hides what we are interested in at the moment.  Already in the very first sentence, it says ‚Äúthe internal RC 8 MHz oscillator is selected as default CPU clock on reset‚Äù, which means that <i>by default, after resetting the MC, the internal 8 MHz RC-chain</i> is selected as the <i>main clock source</i> . <br>  Next comes some kind of incomprehensible Clock Tree scheme, which we will look at later. <br><a name="Clock_tree"></a><br><br><div class="spoiler">  <b class="spoiler_title">Clock tree</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/sg/nl/ul/sgnlul1krp_mdiqntf5it8a0eni.png"></div></div><br>  Strictly speaking, you can rely on the phrase ‚Äúby default after resetting the MK ...‚Äù and read this part of the article diagonally. <br><br>  Now you need to be distracted by the board and look for the internal LED.  I know that the diodes on the circuits are designated <i>D1</i> , <i>D2</i> ..., i.e.  <i>D == diode</i> , on my board near the resistor <i>R7</i> is a diode <i>D1</i> . <br><br><div class="spoiler">  <b class="spoiler_title">Photo board</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ma/ze/ke/mazekeve26x9-imexuqb2k1knb8.png" width="462" height="330"><br></div></div><br>  Perhaps, having carefully examined the board, you will be able to trace to which leg the diode is attached, but I will turn to the circuit board.  Unfortunately, the elements of the board do not exactly correspond to the elements on the diagram in their location;  but I am glad that I found such a scheme on the Internet (otherwise I could not find anything for a long time). <br><br><img src="https://habrastorage.org/webt/id/gz/tw/idgztwbtwraskhguvq-9alkrp18.png"><br><br>  In the diagram we see that the cathode of the diode through jumper <i>J2 is</i> hooked up to the ground, and the anode through the resistor is hooked up to the output <i>PA4</i> .  <i>PA4</i> means the 4th pin of port <i>A</i> , which means that in order to turn on and off the LED, you will need to apply voltage to the pin <i>PA4</i> . <br><br>  Next, you need to determine how to apply voltage to this pin.  For me, it was not at all intuitive, and I plowed the documentation for a long time along and across until I came across the datasheet at the very beginning of the <b>block diagram diagram</b> in the <i>Description</i> section.  And in it, I saw the coveted <i>PA</i> track <i>[15: 0] &lt;=&gt; GPIO port A &lt;=&gt; AHB decoder &lt;=&gt; Bus matrix &lt;=&gt; Cortex-M0</i> , i.e.  Port <i>A</i> is a general-purpose I / O port and is connected to the <abbr title="Advanced High-performance Bus"><i>AHB</i></abbr> bus. <br><br><div class="spoiler">  <b class="spoiler_title">Block diagram</b> <div class="spoiler_text">  (The picture is clickable) <br> <a href=""><img src="https://habrastorage.org/webt/_e/hf/d0/_ehfd0kdf5v87xxud5yj4abp3xu.png"></a> <br></div></div><br>  I note that in electronics it is customary to break the microcontroller pins into ports, and usually the port has 16 pins.  The diagram shows that ports <i>A</i> , <i>B</i> and <i>C</i> have just 16 of them, but ports <i>D</i> and <i>F</i> have fewer of them (less than 16 pins maybe more, no). <br><br>  Let's go back to the <a href="https://habr.com/ru/post/437234/">Clock tree</a> scheme and find the output, signed by <i>AHB</i> .  Let's figure out what frequency this output works.  The <i>AHB</i> signal goes <i>HCLK</i> , which comes out of the <i>HPRE</i> divider.  This divider receives a <abbr title="SYStem CLocK"><i>SYSCLK</i></abbr> signal from the <abbr title="System clock sWitch"><i>SW</i></abbr> switch.  It is programmatically specified which of the signals at the <i>SW</i> input will be used as <i>SYSCLK</i> - then we will <i>specify</i> this in the code.  You can choose from: <br><br><ol><li>  <i><abbr title="High speed internal">HSI</abbr></i> - a signal from an internal high-frequency generator, it is output by an 8 MHz crystal resonator, which I soldered before working with this board; </li><li>  <i><abbr title="Phase Lock Loop CLocK">PLLCLK</abbr></i> - signal from the frequency multiplier <i>PLLMUL</i> ; </li><li>  <i><abbr title="High speed external">HSE</abbr></i> - signal from an external high-frequency generator. </li></ol><br>  Any option is suitable for our task, I suggest choosing the simplest and most accessible of them - <i>HSI</i> . <br><br>  Let's go to the <i>Reference manual</i> and open section <i>7 Reset and clock control (RCC)</i> , and specifically <i>7.2.6 System clock selection</i> , where we once again come across a similar wording found in the datasheet: ‚Äúafter a system reset, the <i>HSI</i> oscillator is selected as system clock ‚Äù- i.e.  we don‚Äôt even have to do anything, MK will start himself on <i>HSI</i> . <br><br>  To make sure that the MC really will work from this source, I will register it explicitly in the program;  we scroll to the registers that are responsible for the reset and clocking (section <i>7.4 of the RCC registers</i> ).  The first register described in the documentation is <b>Clock control register (RCC_CR)</b> ;  Below is a description of the bits, which is responsible for what. <br><br><div class="spoiler">  <b class="spoiler_title">Clock Control Register</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/qq/i4/ll/qqi4llshdqrtgidy2_x-hxx9yhe.png"><br></div></div><br>  We are interested in the zero bit of <i>HSION</i> , which is responsible for turning on the resonator ( <i>0</i> is off, <i>1</i> is on). <br><br>  Thus, it will be necessary to write the unit to the register <i>RCC_CR</i> .  (zero bit is one, or 2 <sup>0</sup> = 1). <br><br>  Now in the <i>stm32f0xx.h</i> file, we find the definition of <b>RCC</b> ( <i>#</i> <i>define RCC</i> ). <br><br><div class="spoiler">  <b class="spoiler_title">RCC-&gt; RC</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/vn/ej/0x/vnej0xmqlqnrgeprbgyjo9cpjt8.png"><br></div></div><br>  As you can see, this is a structure located at <i>RCC_BASE</i> ;  address <i>0x40021000</i> , if you expand all <i>define</i> , the same address can be seen in the <i>Reference manual</i> in section <i>2.2.2 of the Memory Map and register boundary adresses</i> and in the data section in Section <i>5 of the Memory mapping</i> ( <i>AHB</i> area). <br><br>  To write a unit in the <i>CR</i> register of the <i>RCC</i> block to enable <i>HSI</i> , you will need a line of code <br><br><pre><code class="plaintext hljs">RCC-&gt;CR |= 0x1;</code> </pre> <br><h3>  3.3.2 Foot adjustment </h3><br>  Signaling the microcontroller's leg to light the LED and stopping the signal in order for the LED to go out are simple actions, and therefore it refers to <i><abbr title="General-Purpose Inputs / Outputs">GPIO</abbr></i> functions (general-purpose I / O ports). <br><br>  By default, the legs of the MC are not connected, i.e.  output uncertainty.  It is necessary to connect the port, the leg of which will power the LED.  Previously, we determined that the <i>GPIO</i> ports are connected to the <i>AHB</i> bus ‚Äî you need to talk about this bus.  Continuing to scroll through section <i>7.4 of the RCC registers</i> (reset and control control registers), we encounter section <i>7.4.6 of the AHB peripheral clock enable register</i> ( <b>RCC_AHBENR</b> , <i>AHB</i> bus <i>clock enable register</i> ).  Earlier, I determined that my LED is connected to the <i>PA4 pin</i> ‚Äî accordingly, I need to write down the unit in the 17th register bit in order to patch port <i>A.</i> <br><br><div class="spoiler">  <b class="spoiler_title">AHB peripheral clock enable register</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/u7/s5/vs/u7s5vsoduvggexg9chpopozlzdw.png"><br></div></div><br>  Accordingly, the code must be <br><br><pre> <code class="plaintext hljs">RCC-&gt;AHBENR |= (1 &lt;&lt; 17);</code> </pre> <br>  or, which is the same <br><br><pre> <code class="plaintext hljs">RCC-&gt;AHBENR |= 0x20000;</code> </pre> <br>  either using <i>stm32f0xx.h</i> <i>#define</i> file <i>to</i> write <br><br><pre> <code class="plaintext hljs">RCC-&gt;AHBENR |= RCC_AHBENR_GPIOAEN;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">RCC-&gt; AHBENR</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/19/ex/ke/19exkey4g-yyfkz4pmvrrgilnlk.png"><br></div></div><br>  We powered up port <i>A</i> , now we need to inform MK that <i>PA4</i> will work on the <i>way out</i> - we will read section <i>8 of the General-purpose I / Os (GPIO)</i> ;  In the introduction of the section, ‚ÄúEach general-purpose port has four 32-bit configuration registers ( <b>GPIOx_MODER</b> , <b>GPIOx_OTYPER</b> , <b>GPIOx_OSPEEDR</b> and <b>GPIOx_PUPDR</b> ), two 32-bit data registers ( <b>GPIOx_IDR</b> and <b>GPIOx_ODR</b> ) ...‚Äù - <i>each GPIO the port has 4 configuration registers and 2 data registers</i> - this is what we need (configure port <i>A</i> , or rather the output of <i>PA4</i> , and periodically send <i>0</i> and <i>1 to it</i> ).  For a better understanding (theory) of what is happening, you can read this section, but I scroll down to section <i>8.4 of the GPIO registers</i> and configure the port in accordance with the descriptions. <br><br><ol><li>  port <b>mode</b> - exit.  In accordance with the documentation, it is necessary to record <i>01</i> in the corresponding area ( <i>MODER4</i> ) of the corresponding register ( <i>GPIOA_MODER</i> ), i.e.  bits <i>9</i> and <i>8</i> : in the 9th bit should be zero, in the 8th unit: <br><br><pre> <code class="plaintext hljs">GPIOA-&gt;MODER |= (1 &lt;&lt; 8); // –∏–ª–∏</code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;MODER |= 0x100; // –∏–ª–∏</code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;MODER |= GPIO_MODER_MODER4_0;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">GPIO port mode register</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/tv/xf/vt/tvxfvtoiw91rguuz-rtmgcrk8fo.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">GPIOA-&gt; MODER</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/co/df/x5/codfx50xu4hopklififyeecpiqu.png"><br></div></div><br></li><li>  <b>type of</b> output.  Honestly, I still have not fully understood the circuit design of this case (I will understand, re-read forums, etc.), but studying other resources on the configuration of the MK output, as well as logic and intuition, suggest that there should be a <b>push -pull</b> and then should be <i>pull-up</i> .  In any case, the code is written, everything works and nothing burns.  There is a real risk of burning if you select the <b>open-drain</b> type and short the output with another device, since  This is an open exit and is not protected by anything.  In addition, we have a current limiting resistor in front of the diode - it certainly will not burn. <br><br>  Following the documentation, it is necessary to write a zero in the 4th bit;  the documentation also states that after a reset, there will be zero here. <br><br><pre> <code class="plaintext hljs">GPIOA-&gt;OTYPER &amp;= ~(1 &lt;&lt; 4); // –∏–ª–∏</code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;OTYPER &amp;= ~0x10; // –∏–ª–∏</code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;OTYPER &amp;= ~GPIO_OTYPER_OT_4;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">GPIO port output type register</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ii/3k/ch/ii3kcht4jvsbnd7yybouiilgmhk.png"><br></div></div><br></li><li>  output <b>speed</b> .  In our case, it does not matter, but for fidelity, I‚Äôll write here a zero. <br><br><pre> <code class="plaintext hljs">GPIOA-&gt;OSPEEDR &amp;= ~(1 &lt;&lt; 8); // –∏–ª–∏</code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;OSPEEDR &amp;= ~0x100; // –∏–ª–∏</code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;OSPEEDR &amp;= ~GPIO_OSPEEDER_OSPEEDR4_0;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">GPIO port output speed register</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/47/xg/fr/47xgfrtfqdl5ai0eztsrqej1i1k.png"><br></div></div><br></li><li>  <b>a suspender</b>  Since  the output will power the LED, you need to pull up to the power, i.e.  <b>pull-up</b> . <br><br>  It is necessary to tighten the 4th output of port <i>A</i> ;  the documentation says that for this it is necessary to write zero and one bits in <i>9</i> and <i>8,</i> respectively. <br><br><pre> <code class="plaintext hljs">GPIOA-&gt;PUPDR |= (1 &lt;&lt; 8); // –∏–ª–∏</code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;PUPDR |= 0x100; // –∏–ª–∏</code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;PUPDR |= GPIO_PUPDR_PUPDR4_0;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">GPIO port pull-up / pull-down register</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/pg/pa/zk/pgpazkwfltwme4jy0wwrhp9imqi.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">GPIOA-&gt; PUPDR</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/bo/ee/na/boeenaff6fxjiemjuiky9ukhb6w.png"><br></div></div><br></li></ol><br><h3>  3.3.3 LED on-off and delay </h3><br>  Earlier we read that each port has registers, including the <i><abbr title="Input Data Register">IDR</abbr></i> and <i><abbr title="Output Data Register">ODR</abbr></i> data registers - input and output data registers, respectively.  Logical zeros and ones on the MK leg - is this data?  - yes, data.  Data can come into the microcontroller from the outside (to be <i>input</i> ) and exit from the microcontroller and go to another device (to be <i>output</i> ).  The unit on the MK leg is the presence of a high voltage level, i.e.  If you output the unit to the output, then there will be a voltage, and this voltage can power our LED.  The output of the unit on the microcontroller's leg is something else, as the writing of this unit to the register of the output data <i>ODR</i> . <br><br><div class="spoiler">  <b class="spoiler_title">GPIO port output data register</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/or/vw/el/orvwel6seyhwvx6pbxdcow6ufpm.png"><br></div></div><br>  According to the documentation, we see that for each port ( <i>A</i> , <i>B</i> , <i>C</i> , <i>D</i> , <i>F</i> ) there is a 32-bit register, however, since  since a port cannot have more than 16 pins, only the first 16 bits of the register are used.  Each bit corresponds to the port number (output).  To output the unit on the <i>PA4</i> pin, you need to write down the unit to the 4th bit, to output a zero ‚Äî write zero to the 4th bit, i.e.  remove the voltage from the output. <br><br><img src="https://habrastorage.org/webt/pr/0n/pr/pr0npr4jplwjahmcflj_nlksq5i.png" width="400" height="156"><br><br><div class="spoiler">  <b class="spoiler_title">GPIOA-&gt; ODR</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/hs/yy/v4/hsyyv4z5u2kf6fkqqe5wk9t6ti4.png"><br></div></div><br>  The code to turn on the LED will look like this <br><br><pre> <code class="plaintext hljs">GPIOA-&gt;ODR |= (1 &lt;&lt; 4); // –∏–ª–∏</code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;ODR |= 0x10; // –∏–ª–∏</code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;ODR |= GPIO_ODR_4;</code> </pre> <br>  Code to turn off the LED <br><br><pre> <code class="plaintext hljs">GPIOA-&gt;ODR &amp;= ~(1 &lt;&lt; 4); // –∏–ª–∏</code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;ODR &amp;= ~0x10; // –∏–ª–∏</code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;ODR &amp;= ~GPIO_ODR_4;</code> </pre> <br>  But if you write the line for turning off the LED after the line for turning on, then the LED will not blink (if you are wondering what will happen - you can try; it will not burn anything, it has already been discussed above) - it means you need to make a delay.  For the delay, timers are used, but the timers are worthy of a separate article (due to the complexity), so we will do a crutch delay: we will drive the idle cycle.  There is one thing: <b>if compiler optimization is enabled</b> , the <b>compiler will cut out</b> our idle cycle, and there will be no delay.  Make sure that optimization is not enabled.  To do this, go to the project configuration (right-click on the project name in the project tree) and check the <i>Compile Control String</i> line in the <i>Compile</i> tab: it must contain the argument <i>-O0</i> (‚Äúo zero‚Äù means that optimization is disabled).  If you collected everything according to my instructions, then most likely you will also have <i>-O0</i> , since  This was the default and I did not touch anything here.  Arguments <i>-O1 -O2 -O3</i> means that the optimization of the corresponding level is enabled. <br><br><div class="spoiler">  <b class="spoiler_title">Check compiler optimization</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/vc/ps/pu/vcpspuz5xfupw1pa5n-e5at9_nm.png"><br></div></div><br>  The idle cycle can be written like this: <br><br><pre> <code class="plaintext hljs">int t = 4000000; while(t &gt; 0) t--;</code> </pre><br>  I set the value of <i>t to</i> those by chance, argued as follows: if the microcontroller runs at 8MHz, then in a second it will execute an estimated 8,000,000 instructions; if it is deeply exaggerated, then for a half-second delay it will be necessary to drive the cycle 4,000,000 times. <br>  The idle cycle will need to be run after the LED is turned on, and after it is turned off, and together it will loop. <br><br><h3>  3.4 Writing code and running </h3><br>  Let's put together all the lines of code that we wrote before.  You also need to include the header file <i>stm32f0xx.h</i> , because  we relied on it and took from it definitions of structures, addresses and values.  The result should be: <br><br><pre> <code class="plaintext hljs">#include "stm32f0xx.h" int main(void) { int t; // –¥–ª—è '—Ç–∞–π–º–µ—Ä–∞' RCC-&gt;CR |= 0x1; // —Ç–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –æ—Ç HSI RCC-&gt;AHBENR |= RCC_AHBENR_GPIOAEN; // –∑–∞—Ç–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–æ—Ä—Ç A GPIOA-&gt;MODER |= GPIO_MODER_MODER4_0; // PA4 –∫–∞–∫ –≤—ã—Ö–æ–¥ GPIOA-&gt;OTYPER &amp;= ~GPIO_OTYPER_OT_4; // —Ç–∏–ø push-pull –¥–ª—è PA4 GPIOA-&gt;OSPEEDR &amp;= ~GPIO_OSPEEDER_OSPEEDR4_0; // –Ω–∏–∑–∫–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –¥–ª—è PA4 GPIOA-&gt;PUPDR |= GPIO_PUPDR_PUPDR4_0; // —Ä–µ–∂–∏–º pull-up –¥–ª—è PA4 while(1) { GPIOA-&gt;ODR |= GPIO_ODR_4; // –≤–∫–ª—é—á–∏—Ç—å —Å–≤–µ—Ç–æ–¥–∏–æ–¥ –Ω–∞ PA4 t = 4000000; while(t &gt; 0) t--; // –∂–¥–∞—Ç—å GPIOA-&gt;ODR &amp;= ~GPIO_ODR_4; // –≤—ã–∫–ª—é—á–∏—Ç—å —Å–≤–µ—Ç–æ–¥–∏–æ–¥ –Ω–∞ PA4 t = 4000000; while(t &gt; 0) t--; // –∂–¥–∞—Ç—å } }</code> </pre><br>  We press Rebuild and fill in the code to the board through the utility. <br><br><img src="https://habrastorage.org/webt/fo/rr/1d/forr1d6ruw6sohn7eyomgs4yb_g.png"><br><br>  In order for the board to launch a new firmware, do not forget to close the BOOT jumper and make a reset (RESET). <br><br><h1>  4. Conclusion </h1><br>  The code is written, everything works.  Forces spent Nemer.  I am glad that based on the documentation, it turned out to write a working code, largely due to the fact that STM has high-quality documentation. <br><br>  There are plans to write an article on how to assemble everything with your hands, without an IDE, through the console, <i>true oldschool</i> , ideally so that you can do all this from under Linux.  Now I am working on PWM and ADC (also on this board) - I'll write an article on them too. </div><p>Source: <a href="https://habr.com/ru/post/437234/">https://habr.com/ru/post/437234/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>