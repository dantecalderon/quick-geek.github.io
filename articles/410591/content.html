<div class="post__text post__text-html js-mediator-article">  I happened to program on assemblers of different processors.  Last on the list is Xilinx MicroBlaze.  I decided to put some of my observations on the features of these almost magical pieces of iron, which, like the magic key of Pinocchio, opened the doors to the magical country of virtual reality and mass creativity.  On the features of modern systems x86, x86-64, ARM, ARM-64, etc.  I will not write, maybe another time - the topic is very large and complex.  Therefore, I plan to finish on Intel 80486 and Motorola 68040. I also wanted to include IBM / 370, which I dealt with, in the review.  These systems were quite far from the masses of users, but had a huge impact on computer technology.  They simply did not have enough time allocated for the topic, they did not use processors-chips and for some reason, they themselves seemed to be completely gone.  I really hope that my materials will attract the attention and connoisseurs who will be able to add something from what they have not thought about or did not know. <br><br>  As an illustrative material, I attach my own small <a href="https://github.com/litwr2/rosetta-pi-spigot">stone from Rosetta</a> - a program for calculating the number π on different processors and systems using a gate algorithm, claiming to be the fastest of its implementations. <br><br><a name="habracut"></a><br><h2>  Intel 8080 and 8085 </h2><br>  The first real processor on the chip, made in the first half of 1974, is still being manufactured and is currently being used.  Many times it was cloned around the world, in the USSR it had the designation KR580VM80A.  Modern Intel processors for the PC are still easy to detect their affinity to this already in a sense relic product.  I myself did not write codes for this processor, but being well acquainted with the architecture of the z80, I would venture to quote some of my comments. <br><br>  The 8080 command system, like other Intel processors for the PC, can hardly be called ideal, but it is universal, quite flexible and has some very attractive features.  The Motorola 6800 and MOS Technology 6502, 8080 favorably differed from their competitors by a large number of even somewhat clumsy registers, providing the user with one 8-bit A battery, one 16-bit semi-accumulator and part-time fast index register HL, 16-bit SP index stack. , as well as two more 16-bit registers VS and DE.  The BC, DE, and HL registers could also be used as 6 byte registers.  In addition, the 8080 had the support of an almost complete set of state flags: carry, sign, zero, and even parity and half transfer.  Some of the instructions from the 8080 recruiting team have been speed champions for a long time.  For example, the XCHG command makes the exchange of the contents of the 16-bit registers DE and HL in just 4 clock cycles - it was extremely fast!  A number of other teams, although they did not set such bright records, were also among the best for a long time: <br><br><ul><li>  XTHL - the exchange of the contents of the register HL and data at the top of the stack, 18 clocks - it seems like a lot, on even a real 16-bit 8086 such a command takes 22 clocks, and for 6800 or 6502 such a command is even difficult to imagine; </li><li>  DAD - add to the semi-accumulator HL the value of another 16-bit register (BC, DE or even SP), 10 cycles.  This is a true 16-bit addition with a carry flag set.  If you add HL to yourself, you will get a quick 16-bit left shift or multiplication by 2, a key operation for both realizing full multiplication and dividing; </li><li>  PUSH and POP - put in the stack and remove from the stack a 16-bit value, respectively, from the register or in the register.  Performed in 11 and 10 cycles.  These are the fastest 8080 operations for working with memory, and when they are executed, SP is automatically incremented or decremented.  PUSH can be used, for example, to quickly fill a memory with a pattern with values ​​from 3 registers (BC, DE, HL).  There are no commands for working with 8-bit values ​​with a stack at all; </li><li>  LXI - loading a 16-bit constant into a register (HL, DE, BC, SP) in 10 cycles; </li><li>  RNZ, RZ, RNC, RC, RPO, RPE, RP, RM - conditional returns from the subroutine, allowed to make the code cleaner, eliminating the need to write unnecessary conditional transitions.  These commands were abandoned in the x86 architecture, it is possible that in vain, the code with it turns out nicer. </li></ul><br>  This processor was used in the first Altair 8800 personal computer, which became very popular after a journal publication in early 1975. By the way, in the USSR, a similar publication happened only in 1980, and its relevance only in 1986. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9bc/83c/df5/9bc83cdf580f4cc805da782faaf8c9da.jpg" align="left"><br>  <i>First almost pc</i> <i><br></i> <br>  The Intel 8080 became the basis for the development of the first-ever mass professional CP / M operating system, which dominated microcomputers for professional use until the mid-1980s. <br><br>  Now about the shortcomings.  The 8080 required three supply voltages of -5, 5, and 12 volts.  Work with interruptions - clumsy and slow.  And in general, the 8080 is more leisurely, if you compare it with competitors soon to emerge.  6502 could be up to 3 times faster when working on the same frequency as the 8080. <br><br>  But in the 8080 architecture it turned out, as it turned out, the correct vision of the future, namely the unknown in the 70s, the fact that processors will be faster than memory.  Registers 8080 DE and BC are more likely a prototype of modern caches, with manual control, than general registers.  8080 started at 2 MHz, while competitors started at only 1, which smoothed the performance difference. <br><br>  It is difficult to call the 8080 an 8-bit processor at 100%.  Of course, the ALU is 8 bits wide, but there are many 16 bit commands that work faster than using only 8-bit counterparts instead.  And for some teams, there are no 8-bit analogs at all.  Team XCHG in essence and timing 100% 16-bit.  There are real 16-bit registers.  Therefore, I venture to call the 8080 partially 16-bit.  It would be interesting for the totality of signs to calculate the index of the processor's bitness, but, as far as the author knows, no one has done this work so far. <br><br>  The author does not know the reasons why Intel refused to directly support the development of 8-bit personal computers with its processors.  Intel has always distinguished the complexity and ambiguity of the policy.  Its connection with politics, in particular, is illustrated by the fact that for a long time Intel has plants in Israel and until the end of the 90s it was secret.  Intel practically did not try to improve the 8080, it was only up to 3 MHz with the clock frequency raised.  In fact, the 8-bit market was transferred to Zilog with a related 8080 z80 processor, which was able to quite successfully withstand the main competitor, the “terminator” 6502. <br><br>  In the USSR and Russia, the domestic clone 8080 became the basis of many popular computers that remained popular until the early 90s.  This, of course, Radio-86RK, Microsha, multicolor Orion-128, Vector and Corvette.  However, in the Clone Wars, the cheap and improved Z80-based ZX Spectrum clone won. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eb5/256/661/eb525666122755ff4379540acb7d3632.jpg"><br>  <i>This is a real PC</i> <br><br>  In early 1976, Intel was introduced with the 8085 processor, compatible with the 8080, but far superior to its predecessor.  In it, the power supply of -5 and 12 volts has become unnecessary and the connection scheme has been simplified, work with interruptions has been improved, the clock frequency has been used from 3 to a very solid 6 MHz, the command system has been extended with several useful instructions: 16-bit subtraction, 16-bit offset to the right in just 7 cycles (this is very fast), 16-bit rotation to the left through the carry flag, loading a 16-bit register with an 8-bit offset (this command can also be used with the SP pointer of the stack), register HL at the address in the register DE similar to h  HL through DE.  All the instructions mentioned above, except for the shift to the right, are executed in 10 cycles — this is sometimes significantly faster than their counterparts or emulation on the z80.  Some more instructions and even two new flags of signs were added.  Among the new flags it is worth noting the overflow flag, although the work with it was almost not supported.  In addition, many instructions for working with byte data were accelerated.  This was very significant, since on many systems with 8080 or z80 delay ticks were introduced, which, due to the presence of extra ticks on the 8080, could stretch the execution time almost twice.  For example, in a domestic computer Vector, a register-register type instruction was executed 8 cycles, and if there was 8085 or z80, then the same instructions would be executed only in 4 cycles.  The XTHL instruction has become faster even by two cycles.  However, some instructions, for example, 16-bit increment and decrement, PUSH and conditional returns have become slower in tact. <br><br>  The 8085 has built-in interrupt support, which in many cases eliminates the need for a separate interrupt controller in the system, and a serial I / O port.  As already noted, in 8085 they did not add support for the full flag overflow, so the signed arithmetic remained somewhat incomplete. <br><br>  However, I can repeat the formula “for reasons unknown to the author” again. Intel refused to promote 8085 as the main processor.  Only in the 80s some fairly successful 8085-based systems appeared. The first in 1981 was the predecessor and almost competitor to the IBM PC, the IBM System / 23 Datamaster.  Then in 1982, a very fast computer was released with excellent Zenith Z-100 graphics, in which 8085 worked at 5 MHz.  In 1983, the Japanese company Kyotronic created a very successful KC-85 kneecap, versions of which were also produced by other companies: Tandy produced the TRS-80 model 100, NEC - PC-8201a, Olivetti - M-10.  In total, more than 10 million copies of such computers were released!  In the USSR / RF in the early 90s, based on the domestic IM1821BM85A clone, there were attempts to improve some systems, for example, the Vector computer.  Surprisingly, the main processor of the Sojourner rover, which reached the surface of Mars in 1997, was 8085 with a frequency of 2 MHz! <br><br>  In fact, Intel has given the z80 "green".  A few years later, in the battle for the 16-bit market, Intel behaved completely differently, starting a lawsuit banning sales of v20 and v30 processors in the United States.  Interestingly, the mentioned processors of the Japanese company NEC could switch to full binary compatibility with 8080, which made them the fastest processors of the 8080 architecture. <br><br>  Another secret from Intel is to not publish an extended command system, including support for new flags.  However, one of the official manufacturers of these processors has published the entire system of commands.  What are the reasons for such a strange failure?  One can only guess.  Could Zilog then play a role that AMD had once possibly played, and made it seem like competition, while 8085 could bring down Zilog?  Maybe it is a matter of wanting to keep the system of commands closer to the then-designed 8086?  The latter seems doubtful.  Intel 8086 was released more than 2 years after the release of 8085 and it’s hard to believe that in 1975 the system of its commands was already known.  And in any case, compatibility with both 8080 and 8085 by 8086 is achievable only with the use of a macro processor, sometimes replacing one 8080/8085 command with several of its own.  And the two published new instructions 8085 in 8086 are not realizable at all.  It is especially difficult to explain why Intel did not publish information on new teams after the release of 8086. One can only assume that the most likely thing was marketing.  Artificially worsening the 8085 specifications, a more effective 8086 was obtained against this background. <br><br><h2>  Motorola 6800 and close relatives </h2><br>  Motorola processors have always been distinguished by the presence of several very attractive "highlights" with the simultaneous presence of some architectural solutions that are absurd in their abstractness and low practicality.  The main "highlight" of all considered processors is the second full and very fast register battery. <br><br>  The 6800 was the first processor in the world to require only one power supply (5 volts) - this was a very useful innovation.  Ho 6800 because of the uniqueness of the cumbersome 16-bit index register for the 8-bit architecture, turned out to be inconvenient for programming and using the product.  It was released back in 1974, not much later than 8080, but it never became the basis for any known computer system.  Interestingly, the 6502 developers, Chuck Peddle and Bill Mensch, called the 6800 wrong, “too big.”  However, he and his variants were widely used as microcontrollers.  Perhaps here it is worth noting that Intel has been manufacturing processors since 1971, which put Motorola in the position of a catch-up party, for which the 6800 was the very first processor.  And if you compare the 6800 not with the 8080, but with its predecessor 8008, then the 6800 will be much preferable.  Motorola almost caught up with Intel with 68000/20/30/40.  You can also note that in the 70s, Motorola was a significantly larger company than Intel. <br><br>  6809 and 6800 fully support working with signed integers, z80 and 6502 support it worse, while the 8080 and 8085 do not have such support at all.  However, in 8-bit software such support was needed very rarely. <br><br>  6809 was released in 1978, when the 16-bit era began in 8086, and has a highly developed instruction set, including multiplying two byte batteries to produce a 16-bit result in 11 cycles (for comparison, 8086 requires 70 cycles for such an operation) .  Two batteries can in several cases be grouped into one 16-bit one, which gives fast 16-bit instructions.  6809 has two index registers and a record number of addressing methods among 8-bit processors - 12. Among addressing methods there are unique for 8-bit chips, such as an index one with auto increment or decrement relative to the program counter, an index one with offset.  6809 has an interesting possibility to use two types of interrupts: you can use fast interrupts with partial automatic register saving and interrupts with full register saving - the 6809 has three inputs for the FIRQ (fast masked), IRQ (masked), NMI (non-masked) interrupt signals.  Also, quick instructions for reading and setting all flags at once are convenient to use. <br><br>  However, memory operations require more than 6502 clock cycles. The index registers remained clumsy 16-bit dinosaurs in an 8-bit world, some operations simply shock at their slowness, for example, sending one byte battery to another takes 6 clock cycles, and the exchange their contents - 8 cycles (compare with 8080, where the 16-bit exchange takes place in 4 cycles)!  For some reason, two stack pointers are offered at once, perhaps it was the influence of the dead-end architecture of the VAX-11 - in an 8-bit architecture with 64 KB of memory it looks very awkward.  And even the presence of instructions with the interesting name SEX cannot eliminate all 6809 problems.  In general, the 6809 is still somewhat faster than the 6502 at the same frequency, but it requires the same memory speed.  I managed to make the division for 6809 with 32-bit divisible and 16-bit divisor (32/16 = 32.16) for a little more than 520 cycles, for 6502 I could not achieve less than 650 cycles.  The second battery is a great advantage, but the other features of the 6502, in particular, the inverted transfer, reduce this advantage only to the 25% indicated.  But the multiplication by 16-bit constant turned out to be slower than the table for 6502 with a table of 768 bytes.  The 6809 allows you to write fairly compact and fast codes using the addressing of an established page (direct page), but this addressing makes the codes rather confusing.  The essence of this addressing is to set the high byte of the data address in a special register and specify only the low byte of the address in commands.  The same system only with a fixed high byte value is used in 6502, where it is called zero page addressing (zero page).  Addressing the set page is a direct analogue of using the DS segment register in x86 not only for segments of 64 KB in size, but for segments of only 256 bytes in size.  Another fictitiousness of the 6800 architecture is in using byte order from high to low (Big Endian), which slows down 16-bit addition and subtraction operations.  6809 is not fully compatible with the instruction codes from the 6800. 6809 was the last 8-bit processor from Motorola, in further developments, it was decided to use 68008 instead. <br><br>  It can be assumed that Motorola has spent a lot of money to promote the 6809. This is still evident at the mention of this processor.  About 6809 there are a lot of favorable reviews, differing in some nebula, generalizations and vagueness.  The 6809 was positioned as an 8-bit superprocessor for micro-mainframes.  For him, almost Unix was made, OS-9 and UniFlex operating systems.  He was chosen as the main processor for the Apple Macintosh and, as follows from the films about Steve Jobs, only his emotional intervention determined the transition to a more promising 68000. Of course, 6809 is a good processor, but in general only marginally the best of its competitors that appeared much earlier 6502 (three years earlier) and z80 (two).  One wonders what would happen if Motorola spent at least half of the effort spent on developing and promoting 6809 on developing 6502. <br><br>  6809 has been used in several fairly well-known computer systems.  The most famous among them is the American computer Tandy Color or Tandy Coco, as well as their British or, more precisely, Welsh clone Dragon-32/64.  The computer markets of the 80s were distinguished by significant non-transparency and Tandy Coco was distributed mainly only in the USA, and the Dragons besides the UK itself gained some popularity in Spain.  In France, the 6809 for some reason became the basis for the mass computers of the 80s of the Thomson series, which remained virtually unknown elsewhere except in France.  The 6809 was also used as a second processor in at least two systems: in the Commodore SuperPET 9000 series and in the short run and now almost forgotten console for the TUBE interface of BBC Micro computers.  This processor was used in other systems less known to the author, in particular, Japanese ones.  He also received some distribution in the world of gaming consoles.  It is worth mentioning one of these consoles, Vectrex, which uses a unique technology - a vector display. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b5c/df0/b36/b5cdf0b3601902d207bce3c567ff2d7b.jpg"><br>  <i>Color CoCo 3</i> <br><br>  6800 and 6809 have an interesting undocumented instruction with the interesting name “Stop and Fry” (Halt and Catch Fire - HCF), which is used for testing at the electronics level, for example, an oscilloscope.  Its use causes the processor to hang, from which you can exit only by restarting (reset).  These processors have other undocumented instructions.  In the 6800 there are, for example, instructions symmetrical to directly loading the register with a constant, i.e.  instructions for immediate unloading of the register to the address following this instruction! <br><br>  Like the 8080, 8085, or z80 6809, it is very difficult to call pure 8-bit.  A 6309 is even technically difficult to call 8-bit, it was produced by the Japanese company Toshiba (I could not find the exact year of its production, but there is some data indicating 1982) as a processor fully compatible with 6809. However, this processor could be switched new mode, which, while maintaining almost complete compatibility with the 6809, provided almost an order of magnitude greater opportunities.  These features were hidden in the official documentation, but were published in 1988 on the Usenet.  Two more batteries were added, but instructions with them were significantly slower than with the first two.  The execution time of most instructions is greatly reduced.  A number of commands have been added, among which the symbolic division of a 32-bit dividend by a 16-bit divider (32/16 = 16,16) for 34 cycles, which is divisible from memory, is fantastic for processors of this class.  There is also a 16-bit multiplication with a 32-bit result in 28 clock cycles.  Very useful instructions were also added for quickly copying blocks of memory with a runtime of 6 + 3n, where n is the number of bytes to be copied, you can copy with decreasing or increasing addresses.  The same instructions can be used to quickly fill the memory with a given byte.  When they are executed, interruptions may occur.  There were still new bit operations, null-register, etc. Interruptions were added when executing unknown instructions and when dividing by 0. In a sense, 6309 is the pinnacle of technological advances among 8-bit processors or, more precisely, processors with addressable memory size 64 KB. <br><br>  The 6309 is fully terminal-compatible with the 6809, making it a popular upgrade for Tandy or Dragons in color.  There are special OS versions that use the new features of 6309. <br><br><h2>  MOS Technology 6502 and WDC 65816 </h2><br>  This is a processor with a very dramatic fate.  No other processor can compare with it.  Its appearance and introduction was accompanied by very large events in scope and consequences.  I will list some of them: <br><br><ul><li>  the weakening of the giant Motorola, which for some time exceeded the capabilities of Intel; </li><li>  destruction of MOS Technology; </li><li>  cessation of development of 6502 and its stagnation release with little or no modernization </li></ul><br>  It all started when, for unknown reasons, Motorola refused to support the initiative young engineers who offered to improve the rather mediocre 6800 processor in general. They had to leave the company and continue their work in a small but promising company MOS Technology, where they soon prepared two processors 6501 and 6502, made by NMOS technology.  The first one was compatible with the 6800 connector, but otherwise they were identical.  The team 6501/6502 was able to successfully introduce new chip production technology, which radically reduced the price of new processors.  In 1975, MOS Technology could offer 6502 for $ 25, while the starting price for the Intel 8080 and Motorola 6800 was 1974 for $ 360.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In 1975, Motorola and Intel lowered prices, but they were still close to $ 100. MOS Technology specialists claimed that their processor is up to 4 times faster than the 6800. It seems doubtful to me: the 6502 can work much faster with memory, but the second 6800 battery greatly accelerated many calculations. Estimated I can assume that the 6502 was on average faster no more than 2 times. Motorola launched a lawsuit against its former employees - they allegedly used many of the company's technological secrets. During the process, it was possible to establish that one of the engineers who had left Motorola issued some confidential documents on the 6800, acting contrary to the attitudes of his colleagues. Whether it was his own act or there were still some guiding forces behind him is still unknown.For this and other unclear reasons, Motorola forced MOS Technology, whose financial capabilities were very small, to pay a considerable amount of $ 200,000 and to abandon production of 6501. Intel acted quite differently from Zilog. Although it must be admitted that MOS Technology acted sometimes too risky when trying to use the big money spent by Motorola on promoting the 6800 for its own purposes.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Further, the legendary Commodore firm and its no less legendary founder Jack Tramiel appear in the story, in the shadow of which was the figure of the firm’s chief financier, who determines its policy - a man named Irving Gould. Jack got a loan from Irving and with this money, using a few, to say the least, unfair tactics, forced MOS Tecchnology to become part of the Commodore. After that, possibly against the wishes of Tramel, who was forced to give in to Hood, the development of the 6502 almost stopped, despite the fact that as early as 1976 it was possible to produce prototypes of the 6502 with operating frequencies up to 10 MHz, although this message appeared only many years later named Bill Mensch (he was on the team that left Motorola), who often made loud, but by and large empty statements and played a rather ambiguous role in the fate of 6502.The main 6502 developer Chuck Peddle was permanently excluded from the development of processors. 6502 continued to produce not only at Commodore, but also at the firm created by Bill Mensch, the Western Design Center (WDC). It is curious that none of the former team 6502 worked with him in the future.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At this drama around 6502 is not over. In 1980, a short, anonymous article appeared in Rockwell's AIM65 Interactive magazine stating that all 6502 carry a dangerous bug called the JMP (xxFF). The tone of the article suggests something completely out of the ordinary. Subsequently, this attitude moved to the position of Apple on this issue and became a kind of mainstream. Although, strictly speaking, there was no “bug”. Of course, a specialist accustomed to the comfortable processors of large systems of those years, one of the features quite appropriate and even useful among microprocessors, could seem to be something annoying, a bug. But in fact, it was the behavior that hurt someone’s behavior was described in the official documentation from 1976 and in the programming textbooks published before the article appeared. The "bug" was eliminated by Bill Mensch,made 65C02 (CMOS 6502) supposedly by 1983, that is, after the release of 65816. While Intel, Motorola and others have already made 16-bit processors of new generations, 6502 was only microscopically improved and made artificially partially incompatible with itself . In addition to eliminating the "bug," a number of changes were made, which, in particular, led to a change in the course of executing several instructions that became slower in tact, but at the same time they became more correct in some far-fetched academic sense. But, it must be admitted that several new instructions turned out to be expected and useful. On the other hand, the absolute majority of the new instructions only occupied the code space, adding almost nothing to the capabilities of the 6502, which left fewer new codes for possible further upgrades.Commodore and Japanese Ricoh (manufacturer of the most popular game consoles NES) did not accept these changes. The author of this material himself faced several times the problem of this “bug”. Knowing nothing about him, he wrote programs for the Commodores. Then one of them was transferred to systems where the 65C02 command set was used. There was an incompatibility, I had to change codes, do conditional compilation. The code for the 65S02 turned out more cumbersome and slow. Then he raised this question on the forum 6502.org, where the majority of participants from the world of Apple. He asked if anyone could give an example when the aforesaid “bug” crashed the program. Received only emotional and general comments, a specific example was never offered.Knowing nothing about him, he wrote programs for the Commodores. Then one of them was transferred to systems where the 65C02 command set was used. There was an incompatibility, I had to change codes, do conditional compilation. The code for the 65S02 turned out more cumbersome and slow. Then he raised this question on the forum 6502.org, where the majority of participants from the world of Apple. He asked if anyone could give an example when the aforesaid “bug” crashed the program. Received only emotional and general comments, a specific example was never offered.Knowing nothing about him, he wrote programs for the Commodores. Then one of them was transferred to systems where the 65C02 command set was used. There was an incompatibility, I had to change codes, do conditional compilation. The code for the 65S02 turned out more cumbersome and slow. Then he raised this question on the forum 6502.org, where the majority of participants from the world of Apple. He asked if anyone could give an example when the aforesaid “bug” crashed the program. Received only emotional and general comments, a specific example was never offered.where most of the participants are from the Apple world. He asked if anyone could give an example when the aforesaid “bug” crashed the program. Received only emotional and general comments, a specific example was never offered.where most of the participants are from the Apple world. He asked if anyone could give an example when the aforesaid “bug” crashed the program. Received only emotional and general comments, a specific example was never offered.</font></font><br><br><img src="https://habrastorage.org/webt/f-/8q/mv/f-8qmv2x4io6ga8qxomqg0dxqnw.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bug !!! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">65C02 was licensed to many firms, in particular, NCR, GTE, Rockwell, Synertek and Sanyo. Used in the Apple II, starting with the IIe models, although many of the IIe used the NMOS 6502. The 65C02 6512 variant was also used in the later BBC Micro models. Atari used NMOS 6502. In addition to CMOS 6502, Synertek and Rockwell also produced NMOS 6502. By the way, NMOS 6502 has its own set of undocumented instructions, the nature of which is completely different from the “secret” commands of 8085. In 6502, these instructions appeared as a side effect of the technology used, therefore most of them are rather useless, but several, for example, loading or unloading two registers with one command at once, and some others can make the code faster and more compact.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There were other attempts to modernize 6502. In the same 1979, an article appeared that for the Atari computers, the 6509 processor is being prepared for production (not to be confused with the later processor with the same Commodore name), in which command execution acceleration by 25% and many new ones were expected instructions. But for unknown reasons, exactly the production of this processor did not take place. Commodore did only microscopic upgrades. There, in particular, they switched to the HMOS technology and the manufacture of static cores, which made it possible to slow down the processors. From the point of view of programming, the most interesting is the processor 6509, which, albeit in a very primitive form, with the help of only two instructions specially allocated for this purpose allows us to address up to 1 MB of memory. In the super-popular Commodores 64 and 128, there were 6510/8510 processors,and in the less fortunate 264 series - 7501/8501. These processors had only 6 and 7 embedded bit I / O ports, respectively, while 7501/8501 did not support non-masked interrupts. Rockwell produced version 65C02 with its extended 32 bit operations (similar to the z80 bit instructions) instruction set, however, as far as I know, such processors were not used in computers and these bit instructions themselves were most likely only for use in embedded systems. This extension, by the way, was produced by Bill Mensch.Rockwell produced version 65C02 with its extended 32 bit operations (similar to the z80 bit instructions) instruction set, however, as far as I know, such processors were not used in computers and these bit instructions themselves were most likely only for use in embedded systems. This extension, by the way, was produced by Bill Mensch.Rockwell produced version 65C02 with its extended 32 bit operations (similar to the z80 bit instructions) instruction set, however, as far as I know, such processors were not used in computers and these bit instructions themselves were most likely only for use in embedded systems. This extension, by the way, was produced by Bill Mensch.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last scene of the drama with the participation of 6502 was designated in the prevention of computers based on 6502 with a frequency of 2 MHz on the US market in the first half of the 80s. This affected the BBC Micro Englishman, their manufacturing company Acorn made a large batch of computers for the United States, but as it turned out, in vain. Some kind of blocking worked and the computers had to be urgently redone to European standards. Semi-American, but formally Canadian computers Commodore CBM II (1982), despite some problems (in particular, on compliance with the standards for electrical equipment), were still admitted. Perhaps due to the fact that they did not have graphic modes and even colored text - even the stylish Porsche design could not compensate for this. The latest in the list of losers was 100% American Apple III (1980) - it is known that Steve Jobs,like Apple's management as a whole, they did a lot to prevent this computer from taking place. Jobs demanded obviously impracticable specifications, and management - unrealistic deadlines. Do we ever know their motives? The Apple III Plus, released in 1983, managed to eliminate the flaws of the Apple III, but Apple’s management quietly shut down the project in 1984 because of a reluctance to have competition with the Macintosh computer. Only in 1985, when the era of the 8-bit technology began to go away, did the Commodore 128 appear, which could be used in one of its 6502 modes with a 2 MHz clock cycle. But even here it turned out to be more of a joke, since this mode was practically not supported and there were practically no programs for it. Only in the second half of the 80s in the United States began to produce consoles-accelerators for the Apple II, and since 1988 the Apple IIc + model with a 4 MHz processor. Why did it happen so? Perhaps becausethat 6502 at 2 or 3 MHz (and these were already produced at the very beginning of the 80s) could successfully compete with games based on Intel 8088 or Motorola 68000 on a number of tasks and in particular games. In 1991, with a strong will, Commodore closed the interesting, though and the late project C65 based on the 4510 processor with a frequency of 3.54 MHz. The 4510 is the fastest 6502, made only in 1988, it finally carried out the previously mentioned optimization of cycles, which gave a 25% increase in speed. Thus, the processor in C65 is close in speed to systems from 6502 to 4.5 MHz. Surprisingly, this fastest 6502 with an extended set of instructions (in some detail this extension turned out to be more successful than in 65816) has never been used anywhere else.In 1991, the willful decision of the corporation Commodore closed an interesting, albeit belated project C65 based on the 4510 processor with a frequency of 3.54 MHz. The 4510 is the fastest 6502, made only in 1988, it finally carried out the previously mentioned optimization of cycles, which gave a 25% increase in speed. Thus, the processor in C65 is close in speed to systems from 6502 to 4.5 MHz. Surprisingly, this fastest 6502 with an extended set of instructions (in some detail this extension turned out to be more successful than in 65816) has never been used anywhere else.In 1991, the willful decision of the corporation Commodore closed an interesting, albeit belated project C65 based on the 4510 processor with a frequency of 3.54 MHz. The 4510 is the fastest 6502, made only in 1988, it finally carried out the previously mentioned optimization of cycles, which gave a 25% increase in speed. Thus, the processor in C65 is close in speed to systems from 6502 to 4.5 MHz. Surprisingly, this fastest 6502 with an extended set of instructions (in some detail this extension turned out to be more successful than in 65816) has never been used anywhere else.The processor in C65 is close in speed to systems from 6502 to 4.5 MHz. Surprisingly, this fastest 6502 with an extended set of instructions (in some detail this extension turned out to be more successful than in 65816) has never been used anywhere else.The processor in C65 is close in speed to systems from 6502 to 4.5 MHz. Surprisingly, this fastest 6502 with an extended set of instructions (in some detail this extension turned out to be more successful than in 65816) has never been used anywhere else.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C128 and Apple III Plus had a memory management unit (MMU), which allowed using several stacks and zero pages, addressing more than 64 KB of memory, etc. In C128, the MMU was artificially trimmed to work with only 128 KB of memory. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/01e/54a/42c/01e54a42c0159727aa4ca500f629cbe9.jpg"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anti-advertising - multiple Porsche PET in the villain of Pearl of the Nile villain (1985) - the era of "only Apple" in Hollywood has not yet come</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now a few words about the command system 6502. The main feature of this processor is that it was made almost as fast as possible, almost without unnecessary cycles, which are especially numerous in the 8080/8085 / z80 / 8088/68000 processors. In fact, this was the ideology that emerged later and under the direct influence of 6502 processors of the RISC architecture. The same ideology dominates, starting from 80486, and among Intel processors. In addition, the 6502 responded to interrupts as quickly as possible, which made it very useful in some embedded systems. In 6502 one battery and two index registers, in addition, the first 256 bytes of memory can be used in special commands either as faster memory or as a set of 16-bit registers (which are almost identical in their functionality to the BC and DE registers in 8080 / z80) for pretty powerful ways to address.Some arithmetic commands (shifts, rotation, increment and decrement) can be used with memory directly, without using registers. There are no 16-bit instructions - this is a 100% 8-bit processor. All major flags are supported except the characteristic Intel parity flag architecture. There are some more unusual flag of the low-useful 10th mode. Intel and Motorola processors use special corrective instructions for working with decimal numbers, and 6502 can switch to the 10th mode, which makes its speed advantage with 10 numbers even more significant than with binary ones. The presence for 6502 tabular multiplication of 8-bit operands with getting a 16-bit result in less than 30 clock cycles, with an auxiliary table size of 2048 bytes, is very impressive.The slowest in 6502 are bulk copy memory operations — from 14 clocks per byte.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6502 can work in parallel with another device, for example, another 6502. As far as I know, such dual-processor systems have never been produced. Instead of the second processor, a video controller was usually used, which shared memory with 6502.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">65816 was released by WDS in 1983. Interestingly, the specification of the new processor Bill Mensch received from Apple. Of course, it was a big step forward, but obviously belated and with large architectural flaws. 65816 was no longer considered by anyone as a competitor for the main processors of Intel or Motorola - this was already a minor outsider who was already somehow programmed to further lose positions. 65816 had two important advantages - it was relatively cheap and almost compatible with the still very popular 6502. In the following years, Bill Mensch didn’t even try to somehow improve his brainchild, optimize the cycles, replace the zero page addressing using the Z register ( this was done in 4510), add at least multiplication, ... WDC only increased the limiting clock frequencies,reaching the mid-90s to 14 MHz (such a processor was used in the popular accelerator for the C64 SuperCPU at a frequency of 20 MHz). However, even now (2018!) WDC offers 65816 for some reason only at the same 14 MHz. 65816 can use up to 16 MB of memory, but the addressing methods used for this look far from optimal. For example, index registers can only be 8- or 16-bit, the stack can be placed only in the first 64 KB of memory, only there you can use the convenient short addressing of the set page (direct page - generalization zero page), working with memory above 64 KB comparatively awkward, ... 65816 has a 16-bit ALU, but an 8-bit data bus, so it is only about 50% faster than 6502 in arithmetic operations. Nevertheless, 65816 was released in more than a billion. Of course,A number of 65816 commands clearly complement the gaps in the 6502 architecture, for example, bulk memory copy commands for 7 clock cycles per byte.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apple IIx, in the development of which Steve Wozniak was actively involved, was supposed to use 65816, but it was possible to start production of this processor only in 1984 and the first batches of 65816 were defective, which caused excessive delays and eventually the closure of the entire project. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is another version 65816 65802, which uses a 16-bit address bus and is compatible with the 6502 connector. Upgrades were offered for the Apple II based on this processor, but a slight acceleration with such an upgrade can be obtained only on specially written programs.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6502 was used in a large number of computer systems, the most popular of which are 8-bit Commodore, Atari, Apple, NES. Interestingly, 6502 was used as a keyboard controller in the Commodore Amiga computer, and two 6502 at 10 MHz were used in the high-performance Apple Macintosh IIfx. Not to mention the Atari gaming consoles, produced from 1977 to 1996, about 35 million of them were sold! 65816 was used in the rather popular Apple IIgs computer, in the Super NES gaming console, and also in the rare English Acorn Communicator computer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In 1984 an </font><a href="https://habr.com/post/371693/"><font style="vertical-align: inherit;">article</font></a><font style="vertical-align: inherit;"> appeared in the magazine Byte against the background of pictures with red banners, Lenin and marching soldiers </font></font><a href="https://habr.com/post/371693/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">about a bad copy of an Apple computer] [made in the USSR. This article cited a curious price for this computer - $ 17,000 (this is an absurd number, the real price was about 4,000 rubles) and ironically indicated that Soviet manufacturers would have to dramatically lower the price if they want to sell their product in the West. Agate was used mainly in school education. Older Agate models were nearly 100% compatible with Apple] [and had some pretty useful extensions.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One can only try to fantasize about what would have happened if 6502 could develop at the same pace as its competitors. It seems to me that the gradual transfer of zero page memory to registers and the gradual expansion of the instruction set with simultaneous optimization of cycles would allow the "terminator" 6502 to remain at the top in terms of speed until the early 90s. Introducing mode 16 and then 32 bits would allow using larger amounts of memory and faster commands. Would his competitors be able to oppose this?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I would like to finish with some general philosophical arguments. </font><font style="vertical-align: inherit;">Why was the 6502 slowed down and lacking a much brighter future? </font><font style="vertical-align: inherit;">Perhaps due to the fact that he really could very much press large firms and create a completely new reality. </font><font style="vertical-align: inherit;">But was the 6502 team tuned in to this? </font><font style="vertical-align: inherit;">Rather, no, they just wanted to make a better processor.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zilog Z80 </font></font></h2><br>  This processor has become, along with 6502, the main processor of the first personal computers.  In the history of its appearance and use there are no dramatic events.  There is only some intrigue in the failure of Zilog to make the next generation of processors.  Z80 began to be produced in 1976 and its variants are still produced.  Once even Bill Gates himself announced support for z80-based systems. <br><br>  A number of coincidences are interesting.  As in the case of the 6502, the main developer of the Z80, Federico Faggin (Federico Faggin), left a large company, from Intel.  After working on the z80, Federico almost didn’t work with the next-generation Z8000 processor and left the company he founded in the early 80s so that he wouldn’t be engaged in processors in the future.  He then created several relatively successful startups, creating communications systems, touchpads and digital cameras.  It can be mentioned that, in addition to the z80, in the Zilog they had also developed a successful and still-produced Z8 microcontroller. <br><br>  The Z80 is a more convenient processor for inclusion in computer systems than the 8080. It requires only one supply voltage and has built-in support for dynamic memory regeneration.  In addition, with full compatibility with the 8080, it has quite a few new commands, a second set of core registers, and several completely new registers.  It is curious that Zilog abandoned the use of assembler 8080 mnemonics, and began to use its own mnemonics, more suitable for the advanced z80 command system.  A similar story happened with the Intel x86 assembler in the GNU software world, for some reason, they also use their own conventions for writing programs in assembler by default.  Z80 added support for the overflow flag, Intel added support for such a flag only in 8086. However, this flag in z80 was combined with the parity flag, so at the same time, as in 8086, both flags cannot be used.  In z80, as in 6502, there is only a basic check of the value of one flag, i.e.  there are no checks of two or three flags at once, which is necessary for comparisons of "strictly more", "less or equal", as well as all sign ones - in such cases you have to do several checks, one is enough for 8086, 6800 or PDP-11. <br><br>  Among the new commands, the z80 is especially impressive with the massive memory copy commands for 21 clock cycles per byte, as well as the interesting byte search command in memory.  However, the most interesting is the EXX command, which swaps the contents of 48 bytes of the register memory, the BC, DE, HL registers with their counterparts, which runs in just 4 clock cycles!  Even a 32-bit ARM will need at least 6 clock cycles for the same operation.  The remaining additional instructions are not as impressive, although they can sometimes be helpful.  Added more: <br><br><ul><li>  16-bit subtraction with a loan and 16-bit addition with transfer in 15 cycles; </li><li>  unary minus for the battery in 8 cycles; </li><li>  the ability to read from memory and write to it using the registers BC, DE, SP, IX, IY, and not just HL; </li><li>  shifts, rotations and input-output for all 8-bit registers; </li><li>  the operation of checking, setting and resetting a bit by its number; </li><li>  shift transitions (JR); </li><li>  loop command. </li></ul><br><br>  Most of the new commands are rather slow, but their proper use can still make the code somewhat faster and much more compact.  This particularly applies to the use of new 16-bit registers IX and IY, which can be used for new addressing methods. <br><br>  Many of the 8080 teams in the z80 have become faster and this is a very noticeable acceleration.  But the ADD team, which is the main one for 16-bit arithmetic, became slower, which makes arithmetic as a whole, if it is faster, then only slightly. <br><br>  The interrupt system has become much more interesting than the 8080. With the z80, you can use both unmasked interrupts and three methods (one of them compatible with the 8080) for working with masked ones.  The most interesting mode is masked interrupts 2, which allows the flexibility to change the address of the code to handle the interrupt. <br><br>  The Z80 has a number of undocumented instructions, some of which have been documented by some firms and have actually become part of the standard instructions.  Particularly useful instructions allow you to work with individual bytes of awkward 16-bit registers IX and IY. <br><br>  Of course, z80 is even more so than 8080 has the right to be called a slightly 16-bit.  The hypothetical index of the bitiness of the z80 is clearly slightly higher, but it is paradoxical that the ALU of the z80 is actually 4-bit!  At the electronic level, the z80 and 8080 are completely different chips. <br><br>  Much has been written about the comparison of the speed of the z80 and 6502, since these processors are very widely used in the first mass computers.  In this topic there are several difficult moments, without an understanding of which it is very difficult to maintain objectivity.  Due to the presence of a fairly large number of registers z80 is natural to use at a frequency greater than the memory works.  Therefore, the z80 at 4 MHz can use the same memory as the 6502 or 6809 at 1.3 MHz.  According to many experienced programmers who wrote codes for both processors, on the same frequency 6502, on average, about 2.4 to 2.6 times faster than the z80.  The author of this material agrees.  You only need to add that writing good, fast codes for z80 is very difficult, you need to constantly optimize the use of registers, and to use the stack as much as possible to work with memory.  If you try hard, in my opinion, you can reduce the difference between the z80 and 6502 to about 2.2 times.  And if you do not try and ignore the timings, you can easily get the difference up to 4 times.  In some individual cases, the z80 may show very fast performance.  On the task of filling the memory of z80, using the PUSH command, it may even be slightly faster than 6502, but this is at the cost of disabling interrupts.  Copying z80 memory blocks is only 1.5 times slower.  It is especially impressive that in dividing a 32-bit dividend by a 16-divider, the z80 is only 1.7 times slower.  By the way, this super-division was implemented by a Russian programmer.  Thus, we find that the ZX Spectrum with z80 at 3.5 MHz is about one and a half times faster than the C64 from 6502 to 1 MHz.  It is also worth noting that some of the clocks in most systems with z80 or 6502 are taken away from the processor by the video signal generation support circuits, for example, because of this, the popular processor Amstrad CPC / PCW has a real processor frequency of 3.2 MHz, and not full 4. On 6502 systems You can usually turn off the screen for maximum processor performance.  If we take the frequency of memory, and not the processor, then it turns out that z80 is 25-40% faster than 6502. The last result can be illustrated by the fact that with a memory of 2 MHz, z80 can operate at a frequency of up to 6 MHz, and 6502 only up to 2 MHz. <br><br>  Z80 was used in a very large number of computer systems.  In the United States were very popular Tandy TRS-80, in Europe - ZX Spectrum, and later Amstrad CPC and PCW.  It is curious that Amstrad PCW computers remained relevant until the mid-90s and they were massively and actively used as intended until the end of the 90s.  In Japan and other countries, quite successful MSX computers were produced worldwide.  Quite a popular C128 could also use the z80, but here the users were more likely embarrassed - this late, 1985 release, 8-bit z80 computer, officially clocked 2 MHz, really works only at 1.6 MHz.  This is even slower than the first systems in the 8080 mid 70s.  The range of computers for using the CP / M operating system has at least three dozen fairly well-known systems. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d4d/03b/e2e/d4d03be2e5385ac66d8a31cc94d81939.jpg"><br>  <i>Such a PC looked decent even in the mid-90s, but its z80 is slower than that in the ZX Spectrum</i> <br><br>  The fastest z80-based computer system known to the author is the BBC Micro with a TUBE prefix with a z80B at 6 MHz, produced since 1984. The processor in this system runs at full speed, as they say, “without brakes”.  Similar consoles were made for Apple] [since 1979. Later, some of these consoles used Z80H at 8 MHz and even higher.  Interestingly, Microsoft in 1980 received the greatest profit from the sale of such consoles.  You can also mention the Amstrad PCW16, produced since 1994, which used the CMOS Z80 at a frequency of 16 MHz. <br><br>  In Japan, the MSX TurboR (1990) produced an R800 processor compatible with the z80.  A 16-bit multiplication with a 32-bit result was added to the R800.  Although multiplying by a 16-bit constant, table multiplication with a table of 768 bytes is obtained per clock faster.  It is believed that the R800 is a heavily simplified Z800 operating at four times the frequency of the bus, which is about 7.16 MHz.  Thus, the internal frequency of the R800 is approximately 28.64 MHz! <br><br>  The Zilog company itself did work on improving the Z80 very inconsistently and extremely slowly.  The first Z80 worked at frequencies up to 2.5 MHz, the Z80A limit frequency that appeared soon, was increased to 4 MHz - these processors became the basis for most popular computers using the Z80.  The Z80B appeared by 1980, but was used relatively rarely, for example, in the mentioned BBC Micro console or in the late (1989) Sam Coupé computer.  Z80H appeared by the mid-80s and could operate at frequencies up to 8 MHz - it was not used in known computers.  Interestingly, Zilog products had special traps on the chip for those who tried to make copies of them, for example, the base Z80 had 9 traps and they, according to reviews of those who did it, slowed down the copying process for almost a year. <br><br>  A deeper upgrade of the z80 was hampered by the desire of Zilog to create processors that are competitive with 16-bit Intel processors.  In 1978, a little later, the 8086 Z8000 was released, not compatible with the z80.  This processor was unable to withstand competitors from Intel and, especially, Motorola - 68000 surpassed the Z8000 in almost all parameters, although the Z8000 was used in about a dozen different low-cost systems, as a rule, for working with Unix variants.  Interestingly, IBM did not even consider the Z8000 as a possible processor for the IBM PC, since Zilog was funded by Exxon, which was going to compete with IBM.  Perhaps due to the failure of the Z8000, the Zilog became an Exxon division by 1980.  There was also an attempt to create a competitive 32-bit processor.  In 1986, the Z80000 appeared, compatible with the Z8000, which has <b>never</b> been used <b>anywhere</b> . <br><br>  Creating a new processor based on the Z80 was postponed until 1985, when the Z800 was made.  However, then the main efforts of Zilog were directed at the Z80000 and the Z800 was released very little.  In 1986, after the failure of the z80000, the Z280 was released, a slightly improved version of the Z800, which, in particular, could work on the internal frequency several times higher than the bus frequency - this new product brought major success to the Intel 486DX2 and 486DX4 processors.  Z280 had other promising features, which were then successfully applied by other firms.  But, perhaps because of poor performance - the Z280, despite many technological innovations, could use only relatively low clock speeds, this processor also has not found any use <b>anywhere</b> .  It is believed that the Z280 roughly matched the capabilities of the Intel 80286, but was significantly, at least 50% slower when using the same clock speed as used with 80286.  Perhaps, if the Z280 appeared 5 years earlier, it could be very successful. <br><br>  The greatest success was achieved thanks to cooperation with the Japanese company Hitachi, which in 1985 released its super-Z80, HD64180, similar in capabilities to the Intel 80186, which allowed using 512 KB of memory, added a dozen new instructions, but at the same time some almost standard undocumented Z80 instructions not supported.  HD64180 has been used in some computer systems.  Zilog received a license for HD64180 and began to produce them with the marking Z64180.  Zilog managed to slightly improve this processor, in particular, to add support for working with 1 MB of memory and release it by the end of 1986.  This new processor was named Z180 and became the basis for a family of processors and controllers, with clock frequencies up to 33 MHz.  It was used in some rare MSX2 computers, but more as a controller.  It is curious that the Z280 and Z180 appeared in one year, as well as their exemplary counterparts 80286 and 80186 four years before that.  In 1994, a 32-bit Z380 was made on the basis of the Z180, which retained compatibility with the z80 and roughly corresponds to the capabilities of Intel 80386 or Motorola 68020 - Zilog showed a lag behind competitors in almost 10 years.  Already in the 21st century, again on the basis of the Z180, the highly successful eZ80 processor-controllers are manufactured with timings almost like in 6502. They are used in various equipment, in particular, in network cards, DVD-drives, calculators, ... <br><br><h2>  Texas Instruments TMS9900 </h2><br>  For this very special processor codes I did not write.  And this is the first 16-bit processor available for use in personal computers.  It has been produced since 1976.  Uses a much less frequent order of bytes from high to low (Big Endian).  This order is used only in Motorola processors of the 6800 and 68000 series and in the architecture of the giant IBM / 370.  All other processors of this review use the reverse order of bytes (Little Endian). <br><br>  The TMS9900 has only three 16-bit registers: a command counter, a state register, and a pseudo-register base register.  This processor uses 32 bytes of allocated memory as 16 two-byte registers.  This memory usage is a bit like the zero page of memory in the 6502 architecture. Using the base register, the TMS9900 can very quickly change the context.  This is reminiscent of the Z80, which has two register contexts.  The system of flags is distinguished by its peculiarity, along with the typical flags of transfer, zero (equality), overflow, parity, there are two more unique flags of the signs logical and arithmetic less.  Working with the stack and routines is reminiscent of the RISC processors of the future.  There is simply no finished stack, it can be done using one of the pseudo-registers.  When the subprogram is called, a new value is selected for the counter and the base, and all three registers are stored in the pseudo-registers of the new context.  Thus, a subroutine call is more like a program interrupt.  The TMS9900 has a built-in interrupt controller, designed to work with hardware interrupts of up to 16. <br><br><img src="https://habrastorage.org/webt/bs/ir/lv/bsirlvxf7fobwzwpdcvxkcnousc.jpeg"><br>  <i>The first 16-bit home computer - it even has color sprites</i> <br><br>  The command system looks very impressive.  There is even multiplication and division.  The unique X instruction allows you to execute one instruction at any address in memory and move on to the next.  The execution of commands is rather slow, the fastest instructions are executed only in 8 cycles, the arithmetic commands are in 14, but the multiplication (16 * 16 = 32) in 52 cycles and especially division (32/16 = 16.16) in 124 cycles were probably a record fastest among the 70s processors. <br><br>  The TMS9900 requires three supply voltages of -5, 5, and 12 volts, and the four phases of the clock signal — these are anti-records among the processors I know of.  In 1979, this processor was demonstrated to IBM specialists, who were then looking for a processor for an IBM PC prototype in development.  The obvious drawbacks of the TMS9900 (addressability only 64 KB of memory, lack of controller architecture required, relative slowness) made a corresponding impression and the future leader among PCs was Intel 8088. To eliminate the problem of lack of controllers, Texas Instruments also produced the TMS9900 version with an 8-bit bus, TMS -9980, which worked 33% slower. <br><br>  The TMS9900 was used in the fairly popular US computers TI99 / 4 and TI99 / 4A, which were “defeated” in the price war by the Commodore VIC-20 computer by 1983. It is curious that as a result of this war, Texas Instruments was forced to reduce the price of its computer to unbelievable for 1983 $ 49 (in 1979 the price was $ 1150!) and sell them with a big loss for yourself.  For example, a relatively unpopular Commodore + 4 computer, which was ceased to be produced in 1986, but the prices for which fell to those $ 49 only in 1989.  T99 / 4A stopped producing in 1984, when, due to ultra-low prices, it began to gain popularity.  This computer can only conditionally be called 16-bit.  Because it has only 256 bytes (!) Of the RAM memory and all the ROM memory addressed via a 16-bit bus.  The remaining memory and I / O devices work through a slow 8-bit bus.  Therefore, it is possible to more correctly consider the domestic BK-0010 as the first home 16-bit computer.  Curiously, TI99 / 4 and TI99 / 4A use a processor at 3 MHz - exactly the same as the BK-0010. <br><br>  The TI-99/4 and TI99 / 4A used a rather successful TMS9918 chip as a video controller, which became the basis for the very popular MSX standard, as well as some other computers and gaming consoles.  In the Japanese company Yamaha, this video chip was significantly improved and was subsequently used, in particular, to upgrade the TI-99/4 and TI99 / 4A themselves! <br><br>  The TI99 / 4 series is a rare example of computers where the manufacturer of the processor and the computer were the same. <br><br><h2>  DEC PDP-11 processors </h2><br>  From the beginning of the 70s, the 10-year era of DEC domination in the world began.  DEC computers were significantly cheaper than those manufactured by IBM and therefore attracted the attention of small organizations for which IBM systems were not available.  The era of mass professional programming also begins with these computers.  A series of computers PDP-11 has been very successful.  Various PDP-11 models were manufactured from the early 70s to the early 90s.  In the USSR, they were successfully cloned and became the first mass popular computer systems.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Among the clones are computers with the names of SM computers, Electronics-60/81/85, DVK-1/2/3, BK-0010/0011 (BK0010 is the first PC that it became possible to buy in the store). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, DEC also promoted the more expensive and complex computers of the VAX-11 family, the situation around which was somewhat politicized. And since the second half of the 70s, the DEC practically halted development in the PDP-11 line, in particular, support for 16 numbers for the assembler has not been introduced. The speed of the PDP-11 systems has also remained almost unchanged since the mid-70s.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PDP-11 used different, compatible on the main command system processors, for example, LSI-11, F-11, J-11. In the late 70s, DEC made a cheap processor for T-11 microcomputers. However, for unclear reasons, despite the seemingly large and high-quality software that could be transferred to the system using it in the future, it was not noticed by the manufacturers of computer systems. The only exception was one model of Atari game console. T-11 has found a massive use only in the world of embedded equipment, although in its capabilities it was rather slightly superior to the z80. In the USSR, K1801VM1, K1801BM2, K1801BM3, ... processors were manufactured close to the DEC processors, as well as exact copies of the DEC processors. The latter were much more expensive and were produced in small quantities.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The PDP-11 processor command system is distinguished by almost complete orthogonality, pleasant quality, but when taken to the extreme, it can create ridiculous commands. The PDP-11 processor instruction set has influenced many architectures, and especially the Motorola 68000.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The system of commands PDP-11 is strictly 16-bit. All 8 general-purpose registers (and the command counter in this architecture is the usual R7 register) are 16-bit, the state register (contains typical flags) is 16-bit too, the size of commands is from 1 to 3 16-bit words. Each operand in a command can be (although there are exceptions, for example, an XOR instruction) of any type - this is orthogonality. Among the types are ordinary register or memory. Programmers in the 80s sometimes did not understand why there are no memory-memory commands in the Intel x86 command system. This is the influence of the PDP-11 school, where you can easily write complete addresses for each operand. This, of course, is slow and especially slow for systems with slow memory typical from the beginning of the 90s. Memory can also be accessed through a register, a register with an offset, a register with auto-decrements or increments.A feature of the PDP-11 command system is the possibility of double indirect memory access through a register, for example,</font></font><br><br><pre><code class="plaintext hljs">MOV @(R0)+,@-(R1)</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
means the same as the C / C ++ operator </font></font><br>
<br>
<pre><code class="plaintext hljs">**–r1 = **r1++;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
where r0 and r1 are declared as </font></font><br>
<br>
<pre><code class="plaintext hljs">signed short **r0, **r1;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another example is the command. </font></font><br>
<br>
<pre><code class="plaintext hljs">MOVB @11(R2),@-20(R3)</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
corresponds to </font></font><br>
<br>
<pre><code class="plaintext hljs">**(r3-20) = **(r2+11);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
where r2 and r3 are declared as </font></font><br>
<br>
<pre><code class="plaintext hljs">char **r2, **r3;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the currently popular architectures, one team in such cases is not enough, perhaps you will need at least 10 commands. </font><font style="vertical-align: inherit;">You can also get the address relative to the current value of the command counter. </font><font style="vertical-align: inherit;">Let me give you another example with more simple addressing. </font><font style="vertical-align: inherit;">Team</font></font><br>
<br>
<pre><code class="plaintext hljs">ADD #16,11(R4)</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
in Intel x86 architecture can be mapped </font></font><br>
<br>
<pre><code class="plaintext hljs">ADD [BX+11],16</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In DEC assemblers, it is customary to write operands from left to right, unlike Intel, where they write from right to left. </font><font style="vertical-align: inherit;">There is reason to believe that GNU assembler for x86 was made under the influence of the PDP-11 assembler. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The multiplication and division commands are only signed and not available on all processors. </font><font style="vertical-align: inherit;">Arithmetic of decimal numbers is also optional - this is the so-called commercial arithmetic in DEC terminology. </font><font style="vertical-align: inherit;">As a curiosity of complete orthogonality, I will give an example of the command</font></font><br>
<br>
<pre><code class="plaintext hljs">MOV #11,#22</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
which after execution turns into </font></font><br>
<br>
<pre><code class="plaintext hljs">MOV #11,#11</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
- This is an example of using a direct constant as an operand. Another funny command is a unique MARK command, the code of which must be put on the stack and can never be used explicitly. The subprogram call in the PDP-11 architecture is also somewhat peculiar. The corresponding command first stores the allocated register (can be any) on the stack, then saves the command counter in this register and only then writes a new value to the command counter. The return command from the subroutine must do the opposite and know which register was used when calling the subroutine. Very strange and unpredictable effects can be obtained using the command counter as a normal register.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is curious that among the programmers on the PDP-11 there was a culture of working directly with machine codes. Programmers could, for example, work without a disassembler when debugging. Or even write small programs directly into memory, without assembling!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of course, command timings do not differ too high speed characteristics. It was surprising to find out once that on the domestic computer of the ACU, the transfer command from register to register takes as many as 12 clocks (10 clocks using the code from ROM), and commands with two operands with double indirect addressing are executed in more than 100 clocks. The Z80 makes a 16-bit register transfer for 8. However, the slowness of the BC was caused not so much by the processor as by the poor quality of the national memory, for the features of which the BC had to be adapted. If sufficiently fast memory were used, then the BC sent 16 register bits per 8 clock cycles too. Once there was a lot of controversy, which is faster than BC or Spectrum? Immediately I must saythat the Spectrum is when using the top 32 KB of memory one of the fastest mass 8-bit personal computers. Therefore, it is not surprising that the Spectrum is faster than the BC, but not by much. And if the BC worked with memory without brakes, then it would probably be a little faster.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Code density is also a rather weak spot of the PDP-11 architecture. The instruction codes must be multiples of the length of the machine word - 2 bytes, which is especially unpleasant when working with byte arguments or simple commands like setting or resetting the flag.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Attempts to make a personal computer based on the PDP-11 architecture are interesting. One of the first PCs in the world, appearing only slightly later than Apple] [and Commodore PET and, most likely, Tandy TRS-80, was the Terak 8510 / a, which had black and white graphics and the ability to download an incomplete version of Unix. This PC was quite expensive and, as far as I know, was used only in the US higher education system. Since 1978, the computer has been produced as a Heathkit H11 assembly kit. DEC itself also tried to make its PC, but very inconsistently. DEC, for example, released a PC based on the z80 and 8088, obviously playing rather against its main developments. Personal computers based on the PDP-11 DEC PRO-325/350/380 architecture had some rather artificial incompatibilities with the basic architecture, which made it difficult to use part of the software.Best of all, the personalization of the technology of mini-computers turned out in the USSR, where the BC, DCK, UK NC, were produced ... By the way, Electronics-85 is a fairly accurate clone DEC PRO-350. In addition, the CP1600 processor, akin to the PDP-11 architecture, was used in the Intellivision gaming consoles popular in the early 80s.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/c13/44b/6a6/c1344b6a6c38822a6a3a27f9ec544d2c.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Domestic 16-bit home computer (1985) - almost PDP-11 compatible</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
K1802VM2, which was used in DVK, approximately twice as fast as K1801BM1, K1801BM3 even faster and close in speed to Intel 8086. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In older PDP-11 models and those close to them computers processor can address up to 4 MB of memory, but one program can be allocated no more than 64 KB. </font><font style="vertical-align: inherit;">In terms of speed, these processors are also close to 8086 in terms of the number of operations per megahertz, although it is still slower.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Processor for DEC VAX-11</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
VAX-11 systems were quite popular in the 80s, especially in higher education. Now it is difficult to understand some of the concepts described in the books of those years, without knowing the features of the architecture of these systems. VAX-11s were more expensive than PDP-11s, but more oriented towards universal programming and still significantly cheaper than IBM / 370 systems. For the VAX architecture, the V-11 processor was made by the mid-80s, and processor assemblies were used until that time.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The VAX-11 architecture is 32-bit, it uses 16 registers, among which, like the PDP-11, there is a command counter. It assumes the use of two stacks, one of which is used to store the frame-frames of the subroutines. In addition, one of the registers is assigned to work with the arguments of called functions. Thus, 3 of 16 registers are allocated for stacks. The command system of the VAX-11 cannot fail to amaze with its vastness and the presence of very rare and often unique commands, for example, to work with bit fields or several types of queues, to calculate CRC, multiply 10 lines, ... Many commands are as in triaddress variants (as ARM), and in two-address (as x86), but there are also four-address commands, for example, the extended division of EDIV. Of course there is support for working with real numbers.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But the VAX-11 is a very slow system for its class and price. Even the super-simple 6502 at 4 MHz could outrun the slowest VAX-11/30 family, and the fastest VAX-11 systems, huge cabinets and “whole furniture sets,” are at the same level as the first PC ATs. When the 80286 appeared, it became clear that the days of the VAX-11 were numbered and even inhibition with the introduction of systems based on 80286 could not change anything fundamentally. More straightforward Englishmen from Acorn, having made ARM in 1985, without hiding anything, said that ARM is much cheaper and much faster. VAX-11, however, remained relevant until the early 90s, while still having some advantages over the PC, in particular, faster systems for working with disks.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
VAX-11 - this is probably the last mass system, in which the convenience of working in assembly language was considered more important than speed. In a sense, this approach has moved to modern popular scripting languages. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/79d/546/0ff/79d5460ff1580a432d7830e564a91a2f.jpg" align="left"> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The photo shows the VAX-11/785 - this is also a computer (1984) - the fastest among the VAX-11, with processor speeds comparable to IBM PC AT or ARM Evaluation System</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Surprisingly, there is very little literature available on VAX-11 systems in open access. As if there is some strange law of oblivion. Several episodes close to politics and correlated with the history of the USSR are associated with the history of this architecture. It is quite possible that the actual rejection of the development of the PDP-11 architecture was caused by its cheapness and the success of its cloning in the Soviet Union. And the VAX-11 cloning cost an order of magnitude more resources and led to a dead end. Interest in VAX-11 was created using, for example, using drawings such as the famous Kremlin Vaks on April 1, 1984, in which the then USSR leader Konstantin Chernenko offered to drink vodka on the occasion of connecting to the Usenet network. Another joke was that some VAX-11 chips were impressed with a message in broken Russian about how good the VAX-11 was. :)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Some models of the VAX-11 were cloned in the USSR by the end of the 80s, but very few such clones were produced and they found little use for themselves. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Multiple VAX-11 systems are available for use over the network. </font><font style="vertical-align: inherit;">And this distinguishes them favorably from the IBM / 370 systems with which they competed.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intel: 8086 to 80486</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Undoubtedly, one of the best processors made in the 70s is 8086, as well as its cheaper almost analog 8088. The architecture of these processors is pleasantly distinguished by the absence of mechanical borrowing and following abstract theories, reasonableness and balanced architecture, balance and focus on further development. </font><font style="vertical-align: inherit;">Among the shortcomings of the x86 architecture, we can call it some cumbersomeness and a tendency to an extensive increase in the number of instructions.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
One of the brilliant constructive solutions of 8086 was the invention of segment registers. This seemed to achieve two goals simultaneously - “free” transportability of programs up to 64 KB in size (this was a very decent amount for computer memory for one program until the mid-80s), and addressability up to 1 MB of address space. It can also be noted that 8086, like the 8080 or z80, also has a special address space for 64KB I / O ports (y 8080 and 8085, this volume is 256 bytes). There are only four segment registers: for the code, for the stack, and two for the data. Thus, 64 * 4 = 256 KB of memory are available for quick use, but this was very much even in the mid-80s. In fact, there are no problems with code size,since you can use the so-called long subroutine calls with loading and saving the full address from two registers. There is only a 64 KB limit on the size of a single subroutine - this is sufficient for many modern applications. Some problem is created by the impossibility of fast addressing to data arrays larger than 64 KB - when using such arrays, you need to load the segment register and the address itself every time you call, which reduces the speed of working with such large arrays several times.Some problem is created by the impossibility of fast addressing to data arrays larger than 64 KB - when using such arrays, you need to load the segment register and the address itself every time you call, which reduces the speed of working with such large arrays several times.Some problem is created by the impossibility of fast addressing to data arrays larger than 64 KB - when using such arrays, you need to load the segment register and the address itself every time you call, which reduces the speed of working with such large arrays several times.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Segment registers are implemented in such a way that their presence is almost imperceptible in machine codes, which, when the time came, made it easy to discard them. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The 8086 architecture retained its proximity to the 8080 architecture, which made it possible to transfer programs from 8080 (or even z80) to 8086 with relatively little effort, and especially if the source code was available. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The 8086 teams do not have high execution speed, but they are quite comparable with competitors, for example, Motorola 68000, which appeared a year later. One of the new products, a little overclocking the generally unhurried 8086, was a line of teams.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
8086 uses eight 16-bit registers, some of which can be used as two byte registers, and some as index registers. Thus, the 8086 registers are distinguished by some heterogeneity, but it is well balanced and the registers are very convenient to use. This heterogeneity, by the way, allows you to have denser codes. The 8086 uses the same flags as the 8080, plus several new ones. For example, a flag appeared typical of the PDP-11 architecture - step-by-step execution.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
8086 allows you to use very interesting addressing modes, for example, an address can be made up of the sum of two registers and constant 16-bit mixing, which is superimposed on the value of one of the segment registers. From the sum making the address, it is possible to leave only two or even one item. Such a PDP-11 one team will not work. Most of the 8086 commands do not allow both memory operands, one of the operands must be a register. But there are string commands that just know how to work with memory using addresses. String commands allow you to do quick block copying (17 ticks per byte or word), search, fill, load and compare. In addition, string commands can be used when working with I / O ports. The 8086 idea is very interesting to use prefix commands,allowing, without significant complication of command coding schemes, to use often very useful additional functionality.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
8086 has one of the best among all computer systems organization of work with the stack. Using only two registers (BP and SP), 8086 allows you to solve all problems when organizing subroutine calls with parameters. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Among the teams there are sign and unsigned multiplication and division. There are even unique decimal adjustment commands for multiplication and division commands. It is difficult to say that in the command system 8086 something is clearly not enough. Quite the contrary. Dividing a 32-bit divisible by a 16-bit divider with a 32-bit quotient and 16-bit remainder may require up to 300 clock cycles — not particularly fast, but several times faster than such a division on any 8-bit processors (except 6309) and comparable in speed to 68000. The division by x86 has one unexpected feature - it changes the flags of the signs unpredictably ...</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is worth adding that in the x86 architecture, the XCHG team inherited from the 8080 remains, which has been improved. In addition, XADD, CMPXCHG, and CMPXCHG8B instructions were used in later processors, which can also perform an atomically exchanged argument. Such instructions are one of the features of x86, they are difficult to find on processors of other architectures.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It can be summarized that the 8086 is a very successful processor, combining both the convenience of programming and attachment to the memory limitations of its time. The 8086 was used relatively rarely, giving the cheaper 8088 the honorable place to be the first processor for the mainframe for personal computers of our time, the IBM PC architecture. 8088 used an 8-bit data bus, which made it somewhat slower, but it allowed it to build on its basis more accessible to customers of the system.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Interestingly, Intel fundamentally refused to make improvements to its processors, preferring instead to develop their next generations. One of the largest subcontractors (second source) of Intel, the Japanese corporation NEC, which was much larger than Intel in the early 80s, decided to upgrade to 8088 and 8086 by launching V20 and V30 processors compatible with them and up to 30% faster. NEC even offered Intel to become a subcontractor! Intel instead launched a lawsuit against NEC, which, however, could not win. For some reason, this big disassembly between Intel and NEC is completely ignored by Wikipedia.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
80186 and 80286 appeared in 1982. Thus, it can be assumed that Intel had two almost independent development teams. 80186 is improved by several commands and 8086 shortened timings, plus several chip-embedded circuits typical of the x86 architecture: clock generator, timers, DMA / PDP, interrupt controller, delay generator, etc. Such a processor would seem to greatly simplify production computers based on it, but due to the fact that the built-in interrupt controller was for some reason incompatible with the IBM PC, it was almost never used on a PC. The author knows only the BBC Master 512 system based on the BBC Micro computer, which did not use the built-in circuits, even the timer, but there were several other systems using 80186. The addressed memory of 80186 remained in the same size as the 8086 in 1 MB.Japanese corporation NEC produced analogues 80186, which were compatible with the IBM PC.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
80286 had even better timings than 80186, among which just fantastic division stands out (32/16 = 16,16) in 22 bars - since then they haven’t learned how to do the division faster! 80286 supports working with all new 80186 teams, plus many commands for working in a new, secure mode. 80286 became the first processor with integrated support for protected mode, which allowed organizing memory protection, proper use of privileged instructions, access to virtual memory. Although the work in the new mode created many problem moments (the protected mode was made rather unsuccessfully) and was relatively rarely used, it was a big breakthrough. In this new mode, the segment registers have acquired a new quality, allowing you to use up to 16 MB of addressable memory and up to 1 GB of virtual memory per task.The big problem 80286 was the inability to switch from protected mode to real, in which most programs worked then. Using the “secret” undocumented LOADALL instruction, it was possible to use 16 MB in memory and in real mode.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In 80286, the calculation of addresses in the operands of instructions began to be made by separate circuits and stopped slowing down the execution of instructions. </font><font style="vertical-align: inherit;">This added interesting features, such as the command</font></font><br>
<br>
<pre><code class="plaintext hljs">LEA AX,[BX+SI+4000]</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In just 3 clocks, it became possible to perform two additions and transfer the result to the register AX! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Segment registers in protected mode have become part of a full-fledged memory management system (MMU). </font><font style="vertical-align: inherit;">In real mode, these registers only partially provided MMU functionality. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The number of manufacturers and specific systems using 80286 is enormous, but, of course, the first were IBM PC AT computers with almost fantastic performance indicators among personal computers. </font><font style="vertical-align: inherit;">With these computers, the memory began to lag behind the processor in speed, delay states appeared, but then it seemed to be something temporary.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In 80286, as in 8086/8088, work with interruptions was not implemented 100% correctly, which in very rare cases could lead to very unpleasant consequences. For example, the POPF command in 80286 always allowed interrupts in its execution, and when executing a command with two prefixes (for example, you can take the REP ES: MOVSB) on 8086/8088 after calling the interrupt one of the prefixes was lost. An error in POPF was only in the early 80286 releases.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Protected mode 80286 was extremely inconvenient, divided all memory into segments no larger than 64 KB and demanded difficult software support for working with virtual memory. 80386, having appeared in 1985, made the work in protected mode quite comfortable, allowed to use up to 4 GB of addressable memory and easily switch between modes. In addition, virtual 8086 mode was made to support multitasking for programs for 8086. For virtual memory, it became possible to use a relatively easy to manage page mode. 80386 with all its innovations retained full compatibility with the programs written for 80286. Among the innovations 80386, we can also call pulling registers up to 32-bit and adding two new segment registers. Timings have changed, but ambiguous. A quick bit shifter has been added,which allowed for multiple shifts with single timings. However, this innovation is very much for some reason very slowed down the execution of cyclic shift commands. Multiplication became slightly slower than that of 80286. Memory handling, on the contrary, became slightly faster, but this does not apply to string commands that remained faster with 80286. The author of this material had to come across the opinion that in real mode 16 The 80286 bit code is still slightly faster than 80386 at the same frequency.The author of this material more than once had to deal with the opinion that in real mode, with a 16-bit code, 80286, as a result, is still a little bit faster than 80386 at the same frequency.The author of this material more than once had to deal with the opinion that in real mode, with a 16-bit code, 80286, as a result, is still a little bit faster than 80386 at the same frequency.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In 80386 new teams were added, most of which only provided new ways to work with data, virtually duplicating with optimization for some cases available. </font><font style="vertical-align: inherit;">For example, the following commands were added:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to check, set, and reset a bit by number, similar to those made for the z80;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BSF and BSR bitwise scan;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">copy values ​​with a character or zero extension, MOVSX and MOVZX;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setting values ​​depending on the values ​​of the SETxx operation flags;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shifts of double values ​​SHLD, SHRD.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Until the appearance of the 80386, x86 processors could use only short, conditional jumps with a shift of one byte - this was often very insufficient. Since 80386, it became possible to use offsets from two (or four in 32-bit address mode) bytes, and despite the fact that the code of new transitions has become two (or three) times longer, its execution time remains the same as in previous ones, short transitions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Radically improved debugging support by introducing 4 hardware breakpoints, using them, it became possible to stop programs even at addresses in memory that cannot be changed.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The main protected mode became much easier to manage than in 80286, which made a number of inherited commands unnecessary rudiments. In the generally protected, so-called flat-mode, segments of up to 4 GB are used, which makes all segment registers a subtle formality. And the semi-documentary unreal mode allowed even using all the memory as in the flat-mode, but from a simple real-mode for installation and control.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With 80386, Intel declined to share its technology, becoming virtually the exclusive manufacturer of processors for the IBM PC architecture, and with the weakening position of Motorola, for other PC architectures. </font><font style="vertical-align: inherit;">Systems based on 80386 were very expensive until the early 90s, when they finally became available to mass consumers at frequencies from 25 to 40 MHz. </font><font style="vertical-align: inherit;">C 80386 IBM began to lose the position of the leading manufacturer of IBM PC compatible computers. </font><font style="vertical-align: inherit;">This was manifested, in particular, in the fact that the first PC based on 80386 was in 1986 the computer of the company Compaq.</font></font><br>
<br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is hard not to hold back the admiration for the amount of work that was done by the creators of 80386 and its results. </font><font style="vertical-align: inherit;">I dare to even suggest that 80386 encompasses more achievements than all the technological advances of mankind until 1970, and maybe until 1980.</font></font><br>
<br>
</p><p>Довольно интересна тема ошибок в 80386. Напишу про две. Первые чипы имели некоторые команды, которые затем исчезли из руководств по этим процессорам и перестали исполняться на более поздних чипах. Если использовать первые источники информации по 80386 практически, может случиться неожиданное затруднение. Речь идет о командах IBTS и XBTS. У всех 80386DX/SX, производимых как AMD, так и Intel (что обнаруживает их любопытную внутреннюю идентичность), есть очень странный и неприятный баг, который проявлялся в уничтожение значения регистра EAX, если после записи в стек или выгрузке оттуда всех регистров командами POPAD или PUSHAD использовалась команда, использовавшая адрес с регистром BX. В некоторых ситуациях процессор мог даже зависнуть. Просто кошмарный баг и очень массовый, а в википедии нет даже упоминаний про него. Были и другие баги.<br>
<br>
Появление ARM изменило ситуацию в мире компьютерных технологий. Несмотря на проблемы, процессоры ARM продолжали своё развитие. Ответом Intel стал 80486. В борьбе за быстродействие и за первое место в мире передовых технологий Intel пошла даже на уродующее до сих облик персонального компьютера решение – использование охлаждающего вентилятора.<br>
<br>
В 80486 были улучшены тайминги большинства инструкций и некоторые из них стали выполняться как и на процессорах ARM за такт. Хотя умножение и деление почему-то стали чуть медленнее. Особенно странно, что однократные двоичные сдвиги и вращения регистра стали выполняться даже медленнее, чем с 8088! Появилась довольно большая для тех лет, размером 8 КБ, встроенная кэш-память. Появились и новые инструкции, например, CMPXCHG – она заняла место незаметно пропавших инструкций IBTS и XBTS (любопытно, что в качестве секретной эта инструкция была доступна уже и на поздних 80386). Новых инструкции совсем немного – всего шесть, из которых стоит упомянуть весьма полезную команду для смены порядка байт в 32-разрядном слове BSWAP. Большой полезной новинкой стало наличие встроенного в чип арифметического сопроцессора – так ещё никто не делал. Была также улучшена работа очереди команд.<br>
<br>
Первые системы на базе 80486 были невероятно дороги. Довольно необычно, что первые компьютеры на базе 80486, модель VX FT, сделала английская фирма Apricot – их цена в 1989 была от 18 до 40 тысяч долларов, а вес системного блока – более 60 кг! IBM выпустила первый компьютер на базе 80486 в 1990, это была модель PS/2 90 стоимостью $17000. <br>
<br>
Трудно себе представить процессоры Intel без секретных, недокументированных официально возможностей. Часть таких возможностей скрывали от пользователей, начиная с самых первых 8086. Например, такой пусть и почти никому не нужный факт, что второй байт в инструкциях десятичной коррекции AAD и AAM имеет значение и может быть другим, вообще недесятичным (это было документировано только с процессора Pentium спустя 15 лет!). Более неприятно умолчание сокращенных команд AND/OR/XOR с операндом байтовой константой, например, AND BX,7 с опкодом длиной три байта (83 E3 07). Эти команды, делающие код более компактным, что было особенно важно с первыми ПК, были тихо вставлены в документацию только по 80386. Интересно, что в фирменных руководствах по 8086 или 80286 есть намек об этих командах, но конкретных опкодов по ним там нет. В отличие от похожих инструкций ADD/ADC/SBB/SUB, по которым была предоставлена полная информация. Это, в частности, привело к тому, что многие ассемблеры (все?) не умели производить более короткие коды. Ещё одна группа секретов скорее может быть названа некоторой странностью – ряд инструкций имеют по два кода операций. Речь идёт, например, об инструкциях SAL/SHL (опкоды D0 E0, D0 F0 или D1 E0, D1 F0) и некоторых других. Обычно, а может и всегда, используется только один код операции. Второй, секретный не используется практически никогда. Можно только удивляться, почему Intel так бережно сохраняет эти лишние, захламляющие пространство опкодов дублирующие инструкции? Инструкция SALC ждала своего официального документирования до 1995 почти 20 лет! Инструкция для отладки ICEBP была официально несуществующей 10 лет с 1985 по 1995. Более всего писалось про тайные инструкции LOADALL и LOADALLD – они так навсегда и останутся тайными, так как их можно было использовать для простого доступа к большим объемам памяти только на 80286 и 80386 соответственно. До недавнего времени сохранялась интрига вокруг инструкции UD1 (0F B9), которая неофициально являлась примером неправильного опкода. Неофициальное недавно стало официальным.<br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the USSR, the production of clones of the 8088 and 8086 processors was mastered, and the 80286 was never fully reproduced.</font></font><br>
<br>
</p><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Motorola: from 68000 to 68040</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Motorola is the only company that for some time has been able to successfully compete with Intel in the production of processors for personal computers.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
68000 was released in 1979 and at first glance it looked much more impressive than 8086. It had 16 32-bit registers (more precisely, even 17), a separate command counter and a status register. Could address 16 MB of memory directly, which did not create any restrictions, for example, for large arrays. However, a careful analysis of the features of the 68000 shows that not everything is as good as it seems. In those years, having a memory of more than 1 MB is an unattainable luxury even for medium-sized organizations. 68000 code density is worse than 8086 - which means codes with the same functionality occupy 68000 more space. The latter is due to the fact that codes for 68k should be multiples of 2 bytes in length, and for x86 - 1. But information about the density of codes is controversial, as there is evidence that in some cases it can be better for 68000 than for 8086 . Of the 16 registers - 8 address,in some ways, these are slightly more advanced analogs of the x86 segment registers. The ALU and data bus are 16-bit, so operations with 32-bit data are slower than you might expect. The execution time of register-register operations is 4 clocks, while the 8086 has only 2. Computers based on 68000 until the mid-80s were much more expensive than those based on Intel 8088, but 68000 could not work with virtual memory and did not have hardware support of working with real numbers, which made it unsuitable for use in the most advanced systems.than on the Intel 8088 base, but the 68000 could not work with virtual memory and did not have hardware support for working with real numbers, which made it unsuitable for use in the most advanced systems.than on the Intel 8088 base, but the 68000 could not work with virtual memory and did not have hardware support for working with real numbers, which made it unsuitable for use in the most advanced systems.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As always, with products from Motorola, the architecture of the 68000 reveals a few clumsiness and contrived oddities. For example, two stacks or two carry flags (one for features and the other for operations). At this oddity with the flags do not end. For some reason, many teams, including even MOVE, disable the flags of the carry and overflow flag. Another oddity is that the command to save the state of arithmetic flags, which worked normally in 68000, was made privileged in all processors starting from 68010. Some operations are annoying because they are not optimized, for example, writing the zero to the CLR works slower than writing the constant 0 to memory with the MOVE command or left shift slower than adding the operand to itself. There are some almost unnecessary commands, for example, there are both arithmetic and logical left shifts.Even address registers, while seemingly superior to segment registers 8086, have a number of annoying flaws. For example, they needed to load as many as 4 bytes instead of two in 8086, and of these four, one was superfluous. The 68000 command system reveals many similarities with the PDP-11 command system developed back in the 60s.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The codes for Motorola look somehow more cumbersome and awkward compared to x86 or ARM. On the other hand, 68000 is still faster than 8086, according to my estimates by about 20-30%. The 680x0 code, however, has its own peculiar beauty and elegance, less mechanicalism, characteristic of x86. In addition, as shown by communication with </font></font><a href="http://eab.abime.net/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eab.abime.net</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> experts </font><font style="vertical-align: inherit;">, the code density of 68k is often better than that of x86.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Overall, 68000 is a good processor, with a large system of commands. It was used in many now legendary personal computers: in the first Apple Macintosh computers, which were produced before the early 90s, in the first Commodore Amiga multimedia computers, in relatively inexpensive and high-quality Atari ST computers. 68000 was also used in relatively inexpensive computers that work with Unix variants, in particular, in the rather popular Tandy 16B. Interestingly, IBM simultaneously with the development of the PC led the development of the System 9000 computer based on the 68000, which was released less than a year after the PC.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
68010 appeared clearly late, only in 1982, at the same time, Intel released 80286, which put personal computers at the level of a mini-computer. 68010 is compatible with the 68000 connector, but the system of its commands is slightly different, so replacing 68000 with 68010 did not become popular. The incompatibility was caused by a contrived cause to bring 68,000 more into line with the ideal theory of virtualization support organization. 68010 only slightly, no more than 10% faster than 68000. Obviously, 68010 lost much 80286 and was even weaker than 80186 that appeared in the same year. Like 80186, 68010 practically did not find any use for personal computers.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
68008 was also released in 1982, probably with the hope of repeating the success of the 8088. This is 68000, but with an 8-bit data bus, which made it possible to use it in cheaper systems. But 68008, like 68000, does not have a queue of commands, which makes it about 50% slower than 68000. Thus, 68008 may even be a little slower than 8088, which is only about 20% slower due to the presence of a command queue. than 8086.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Based on it, Sir Clive Sinclair made the Spectrum QL - a very interesting computer that, due to its lower price, could compete with Atari ST and similar computers. But Clive simultaneously and obviously prematurely began to put a lot of energy into the development of electric vehicles, leaving QL (Quantum leap - quantum leap) rather as a secondary task, which, with some unsuccessful design solutions, led the computer and the entire Clive company to prematurely close (the company became part of Amstrad, which refused to produce QL). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It would be interesting to calculate the index of digit capacity for 68000, it seems to me that it is clearly higher than 16, although rather not higher than 24.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Appearing in 1984, the 68020 again returned Motorola to the first positions. This processor has been implemented many very interesting and promising new items. The strongest effect certainly produces an instruction pipeline, sometimes allowing you to perform up to three instructions at a time! The 32-bit address bus looked a bit premature in those years and therefore a cheaper version of the 68020EC processor with a 24-bit bus was produced. But the 32-bit data bus already looked quite appropriate and allowed to significantly speed up the work. The built-in cache, albeit small, 256 bytes, looked like a novelty, which made it possible to significantly improve performance, since the main dynamic memory could not keep up with the processor. Sufficiently fast operations were added for division (64/32 = 32.32) and multiplication (32 * 32 = 64), approximately 80 and up to 45 cycles, respectively.The instruction timings were generally significantly improved, for example, the division (32/16 = 16,16) was performed in approximately 45 cycles (more than 140 cycles in 68000). Some instructions in the most favorable cases can be executed without taking any bars at all! New addressing modes were added, in particular, with scaling - in x86, this mode appeared only in the next year in 80386. Other new addressing modes allow the use of dual indirect addressing, using several offsets, - the PDP-11 was noticeably surpassed here.with scaling - in x86, such a mode appeared only in the next year in 80386. Other new addressing modes allow using double indirect addressing, using several shifts, - the PDP-11 was noticeably surpassed here.with scaling - in x86, such a mode appeared only in the next year in 80386. Other new addressing modes allow using double indirect addressing, using several shifts, - the PDP-11 was noticeably surpassed here.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But some new instructions, for example, heavy operations with bit fields or that became less important with fast division and multiplication of new operations with 10 numbers, looked more like a fifth wheel of a cart than something essentially useful. Theoretically, dual address indirect addressing modes look interesting, but they are rarely needed and are executed very slowly. In contrast to 80286, 68020 takes time to calculate the address of the operand, the so-called effective address. The division in 68020 turned out to be almost two times slower than the miracle division in 80286. Multiplication and some operations are also slower. The 68020 does not have a built-in memory management system (MMU) and rather the exotic ability to connect up to eight co-processors could not fix this.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The 68020 was widely used in the mainstream Apple Macintosh II, Macintosh LC, and Commodore Amiga 1200 computers. It was also used in several Unix systems.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The appearance of the 80386 with the built-in and very solidly made MMU and 32-bit tires and registers, again put Motorola in position number 2. 68030, having appeared in 1987, the last time, for a short time was able to return Motorola leadership. The 68030 has a built-in memory management system and a cache doubled, divided into a cache for instructions and data - this was a very promising new product. In addition, the 68030 could use a faster memory access interface, which can speed memory operations by almost a third. But, despite all the innovations, the 68030 was slightly slower than the 80386 at the same frequencies. However, 68030 was available at frequencies up to 50 MHz, and 80386 only up to 40 MHz, which made the top systems based on the 68030 slightly faster.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
68030 was used in computers of the Apple Macintosh II series, Commodore Amiga 3000, Atari TT, Atari Falcon and some others.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With the 68040, Motorola once again attempted to outperform Intel. This processor appeared a year later after 80486, but in terms of the totality of useful qualities it could not surpass it. In fact, Motorola, having a more overloaded system of commands, was unable to support it and, in a sense, left the race. In 68040 only a very trimmed coprocessor for working with real numbers could be placed and the chip itself warmed up significantly more than 80486. 68040 practically did not find use in popular computers. Some notable use was found only by its cheaper version - 68LC040, which does not have a built-in coprocessor. However, the first versions of this chip had a serious hardware defect, which did not allow using even the programmed emulation of the coprocessor!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Problems with math coprocessors at Motorola have always been. </font><font style="vertical-align: inherit;">Motorola, as already mentioned, has never released such a co-processor for the 68000/68010, while Intel has released its very successful 8087 since 1980. For the 68020/68030 processor, two co-processors 68881 and its improved pin-compatible version 68882 were made at once But to get a significant performance gain, the code for 68882 needs to be compiled differently than for 68881. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is appropriate to say that Intel x86 still has problems with the mathematical coprocessor - the accuracy of calculations of some functions, for example, the sine on some arguments is quite small, </font><font style="vertical-align: inherit;">sometimes no more than 4 characters. </font><font style="vertical-align: inherit;">Therefore, modern compilers often compute such functions without resorting to the services of a coprocessor.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">National Semiconductor 32016</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is the first true 32-bit processor proposed for use in computers as early as 1982. This processor was originally planned as a VAX-11 on a chip, but because of the impossibility of negotiating with DEC, National Semiconductor (NS) had to make the processor only similar parts on the architecture of VAX-11. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The use of paged virtual memory begins with this processor - today it is the dominant technology. But virtual memory support is not built into the processor, but requires a coprocessor. A separate coprocessor is required to work with real numbers.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The NS32016 command system is huge and similar to the VAX-11 command system, in particular, by having a separate stack for subroutine frames. The address bus is 24-bit, which allows up to 16 MB of memory. Feature 32016 is the work with flags flags. In addition to the standard transfer flags (which can also be used as a sign for a conditional transition), overflow, sign, equality (or zero), there is also the L (less) flag, meaning less - this is like a transfer for comparisons. The situation with the transfer is similar to the one that is in processors Motorola 680x0. The overflow flag is for some reason called F. There are flags of step-by-step mode, privileged mode and (uniqueness!) Flag for selecting the current stack. When executing arithmetic instructions, flags of the sign, zero, and lesser (L) are not set, they are set only by the comparison commands.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eight 32-bit general purpose registers can be used. In addition, there is also a command counter, two stack pointers, a stack pointer for subprogram frames, a program base pointer (this is something unique), a module base pointer (also something very rare), a pointer to the interrupt vector table, a configuration register, and a register states. In terms of speed, the NS32016 was comparable to the 68000.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
32016 as far as I know it was used only with BBC Micro personal computers as a second processor. </font><font style="vertical-align: inherit;">It was a very expensive and prestigious prefix for 1984. </font><font style="vertical-align: inherit;">It was possible to order a processor with frequencies of 6, 8 and 10 MHz. </font><font style="vertical-align: inherit;">There were some technical problems with the latter and it was very expensive. </font><font style="vertical-align: inherit;">The software for 32016 was very small, only made by Acorn, the Unix-like operating system Panos, and Acorn's regular satellite BASIC. </font><font style="vertical-align: inherit;">BBC Micro did not use the MMU chip - although it could be connected, there were no programs to use it. </font><font style="vertical-align: inherit;">Arithmetic coprocessor even connect was not provided. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is known that this very complex processor had serious hardware errors that have been fixed for years.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acorn arm</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The 6502 ideology, namely, making it easier, cheaper and better, found its continuation in the almost fantastic development of Acorn, the ARM-1 processor, released in 1985, at the same time as Intel’s technological miracle, 80386 processor. ARM consisted of an order of magnitude smaller the number of transistors and therefore consumed significantly less energy and was at the same time much faster on average. Of course, ARM did not have any MMU and even divide and multiply operations, so in some calculations based on the division 80386 could be faster. However, the advantages of ARM were so great that today it is the most massive processor architecture. It was released more than 100 billion of these processors.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The development of ARM in 1983 began after Acorn conducted research with a 32016 processor, which showed that many 6502 calculations at half the operating frequency could be faster than this, as it seemed, a much more powerful processor. At that time, 80286 was already available, which showed very good performance, but Intel, perhaps sensing the rather small potential of the small Acorn company, refused to provide its processor for testing. At the same time, the technology 80286 was not closed as 80386 and was transferred to many companies, so the story is still waiting for the disclosure of details of this somewhat unusual refusal. Perhaps, if Intel allowed to use its own processor, Acorn would use it, and would not develop ARM.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ARM was developed by only a few people, and they tested the command system using the BBC Micro basic. The development itself took place in the building of the former outbuilding, which is often called the barn or barn. The debut of the processor turned out rather unsuccessful. In 1986, a prefix for the BBC Micro was released with the name ARM Evaluation system, which contains 4 MB of memory in addition to the processor (this is very much for those years), which made this console a very expensive product (its price was more than 4000 pounds sterling, i.e. 6000 dollars). Of course, if you compare it with the computers of that time with comparable capabilities in speed, the console turned out to be an order of magnitude or even almost two cheaper. But for the new system there were very few programs. And this is somewhat strangesince it was quite possible to port Unix for this system - then numerous Unix variants were available that did not require the MMU, there were Unix variants for the PDP-11, 68000, 80186 and even 8088. It is curious that in the 90s Acorn Archimedes was ported Linux Perhaps the delay in the emergence of this Unix for ARM was caused by Acorn's reluctance to transfer ARM technology to other firms.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/f0d/cd2/97c/f0dcd297ccb2c89b6ac0e1bea44397f2.jpg"><br>
<i>Первая система на базе ARM</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Acorn's somewhat unsuccessful marketing policy led to a very difficult financial situation in 1985. Acorn, in addition to ARM, also tried to conduct expensive development of computers for business, which failed, in particular, due to the shortcomings of the 32016 processor chosen for them. Acorn Communicator also turned out to be not very successful. The development of a relatively successful, but not quite IBM PC compatible Master 512 computer was very costly. In addition, a lot of financial resources were spent in an unsuccessful attempt to enter the US market, which the Italian company Olivetti, with its rather successful Intel 8086 and 80286-based computers, was allowed to enter into as part of the hypothetical big game of absorbing Acorn itself. By the way, after absorbing Acorn,Olivetti's role in the American market quickly faded away.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As part of Olivetti, Acorn developed an improved ARM2 chip with built-in multiplication commands, on the basis of which Archimedes personal computer was amazing then with its speed, the first models of which became available in 1987. However, the management from Olivetti was focused on working with IBM PC compatible computers and I did not want to use my resources to sell Acorn products.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ARM provides for the use of 16 32-bit registers (there are actually more of them, if we consider the registers for system needs). One of the registers, R15, like the PDP-11 architecture, is a command counter. Almost all operations are performed in 1 cycle. More ticks are needed, in particular, for transitions, multiplications and memory accesses. In comparison, with the main processors of those years, ARM was distinguished by the absence of such a typical structure as a stack. The stack is implemented, if necessary, through one of the registers. When calling subprograms, the stack is not used; instead, the return address is stored in the register allocated for it. Such a scheme obviously does not work for nested calls for which you have to organize a stack. A unique feature of ARM is the combination of the program counter, which is 26-bit, i.e. it allows you to address up to 64 MB with a state register.For flags in this case, eight bits are allocated, two more bits in this register are obtained due to the fact that the lower two bits of the address are not used, since the codes must be aligned along the 4-byte word boundary. The processor can refer to bytes and 4-byte words, it cannot directly access 16-bit data. Instructions for working with data from ARM 3-address. A characteristic feature of the RISC architecture is the use of register-memory commands only for loading and unloading data. ARM has a built-in fast bit shifter (Barrel Shifter), which allows you to shift the value of one of the registers in a command by any number of times without any clock cycles. For example, multiplying the value of register R0 by 65 and placing the result in register R1 can be written with one single-cycle addition commandmultiplying the value of the register R0 by 65 and placing the result in the register R1 can be written with one single-cycle addition command</font></font><br>
<br>
<pre><code class="plaintext hljs">ADD R1, R0, R0 shl 6</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
, and multiplication by 63 - by the command</font></font><br>
<br>
<pre><code class="plaintext hljs">RSB R1, R0, R0 shl 6</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the command system there is a reverse subtraction, which allows, in particular, to have a unary minus as a special case of this command and speed up the division procedure. ARM has another unique feature: all its instructions are conditional. There are 16 cases (flag combinations) that are attached to each instruction. The instruction is executed only if the current set of flags corresponds to the set in this instruction. In processors of other architectures, such an execution takes place, as a rule, only for conditional transitions. This feature of ARM allows in many cases to avoid a slow transition operation. The latter also contributes to the fact that when performing arithmetic operations, you can refuse to set the status flags. With ARM like a 6809 processor, you can use both fast and regular interrupts. Besides,in the interrupt modes, the higher-numbered registers are replaced with the system ones, which makes interrupt handlers more compact and fast.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The ARM instruction system contains substantially fewer basic instructions than the x86 processor instruction system. But the ARM instructions themselves are very flexible and powerful. Several very convenient and powerful ARM instructions have no analogues for 80386, for example, RSB (reverse subtraction), BIC (AND with inversion, this is a PDP-11 command), 4-address MLA (multiplication with summation), LDM and STM ( loading or unloading multiple registers from memory is similar to the MOVEM command for 68k processors). Almost all ARM instructions are 3-address, and almost all instructions 80386 have no more than 2 operands. The ARM command system is more orthogonal - all registers are interchangeable, some exceptions are registers R14 and R15. Most ARM commands may require 3-4 80386 commands for their emulation, and most 80386 commands can be emulated by 2-3 ARM commands. Interesting,That the IBM PC XT emulator on the Acorn Archimedes computer hardware with an 8 MHz processor runs even faster than a real PC XT computer. On a Commodore Amiga computer with a 68000 7 MHz processor, the emulator can only work at a speed no greater than 10-15% of the real PC XT. It is also interesting that the first NeXT computers with 25 MHz 68030 showed the performance of integer calculations at the level of the same 8 MHz ARM. Apple was going to make Apple's successor computer in the Möbius project] [, but when it turned out that the prototype of this computer in emulation mode overtakes not only Apple] [but also based on 68k Macintosh processors, the project was closed!On a Commodore Amiga computer with a 68000 7 MHz processor, the emulator can only work at a speed no greater than 10-15% of the real PC XT. It is also interesting that the first NeXT computers with 25 MHz 68030 showed the performance of integer calculations at the level of the same 8 MHz ARM. Apple was going to make Apple's successor computer in the Möbius project] [, but when it turned out that the prototype of this computer in emulation mode overtakes not only Apple] [but also based on 68k Macintosh processors, the project was closed!On a Commodore Amiga computer with a 68000 7 MHz processor, the emulator can only work at a speed no greater than 10-15% of the real PC XT. It is also interesting that the first NeXT computers with 25 MHz 68030 showed the performance of integer calculations at the level of the same 8 MHz ARM. Apple was going to make Apple's successor computer in the Möbius project] [, but when it turned out that the prototype of this computer in emulation mode overtakes not only Apple] [but also based on 68k Macintosh processors, the project was closed!that the prototype of this computer in emulation mode overtakes not only Apple] [, but also based on 68k Macintosh processors, the project is closed!that the prototype of this computer in emulation mode overtakes not only Apple] [, but also based on 68k Macintosh processors, the project is closed!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Among the disadvantages of ARM, we can highlight the problem of loading a constant into a register. You can load only 8 bits at a time, although the constant can be inverted and shifted. Therefore, loading a full 32-bit constant can take up to 4 commands. You can, of course, load a constant from memory with a single command, but here the problem arises of specifying an address of this value, since the offset can only be 12-bit. Another disadvantage of ARM is its relatively low code density, which makes the programs somewhat large and, most importantly, reduces the efficiency of the processor cache. However, this is probably the result of the low quality of the compilers for this platform. For a long time, a significant disadvantage of ARM was the lack of built-in support for memory management (MMU) - this support, for example, was demanded by Apple in the early 90s.Coprocessors for working with real numbers for the ARM architecture also began to be used with a significant delay. ARM did not have such advanced debugging tools as x86 had. There is still some strangeness in the standard assembler language for ARM: it is customary to write bit shifter operations separated by commas. Thus, instead of a simple form</font></font><pre><code class="plaintext hljs">R1 shl 7</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - shift the contents of register R1 by 7 bits to the left - you need to write </font></font><pre><code class="plaintext hljs">R1, shl 7</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since 1989, ARM3 has become available with built-in cache. </font><font style="vertical-align: inherit;">In 1990, the ARM development team separated from Acorn and created ARM Holding with the help of Apple and VLSI. </font><font style="vertical-align: inherit;">One of the reasons for the separation was the excessive cost of ARM development in the opinion of Acorn-Olivetti management. </font><font style="vertical-align: inherit;">Subsequently, Acorn ceased its independent existence, and ARM Holding turned into a large company. </font><font style="vertical-align: inherit;">The separation of Acorn and ARM Holding was also initiated by Apple’s desire to have an ARM processor in its Newton computer and not be dependent on another computer manufacturer.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Further development of the ARM architecture is also very curious, it affected, in particular, the interests of such well-known companies like Intel, DEC and Microsoft, but this is another story. </font><font style="vertical-align: inherit;">Although it can be mentioned that it was thanks to a stake in ARM Holding Apple in the 90s that it was able to avoid bankruptcy.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Some conclusions, assumptions and questions</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is difficult to get rid of the feeling that 8-bit processors turned out to be only an undesirable necessity for the main characters in the 70s and 80s characters on the computer history scene. The most successful 8-bit 6502 was actually frozen. Intel and Motorola rather slowed down as their own development of small processors, and restrained other developers. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I’m pretty sure that the Amiga or Atari ST would work better and faster on a 4 MHz processor with a 20 or 24-bit address compatible with 6502 than with a 68000. Bill Mensch said recently that it’s easy to make 6502 at 10 GHz. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If in the Amstrad PCW series, the success of which the Commodore CBM II could have divided, began to use optimized z80 at higher frequencies, then it is quite possible that this series would be relevant 10 years ago.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What would the world be like if ARM did in 1982, which was quite possible? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What would domestic computers be like if they copied and developed not the most expensive, but the most promising technologies?</font></font></div>