<div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/kj/60/vi/kj60vi6ugv7bunlqdts2nlr2vja.png"></p><br><p>  A small tutorial on how to use Keycloak can connect Kubernetes with your LDAP server and configure the import of users and groups.  This will allow you to configure RBAC for your users and use auth-proxy to protect the Kubernetes Dashboard and other applications that do not know how to authorize themselves. </p><a name="habracut"></a><br><h2 id="ustanovka-keycloak">  Install keycloak </h2><br><p>  Suppose you already have an LDAP server.  This could be Active Directory, FreeIPA, OpenLDAP, or anything else.  If you do not have an LDAP server, then in principle you can create users directly in the Keycloak interface, or use public oidc providers (Google, Github, Gitlab), the result will be almost the same. </p><br><p>  First of all, we install Keycloak itself, the installation can be performed separately, and immediately into the Kubernetes cluster, as a rule, if you have several Kubernetes clusters, it would be easier to install it separately.  On the other hand, you can always use the <a href="https://github.com/helm/charts/tree/master/stable/keycloak">official helm-chart</a> and set it directly in your cluster. </p><br><p> To store Keycloak data you need a database.  The default is <code>h2</code> (all data is stored locally), but it is also possible to use <code>postgres</code> , <code>mysql</code> or <code>mariadb</code> . <br>  If you decided to install Keycloak separately, you will find more detailed instructions in the <a href="https://www.keycloak.org/docs/latest/getting_started/index.html">official documentation</a> . </p><br><h2 id="nastroyka-federacii">  Federation setting </h2><br><p>  First of all, create a new realm.  Realm is the space of our application.  Each application can have its realm with different users and authorization settings.  The master realm is used by Keycloak itself and using it for something else is wrong. </p><br><p>  Click <strong>Add realm</strong> </p><br><table><thead><tr><th>  Option </th><th>  Value </th></tr></thead><tbody><tr><td>  <strong>Name</strong> </td><td> <code>kubernetes</code> </td> </tr><tr><td>  <strong>Display name</strong> </td><td> <code>Kubernetes</code> </td> </tr><tr><td>  <strong>HTML Display Name</strong> </td><td> <code>&lt;img src="https://kubernetes.io/images/nav_logo.svg" width="400" \&gt;</code> </td> </tr></tbody></table><br><p>  Kubernetes by default checks whether the user has confirmed email or not.  Since we use our own LDAP server, this check will almost always return <code>false</code> .  Let's turn off the view of this parameter in Kubernetes: </p><br><p>  <strong>Client scopes</strong> -&gt; <strong>Email</strong> -&gt; <strong>Mappers</strong> -&gt; <strong>Email verified</strong> (Delete) </p><br><p>  Now let's set up the federation, for this we go to: </p><br><p>  <strong>User federation</strong> -&gt; <strong>Add provider ...</strong> -&gt; <strong>ldap</strong> </p><br><p>  I will give an example of settings for FreeIPA: </p><br><table><thead><tr><th>  Option </th><th>  Value </th></tr></thead><tbody><tr><td>  <strong>Console Display Name</strong> </td><td> <code>freeipa.example.org</code> </td> </tr><tr><td>  <strong>Vendor</strong> </td><td> <code>Red Hat Directory Server</code> </td> </tr><tr><td>  <strong>UUID LDAP attribute</strong> </td><td> <code>ipauniqueid</code> </td> </tr><tr><td>  <strong>Connection URL</strong> </td><td> <code>ldaps://freeipa.example.org</code> </td> </tr><tr><td>  <strong>Users DN</strong> </td><td> <code>cn=users,cn=accounts,dc=example,dc=org</code> </td> </tr><tr><td>  <strong>Bind DN</strong> </td><td> <code>uid=keycloak-svc,cn=users,cn=accounts,dc=example,dc=org</code> </td> </tr><tr><td>  <strong>Bind credential</strong> </td><td> <code>&lt;password&gt;</code> </td> </tr><tr><td>  <strong>Allow Kerberos authentication:</strong> </td><td> <code>on</code> </td> </tr><tr><td>  <strong>Kerberos Realm:</strong> </td><td> <code>EXAMPLE.ORG</code> </td> </tr><tr><td>  <strong>Server Principal:</strong> </td><td> <code>HTTP/freeipa.example.org@EXAMPLE.ORG</code> </td> </tr><tr><td>  <strong>KeyTab:</strong> </td><td> <code>/etc/krb5.keytab</code> </td> </tr></tbody></table><br><p>  The user <code>keycloak-svc</code> must be created in advance on our LDAP server. </p><br><p>  In the case of Active Directory, simply select <strong>Vendor: Active Directory</strong> and the necessary settings will be substituted into the form automatically. </p><br><p>  Click <strong>Save</strong> </p><br><p>  Now let's go: </p><br><p>  <strong>User federation</strong> -&gt; <strong>freeipa.example.org</strong> -&gt; <strong>Mappers</strong> -&gt; <strong>First Name</strong> </p><br><table><thead><tr><th>  Option </th><th>  Value </th></tr></thead><tbody><tr><td>  <strong>Ldap attribure</strong> </td><td> <code>givenName</code> </td> </tr></tbody></table><br><p>  Now enable mapping groups: </p><br><p>  <strong>User federation</strong> -&gt; <strong>freeipa.example.org</strong> -&gt; <strong>Mappers</strong> -&gt; <strong>Create</strong> </p><br><table><thead><tr><th>  Option </th><th>  Value </th></tr></thead><tbody><tr><td>  <strong>Name</strong> </td><td> <code>groups</code> </td> </tr><tr><td>  <strong>Mapper type</strong> </td><td> <code>group-ldap-mapper</code> </td> </tr><tr><td>  <strong>LDAP Groups DN</strong> </td><td> <code>cn=groups,cn=accounts,dc=example,dc=org</code> </td> </tr><tr><td>  <strong>User Groups Retrieve Strategy</strong> </td><td> <code>GET_GROUPS_FROM_USER_MEMBEROF_ATTRIBUTE</code> </td> </tr></tbody></table><br><p>  This completes the federation setup, let's proceed to the client setup. </p><br><h2 id="nastroyka-klienta">  Client setup </h2><br><p>  Create a new client (the application that will receive users from Keycloak).  Moving on: </p><br><p>  <strong>Clients</strong> -&gt; <strong>Create</strong> </p><br><table><thead><tr><th>  Option </th><th>  Value </th></tr></thead><tbody><tr><td>  <strong>Client ID</strong> </td><td> <code>kubernetes</code> </td> </tr><tr><td>  <strong>Access Type</strong> </td><td> <code>confidenrial</code> </td> </tr><tr><td>  <strong>Root URL</strong> </td><td> <code>http://kubernetes.example.org/</code> </td> </tr><tr><td>  <strong>Valid Redirect URIs</strong> </td><td> <code>http://kubernetes.example.org/*</code> </td> </tr><tr><td>  <strong>Admin URL</strong> </td><td> <code>http://kubernetes.example.org/</code> </td> </tr></tbody></table><br><p>  Also create a scope for the groups: </p><br><p>  <strong>Client Scopes</strong> -&gt; <strong>Create</strong> </p><br><table><thead><tr><th>  Option </th><th>  Value </th></tr></thead><tbody><tr><td>  <strong>Template</strong> </td><td> <code>No template</code> </td> </tr><tr><td>  <strong>Name</strong> </td><td> <code>groups</code> </td> </tr><tr><td>  <strong>Full group path</strong> </td><td> <code>false</code> </td> </tr></tbody></table><br><p>  And set up a mapper for them: </p><br><p>  <strong>Client Scopes</strong> -&gt; <strong>groups</strong> -&gt; <strong>Mappers</strong> -&gt; <strong>Create</strong> </p><br><table><thead><tr><th>  Option </th><th>  Value </th></tr></thead><tbody><tr><td>  <strong>Name</strong> </td><td> <code>groups</code> </td> </tr><tr><td>  <strong>Mapper type</strong> </td><td> <code>Group membership</code> </td> </tr><tr><td>  <strong>Token claim name</strong> </td><td> <code>groups</code> </td> </tr></tbody></table><br><p>  Now we need to enable the mapping group in our client scope: </p><br><p>  <strong>Clients</strong> -&gt; <strong>kubernetes</strong> -&gt; <strong>Client Scopes</strong> -&gt; <strong>Default Client Scopes</strong> </p><br><p>  Select <strong>groups</strong> in <strong>Available Client Scopes</strong> , click <strong>Add selected</strong> </p><br><p>  Now we will configure authentication of our application, we pass: </p><br><p>  <strong>Clients</strong> -&gt; <strong>kubernetes</strong> </p><br><table><thead><tr><th>  Option </th><th>  Value </th></tr></thead><tbody><tr><td>  <strong>Authorization Enabled</strong> </td><td> <code>ON</code> </td> </tr></tbody></table><br><p>  Press <strong>save</strong> and this completes the client setup, now on the tab </p><br><p>  <strong>Clients</strong> -&gt; <strong>kubernetes</strong> -&gt; <strong>Credentials</strong> </p><br><p>  You can get <strong>Secret</strong> which we will use in the future. </p><br><h2 id="nastroyka-kubernetes">  Kubernetes Setup </h2><br><p>  Setting up Kubernetes for OIDC authorization is quite trivial and is not something very complicated.  All you need is to put the CA certificate of your OIDC server in <code>/etc/kubernetes/pki/oidc-ca.pem</code> and add the necessary options for kube-apiserver. <br>  To do this, update <code>/etc/kubernetes/manifests/kube-apiserver.yaml</code> on all your wizards: </p><br><pre> <code class="plaintext hljs">... spec: containers: - command: - kube-apiserver ... - --oidc-ca-file=/etc/kubernetes/pki/oidc-ca.pem - --oidc-client-id=kubernetes - --oidc-groups-claim=groups - --oidc-issuer-url=https://keycloak.example.org/auth/realms/kubernetes - --oidc-username-claim=email ...</code> </pre> <br><p>  And also update the kubeadm config in the cluster, so as not to lose these settings when updating: </p><br><pre> <code class="plaintext hljs">kubectl edit -n kube-system configmaps kubeadm-config</code> </pre> <br><pre> <code class="plaintext hljs">... data: ClusterConfiguration: | apiServer: extraArgs: oidc-ca-file: /etc/kubernetes/pki/oidc-ca.pem oidc-client-id: kubernetes oidc-groups-claim: groups oidc-issuer-url: https://keycloak.example.org/auth/realms/kubernetes oidc-username-claim: email ...</code> </pre> <br><p>  This completes the Kubernetes setup.  You can repeat these actions in all your Kubernetes clusters. </p><br><h2 id="nachalnaya-avtorizaciya">  Initial authorization </h2><br><p>  After these actions, you will already have a Kubernetes cluster with configured OIDC authorization.  The only time that your users do not yet have a customized client, like their own kubeconfig.  To solve this problem, you need to configure the automatic issuance of kubeconfig users after successful authorization. </p><br><p>  To do this, you can use special web applications that allow you to authenticate the user and then download the finished kubeconfig.  One of the most convenient is <a href="https://github.com/negz/kuberos">Kuberos</a> , it allows you to describe all Kubernetes clusters in one config and easily switch between them. </p><br><p>  To configure Kuberos, it suffices to describe the template for kubeconfig and run it with the following parameters: </p><br><pre> <code class="plaintext hljs">kuberos https://keycloak.example.org/auth/realms/kubernetes kubernetes /cfg/secret /cfg/template</code> </pre> <br><p>  For more information, see <a href="https://github.com/negz/kuberos">Usage</a> on Github. </p><br><p>  It is also possible to use <a href="https://github.com/int128/kubelogin">kubelogin</a> if you want to perform authorization directly on the user's computer.  In this case, the user will open a browser with an authorization form on localhost. </p><br><p>  The resulting kubeconfig can be checked on the <a href="https://jwt.io/">jwt.io</a> website.  Just copy the value of <code>users[].user.auth-provider.config.id-token</code> from your kubeconfig to the form on the site and immediately get a decryption. </p><br><h2 id="nastroyka-rbac">  RBAC setup </h2><br><p>  When configuring RBAC, you can refer to both the user name (the <code>name</code> field in the jwt-token) and the user group (the <code>groups</code> field in the jwt-token).  Here is an example of setting permissions for the group <code>kubernetes-default-namespace-admins</code> : </p><br><div class="spoiler">  <b class="spoiler_title">kubernetes-default-namespace-admins.yaml</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: name: default-admins namespace: default rules: - apiGroups: - '*' resources: - '*' verbs: - '*' --- apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: name: kubernetes-default-namespace-admins namespace: default roleRef: apiGroup: rbac.authorization.k8s.io kind: Role name: default-admins subjects: - apiGroup: rbac.authorization.k8s.io kind: Group name: kubernetes-default-namespace-admins</code> </pre> </div></div><br><p>  More examples for RBAC can be found in the <a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/">official Kubernetes documentation.</a> </p><br><h2 id="nastroyka-auth-proxy">  Configure auth-proxy </h2><br><p>  There is a wonderful project <a href="https://github.com/keycloak/keycloak-gatekeeper">keycloak-gatekeeper</a> , which allows you to protect any application, allowing the user to authenticate with the OIDC server.  I will show how you can configure it using the Kubernetes Dashboard as an example: </p><br><div class="spoiler">  <b class="spoiler_title">dashboard-proxy.yaml</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">apiVersion: extensions/v1beta1 kind: Deployment metadata: labels: ksonnet.io/component: proxy name: kubernetes-dashboard-proxy spec: replicas: 1 template: metadata: labels: app: kubernetes-dashboard-proxy spec: containers: - args: - --listen=0.0.0.0:80 - --discovery-url=https://keycloak.example.org/auth/realms/kubernetes - --client-id=kubernetes - --client-secret=&lt;your-client-secret-here&gt; - --redirection-url=https://kubernetes-dashboard.example.org - --enable-refresh-tokens=true - --encryption-key=ooTh6Chei1eefooyovai5ohwienuquoh - --upstream-url=https://kubernetes-dashboard.kube-system.svc.cluster.local - --resources=uri=/* image: keycloak/keycloak-gatekeeper name: kubernetes-dashboard-proxy ports: - containerPort: 80 livenessProbe: httpGet: path: /oauth/health port: 80 initialDelaySeconds: 3 timeoutSeconds: 2 readinessProbe: httpGet: path: /oauth/health port: 80 initialDelaySeconds: 3 timeoutSeconds: 2 --- apiVersion: v1 kind: Service metadata: labels: ksonnet.io/component: proxy name: kubernetes-dashboard-proxy spec: ports: - port: 80 protocol: TCP targetPort: 80 selector: app: kubernetes-dashboard-proxy type: ClusterIP</code> </pre> </div></div></div>