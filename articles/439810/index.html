<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Get acquainted with the Moleculer microservice framework</title>
  <meta name="description" content="Hi% habrauser%! 

 Today I want to tell you about one great, in my opinion, microservice framework Moleculer . 



 Initially, this framework was writ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Get acquainted with the Moleculer microservice framework</h1><div class="post__text post__text-html js-mediator-article">  Hi% habrauser%! <br><br>  Today I want to tell you about one great, in my opinion, microservice framework <a href="https://moleculer.services/">Moleculer</a> . <br><br><img src="https://habrastorage.org/webt/n1/8a/ew/n18aewfs_oj6ndbonuakkyjfwte.png"><br><br>  Initially, this framework was written in Node.js, but later it had ports in other languages ‚Äã‚Äãsuch as Java, Go, Python, and .NET, and most likely other implementations <a href="https://github.com/moleculerjs/moleculer/issues/347">will appear</a> in the near future.  We have been using it in production in several products for about a year and it is difficult to describe in words what a blessing it seemed to us after using Seneca and our_bicycles.  We got everything we need out of the box: collecting metrics, caching, balancing, fault-tolerance, optional transports, parameter validation, logging, concise method declaration, several ways of inter-service interaction, mixins, and more.  And now in order. <br><a name="habracut"></a><br><h2>  Introduction </h2><br>  The framework, in fact, consists of three components (in fact, not, but you will learn about it below). <br><br><h4>  Transporter </h4><br>  Responsible for discovering and communicating between services.  This is an interface that, with a strong desire, you can implement yourself, or you can use ready-made implementations that are part of the framework itself.  Out of the box there are 7 transports available: TCP, Redis, AMQP, MQTT, NATS, NATS Streaming, Kafka.  <a href="https://moleculer.services/docs/0.13/networking.html">Here</a> you can see more.  We use Redis transport, but we plan to switch to TCP with its exit from the experimental state. <br><br>  In practice, when writing code, we do not interact with this component.  You just need to know what it is.  Used transport is indicated in the config.  Thus, to switch from one transport to another, simply change the config.  Everything.  Like that: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ./moleculer.config.js module.exports = { transporter: 'redis://:pa$$w0rd@127.0.0.1:6379', // ... –ø—Ä–æ—á–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã }</span></span></code> </pre> <br>  Data, by default, go in the JSON format.  But you can use anything: Avro, MsgPack, Notepack, ProtoBuf, Thrift, etc. <br><br><h4>  Service </h4><br>  The class from which we inherit when writing our microservices. <br><br>  Here is the simplest service without methods, which, however, will be detected by other services: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ./services/telemetry/telemetry.service.js const { Service } = require('moleculer'); module.exports = class TelemetryService extends Service { constructor(broker) { super(broker); this.parseServiceSchema({ name: 'telemetry', }); } };</span></span></code> </pre><br><h4>  ServiceBroker </h4><br>  Exaggerating, we can say that this is a layer between transport and service.  When one service wants to somehow interact with another service, it does so through a broker (examples will be lower).  The broker is engaged in load balancing (supports several strategies, including custom ones, by default - round-robin), taking into account live services, available methods in these services, etc.  For this ServiceBroker under the hood uses another component - the Registry, but I will not dwell on it, for the acquaintance we do not need it. <br><br>  Having a broker gives us an extremely convenient piece.  Now I will try to explain, but I will have to step aside a little.  In the context of the framework, there is such a thing as node.  In simple language, a node is a process in the operating system (i.e., what happens when we enter ‚Äúnode index.js‚Äù in the console, for example).  Each node is a ServiceBroker with a set of one or more microservices.  Yes, you heard right.  We can compose our stack of services as we please.  What is convenient?  For development, we start one node, in which all microservices are started at once (1 piece each), just one process in the system with the ability to very easily connect hotreload, for example.  In the production - a separate node for each instance of the service.  Well, either a mix, when a part of services is in one node, a part is in another, and so on (although I don‚Äôt know why, just to understand that you can do this too). <br><br><div class="spoiler">  <b class="spoiler_title">Here is our index.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { resolve } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { ServiceBroker } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'moleculer'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> config = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./moleculer.config.js'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { SERVICES, NODE_ENV, } = process.env; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> broker = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ServiceBroker(config); broker.loadServices( resolve(__dirname, <span class="hljs-string"><span class="hljs-string">'services'</span></span>), SERVICES ? <span class="hljs-string"><span class="hljs-string">`*/@(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${SERVICES.split(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">','</span></span></span></span><span class="hljs-string"><span class="hljs-subst">).map(i =&gt; i.trim()).join(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'|'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">).service.js`</span></span> : <span class="hljs-string"><span class="hljs-string">'*/*.service.js'</span></span>, ); broker.start().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NODE_ENV === <span class="hljs-string"><span class="hljs-string">'development'</span></span>) { broker.repl(); } });</code> </pre><br></div></div><br>  In the absence of an environment variable, all services from the directory are loaded, otherwise by mask.  By the way, broker.repl () is another handy feature of the framework.  When starting in development mode, we immediately, in the console, have an interface for calling methods (what you would do, for example, through postman in your microservice that communicates via http), only here it is much more convenient: the interface in the same console where npm start was performed. <br><br><h2>  Interservice interaction </h2><br>  It is carried out in three ways: <br><br><h4>  call </h4><br>  Most commonly used.  Made a request, received an answer (or error). <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// –ú–µ—Ç–æ–¥ —Å–µ—Ä–≤–∏—Å–∞ "report", –∫–æ—Ç–æ—Ä—ã–π –≤—ã–∑—ã–≤–∞–µ—Ç –º–µ—Ç–æ–¥ —Å–µ—Ä–≤–∏—Å–∞ "csv". async getCsvReport({ jobId }) { const rows = []; // ... return this.broker.call('csv.stringify', { rows }); }</span></span></code> </pre><br><h4>  emit </h4><br>  It is used when we just want to notify other services about an event, but we don‚Äôt need a result. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// –ú–µ—Ç–æ–¥ —Å–µ—Ä–≤–∏—Å–∞ "user" —Ç—Ä–∏–≥–≥–µ—Ä–∏—Ç —Å–æ–±—ã—Ç–∏–µ –æ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏. async registerUser({ email, password }) { // ... this.broker.emit('user_registered', { email }); return true; }</span></span></code> </pre><br>  Other services can subscribe to this event and respond accordingly.  Optionally, the third argument, you can explicitly specify the services that can receive this event. <br><br>  The important point is that the event will receive only one instance of each type of service, i.e.  if we have 10 ‚Äúmail‚Äù and 5 ‚Äúsubscription‚Äù services that are subscribed to this event, then in fact only 2 copies will receive it - one ‚Äúmail‚Äù and one ‚Äúsubscription‚Äù. <br><br><h4>  broadcast </h4><br>  The same as emit, but without restrictions.  All 10 ‚Äúmail‚Äù and 5 ‚Äúsubscription‚Äù services will catch this event. <br><br><h2>  Validation of parameters </h2><br>  By default, for validation of parameters it is used by <a href="https://www.npmjs.com/package/fastest-validator">fastest-validator</a> , it seems as very fast.  But nothing prevents you from using any other, for example, the same joi, if you need more advanced validation. <br><br>  When we write a service, we inherit from the base class Service, we declare business logic methods in it, but these methods are ‚Äúprivate‚Äù, they cannot be called from the outside (from another service) until we explicitly want to, declaring them in special section of actions during service initialization (public methods of services in the context of the framework are called actions). <br><br><div class="spoiler">  <b class="spoiler_title">Example method declaration with validation</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(broker) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(broker); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.parseServiceSchema({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'job'</span></span>, <span class="hljs-attr"><span class="hljs-attr">actions</span></span>: { <span class="hljs-attr"><span class="hljs-attr">update</span></span>: { <span class="hljs-attr"><span class="hljs-attr">params</span></span>: { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">convert</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">empty</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">optional</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-attr"><span class="hljs-attr">data</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'object'</span></span>, <span class="hljs-attr"><span class="hljs-attr">optional</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, }, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> handler(ctx) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.update(ctx.params); }, }, }, }); } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> update({ id, name, data }) { <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre><br></div></div><br><h2>  Mixins </h2><br>  Used, for example, to initialize connections to databases.  Avoid duplication of code from service to service. <br><br><div class="spoiler">  <b class="spoiler_title">Mixin example for initializing connection to Redis</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Redis = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'ioredis'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ key = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'redis'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, options } = {}</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">settings</span></span>: { [key]: options, }, created() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[key] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Redis(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.settings[key]); }, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> started() { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[key].connect(); }, stopped() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[key].disconnect(); }, });</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">The use of mixin in the service</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Service, Errors } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'moleculer'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> redis = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../../mixins/redis'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../../mixins/server'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./router'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { REDIS_HOST, REDIS_PORT, REDIS_PASSWORD, } = process.env; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> redisOpts = { <span class="hljs-attr"><span class="hljs-attr">host</span></span>: REDIS_HOST, <span class="hljs-attr"><span class="hljs-attr">port</span></span>: REDIS_PORT, <span class="hljs-attr"><span class="hljs-attr">password</span></span>: REDIS_PASSWORD, <span class="hljs-attr"><span class="hljs-attr">lazyConnect</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(broker) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(broker); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.parseServiceSchema({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'auth'</span></span>, <span class="hljs-attr"><span class="hljs-attr">mixins</span></span>: [redis({ <span class="hljs-attr"><span class="hljs-attr">options</span></span>: redisOpts }), server({ router })], }); } }</code> </pre> <br></div></div><br><h2>  Caching </h2><br>  Method calls (actions) can be cached in several ways: LRU, Memory, Redis.  Optionally, you can specify by what key calls will be cached (by default, object hash is used as the caching key) and with which TTL. <br><br><div class="spoiler">  <b class="spoiler_title">Example of cached method declaration</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InventoryService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(broker) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(broker); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.parseServiceSchema({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'inventory'</span></span>, <span class="hljs-attr"><span class="hljs-attr">actions</span></span>: { <span class="hljs-attr"><span class="hljs-attr">getInventory</span></span>: { <span class="hljs-attr"><span class="hljs-attr">params</span></span>: { <span class="hljs-attr"><span class="hljs-attr">steamId</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">pattern</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/^76\d{15}$/</span></span> }, <span class="hljs-attr"><span class="hljs-attr">appId</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">integer</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-attr"><span class="hljs-attr">contextId</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">integer</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, }, <span class="hljs-attr"><span class="hljs-attr">cache</span></span>: { <span class="hljs-attr"><span class="hljs-attr">keys</span></span>: [<span class="hljs-string"><span class="hljs-string">'steamId'</span></span>, <span class="hljs-string"><span class="hljs-string">'appId'</span></span>, <span class="hljs-string"><span class="hljs-string">'contextId'</span></span>], <span class="hljs-attr"><span class="hljs-attr">ttl</span></span>: <span class="hljs-number"><span class="hljs-number">15</span></span>, }, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> handler(ctx) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }, }, }, }); } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br></div></div><br>  The caching method is set via the ServiceBroker config. <br><br><h2>  Logging </h2><br>  Here, however, everything is also quite simple.  There is a fairly good built-in logger that writes to the console, it is possible to set custom formatting.  Nothing prevents you from stealing up any other popular logger, be it winston or bunyan.  Detailed manual is in the <a href="https://moleculer.services/docs/0.13/logging.html">documentation</a> .  Personally, we use the built-in logger, in the prod, the custom formatter is simply truncated for a couple of lines of code that spam into the JSON console, after which they get into the graylog with the help of the driver‚Äôs driver log. <br><br><h2>  Metrics </h2><br>  If you wish, you can collect metrics for each method and treys it all in some zipkin.  It is configured, as well as caching, when a method (action) is declared. <br><br><h2>  Fault tolerance </h2><br>  The framework has a built-in circuit-breaker, which is controlled through the ServiceBroker settings.  If any service fails and the number of these failures exceeds a certain threshold, then it will be marked as unhealthy, requests to it will be severely limited, until it ceases to throw errors. <br><br>  As a bonus, there is also a fallback that can be customized individually for each method (action), if we assume that the method can fail and, for example, give cached data or a stub. <br><br><h2>  Conclusion </h2><br>  The introduction of this framework for me was a breath of fresh air, eliminated from a huge amount of smut (except for microservice architecture is one big smut) and cycling, made writing the next microservice simple and transparent.  There is nothing superfluous in it, it is simple and very flexible, and you can write the first service in an hour or two after reading the documentation.  I would be glad if this material will be useful to you and in your next project you will want to try this miracle, as we did (and have never regretted it).  All good! </div><p>Source: <a href="https://habr.com/ru/post/439810/">https://habr.com/ru/post/439810/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
</ul></nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>