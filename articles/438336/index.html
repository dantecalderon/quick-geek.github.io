<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Automated Smart Contract Audit Guide. Part 1: Preparing for an Audit</title>
  <meta name="description" content="Introduction 


 Our company is engaged in auditing the security of smart contracts, and the use of automated tools is very serious. How much they can...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Automated Smart Contract Audit Guide. Part 1: Preparing for an Audit</h1><div class="post__text post__text-html js-mediator-article"><h2 id="vvedenie">  Introduction </h2><br><p>  Our company is engaged in auditing the security of smart contracts, and the use of automated tools is very serious.  How much they can help in identifying suspicious places, what is worth using them, what they can do and what are the specifics of work in this area?  These and related questions are the subject of this article.  And the material will be attempts to work with real contracts with the help of the most interesting representatives and recipes for the launch of this extremely disparate and wildly interesting software.  At first I wanted to make one article, but after some time the amount of information became too large, so it was decided to make a cycle of articles, one for each autoanalyzer.  A list from which we will take tools is presented, for example, <a href="https://consensys.github.io/smart-contract-best-practices/security_tools/">here</a> , but if during the writing other interesting tools are found, I will gladly describe and test them. </p><a name="habracut"></a><br><p>  I must say that the audit tasks turned out to be extremely interesting, since  so far, developers have not paid much attention to the economic aspects of algorithms, and internal optimization.  And the audit of smart contracts added some interesting attack vectors that need to be considered when searching for errors.  Also, as it turned out, quite a lot of tools for automatic testing appeared: static analyzers, bytecode analyzers, fuzzers, parsers and many other good software. </p><br><p>  The purpose of the article: to promote the spread of secure contract codes and allow developers to quickly and easily get rid of the stupid bugs that are often the most offensive.  When the protocol itself is completely reliable, and solves a serious problem, the presence of a stupid mistake, forgotten during the testing phase, can seriously ruin a project‚Äôs life.  Therefore, let us learn how to use, at a minimum, tools that allow ‚Äúlittle blood‚Äù to get rid of well-known problems. </p><br><p>  Looking ahead, I must say that the most frequently encountered critical bugs that we encountered in audits are still logical implementation problems, and not typical vulnerabilities, such as access rights, integer overflow, reentrancy.  A large, full audit of solutions is impossible without experienced developers who are able to audit the high-level logic of contracts, their lifecycle, aspects of actual operation and compliance with the task, and not just typical attack patterns.  It is high-level logic that often becomes a source of critical bugs. </p><br><p>  But warnings, typical holes and mistakes left out of carelessness that should not be missed - the lot of automatic analyzers, they should cope with these tasks better than people.  It is this thesis and will be subjected to verification. </p><br><h2 id="osobennosti-audita-koda-smart-kontraktov">  Features of the audit of the code of smart contracts </h2><br><p>  Smart contract code auditing is a fairly specific area.  Despite its small size, a smart contract in Ethereum is a full-fledged program, capable of organizing complex branches, cycles, decision trees, and even to automate seemingly simple transactions require thinking through all possible branches at every step.  From this point of view, blockchain development is extremely low-level, very resource-intensive and extremely reminiscent of the development of system and embedded software in C / C ++ and assembly languages.  That is why we love to see at interviews of developers of low-level algorithms, network stack, high-load services, all who dealt with low-level optimization and code auditing. </p><br><p>  From the developer's point of view, Solidity is also quite specific, although it is easy to read by almost any programmer and in the first steps it seems extremely simple.  Solidity code is fairly easy to read; it is familiar to any developer who owns C / C ++ syntax and OOP, such as JavaScript. </p><br><p>  Here, the simplicity of the code is the key to survival, nothing heavy works, so the whole arsenal of low-level development is used in the work ‚Äî algorithms that allow efficient use of resources and save memory: Merkle trees, Bloom filters, ‚Äúlazy‚Äù loading resources, expanding cycles, manual garbage collection and much more. <br>  A small amount of source code and the resulting bytecode. </p><br><p>  A separate smart contract is limited by the volume of the byte-code, each byte costs some amount of gas, and the maximum is limited from above, so you can push about 10Kb into the blockchain (at the moment), it will not work anymore.  <a href="https://hackernoon.com/costs-of-a-real-world-ethereum-contract-2033511b3214">Here's a good article on how much it costs to deploy a contract and how much gas it costs</a> .  Therefore, a lot of stuff will not succeed.  If you exaggerate, then a few thousand lines of ‚Äúaverage‚Äù code is the maximum.  Several dozen methods, the absence of aggregation and generally complex logic is extremely characteristic of contracts.  All that does not fit, requires you to isolate the code in separate libraries, change and complicate the order of calculations in the network.  Solidity developers may be happy to shove a bunch of code into one contract, but simply have to arrange their contract systems correctly, creating separate library classes with their own storage.  And such separate ‚Äúclasses‚Äù are conveniently laid out in separate files, and, therefore, it is quite pleasant to read the contract code, everything is quite well structured initially - otherwise it will not work.  As an example, I <a href="https://github.com/OpenZeppelin/openzeppelin-solidity/tree/master/contracts/token/ERC721">recommend to look at how ERC721 is made in openzeppelin-solidity</a> . </p><br><h3 id="gaz-gaz-gaz">  Gas, gas, gas </h3><br><p>  Gas introduces an additional layer of logic into the execution of the contract code, which requires an audit.  Moreover, unlike the traditional code, one and the same code segment can spend different amounts of gas.  A table of EVM opcodes and their cost is useful for understanding gas limitations, <a href="https://github.com/trailofbits/evm-opcodes">here it is</a> . </p><br><p>  To demonstrate why it is necessary to devote a lot of time to evaluating gas, consider such a piece of pseudo code (of course unreal, bullet in the cycle with ether is a bad idea): </p><br><pre><code class="plaintext hljs">// —Ñ—É–Ω–∫—Ü–∏—è –ø—Ä–æ—Å—Ç–æ –∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç –∫–æ–¥ —Å–æ–±—ã—Ç–∏—è –¥–ª—è –∞–∫–∫–∞—É–Ω—Ç–∞ –≤ –±–ª–æ–∫—á–µ–π–Ω function fixSomeAccountAction(uint _actionId) public onlyValidator { // ‚Ä¶ events[msg.sender].push(_actionId); } // —é–∑–µ—Ä –¥–µ—Ä–≥–∞–µ—Ç —Ñ—É–Ω–∫—Ü–∏—é, –∫–æ—Ç–æ—Ä–∞—è —Å—É–º–º–∏—Ä—É–µ—Ç –Ω–∞–≥—Ä–∞–¥—ã –∑–∞ –∫–∞–∂–¥—ã–π —Ç–∏–ø –¥–µ–π—Å—Ç–≤–∏—è –∏ –≤—ã–ø–ª–∞—á–∏–≤–∞–µ—Ç –Ω–∞–≥—Ä–∞–¥—É function receivePaymentForSavedActions() { // ... for (uint256 i = 0; i &lt; events[msg.sender].length; i++) { // –±–µ—Ä–µ–º actionId –∏–∑ –º–∞—Å—Å–∏–≤–∞ uint actionId = events[msg.sender][i]; // –≤—ã—á—Å–ª—è–µ–º –Ω–∞–≥—Ä–∞–¥—É –∑–∞ –¥–∞–Ω–Ω—ã–π –≤–∏–¥ action uint payment = getPriceByEventId(actionId); if (payment &gt; 0) { paymentAccumulators[msg.sender] += payment; } emit LogEventPaymentForAction(msg.sender, actionId, payment); // ‚Ä¶ // delete ‚Äúevents[msg.sender][i]‚Äù from array } }</code> </pre> <br><p>  the fact is that the cycle in the contract is executed events [msg.sender] .length times, and each iteration is an entry in the blockchain (transfer () and emit ()).  If the length of the array is small, then the cycle works a dozen times, handing out payment for each action.  But, if the array of events [msg.sender] is large, then there will be a lot of iterations and the gas spent will be rested against the hard-boiled maximum gas limit (~ 8,000,000).  The transaction will fall, and now it will never work out, since there is no way to reduce the length of the array events [msg.sender] in the contract.  If a cycle does not just calculate a single unit value, but writes to the blockchain (for example, some commissions, payments for actions are paid), then the allowed number of iterations is quite substantially limited.  Judge for yourself - limit: 8 000 000, record of new 256-bit value: 20 000. Ie  you can save or update metadata only for a couple of hundreds of 256-bit addresses with some metadata. Another fun thing is that the new value entry: 20,000, and the update of the existing one: 5,000, so even with your contract environment completely identical, when you make a transfer Tokens for an address where there are already tokens, you spend on recording 4 times less gas (5,000 vs 20,000). </p><br><p>  Therefore, do not be surprised that the issue of gas in smart contracts is so closely related to the security of contracts, because the situation when funds are stuck in a contract for all practical purposes is not much different from the situation when they were stolen.  The fact that the ADD instruction costs 3 gas, and SSTORE (saving to storage): 20,000 says that the most expensive resource in the blockchain is storage, and the problems of contract code optimization are in many ways aligned with the low-level development tasks in C and ASM for embedded. systems, where storage is also a very limited resource. </p><br><h3 id="prekrasnyy-blokcheyn">  Beautiful blockchain </h3><br><p>  This is a very positive paragraph about why the blockchain is so good from a security point of view for the auditor.  Determinism of execution of a contract code is the key to successful debugging and reproducing bugs and vulnerabilities.  Technically, any call to a contract code can be replicated on any platform up to a bit, it allows tests to work everywhere and be extremely simple to support, and incident investigation reliable and undeniable.  Now we always know who called which function, with which parameters, which code processed it, and what the result was.  All this is completely deterministic, i.e.  reproduced anywhere, even in JS on a web page.  If we talk about Ethereum, then any test case is extremely easy to write in convenient JavaScript, including fuzzing parameters, and works great anywhere where there are Node.js. </p><br><p>  All these beautiful words, however, should not relax the developers, because, as mentioned above, the most serious mistakes are logical, and for them the determinism of execution is an orthogonal property. </p><br><h2 id="okruzhenie-dlya-sborki-kontrakta">  Contract Build Environment </h2><br><p>  To write an article, I took an old experimental contract for booking housing from the Smartz designer: <a href="https://github.com/smartzplatform/constructor-eth-booking">https://github.com/smartzplatform/constructor-eth-booking</a> .  The contract allows you to create a record of the object (apartment or hotel room), set the price and the date of delivery, after which the contract waits for payment and, if received, records the booking act, keeping the funds on the balance until the guest enters the room and will not confirm entry.  At this point, the owner of the number gets paid.  The contract is essentially a state machine, the state and transitions of which can be viewed on Booking.sol.  We did it pretty quickly, changed the development process and did not have time to do a lot of tests, it is far from a new version of the compiler and more or less rich internal logic.  So let's see how the analyzers deal with it, what errors they find, and, if necessary, add our own. </p><br><h3 id="rabota-s-raznymi-versiyami-solc">  Work with different versions of solc </h3><br><p>  Different analyzers will have to be used differently - some are launched from the docker, others use ready-made compiled byte-code, and the auditor itself also has to deal not with a pair, but with dozens of contracts with different versions of the compiler.  Therefore, different versions of <code>solc</code> need to be able to ‚Äúpodsovyvat‚Äù in different ways, and in the host system, and inside the docker-image, and inside the truffle, so I‚Äôll give these several options for dirty hacks: </p><br><p>  1 way: inside the truffle </p><br><p>  For this, no tricks are needed, because  since truffle version 5.0.0, you can specify the version of the compiler directly in truffle.js, as in <a href="https://github.com/smartzplatform/constructor-eth-booking/commit/62b0628b60de53e9267426ee92dae423878bd852">this diff</a> . </p><br><p>  Now truffle will download the necessary compiler itself and run it.  Many thanks to the team for this, Solidity is young, changes in the language are serious, and moving from version to version for the auditor is unacceptable - this way you can make new mistakes and disguise the old ones. </p><br><p>  2 way: replacing / usr / bin / solc in the analyzer docker container <br>  If the analyzer is distributed as a Dockerfile, you can replace it when building a docker image by adding a line to the Dockerfile that takes the <code>solc</code> required version directly from the image, which pulls out of the network and replaces / usr / bin / solc: </p><br><pre> <code class="plaintext hljs">COPY --from=ethereum/solc:0.4.19 /usr/bin/solc /usr/bin</code> </pre> <br><p>  3 way: replacing / usr / bin / solc </p><br><p>  The dirtiest way to the forehead, if there is no way out at all, you can despicably replace the / usr / bin / solc binary with a script like this (remember to save the original file): </p><br><pre> <code class="plaintext hljs">#!/bin/bash # run Solidity compiler of given version, pass all parameters # you can run ‚ÄúSOLC_DOCKER_VERSION=0.4.20 solc --version‚Äù SOLC_DOCKER_VERSION="${SOLC_DOCKER_VERSION:-0.4.24}" docker run \ --entrypoint "" \ --tmpfs /tmp \ -v $(pwd):/project \ -v $(pwd)/node_modules:/project/node_modules \ -w /project \ ethereum/solc:$SOLC_DOCKER_VERSION \ /usr/bin/solc \ "$@"</code> </pre> <br><p>  It downloads and caches the docker image with the correct <code>solc</code> version, switches to the current directory, and starts <code>/usr/bin/solc</code> with the parameters passed.  Not a very good way, but perhaps for some tasks, it will suit you. </p><br><h3 id="flattening-code">  Flattening code </h3><br><p>  Now we will deal with source codes.  Of course, in theory, autoanalyzers (especially for static source code analysis) should collect a contract, pull up all dependencies, put everything together in one monolith and analyze it.  But, as I have already said, changes from version to version can be serious, and I constantly stumbled upon the need to add an additional directory to the docker, configure it inside the path, and all this so that he correctly pulled up the necessary imports.  Some analyzers understand everything, the latter are not, therefore, it is more convenient for a analyzer to eat a single file to merge everything into one file and analyze only it, as a universal option so that you don‚Äôt have to worry. </p><br><p>  For this, use a <a href="https://github.com/nomiclabs/truffle-flattener">regular truffle-flattener</a> . </p><br><p>  This is the standard npm module, used very simply: </p><br><pre> <code class="bash hljs">truffle-flattener contracts/Booking.sol &gt; contracts/flattened.sol</code> </pre> <br><p>  : <a href="https://github.com/trailofbits/slither">https://github.com/trailofbits/slither</a> <br>  If you need to customize flattening somehow, you can write your flattener, for example, before we used the python-based option: <a href="https://github.com/mixbytes/solidity-flattener">https://github.com/mixbytes/solidity-flattener</a> </p><br><h2 id="nachnem-analiz">  Let's start the analysis. </h2><br><p>  Using the example of the old man <a href="https://github.com/smartzplatform/constructor-eth-booking">https://github.com/smartzplatform/constructor-eth-booking, we</a> will continue the analysis.  The contract has an old version of the compiler ‚Äú0.4.20‚Äù, and I deliberately took the old contract to solve problems with the compiler.  Worse the situation is that the auto-analyzer, for example, studying byte-code, may depend on this version of solc, and here the discrepancies in the versions can greatly affect the results or even break everything.  so if even if you are doing everything kosher, using the latest versions, you can still fly to the analyzer, sharpened by the previous version of the compiler. <br>  Compiling and running tests </p><br><p>  To get started, just pull the project from the github and try to compile: </p><br><pre> <code class="plaintext hljs">git clone https://github.com/smartzplatform/constructor-eth-booking.git cd constructor-eth-booking npm install truffle compile</code> </pre> <br><p>  Surely you have a problem with the compiler version.  And there are also problems with autoanalyzers, so use any means to get the compiler 0.4.20 and build the project.  I just registered the correct version of the compiler in truffle.js and it all came together as above. </p><br><p>  Also run </p><br><pre> <code class="bash hljs">truffle-flattener contracts/Booking.sol &gt; contracts/flattened.sol</code> </pre> <br><p>  as mentioned in the paragraph about flattening, we will be giving <code>contracts/flattened.sol</code> to different analyzers for analysis <br>  Conclusion to the introductory part </p><br><p>  Now, having flattened.sol and the ability to use a <code>solc</code> arbitrary version, you can begin the analysis.  I will omit the problems with running truffle and tests, there is a lot of documentation on this subject, sort it out yourself.  Of course, tests must be run and successfully run.  Also, in order to check the logic, the auditor often has to add his own tests, checking potentially leaky places, for example, checking the functionality of a contract at the boundaries of arrays, covering all variables, even those strictly intended for data storage, with tests, etc.  There are many recommendations here, and besides this is just the product that our company supplies to the market, so the study of logic is a purely human task. </p><br><p>  We will go to analyzers that are interesting from our point of view, try to slip our contract with them, and artificially introduce vulnerabilities into it in order to evaluate how autoanalyzers react to them.  The next article will be devoted to the Slither analyzer, but in general, the action plan is approximately as follows: </p><br><p>  Part 1. Introduction.  Compilation, flattening, Solidity versions (this article) <br>  Part 2. <a href="https://habr.com/ru/post/438338/">Slither</a> <br>  Part 3. Mythril <br>  Part 4. Manticore <br>  Part 5. Echidna <br>  Part 6. Unknown tool 1 <br>  Part 7. Unknown tool 2 </p><br><p>  Such a set of analyzers turned out because it is important for an auditor to be able to use different types of analysis - static and dynamic, and for their implementation completely different approaches are required.  Our task is to learn how to use the basic tools in each type of analysis and understand which one to use. </p><br><p>  Perhaps in the process of detailed research, there will be new candidates for consideration, or the order of articles will change, so stay tuned.  To go to the next part, <a href="https://habr.com/ru/post/438338/">click here.</a> </p></div><p>Source: <a href="https://habr.com/ru/post/438336/">https://habr.com/ru/post/438336/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>