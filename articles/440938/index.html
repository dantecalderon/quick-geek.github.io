<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why did Google need a knowledge graph</title>
  <meta name="description" content="When I introduce myself and say what our startup does, my interlocutor immediately has a question: have you worked on Facebook before, or has your dev...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Why did Google need a knowledge graph</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/_b/5j/ed/_b5jedmpncy6tkfvqbhqc_jd6zi.png" align="left" width="280">  When I introduce myself and say what our startup does, my interlocutor immediately has a question: have you worked on Facebook before, or has your development been influenced by Facebook?  Many are aware of Facebook‚Äôs efforts to maintain its social graph, because the company has published <a href="https://www.facebook.com/notes/facebook-engineering/tao-the-power-of-the-graph/10151525983993920/">several</a> <a href="https://code.fb.com/data-infrastructure/dragon-a-distributed-graph-query-engine/">articles</a> about the infrastructure of this graph, which it has carefully constructed. <br><br>  Google talked about <a href="https://en.wikipedia.org/wiki/Knowledge_Graph">its knowledge graph</a> , but nothing about the internal infrastructure.  However, the company also has specialized subsystems for it.  In fact, now a lot of attention is paid to the knowledge column.  Personally, I put at least two of my promotions on this horse - and began work on a new graph back in 2010. <br><a name="habracut"></a><br>  <b>Google needed to build the infrastructure</b> not only to serve the complex relationships in the Knowledge Graph, but also to support all the <a href="https://en.ryte.com/wiki/Google_OneBox">OneBox</a> thematic blocks in search results that have access to structured data.  Infrastructure is necessary for 1) qualitative circumvention of facts with 2) sufficiently high throughput and 3) low enough latency to get into a good share of search queries on the web.  It turned out that no available system or database can perform all three actions. <br><br>  Now that I have told you why the infrastructure is needed, the rest of the article will tell you about my experience in building such systems, including for the <a href="https://en.wikipedia.org/wiki/Knowledge_Graph">Knowledge Graph</a> and <a href="https://en.ryte.com/wiki/Google_OneBox">OneBox</a> . <br><br><h1>  How do I know this? </h1><br>  Briefly introduce myself.  I worked at Google from 2006 to 2013.  First as a trainee, then as a software engineer in the web search infrastructure.  In 2010, Google <a href="https://techcrunch.com/2010/07/16/google-acquires-metaweb-to-make-search-smarter/">acquired Metaweb</a> , and my team just launched <a href="https://googleblog.blogspot.com/2010/06/our-new-search-index-caffeine.html">Caffeine</a> .  I wanted to do something else - and started working with the guys from Metaweb (in San Francisco), spending time traveling between San Francisco and Mountain View.  I wanted to figure out how to use the knowledge graph to improve the web search. <br><br>  Google has had such projects before me.  It is noteworthy that the project called <a href="https://en.wikipedia.org/wiki/Google_Squared">Squared was</a> created in the New York office, and there was some talk about Knowledge Cards.  Then there were sporadic efforts of individuals / small teams, but at that time there was no established command chain, which ultimately led me to leave Google.  But let's come back to this later ... <br><br><h1>  Metaweb History </h1><br>  As mentioned, Google acquired Metaweb in 2010.  Metaweb built a high-quality knowledge graph using several techniques, including cracking and parsing Wikipedia, as well as crowdsourcing editing system in a wiki-style using <a href="https://developers.google.com/freebase/">Freebase</a> .  All this worked on Graphd's own graph database graph database, the graph daemon (now <a href="https://github.com/google/graphd">published</a> on GitHub). <br><br>  Graphd had some fairly typical properties.  As a demon, he worked on the same server, kept all the data in memory and could issue the whole Freebase site.  After buying Google put one of the tasks to continue working with Freebase. <br><br>  <b>Google built an empire on standard hardware and distributed software.</b>  A single server database could never serve both crawling, indexing, and search results.  First created SSTable, then Bigtable, which horizontally scales to hundreds or thousands of machines that collectively serve petabytes of data.  The machines are allocated by Borg ( <a href="https://kubernetes.io/">K8</a> appeared from here), they communicate via Stubby (gRPC appeared from here) with IP address rezolving via the Borg name service (BNC inside K8) and store data in Google File System ( <a href="https://en.wikipedia.org/wiki/Google_File_System">GFS</a> , you can say Hadoop FS).  <i>The processes may die, the machines may break, but the system as a whole is unkillable and continues to buzz.</i> <br><br>  In such an environment got Graphd.  The idea of ‚Äã‚Äãa database serving a whole website on one server is alien to Google (including me).  In particular, Graphd required 64 GB or more of memory.  If it seems to you that this is a bit, remember: this is 2010.  Most Google servers were equipped with a maximum of 32 GB.  In fact, Google had to purchase special machines with enough RAM to serve Graphd in its current form. <br><br><h3>  Graphd replacement </h3><br>  Brainstorming started, how to move Graphd data or rewrite the system to work in a distributed way.  But, you see, graphs are complex.  This is not a key-value database for you, where you can simply take a piece of data, move it to another server and issue it when a key is requested.  Counts perform efficient unions and detours that require the software to work in a certain way. <br><br>  One idea was to use a project called MindMeld (IIRC).  It was assumed that the memory from another server will be available much faster through the network equipment.  It had to work faster than regular RPCs, fast enough to pseudo-replicate direct memory access required by the in-memory database.  But the idea did not go too far. <br><br>  Another idea that actually became a project was to create a truly distributed graph service system.  Something that can not only replace Graphd for Freebase, but also really work in production.  <b>It was called Dgraph - a distributed graph, inverted from Graphd (graph-demon).</b> <br><br>  If you are interested, then yes.  My startup Dgraph Labs, the company and the open source project Dgraph are named after the project at Google (note: Dgraph is a trademark of Dgraph Labs; as far as I know, Google does not release projects with names that coincide with internal ones). <br><br>  In almost all the rest of the text, when I mention Dgraph, I mean the internal Google project, not the open source project we created.  But more about <i>that</i> later. <br><br><h1>  Cerebro history: knowledge engine </h1><br>  <i>Creating inadvertently infrastructure for graphs</i> <br><br>  Although I was generally aware of Dgraph's attempts to replace Graphd, my goal was to create something to improve the web search.  In Metaweb, I met a DH research engineer who created <a href="https://blog.dgraph.io/refs/freebase-cubed.pdf">Cubed</a> . <br><br>  As I mentioned, a motley group of engineers from the New York subdivision developed Google <a href="https://en.wikipedia.org/wiki/Google_Squared">Squared</a> .  But the DH system was <i>much</i> better.  I started thinking how to embed it in Google.  Google had puzzle pieces that I could easily use. <br><br>  The first part of the puzzle is the search engine.  This is a way to determine with a high degree of accuracy which words are related to each other.  For example, when you see a phrase like [tom hanks movies], she can tell you that [tom] and [hanks] are related to each other.  Similarly, from [san francisco weather] we see the connection between [san] and [francisco].  These are obvious things for people, but not so obvious for cars. <br><br>  The second part of the puzzle is understanding grammar.  When in the query [books by french authors], the machine can interpret it as [books] from [french authors], i.e. the books of those authors who are French.  But she can also interpret this as [french books] from [authors], i.e. books in French of any author.  I used <a href="https://nlp.stanford.edu/software/tagger.shtml">Part-Of-Speech</a> (POS) tegger from Stanford University to better understand the grammar and build the tree. <br><br>  The third part of the puzzle is the understanding of entities.  [french] can mean a lot.  This may be a country (region), nationality (belonging to the French people), cuisine (relating to food) or language.  Here I applied another system to get a list of entities that can correspond to a word or phrase. <br><br>  The fourth part of the puzzle was to understand the relationship between entities.  When it is known how to link words into phrases, in which order the phrases should be executed, that is, their grammar, and to which entities they can match, it is necessary to find relationships between these entities in order to create machine interpretations.  For example, we run the query [books by french authors], and POS says that it is [books] from [french authors].  We have several entities for [french] and several entities for [authors]: the algorithm must determine how they are related.  For example, they may be related by place of birth, that is, authors who were born in France (although they can write in English).  Or it may be authors who are French citizens.  Or authors who may speak or write French (but may not be related to France as a country), or authors who simply love French cuisine. <br><br><h1>  The system of graphs on the search index </h1><br>  To determine whether there is a connection between objects and how they are related, a graph system is needed.  Graphd was never going to scale to Google, but you could use the search itself.  Knowledge Graph data is stored in <a href="https://www.w3.org/TR/rdf-concepts/">Triples</a> triples format, that is, each fact is represented in three parts: the subject (entity), the predicate (relation) and the object (other entity).  Requests go as <code>[SP] ‚Üí [O]</code> or <code>[PO] ‚Üí [S]</code> , and sometimes <code>[SO] ‚Üí [P]</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/29f/324/29b/29f32429b78e9fc1387deda24e3fc986.png"><br><br>  <b>I used the Google search index</b> , assigned a docid to each three, and built three indexes, one for S, P, and O. In addition, the index allows attachments, so I added information about the type of each entity (i.e. actor, book, person, and etc.) <br><br>  <i>I made such a system, although I saw a problem with the depth of associations (which is explained below) and it is not suitable for complex queries.</i>  <i>Actually, when someone from the Metaweb team asked me to publish a system for colleagues, I refused.</i> <br><br>  To determine the relationship, you can see how many results each query gives.  For example, how many results give [french] and [author]?  We take these results and see how they are related to [books], etc. So a lot of machine interpretations of the query appeared.  For example, the query [tom hanks movies] generates a variety of interpretations, such as [movies directed by tom hanks], [movies starring tom hanks], [movies produced by tom hanks], but automatically rejects interpretations like [movies named tom hanks]. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/50b/a4a/424/50ba4a424adfac5ada59b3c9ea29a82c.png"><br>  Each interpretation generates a list of results ‚Äî valid entities on the graph ‚Äî and also returns their types (present in the attachments).  This proved to be an extremely powerful function, because understanding the type of results opened up possibilities such as filtering, sorting, or further expansion.  You can sort out the results with movies by year of production, length of the film (short, long), language, awards received, etc. <br><br>  The project seemed so intellectual that we (DH was also partially involved as an expert in the knowledge graph) called it Cerebro, in honor of the eponymous device from the movie <a href="https://en.wikipedia.org/wiki/Cerebro">‚ÄúX-Men‚Äù</a> . <br><br>  <b>Cerebro often uncovered very interesting facts</b> that were not originally in the search query.  For example, on request [US presidents], Cerebro will understand that presidents are people, and people have growth.  This allows presidents to be sorted by height and to show that Abraham Lincoln is the highest president of the United States.  In addition, people can be filtered by nationality.  In this case, America and the United Kingdom appear on the list because the United States had one British president, namely George Washington.  (Disclaimer: the results are based on the state of the knowledge graph at the time of the experiments; I can not vouch for their correctness). <br><br><h1>  Blue links against knowledge </h1><br>  Cerebro was able to really understand user requests.  Having obtained the data for the entire graph, we could generate machine interpretations of the query, generate a list of results, and understand much of these results for further study of the graph.  It was explained above: as soon as the system understands that it deals with films, people or books, etc., certain filters and sorting can be activated.  You can also go around the nodes and show related information: from [US presidents] to [schools they went to] or [children they fathered].  Here are some other queries that the system generated by itself: [female african american politicians], [bollywood actors married to politicians], [children of us presidents], [movies starring tom hanks released in the 90s] <br><br>  DH demonstrated this opportunity to move from one list to another in another project called <a href="https://vimeo.com/1513562">Parallax</a> . <br><br>  Cerebro showed a very impressive result, and Metaweb management supported it.  Even in terms of infrastructure, it was operational and functional.  I called it <b>the knowledge engine</b> (like a search engine).  But on Google, no one was directing this topic specifically.  She was of little interest to my manager, they advised me to talk to one person or another, and in the end I got a chance to demonstrate the system to one very high top search manager. <br><br>  <b>The answer was not the one I hoped for</b> .  When demonstrating the results of the knowledge engine for [books by french authors], he launched a Google search, showed ten lines with blue links, and said that Google could do the same.  In addition, they do not want to take traffic from sites, because they are angry. <br><br>  <i>If you think he's right, think about this:</i> when Google does a search on the Internet, you really don't understand the query.  The system is looking for the right words in the right position, taking into account the weight of the page and so on.  This is a very complex system, but it does not understand either the query or the results.  The user himself does all the work: reading, analyzing, extracting the necessary information from the results and further searches, adding together a complete list of results, etc. <br><br>  For example, for [books by french authors], a person will first try to find an exhaustive list, although there may not be a single page with such a list.  Then sort these books by year of publication or filter by publishers, and so on - all this requires a person to process a large amount of information, numerous searches and results processing.  Cerebro is able to reduce these efforts and make user interaction simple and flawless. <br><br>  But then there was no complete understanding of the importance of the knowledge graph.  The manual was not sure of its usefulness or how to connect it with the search.  <b>This new approach to knowledge is not easy to assimilate to an organization that has achieved such significant success by providing users with links to web pages.</b> <br><br>  For a year, I struggled with a lack of understanding of managers, and eventually gave up.  A manager from the Shanghai office approached me, and I handed him the project in June 2011.  He put on him a team of 15 engineers.  I spent a week in Shanghai, passing on to the engineers everything that I created and what I learned.  DH was also involved in this matter, and he led that team for a long time. <br><br><h1>  Join-depth problem </h1><br>  In the system of work with graphs Cerebro was the problem of the depth of association.  A join is performed when the result of an earlier query is needed to perform a later one.  A typical union includes some <code>SELECT</code> , that is, a filter in certain results from the universal data set, and then these results are used to filter by another part of the data set.  I will explain with an example. <br><br>  Say you want to know [people in SF who eat eat sushi].  All people are assigned some data, including who lives in what city and what food they eat. <br><br>  The above query is a single-level join.  If the application accesses the database, it will make one request for the first step.  Then several requests (one request for each result) to find out what each person eats, choosing only those who eat sushi. <br><br>  The second step suffers from fan-out problems.  If the first step gives a million results (the population of San Francisco), then the second step should give out to everyone on request, asking for their eating habits, and then applying a filter. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/76a/f20/f9e/76af20f9e21b097fed9420f4174ab8ae.png"><br><br>  Engineers of distributed systems usually solve this problem by <i>Broadcast</i> , that is, widespread distribution.  They accumulate relevant results by making one request to each server in the cluster.  This provides a join, but causes problems with the delay of the request. <br><br>  Broadcast does not work well in a distributed system.  This problem is best explained by <a href="https://en.wikipedia.org/wiki/Jeff_Dean_(computer_scientist)">Jeff Dean</a> from Google in his speech ‚ÄúAchieving a Fast Response in Large Online Services‚Äù ( <a href="https://www.youtube.com/watch%3Fv%3D1-3Ahy7Fxsc">video</a> , <a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/44875.pdf">slides</a> ).  Total delay is always greater than the delay of the slowest component.  <b>Small reflections on individual computers cause delays, and the inclusion of many computers in the request dramatically increases the likelihood of delays.</b> <br><br><blockquote>  Consider a server that has a delay of more than 1 ms in 50% of cases, and more than 1 s in 1% of cases.  If the request goes to only one such server, only 1% of responses exceed a second.  But if the request goes to a hundred of these servers, then 63% of the answers exceed a second. </blockquote><br>  Thus, the broadcaster of a single request greatly increases the delay.  Now think, and if you need two, three or more associations?  It is too slow to perform in real time. <br><br>  The problem of fan deployment with query query is typical of most non-native database graphs, including <a href="https://github.com/JanusGraph/janusgraph">graph Janus</a> , <a href="https://blog.twitter.com/engineering/en_us/a/2010/introducing-flockdb.html">Twitter FlockDB,</a> and <a href="https://www.facebook.com/notes/facebook-engineering/tao-the-power-of-the-graph/10151525983993920/">Facebook TAO</a> . <br><br>  Distributed unions are hard problems.  Native graph databases allow you to avoid this problem by saving the universal data set within one server (stand-alone database) and performing all the merges without accessing other servers.  For example, <a href="https://github.com/neo4j/neo4j">Neo4j</a> does this. <br><br><h1>  Dgraph: joins with arbitrary depth </h1><br>  Having completed work on Cerebro and having experience in building a graph service system, I took part in the Dgraph project, becoming one of the three technical project managers.  We applied innovative concepts that solved the problem of the depth of integration. <br><br>  In particular, the Dgraph divides the graph data in such a way that each union can be completely executed by one machine.  Returning to the <code>subject-predicate-object</code> (SPO) <code>subject-predicate-object</code> , each Dgraph instance contains all the subjects and objects corresponding to each predicate in this instance.  In a copy several predicates are stored, and everyone is stored completely. <br><br>  <b>This made it possible to carry out queries with arbitrary depth of associations</b> , eliminating the problem of fan deployment with broadcast.  For example, the query [people in SF who eat sushi] will generate a <i>maximum of two network calls</i> to the database, regardless of the cluster size.  The first challenge will find all the people who live in San Francisco.  The second request will send this list to the intersect with all people who eat sushi.  You can then add additional restrictions or extensions; each step still requires no more than one network call. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/428/283/668/428283668a3ede1b3a7f3b142b648888.png"><br>  This creates a problem of very large predicates on one server, but it can be solved by further separating the predicates between two or more instances as the size increases.  In the worst case, one predicate will split across the cluster.  But this happens only in a fantastic situation, when all the data correspond to only one predicate.  In other cases, this approach allows to significantly reduce the delay in requests in real systems. <br><br>  Charding was not the only innovation in the Dgraph.  All objects were assigned integer identifiers, sorted and saved as a list (posting list) for quick intersection of such lists afterwards.  This allows you to quickly filter during a merge, find common links, etc. It also came in handy ideas from Google search engines. <br><br><h1>  We combine all OneBox blocks through Plasma </h1><br>  <b>Dgraph at Google was not a database</b> .  It was one of the subsystems, besides reacting to updates.  Therefore, it needed indexing.  I had a lot of experience with real-time incremental indexing systems working under <a href="https://googleblog.blogspot.com/2010/06/our-new-search-index-caffeine.html">Caffeine</a> . <br><br>  I started a project to integrate all OneBox within this system of indexing graphs, including weather, flight schedules, events, and so on.  Maybe you do not know the term OneBox, but you definitely saw it - this is a separate window that is displayed when performing certain types of requests, where Google returns richer information.  To see OneBox in action, try [ <a href="https://www.google.com/search%3Fq%3Dweather%2Bin%2Bsf">weather in sf</a> ]. <br><br>  Previously, each OneBox worked on an autonomous backend and was supported by different development teams.  <b>There was a rich set of structured data, but the OneBox blocks did not exchange data with each other.</b>  First, different backends multiplied the labor costs many times.  Secondly, the lack of information sharing limited the range of requests that Google could respond to. <br><br>  For example, [events in SF] could show events, and [weather in SF] could show events.  But if [events in SF] understood that it was rainy weather, they could filter or sort events by the type of "indoors" or "outdoors" ( <i>perhaps it is better to go to the movies in heavy rain than in football</i> ). <br><br>  With the help of the Metaweb command, we started to convert all this data into SPO format and index it with one system.  I called it <b>Plasma, the real-time graph indexing engine</b> for Dgraph maintenance. <br><br><h1>  Leapfrog Management </h1><br>  Like Cerebro, the Plasma project received few resources, but continued to gain momentum.  In the end, when the management realized that the OneBox blocks inevitably belong to our project, they immediately decided to install the <i>‚Äúright people‚Äù</i> to manage the graph system.  At the height of the political game, three leaders changed, each of whom had zero experience working with graphs. <br><br>  During this messy Dgraph, <a href="https://en.wikipedia.org/wiki/Spanner_(database)">Spanner</a> project managers called the Dgraph <i>too complex</i> .  For reference, Spanner is a worldwide distributed SQL database that needs its own GPS clock to ensure global consistency.  <i>The irony of this is still tearing down my roof.</i> <br><br>  Dgraph canceled, Plasma survived.  And at the head of the project they put a new team with a new leader, with a clear hierarchy and accountability to the CEO.  The new team - with a weak understanding of the graphs and related problems - decided to make an infrastructure subsystem based on the existing Google search index (as I did for Cerebro).  I suggested using the system I had already done for Cerebro, but it was rejected.  I modified Plasma to crawl and expand each knowledge node to several levels so that the system could view it as a web document.  They called this system TS ( <i>abbreviation</i> ). <br><br>  <b>This meant that the new subsystem would not be able to perform deep associations.</b>  Again this is a curse that I see in many companies, because engineers start with the wrong idea that ‚Äúgraphs are a simple problem that can be solved simply by building a layer on top of another system‚Äù. <br><br>  A few months later, in May 2013, I left Google, having worked on Dgraph / Plasma for about two years. <br><br><h1>  Afterword </h1><br><ul><li>  A few years later, the Internet Search Infrastructure division was renamed the Internet Search Infrastructure and Knowledge Graph, and the manager, whom I once showed Cerebro, headed the Knowledge Graph direction, telling about how they intend to replace simple blue links Knowledge, as often as possible to directly answer user questions. <br></li><li>  When the team in Shanghai, working on Cerebro, was close to launching it into production, the project was taken from them and sent to the New York subdivision.  In the end, it was launched as the Knowledge Strip.  If you are looking for [ <a href="https://www.google.com/search%3Fq%3Dtom%2Bhanks%2Bmovies">tom hanks movies</a> ], you will see it at the top.  It has improved slightly since the first launch, but still does not support the level of filtering and sorting that was laid in Cerebro. <br></li><li>  All three technical managers who worked on Dgraph (including me) eventually left Google.  As far as I know, the rest are now working in Microsoft and LinkedIn. <br></li><li>  I managed to get two promotions in Google and I had to get the third one when I left the company as a senior software engineer. <br></li><li>  Judging by some fragmentary rumors, the current version of TS is in fact very close to the design of the graph system Cerebro, and each subject, predicate and object has an index.  <b>Therefore, it still suffers from the problem of depth of association.</b> <br></li><li>  Since then, Plasma has been rewritten and renamed, but it continues to work as a real-time indexing system for graphs for TS.  Together, they continue to post and process all structured data on Google, including the Knowledge Graph. <br></li><li>  <b>Google‚Äôs inability to make deep associations is visible in many places.</b>  For example, we still do not see the data exchange between OneBox blocks: [cities by cities does not give out a list of cities, although all data is in the knowledge column (instead, a web page is quoted in search results);  [events in SF] cannot be filtered by weather;  [US presidents] results are not sorted, not filtered, or extended by other facts: their children or the schools where they studied.  I guess this was one of the reasons why <a href="https://developers.google.com/freebase/">Freebase is no</a> longer supporting. </li></ul><br><h1>  Dgraph: phoenix bird </h1><br>  Two years after leaving Google, I decided to <a href="https://github.com/dgraph-io/dgraph">develop a Dgraph</a> .  In other companies, I see the same indecision regarding graphs as in Google.  There were many unfinished solutions in graph space, in particular, many user solutions that were hastily assembled over relational or NoSQL databases, or as one of the many features of multi-model databases.  If there was a native solution, then it suffered from scalability problems. <br><br>  Nothing I saw had a coherent story with a productive, scalable design.  <b>Building a low latency, horizontally scalable graph database with arbitrary depth combining is extremely challenging</b> , and I wanted to make sure that we built the Dgraph correctly. <br><br>  The Dgraph team has spent the last three years not only studying my own experience, but also investing a lot of my own efforts in designing - creating a database of graphs that has no analogues in the market.  Thus, companies have the opportunity to use reliable, scalable and productive solutions instead of another half-finished. </div><p>Source: <a href="https://habr.com/ru/post/440938/">https://habr.com/ru/post/440938/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>