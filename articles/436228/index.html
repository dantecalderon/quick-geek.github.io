<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Developing a team to request data from the database</title>
  <meta name="description" content="Currently engaged in the implementation of interaction with a supplier of KYC services. As usual, nothing cosmic. You just need to select from your da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Developing a team to request data from the database</h1><div class="post__text post__text-html js-mediator-article"><p>  Currently engaged in the implementation of interaction with a supplier of KYC services.  As usual, nothing cosmic.  You just need to select from your database some rather large set of copies of various records, upload them to the service provider and ask the supplier of these records to check. </p><br><p> The initial stage of processing contains a dozen identical operations with sending requests for extracting data of a certain specific user from various tables of the database.  There is an assumption that in this case a sufficiently large part of the code can be reused as an abstraction <code>Request</code> .  I will try to suggest how this could be used.  I will write the first test: </p><a name="habracut"></a><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'Request'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Request = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./Request'</span></span>); it(<span class="hljs-string"><span class="hljs-string">'execute should return promise'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> request = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Request(); request.execute().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { expect(result).toBeNull(); }); }); });</code> </pre> <br><p>  Looks like pretty good?  Perhaps imperfect, but at first glance it seems that <code>Request</code> is essentially a <code>–∫–æ–º–∞–Ω–¥–∞</code> that returns a <code>Promise</code> with the result?  From this it is possible to begin.  I jot down the code so that the test can be run. </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Request</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){} execute(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); }); } } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = Request;</code> </pre> <br><p>  I run the <code>npm test</code> and watch in the console the green dot of the test that was executed. </p><br><p>  So.  I have a request, and he knows how to execute.  In reality, however, I will need to somehow inform my query about which table he should look for the necessary data and what criteria this data must meet.  I'll try to write a new test: </p><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'should configure request'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> options = { <span class="hljs-attr"><span class="hljs-attr">tableName</span></span>: <span class="hljs-string"><span class="hljs-string">'users'</span></span>, <span class="hljs-attr"><span class="hljs-attr">query</span></span>: { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } }; request.configure(options); expect(request.options).toEqual(options); });</code> </pre> <br><p>  Fine?  In my opinion completely.  Since I now have two tests that use an instance of the <code>request</code> variable, I will initialize this variable into a special method that runs before each test is run.  Thus, in each test I will have a fresh instance of the request object: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; beforeEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { request = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Request(); });</code> </pre> <br><p>  I implement this functionality in the query class, add a method to it that saves the settings in a class instance variable, as the test demonstrates. </p><br><pre> <code class="javascript hljs">configure(options){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.options = options; }</code> </pre> <br><p>  I run test execution and now I see two green points.  Two of my tests have been successfully completed.  But.  It is assumed, however, that my queries will be addressed to the database.  Now it is probably worth trying to see from which side the request will receive information about the database.  I will return to the tests and write some code: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DbMock = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./DbMock'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> db = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; beforeEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { db = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DbMock(); request = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Request(db); });</code> </pre> <br><p>  It seems to me that such a classic version of initialization through the constructor fully satisfies my current requirements. </p><br><p>  Naturally, I am not going to use in the unit tests an interface to the real MySQL database with which our project works.  Why?  Because: </p><br><ol><li>  If, instead of me, someone from my colleagues will need to work on this part of the project, and perform unit tests before they can do anything, they will have to spend time and energy to install and set up their own MySQL server instance. </li><li>  The success of the unit tests will depend on the correctness of the pre-filling data used by the MySQL server database. </li><li>  The time it takes to run tests using a MySQL database will be significantly longer. </li></ol><br><p>  Okay.  And why, for example, not to use any database in memory in the unit tests?  It will work quickly, and the process of its configuration and initialization can be automated.  All right, but at the moment I do not see any benefits from using this additional tool.  It seems to me that my current needs are faster and cheaper (no need to spend time studying) can be satisfied using classes and methods of <code>–∑–∞–≥–ª—É—à–µ–∫</code> and <code>–ø—Å–µ–≤–¥–æ–æ–±—ä–µ–∫—Ç–æ–≤</code> -objects, which will only imitate the behavior of interfaces that are supposed to be used in combat conditions. </p><br><p>  By the way.  In combat conditions, I suggest using <a href="https://bookshelfjs.org/index.html">bookshelf</a> in conjunction with <a href="https://knexjs.org/">knex</a> .  Why?  Because following the documentation on installing, configuring and using these two tools, I managed to create and execute a database query in a few minutes. </p><br><p>  What follows from this?  From this it follows that I have to modify the <code>Request</code> class code so that the execution of the request corresponds to the interfaces exported to my combat tools.  So now the code should look like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Request</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(db){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.db = db; } configure(options){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.options = options; } execute(){ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> table = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.db.Model.extend({ <span class="hljs-attr"><span class="hljs-attr">tableName</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.options.tableName }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> table.where(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.options.query).fetch(); } } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = Request;</code> </pre> <br><p>  I will run the tests and see what happens.  Yeah.  <code>DbMock</code> course, I don‚Äôt have a <code>DbMock</code> module, so the first thing I do is implement a stub for it: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DbMock</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){} } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = DbMock;</code> </pre> <br><p>  I will run the tests again.  Now what?  Now Princess <code>Jasmine</code> tells me that my <code>DbMock</code> does not implement the <code>Model</code> property.  I'll try to think of something: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DbMock</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Model = { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {} }; } } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = DbMock;</code> </pre> <br><p>  Run tests again.  Now the error is that in my unit test, I run the query execution, without having previously configured its parameters using the <code>configure</code> method.  I fix this: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> options = { <span class="hljs-attr"><span class="hljs-attr">tableName</span></span>: <span class="hljs-string"><span class="hljs-string">'users'</span></span>, <span class="hljs-attr"><span class="hljs-attr">query</span></span>: { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } }; it(<span class="hljs-string"><span class="hljs-string">'execute should return promise'</span></span>, () =&gt; { request.configure(options); request.execute().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { expect(result).toBeNull(); }); });</code> </pre> <br><p>  Since I have already used an instance of the <code>options</code> variable in two tests, I put it into the initialization code of the entire test suite and run the tests again. </p><br><p>  As expected, the <code>extend</code> method, the <code>Model</code> properties, of the <code>DbMock</code> class returned us <code>undefined</code> , so naturally our query has no way to call the <code>where</code> method. </p><br><p>  I already understand that the <code>Model</code> property, the <code>DbMock</code> class, should be implemented outside of the <code>DbMock</code> class <code>DbMock</code> .  First of all, due to the fact that the implementation of the <code>–∑–∞–≥–ª—É—à–µ–∫</code> necessary for the existing tests to be executed, will require too many nested scopes when initializing the <code>Model</code> property right in the <code>DbMock</code> class.  It will be absolutely impossible to read and understand ... And this, however, will not stop me from such an attempt, because I want to make sure that I still have the opportunity to write only a few lines of code and make the tests run successfully. </p><br><p>  So.  Inhale, exhale, nervous to leave the room.  I <code>DbMock</code> implementation of the designer of <code>DbMock</code> .  Taaaaaammmm .... </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DbMock</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Model = { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">where</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">fetch</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); }); } }; } }; } }; } } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = DbMock;</code> </pre> <br><p>  Tin!  However, we run tests with a firm hand and make sure that <code>Jasmine</code> again shows us green dots.  And that means we are still on the right track, although something has inadmissibly swollen around us. </p><br><p>  What's next?  The naked eye can see that the <code>Model</code> property of a pseudo-database should be implemented as something completely separate.  Although offhand and not clear how it should be implemented. </p><br><p>  But I absolutely know for sure that the records in this pseudo-base right now I will be stored in the most ordinary arrays.  And since for the existing tests I need only an imitation of the <code>users</code> table, then for a start I will implement an array of users, with one record.  But first, I will write a test: </p><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'Users'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./Users'</span></span>); it(<span class="hljs-string"><span class="hljs-string">'should contain one user'</span></span>, () =&gt; { expect(<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.isArray(users)).toBeTruthy(); expect(users.length).toEqual(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = users[<span class="hljs-number"><span class="hljs-number">0</span></span>]; expect(user.Id).toEqual(<span class="hljs-number"><span class="hljs-number">1</span></span>); expect(user.Name).toEqual(<span class="hljs-string"><span class="hljs-string">'Jack'</span></span>); }); });</code> </pre> <br><p>  I run the tests.  I am convinced that they do not pass, and I implement my simple container with the user: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Users = [ { <span class="hljs-attr"><span class="hljs-attr">Id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">Name</span></span>: <span class="hljs-string"><span class="hljs-string">'Jack'</span></span> } ]; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = Users;</code> </pre> <br><p>  Now the tests are performed, and it occurs to me that, semantically, the <code>Model</code> , in the <code>bookshell</code> package, is the provider of the access interface to the contents of the table in the database.  Not for nothing, we pass the object with the name of the table to the <code>extend</code> method.  Why it is called <code>extend</code> , and not for example <code>get</code> , I do not know.  Perhaps this is just a lack of knowledge about the <code>bookshell</code> API. </p><br><p>  Well, God bless him, for now I have an idea in my head about the following test: </p><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'TableMock'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> container = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./Users'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Table = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./TableMock'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Table(container); it(<span class="hljs-string"><span class="hljs-string">'should return first item'</span></span>, () =&gt; { users.fetch({ <span class="hljs-attr"><span class="hljs-attr">Id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function">) =&gt;</span></span> { expect(item.Id).toEqual(<span class="hljs-number"><span class="hljs-number">1</span></span>); expect(item.Name).toEqual(<span class="hljs-string"><span class="hljs-string">'Jack'</span></span>); }); }); });</code> </pre> <br><p>  Since at the moment I need an implementation that only simulates the functionality of a real storage driver, I call the classes appropriately, adding the <code>Mock</code> suffix: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TableMock</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(container){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.container = container; } fetch() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.container[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }); } } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = TableMock;</code> </pre> <br><p>  But <code>fetch</code> not the only method I intend to use in the combat version, so I add another test: </p><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'where-fetch chain should return first item'</span></span>, () =&gt; { users.where({ <span class="hljs-attr"><span class="hljs-attr">Id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }).fetch().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function">)=&gt;</span></span> { expect(item.Id).toEqual(<span class="hljs-number"><span class="hljs-number">1</span></span>); expect(item.Name).toEqual(<span class="hljs-string"><span class="hljs-string">'Jack'</span></span>); }); });</code> </pre> <br><p>  Running it, as it should be, displays an error message to me.  So I supplement the implementation of <code>TableMock</code> with the <code>where</code> method: </p><br><pre> <code class="javascript hljs">where(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br><p>  Now the tests are performed and you can move on to reflections on the implementation of the <code>Model</code> property in the <code>DbMock</code> class.  As I have already assumed, this will be some kind of provider of instances of objects of the type <code>TableMock</code> : </p><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'TableMockMap'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TableMock = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./TableMock'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TableMockMap = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./TableMockMap'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> map = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TableMockMap(); it(<span class="hljs-string"><span class="hljs-string">'extend should return existent TableMock'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = map.extend({<span class="hljs-attr"><span class="hljs-attr">tableName</span></span>: <span class="hljs-string"><span class="hljs-string">'users'</span></span>}); expect(users <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> TableMock).toBeTruthy(); }); });</code> </pre> <br><p>  Why <code>TableMockMap</code> , because semantically this is it.  Just instead of the name of the <code>get</code> method, use the <code>extend</code> method name. </p><br><p>  As the test falls, we do the implementation: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Users = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./Users'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TableMock = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./TableMock'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TableMockMap</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.set(<span class="hljs-string"><span class="hljs-string">'users'</span></span>, Users); } extend(options){ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> container = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.get(options.tableName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TableMock(container); } } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = TableMockMap;</code> </pre> <br><p>  We run the tests and see six green points in the console.  Life is Beautiful. </p><br><p>  As it seems to me right now, you can get rid of the <code>—Å—Ç—Ä–∞—à–Ω–æ–π –ø–∏—Ä–∞–º–∏–¥—ã</code> initialization in the constructor of the <code>DbMock</code> class, using the wonderful <code>TableMockMap</code> .  Let's not postpone it, especially since it would be nice to have tea already.  The new implementation is exquisitely elegant: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TableMockMap = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./TableMockMap'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DbMock</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Model = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TableMockMap(); } } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = DbMock;</code> </pre> <br><p>  Run tests ... and oops!  Our most important test falls.  But this is even good, because it was a test stub and now we just have to fix it: </p><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'execute should return promise'</span></span>, () =&gt; { request.configure(options); request.execute().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { expect(result.Id).toEqual(<span class="hljs-number"><span class="hljs-number">1</span></span>); expect(result.Name).toEqual(<span class="hljs-string"><span class="hljs-string">'Jack'</span></span>); }); });</code> </pre> <br><p>  Tests completed successfully.  And now you can take a break, and then return to finalizing the resulting request code, because it is still very, very far from perfect, but even from an easy-to-use interface, despite the fact that the data from it bases can already be received. </p></div><p>Source: <a href="https://habr.com/ru/post/436228/">https://habr.com/ru/post/436228/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>