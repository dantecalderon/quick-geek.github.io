<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Building the transport package without installing MODX</title>
  <meta name="description" content="Writing your packages for MODX is not easy for a beginner, and even an experienced developer sometimes has a hard time. But the novice is frightened, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Building the transport package without installing MODX</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/jv/hq/2n/jvhq2nbsj0ti2v8v_ucoyk_bwam.jpeg"><br><br>  Writing your packages for MODX is not easy for a beginner, and even an experienced developer sometimes has a hard time.  But the novice is frightened, and the experienced understands :). <br><br>  This note describes how to write and assemble a component package for MODX without installing and configuring MODX itself.  The level is above average, so you may have to break your head on occasion, but it's worth it. <br><br>  For details, I ask under the cat. <br><a name="habracut"></a><br>  Once, when MODX Revolution had just appeared, it was still in the early beta version, developers still did not know how to work with it and how to write plugins for it.  Well, except for the team that pored over the CMS.  And the team, I must say, partially succeeded and provided in the system itself the ability to conveniently assemble packages, which can then be installed through a repository, which looks logical.  But many years have passed since then and the requirements for packages and their assembly have changed a bit. <br><br><h2>  Copypasta is evil, though not always </h2><br>  For the past few months, I wondered why, in order to build a package for MODX, you need to install it, create a database, create an admin, etc.  So much extra action.  No, there is nothing wrong with that, if you set it up once and then use it.  Many do.  But what to do when you want to entrust the assembly to the script, and go yourself to drink some coffee? <br><br>  It so happened that the creators of MODX got used to working with MODX itself and added classes directly to the kernel that provide package building.  They wrote the first components, the first build-scripts, which were later used as examples by other developers who simply copied the solution, not always really delving into the essence of what is happening.  And I did that. <br><br>  But the task is to automate the assembly of the package, preferably on the server, necessarily with the minimum set of required software, with the minimum expenditure of resources and therefore with greater speed.  The task was set and after examining the sources, Jason was hampered by a solution in the chat. <br><br><h2>  And what? </h2><br>  The first thing I found out is that the code responsible for building the package directly lies in the xPDO library, and in MODX only the wrapper classes provide a more convenient API and with which it is somewhat easier to work, but only if MODX is installed.  Therefore, probably somehow you can use only xPDO, but in the code, the xPDO object constructor requires you to specify data for the connection to the database. <br><br><pre><code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( $dsn, $username = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span><span class="hljs-function"><span class="hljs-params">, $password = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span><span class="hljs-function"><span class="hljs-params">, $options = [], $driverOptions= null )</span></span></span></span>;</code> </pre> <br>  After Jason's inquiries, it became clear that although the parameters had to be set, the real physical connection to the database occurred exactly at the moment when it was necessary.  Lazy load in all its glory.  The second problem was solved. <br><br>  The third problem was the issue of connecting xPDO to the project.  Composer immediately came to mind, but the 2.x version, on which the current MODX runs, does not support Composer, and the 3.x branch uses namespaces and class names are written differently from 2.x, which leads to conflicts and errors.  In general, incompatible.  Then I had to use git tools and connect xPDO as a submodule. <br><blockquote><h4>  How to use submodules </h4><br><br>  To get started is to read the <a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules">documentation</a> on them. <br><br>  Then, if this is a new project, you need to add a submodule: <br><br><pre> <code class="plaintext hljs">$ git submodule add https://github.com/username/reponame</code> </pre> <br>  This command will incline and install a submodule in your project.  Then you will need to add the submodule folder to your repository with the git add command.  It will not add the entire folder with the submodule, but will add to git only a link to the last commit from the submodule. <br><br>  In order for another developer to clone a project with all dependencies, you need to create a .gitmodules config for submodules.  In the Slackify project, he is: <br><br><pre> <code class="plaintext hljs">[submodule "_build/xpdo"] path = _build/xpdo url = https://github.com/modxcms/xpdo.git branch = 2.x</code> </pre><br>  After that, when cloning, just specify the recursive flag and git will download all dependent repositories. </blockquote>  As a result, we have xPDO, xPDO can be used without connecting to the database, if it is not necessary, xPDO can be connected to the component code as an external dependency (git submodule).  Now the implementation of the build script. <br><br><h2>  Let's understand </h2><br>  I will describe the <a href="https://github.com/Alroniks/modx-slackify/blob/master/_build/build.transport.php">build script of the</a> <a href="https://github.com/Alroniks/modx-slackify">Slackify</a> add-on I recently posted.  This component is free and available on Github to make it easy to learn on your own. <br><br><h3>  Connecting xPDO </h3><br>  Omit the task of the constants with the package name and other necessary calls and connect the xPDO. <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">require_once</span></span> <span class="hljs-string"><span class="hljs-string">'xpdo/xpdo/xpdo.class.php'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">require_once</span></span> <span class="hljs-string"><span class="hljs-string">'xpdo/xpdo/transport/xpdotransport.class.php'</span></span>; $xpdo = xPDO::getInstance(<span class="hljs-string"><span class="hljs-string">'db'</span></span>, [ xPDO::OPT_CACHE_PATH =&gt; <span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span> . <span class="hljs-string"><span class="hljs-string">'/../cache/'</span></span>, xPDO::OPT_HYDRATE_FIELDS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDO::OPT_HYDRATE_RELATED_OBJECTS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDO::OPT_HYDRATE_ADHOC_FIELDS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDO::OPT_CONNECTIONS =&gt; [ [ <span class="hljs-string"><span class="hljs-string">'dsn'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'mysql:host=localhost;dbname=xpdotest;charset=utf8'</span></span>, <span class="hljs-string"><span class="hljs-string">'username'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'test'</span></span>, <span class="hljs-string"><span class="hljs-string">'password'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'test'</span></span>, <span class="hljs-string"><span class="hljs-string">'options'</span></span> =&gt; [xPDO::OPT_CONN_MUTABLE =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>], <span class="hljs-string"><span class="hljs-string">'driverOptions'</span></span> =&gt; [], ] ] ]);</code> </pre> <br>  I added the xPDO submodule to the _build folder, which we need only during the development and build phase of the package and which will not go into the main component archive.  The second copy of xPDO on the site with live MODX is not needed. <br><br>  In the xPDO connection settings, I set the database name in <code>dsn</code> , but it does not play any role.  It is important that the cache folder inside the xPDO is writable.  That's all, xPDO is initialized. <br><br><h3>  Making a tricky hack with classes </h3><br>  When creating a package uses the installed MODX, everything is simple, we take and create an object of the class we need.  MODX actually finds the necessary class, finds the necessary implementation for this class (the class with the _mysql postfix), which depends on the database and then creates the necessary object (because of this peculiarity, you may encounter errors when building the package * _mysql not found, it's not scary).  However, we have neither a base nor an implementation.  We need to somehow replace the desired class, which we do. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">modNamespace</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xPDOObject</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">modSystemSetting</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xPDOObject</span></span></span><span class="hljs-class"> </span></span>{}</code> </pre> <br>  We create a dummy class (stub), which is needed to create the desired object.  This would not have to be done if xPDO had not checked in a special way which class the object belongs to.  But he checks. <br><br>  But there are special cases when you need to do a little more than just define a class.  These are cases of dependencies between classes.  For example, we need to add a plugin to the category.  In the code, just <code>$category-&gt;addOne($plugin);</code>  but in our case it will not work. <br><br>  If you have ever looked at <a href="">the MODX database schema</a> , you probably have seen such elements as aggregate and composite.  It is written about them in the <a href="https://rtfm.modx.com/xpdo/2.x/getting-started/creating-a-model-with-xpdo/defining-a-schema/more-examples-of-xpdo-xml-schema-files">documentation</a> , but if in simple terms, they describe the interconnections between the classes. <br><br>  In our case, there may be several plug-ins in a category, for which the aggregate element is responsible for the <code>modCategory</code> class.  Consequently, since we have a class without a concrete implementation, we need to point this connection with our hands.  It is easier to do this by overriding the <code>getFKDefinition</code> method: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">modCategory</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xPDOObject</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFKDefinition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($alias)</span></span></span><span class="hljs-function"> </span></span>{ $aggregates = [ <span class="hljs-string"><span class="hljs-string">'Plugins'</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">'class'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'modPlugin'</span></span>, <span class="hljs-string"><span class="hljs-string">'local'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'id'</span></span>, <span class="hljs-string"><span class="hljs-string">'foreign'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'category'</span></span>, <span class="hljs-string"><span class="hljs-string">'cardinality'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'many'</span></span>, <span class="hljs-string"><span class="hljs-string">'owner'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'local'</span></span>, ] ]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">isset</span></span>($aggregates[$alias]) ? $aggregates[$alias] : []; } }</code> </pre> <br>  In our component, only plugins are used, so we add links only for them.  After this, the addMany method of the modCategory class will be able to add the necessary plugins to the category without any problems and then to the package. <br><br><h3>  Create a package </h3><br><pre> <code class="php hljs">$package = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> xPDOTransport($xpdo, $signature, $directory);</code> </pre> <br>  As you can see, everything is very, very simple.  Here we need to pass the <code>$xpdo</code> parameter, which we initialized at the very beginning.  If not for this moment, problem 2 would not exist.  <code>$signature</code> is the name of the package, including the version, <code>$directory</code> is the place where the package will be carefully put.  Where do these variables come from? <br><br><h3>  Create a namespace and add it to the package. </h3><br>  We need the namespace in order to attach lexicons and system settings to it.  In our case, only for this, others are not yet considered. <br><br><pre> <code class="php hljs">$namespace = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> modNamespace($xpdo); $namespace-&gt;fromArray([ <span class="hljs-string"><span class="hljs-string">'id'</span></span> =&gt; PKG_NAME_LOWER, <span class="hljs-string"><span class="hljs-string">'name'</span></span> =&gt; PKG_NAME_LOWER, <span class="hljs-string"><span class="hljs-string">'path'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'{core_path}components/'</span></span> . PKG_NAME_LOWER . <span class="hljs-string"><span class="hljs-string">'/'</span></span>, ]); $package-&gt;put($namespace, [ xPDOTransport::UNIQUE_KEY =&gt; <span class="hljs-string"><span class="hljs-string">'name'</span></span>, xPDOTransport::PRESERVE_KEYS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDOTransport::UPDATE_OBJECT =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDOTransport::RESOLVE_FILES =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDOTransport::RESOLVE_PHP =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDOTransport::NATIVE_KEY =&gt; PKG_NAME_LOWER, <span class="hljs-string"><span class="hljs-string">'namespace'</span></span> =&gt; PKG_NAME_LOWER, <span class="hljs-string"><span class="hljs-string">'package'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'modx'</span></span>, <span class="hljs-string"><span class="hljs-string">'resolve'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-string"><span class="hljs-string">'validate'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ]);</code> </pre> <br>  The first part is clear to anyone who has ever written code for MODX.  The second, with the addition of the package, a little more complicated.  The <code>put</code> method takes 2 parameters: the object itself and an array of parameters describing this object and its possible behavior at the time the package is installed.  For example, <code>xPDOTransport::UNIQUE_KEY =&gt; 'name'</code> says that for the namespace the <code>name</code> field with the name of the namespace itself will be used as the value as a unique key in the database.  More information about the parameters can be found in the <a href="https://rtfm.modx.com/xpdo/2.x/">documentation on xPDO</a> , or better having studied the source code. <br><br>  In the same way, you can add other objects, such as system settings. <br><br><pre> <code class="php hljs">$package-&gt;put($setting, [ xPDOTransport::UNIQUE_KEY =&gt; <span class="hljs-string"><span class="hljs-string">'key'</span></span>, xPDOTransport::PRESERVE_KEYS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDOTransport::UPDATE_OBJECT =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, <span class="hljs-string"><span class="hljs-string">'class'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'modSystemSetting'</span></span>, <span class="hljs-string"><span class="hljs-string">'resolve'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-string"><span class="hljs-string">'validate'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-string"><span class="hljs-string">'package'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'modx'</span></span>, ]);</code> </pre> <br><h3>  Create a category </h3><br>  With the addition of a category, I had the biggest gag when I understood all this.  The elements put into a category in the xPDO model must both belong to this category, i.e.  to be nested in it, and only then the category itself should be nested in a package.  And at the same time, it is necessary to take into account the interrelations between the classes that I have already described above.  It took quite a lot of time to understand this, realize and apply it correctly. <br><br><pre> <code class="php hljs">$package-&gt;put($category, [ xPDOTransport::UNIQUE_KEY =&gt; <span class="hljs-string"><span class="hljs-string">'category'</span></span>, xPDOTransport::PRESERVE_KEYS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, xPDOTransport::UPDATE_OBJECT =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDOTransport::ABORT_INSTALL_ON_VEHICLE_FAIL =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDOTransport::RELATED_OBJECTS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDOTransport::RELATED_OBJECT_ATTRIBUTES =&gt; [ <span class="hljs-string"><span class="hljs-string">'Plugins'</span></span> =&gt; [ xPDOTransport::UNIQUE_KEY =&gt; <span class="hljs-string"><span class="hljs-string">'name'</span></span>, xPDOTransport::PRESERVE_KEYS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, xPDOTransport::UPDATE_OBJECT =&gt; <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, xPDOTransport::RELATED_OBJECTS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> ], <span class="hljs-string"><span class="hljs-string">'PluginEvents'</span></span> =&gt; [ xPDOTransport::UNIQUE_KEY =&gt; [<span class="hljs-string"><span class="hljs-string">'pluginid'</span></span>, <span class="hljs-string"><span class="hljs-string">'event'</span></span>], xPDOTransport::PRESERVE_KEYS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDOTransport::UPDATE_OBJECT =&gt; <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, xPDOTransport::RELATED_OBJECTS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> ] ], xPDOTransport::NATIVE_KEY =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, <span class="hljs-string"><span class="hljs-string">'package'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'modx'</span></span>, <span class="hljs-string"><span class="hljs-string">'validate'</span></span> =&gt; $validators, <span class="hljs-string"><span class="hljs-string">'resolve'</span></span> =&gt; $resolvers ]);</code> </pre> <br>  It looks monstrous, but not so seen.  The important parameter <code>xPDOTransport::RELATED_OBJECTS =&gt; true</code> , which says that the category has nested elements that also need to be packaged and then installed. <br><br>  Since most modules contain various elements (chunks, snippets, plug-ins), the category with elements is the most important piece of the transport package.  Therefore, it is here that validators and resolvers are set that are executed during the package installation process. <br><blockquote>  Validators are performed before installation, resolvers - after. </blockquote><br>  I almost forgot, before packing the category, we need to add our elements to it.  Like this: <br><br><pre> <code class="php hljs">$plugins = <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> $sources[<span class="hljs-string"><span class="hljs-string">'data'</span></span>] . <span class="hljs-string"><span class="hljs-string">'transport.plugins.php'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_array($plugins)) { $category-&gt;addMany($plugins, <span class="hljs-string"><span class="hljs-string">'Plugins'</span></span>); }</code> </pre> <br><h3>  Add other data to the package </h3><br>  In the package you need to add another file with the license, a file with a change log and a file with a description of the component.  If necessary, you can add another special script through the <code>setup-options</code> attribute, which will show the window before installing the package.  This is when instead of "Install" button "Installation Options".  And since MODX 2.4, it has become possible to specify dependencies between packages using the <code>requires</code> attribute, and you can also specify the version of PHP and MODX in it. <br><br><pre> <code class="php hljs">$package-&gt;setAttribute(<span class="hljs-string"><span class="hljs-string">'changelog'</span></span>, file_get_contents($sources[<span class="hljs-string"><span class="hljs-string">'docs'</span></span>] . <span class="hljs-string"><span class="hljs-string">'changelog.txt'</span></span>)); $package-&gt;setAttribute(<span class="hljs-string"><span class="hljs-string">'license'</span></span>, file_get_contents($sources[<span class="hljs-string"><span class="hljs-string">'docs'</span></span>] . <span class="hljs-string"><span class="hljs-string">'license.txt'</span></span>)); $package-&gt;setAttribute(<span class="hljs-string"><span class="hljs-string">'readme'</span></span>, file_get_contents($sources[<span class="hljs-string"><span class="hljs-string">'docs'</span></span>] . <span class="hljs-string"><span class="hljs-string">'readme.txt'</span></span>)); $package-&gt;setAttribute(<span class="hljs-string"><span class="hljs-string">'requires'</span></span>, [<span class="hljs-string"><span class="hljs-string">'php'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'&gt;=5.4'</span></span>]); $package-&gt;setAttribute(<span class="hljs-string"><span class="hljs-string">'setup-options'</span></span>, [<span class="hljs-string"><span class="hljs-string">'source'</span></span> =&gt; $sources[<span class="hljs-string"><span class="hljs-string">'build'</span></span>] . <span class="hljs-string"><span class="hljs-string">'setup.options.php'</span></span>]);</code> </pre> <br><h3>  We pack </h3><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($package-&gt;pack()) { $xpdo-&gt;log(xPDO::LOG_LEVEL_INFO, <span class="hljs-string"><span class="hljs-string">"Package built"</span></span>); }</code> </pre> <br>  Everything, we take away a ready package in <code>_packages</code> , well, or from there, where you set up the assembly. <br><br><h2>  What is the result? </h2><br>  The result exceeded my expectations, because such an approach, although it imposes some restrictions and sometimes adds some inconvenience, gains in application possibilities. <br><br>  To build a package, just run 2 commands: <br><br><pre> <code class="plaintext hljs">git clone --recursive git@github.com:Alroniks/modx-slackify.git cd modx-slackify/_build &amp;&amp; php build.transport.php</code> </pre> <br>  The first is the cloning of the repository and its submodules.  An important parameter is <code>--recursive</code> . Thanks to it, git will download and install, in addition to the component code itself, all the dependencies described as submodules. <br><br>  The second is building the package directly.  After that, you can take the finished <code>package-1.0.0-pl.transport.zip</code> from the <code>_packages</code> folder and download it, for example, into the repository. <br><br>  The prospects are broad.  For example, you can set up a hook in GitHub, which, after a commit to a branch, will run a script on your server that will compile the package and put it in all sites that you have.  Or you will download a new version in some repository, and at this time you will make coffee for yourself, as I said in the beginning.  Or you can invent and write tests to the module and run the test run and build through Jenkins or Travis.  Yes, a bunch of scenarios can be invented.  With this approach, doing it is now much easier. <br><br>  Ask questions, try to answer. <br><br>  PS Don't pass by, <a href="https://github.com/Alroniks/modx-slackify">put a Slackify star on GitHub</a> , please. </div><p>Source: <a href="https://habr.com/ru/post/439420/">https://habr.com/ru/post/439420/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>