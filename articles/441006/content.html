<div class="post__text post__text-html js-mediator-article"><h2>  Thresholding </h2><br>  This is the easiest way to separate objects from the background by selecting pixels above or below a certain threshold.  This is usually useful when we are going to segment objects by their background.  You can read more about the threshold <a href="http://scikit-image.org/docs/dev/auto_examples/xx_applications/plot_thresholding.html">here</a> . <br><br>  People who are familiar with the movie "Terminator", will certainly agree that it was the greatest science fiction film of that era.  In the film, James Cameron presented an interesting concept of visual effects that allowed viewers to hide behind the cyborg's eyes, called Terminator.  This effect became known as “Terminator Vision” (English Terminator Vision).  In a sense, he separated the silhouettes of people from the background.  Then it might sound completely inappropriate, but image segmentation today is an important part of many image processing techniques. <br><br><h2>  Image segmentation </h2><br>  There are a number of libraries written for image analysis.  In this article we will discuss in detail scikit-image, an image processing library in the Python environment. <br><br><h2>  Scikit-image </h2><br><img src="https://habrastorage.org/webt/g2/fm/vh/g2fmvhs1nha3wxsoofyblton3hq.png" alt="image"><br><br>  Scikit-image is a Python library for image processing. <br><br><h2>  Installation </h2><br>  scikit-image is set as follows: <br><br><pre><code class="python hljs">pip install -U scikit-image(Linux <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> OSX) pip install scikit-image(Windows) <span class="hljs-comment"><span class="hljs-comment"># For Conda-based distributions conda install scikit-image</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/hy/at/nt/hyatntvr-9i-awiwo2yxcvx_vym.png"><br><a name="habracut"></a><br><h2>  Image Review in Python </h2><br>  Before embarking on the technical aspects of image segmentation, it is important to become familiar with the Scikit image ecosystem and how it processes images. <br><br><h3>  Import GrayScale Image from skimage </h3><br>  The skimage data module contains several built-in examples of data sets, which are usually stored in jpeg or png format. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> skimage <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt image = data.binary_blobs() plt.imshow(image, cmap=<span class="hljs-string"><span class="hljs-string">'gray'</span></span>)</code> </pre> <br><h3>  Import a color image from the skimage library </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> skimage <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt image = data.astronaut() plt.imshow(image)</code> </pre> <br><img src="https://habrastorage.org/webt/j2/8b/x5/j28bx5eailfqsuainwhmyskx4ek.png"><br><br><h3>  Import image from external source </h3><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># The I/O module is used for importing the image from skimage import data import numpy as np import matplotlib.pyplot as plt from skimage import io image = io.imread('skimage_logo.png') plt.imshow(image);</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/bx/ho/xe/bxhoxercb7yo1soyfgduy9asuwk.png"><br><br><h3>  Upload multiple images </h3><br><pre> <code class="python hljs">images = io.ImageCollection(<span class="hljs-string"><span class="hljs-string">'../images/*.png:../images/*.jpg'</span></span>) print(<span class="hljs-string"><span class="hljs-string">'Type:'</span></span>, type(images)) images.files Out[]: Type: &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skimage</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">io</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">collection</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ImageCollection</span></span></span><span class="hljs-class">'&gt;</span></span></code> </pre> <br><h3>  Saving images </h3><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#Saving file as 'logo.png' io.imsave('logo.png', logo)</span></span></code> </pre> <br><h2>  Image segmentation </h2><br>  Now that we have an idea about scikit-image, we offer to consider the details of image segmentation.  Image segmentation is the process of dividing a digital image into several segments in order to simplify and / or change the image representation to something more meaningful and easier to analyze. <br><br>  In this article, we will look at algorithms for student models, both with a teacher (supervised) and without a teacher (unsupervised). <br><br><img src="https://habrastorage.org/webt/zi/93/f7/zi93f7mpnuzuyo_evzeu6jqzxgo.png"><br>  <i>Some of the segmentation algorithms are available in the scikit-image library.</i> <br><br>  Teacher segmentation: some prior knowledge, possibly from human input, is used to guide the algorithm. <br><br>  Segmentation without a teacher: no prior knowledge is required.  These algorithms attempt to automatically divide images into meaningful areas.  The user can still adjust certain parameters to get the desired results. <br><br>  Let's try this on the tutorial image that comes with the scikit-image pre-installed dataset. <br><br><h3>  Normal import </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> skimage.data <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> skimage.segmentation <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> seg <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> skimage.filters <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> filters <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> skimage.draw <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> draw <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> skimage.color <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> color</code> </pre> <br>  Simple function to build images <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image_show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image, nrows=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, ncols=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, cmap=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'gray'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> fig, ax = plt.subplots(nrows=nrows, ncols=ncols, figsize=(<span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>)) ax.imshow(image, cmap=<span class="hljs-string"><span class="hljs-string">'gray'</span></span>) ax.axis(<span class="hljs-string"><span class="hljs-string">'off'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fig, ax</code> </pre> <br><h3>  Form </h3><br><pre> <code class="python hljs">text = data.page() image_show(text)</code> </pre> <br><img src="https://habrastorage.org/webt/hr/ci/ac/hrciacrdvu72qvq8yhivtvt1e78.png"><br><br>  This image is a bit darker, but perhaps we can still choose a value that will give us a reasonable segmentation without any complicated algorithms.  Now, to help us choose this value, we will use a histogram. <br><br>  In this case, the histogram shows the number of pixels in the image with different intensity values ​​found in this image.  Simply put, a histogram is a graph in which the X axis shows all the values ​​that are on the image, and the Y axis shows the frequency of these values. <br><br><pre> <code class="python hljs">fig, ax = plt.subplots(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) ax.hist(text.ravel(), bins=<span class="hljs-number"><span class="hljs-number">32</span></span>, range=[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">256</span></span>]) ax.set_xlim(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">256</span></span>);</code> </pre> <br><img src="https://habrastorage.org/webt/8c/ha/nc/8chanc-jg5519ms6yk0w-h90lfc.png"><br><br>  Our example turned out to be an 8-bit image, so we have 256 possible values ​​along the X axis. From the histogram, you can see that there is a concentration of fairly bright pixels (0: black, 255: white).  Most likely, this is our rather light text background, but the rest is a bit blurry.  A perfect segmentation histogram would be bimodal, so that we could choose the number right in the middle.  Now let's try creating some segmented images based on a simple threshold value. <br><br><h3>  Controlled threshold </h3><br>  Since we ourselves choose the threshold value, we call it a monitored threshold value. <br><br><pre> <code class="python hljs">text_segmented = text &gt; (value concluded <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> histogram ie <span class="hljs-number"><span class="hljs-number">50</span></span>,<span class="hljs-number"><span class="hljs-number">70</span></span>,<span class="hljs-number"><span class="hljs-number">120</span></span> ) image_show(text_segmented);</code> </pre> <br><table><tbody><tr><td><img src="https://habrastorage.org/webt/iv/2l/gr/iv2lgrmmcgef-0geutdoybn85t0.png"></td><td><img src="https://habrastorage.org/webt/rl/k3/on/rlk3oneyt6yvcuq9mqkwel7jg3k.png"></td><td><img src="https://habrastorage.org/webt/e5/o8/fw/e5o8fwm7cs7xzneo-v29k1_vf7e.png"></td></tr></tbody></table><br>  <i>Left: text&gt; 50 |</i>  <i>Middle: text&gt; 70 |</i>  <i>Right: text&gt; 120</i> <br><br>  We did not get perfect results, as the shadow on the left creates problems.  Let's try with the threshold unattended now. <br><br><h3>  Unmonitored threshold </h3><br>  Uncontrolled threshold Scikit-image has a number of automatic methods for determining the threshold, which do not require input when choosing the optimal threshold.  Here are some of the methods: otsu, li, local. <br><br><pre> <code class="python hljs">text_threshold = filters.threshold_ <span class="hljs-comment"><span class="hljs-comment"># Hit tab with the cursor after the underscore to get all the methods. image_show(text &lt; text_threshold);</span></span></code> </pre> <br><table><tbody><tr><td><img src="https://habrastorage.org/webt/zo/zb/ne/zozbnecnzak8i_-chy9ghhwa7e0.png"></td><td><img src="https://habrastorage.org/webt/h0/ik/-m/h0ik-mxys3qwdruh-gefraebnto.png"></td></tr></tbody></table><br>  <i>Left otsu ||</i>  <i>Right: li</i> <br><br>  In the case of local, we also need to specify block_size.  Offset helps to adjust the image for better results. <br><br><pre> <code class="python hljs">text_threshold = filters.threshold_local(text,block_size=<span class="hljs-number"><span class="hljs-number">51</span></span>, offset=<span class="hljs-number"><span class="hljs-number">10</span></span>) image_show(text &gt; text_threshold);</code> </pre> <br><img src="https://habrastorage.org/webt/en/ns/zp/ennszp_rpslshqnd0y78mqax76w.png"><br><br>  This method has a pretty good effect.  To a large extent, you can mute from noisy regions. <br><br><h2>  Segmentation with an algorithm for a model with a teacher </h2><br>  Thresholding is a very simple segmentation process, and it will not work properly on a high-contrast image for which we need more advanced tools. <br><br>  In this section, we will use an example of an image that is freely available, and try to segment the head using methods with a teacher. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># import the image from skimage import io image = io.imread('girl.jpg') plt.imshow(image);</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/g6/dw/ga/g6dwgagldj71bqemwgosylqkusw.png"><br><br>  <i>Before doing any image segmentation, it is recommended to remove noise from it using some filters.</i> <br><br>  However, in our case, the image has no significant noise, so we take it as it is.  The next step is to convert the image to grayscale using rgb2gray. <br><br><pre> <code class="python hljs">image_gray = color.rgb2gray(image) image_show(image_gray);</code> </pre> <br><img src="https://habrastorage.org/webt/qx/jl/qs/qxjlqspqdsqiaxu6px23j4q7mvs.png"><br><br>  We will use two segmentation methods that work on completely different principles. <br><br><h3>  Active contour segmentation </h3><br>  The active contour segmentation is also called a snake and is initialized using a user-defined contour or line around the region of interest, and then the contour is slowly compressed and attracted or repelled by light and edges. <br><br>  For our example image, let's draw a circle around the head of a person to initialize the snake. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">circle_points</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolution, center, radius)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Generate points which define a circle on an image.Centre refers to the centre of the circle """</span></span> radians = np.linspace(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>*np.pi, resolution) c = center[<span class="hljs-number"><span class="hljs-number">1</span></span>] + radius*np.cos(radians)<span class="hljs-comment"><span class="hljs-comment">#polar co-ordinates r = center[0] + radius*np.sin(radians) return np.array([c, r]).T # Exclude last point because a closed path should not have duplicate points points = circle_points(200, [80, 250], 80)[:-1]</span></span></code> </pre> <br>  The above calculations calculate the x and y coordinates of the points on the periphery of the circle.  Since we gave a resolution of 200, it will calculate 200 such points. <br><br><pre> <code class="python hljs">fig, ax = image_show(image) ax.plot(points[:, <span class="hljs-number"><span class="hljs-number">0</span></span>], points[:, <span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-string"><span class="hljs-string">'--r'</span></span>, lw=<span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br><img src="https://habrastorage.org/webt/4o/f1/bu/4of1buz3h2boatz5lpfpnlogh6g.png"><br><br>  The algorithm then segments the person's face from the rest of the image, fitting a closed curve to the edges of the face. <br><br><img src="https://habrastorage.org/webt/z_/o1/ep/z_o1epmu9zcrxuyju7tr85p9n1o.png"><br><br>  We can customize parameters called alpha and beta.  Higher alpha values ​​cause the curve to contract faster, while beta makes the curve smoother. <br><br><pre> <code class="python hljs">snake = seg.active_contour(image_gray, points,alpha=<span class="hljs-number"><span class="hljs-number">0.06</span></span>,beta=<span class="hljs-number"><span class="hljs-number">0.3</span></span>) fig, ax = image_show(image) ax.plot(points[:, <span class="hljs-number"><span class="hljs-number">0</span></span>], points[:, <span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-string"><span class="hljs-string">'--r'</span></span>, lw=<span class="hljs-number"><span class="hljs-number">3</span></span>) ax.plot(snake[:, <span class="hljs-number"><span class="hljs-number">0</span></span>], snake[:, <span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-string"><span class="hljs-string">'-b'</span></span>, lw=<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br><img src="https://habrastorage.org/webt/ne/pw/vw/nepwvw8xqanbj61fikjg6qorxq0.png"><br><br><h3>  Segmentation of random passing (eng. Random walker segmentation) </h3><br>  In this method, the segmentation is carried out with the help of interactive labeling, which are called labels.  By drawing each pixel to a label for which the highest probability is calculated, you can get high-quality image segmentation.  More details on this method can be found in <a href="https://ieeexplore.ieee.org/document/1704833">this</a> work. <br><br>  Next we will reuse the previous values ​​from our example.  We could have done different initializations, but for simplicity, let's stick to the principle of circles. <br><br><pre> <code class="python hljs">image_labels = np.zeros(image_gray.shape, dtype=np.uint8)</code> </pre> <br>  Algorithm of random passing to accept tags as input.  Thus, we will have a large circle, covering the entire face of a person, and another smaller circle near the middle of the face. <br><br><pre> <code class="python hljs">indices = draw.circle_perimeter(<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">250</span></span>,<span class="hljs-number"><span class="hljs-number">20</span></span>)<span class="hljs-comment"><span class="hljs-comment">#from here image_labels[indices] = 1 image_labels[points[:, 1].astype(np.int), points[:, 0].astype(np.int)] = 2 image_show(image_labels);</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/ol/2n/nw/ol2nnwq0un_qzngiv25atfh3d5g.png"><br>  Now let's use the Random Walker and see what happens. <br><br><pre> <code class="python hljs">image_segmented = seg.random_walker(image_gray, image_labels) <span class="hljs-comment"><span class="hljs-comment"># Check our results fig, ax = image_show(image_gray) ax.imshow(image_segmented == 1, alpha=0.3);</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/au/bs/jn/aubsjn1b1uedkiorghu5izwbbha.png"><br><br>  The result is not the best, remained uncovered edges of the face.  To correct this situation, we can adjust the passing parameter until we get the desired result.  After several attempts, we set the value to 3000, which works quite well. <br><br><pre> <code class="plaintext hljs">image_segmented = seg.random_walker(image_gray, image_labels, beta = 3000) # Check our results fig, ax = image_show(image_gray) ax.imshow(image_segmented == 1, alpha=0.3);</code> </pre><br><img src="https://habrastorage.org/webt/ii/4s/h1/ii4sh1n0rxcwgply9xmafyerk5a.png"><br><br>  This is all for segmentation with the teacher, where we had to provide certain input data, as well as configure some parameters.  However, it is not always possible for a person to look at the image and then decide what contribution to give and where to start.  Fortunately, for such situations we have uncontrolled segmentation methods. <br><br><h2>  Teacherless segmentation </h2><br>  Segmentation without a teacher does not require prior knowledge.  Consider an image that is so large that it is impossible to view all the pixels simultaneously.  Thus, in such cases, segmentation without a teacher can split the image into several subregions, so instead of millions of pixels you have dozens or hundreds of areas.  Let's look at two such algorithms: <br><br><h3>  Simple Linear Iterative Clustering </h3><br>  The method (Simple Linear Iterative Clustering or SLIC) uses a machine learning algorithm called K-Means.  It takes all the pixel values ​​of the image and tries to divide them into a given number of subdomains.  Read <a href="https://ieeexplore.ieee.org/document/6205760">this</a> work for more information. <br><br>  SLIC works with different colors, so we will use the original image. <br><br><pre> <code class="python hljs">image_slic = seg.slic(image,n_segments=<span class="hljs-number"><span class="hljs-number">155</span></span>)</code> </pre> <br>  All we have to do is simply set the average for each segment we find, which makes it look more like an image. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># label2rgb replaces each discrete label with the average interior color image_show(color.label2rgb(image_slic, image, kind='avg'));</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/7_/kn/b4/7_knb4b5fgefv0vsg3bed3dtx3o.png"><br><br>  We have reduced this image from 512 * 512 = 262,000 pixels to 155 segments. <br><br><h3>  Felzenszwalb </h3><br>  This method also uses a machine learning algorithm called minimum-spanning tree clustering (English minimum-spanning tree clustering).  Felzenszwaib does not tell us the exact number of clusters into which the image will be divided.  It will generate as many clusters as it considers necessary for this. <br><br><pre> <code class="python hljs">image_felzenszwalb = seg.felzenszwalb(image) image_show(image_felzenszwalb);</code> </pre> <br><img src="https://habrastorage.org/webt/ht/bk/ao/htbkaotqhcgg_xlbys0_z_0bwie.png"><br><br>  There are too many regions in the picture.  Let's count the number of unique segments. <br><br><pre> <code class="python hljs">np.unique(image_felzenszwalb).size <span class="hljs-number"><span class="hljs-number">3368</span></span></code> </pre> <br>  Now let's repaint them using the average value for the segment, as we did in the SLIC algorithm. <br><br><pre> <code class="python hljs">image_felzenszwalb_colored = color.label2rgb(image_felzenszwalb, image, kind=<span class="hljs-string"><span class="hljs-string">'avg'</span></span>) image_show(image_felzenszwalb_colored);</code> </pre> <br>  Now we get less number of segments.  If we wanted even smaller segments, we could change the scale parameter.  This approach is sometimes referred to as over-segmentation. <br><br><img src="https://habrastorage.org/webt/dw/-2/3-/dw-23-xllphmwajmn1sg-sk-nws.png"><br><br>  This is more like a posterized image, which in essence is only a decrease in the number of colors.  To merge them again (RAG). <br><br><h2>  Conclusion </h2><br>  Image segmentation is a very important stage of image processing.  It is an active area of ​​research with a variety of applications, ranging from computer vision to medical imaging, traffic and video surveillance.  Python provides a reliable scikit-image library with a large number of image processing algorithms.  It is available for free and without restrictions, behind which there is an active community.  I recommend to read their documentation.  The original article can be found <a href="https://towardsdatascience.com/image-segmentation-using-pythons-scikit-image-module-533a61ecc980">here</a> . </div>