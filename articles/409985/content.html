<div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/5f/i6/je/5fi6jegvdeysgvpqtplmvfn9opi.png"></div><br>  In this article I will talk about the security problem in blockchain technology in the light of the growth in performance of quantum computers, analyze some methods of protection against attacks using a quantum computer, and a recent project: Quantum-Resistant Ledger.  According to the developers, this will be the first platform in the world, built on the principles of post-quantum encryption and designed to provide protection from the "quantum blow" in the event of the rapid development of these technologies.  Platforms built using classical encryption principles can be subjected to such a blow.  Without fundamental changes, Bitcoin, Ethereum, Ardor, and most similar platforms may be in the near future. <br><a name="habracut"></a><br><h2>  Part 1. Security issue </h2><br><h3>  Vulnerability </h3><br>  The algorithm for protecting Bitcoin and similar systems is based on the principle of asymmetric encryption with public and private keys.  The transaction is signed by the private key, and its truth is verified using the public key. <br><br>  Using the classic attack algorithms, it is almost impossible to find the private key, knowing the public key.  Asymmetric encryption systems such as RSA and the like (DSA, DH, etc.) are based on the statement that the complexity of decomposing a number into prime factors grows exponentially with the size of the key.  However, using <a href="https://eax.me/shors-algorithm/">the Shor algorithm</a> on a quantum computer, it becomes possible to decompose a number into prime factors in polynomial time and, thus, find the private key, knowing the public key. <br><br>  In 2001, IBM <a href="https://www-03.ibm.com/press/us/en/pressrelease/965.wss">demonstrated</a> this capability by decomposing the number 15 into two simple factors 3 and 5. For these purposes, a quantum computer consisting of 7 qubits was used.  Since then, the development of quantum computing technology is happening faster. <br><br>  In 2016, a group of researchers from the Massachusetts Institute of Technology, together with the Innsbruck Institute, performs the same task of decomposing the number 15, <a href="http://news.mit.edu/2016/quantum-computer-end-encryption-schemes-0303">using only 5 qubits</a> . <br><br>  In July 2017, a <a href="https://arxiv.org/pdf/1707.04344.pdf">programmable 51 qubit computer</a> was created by Russian-American physicists. <br><br>  At the end of October 2017, an international research team from Singapore and Australian universities concluded that most cryptographic protocols used in the blockchain are vulnerable to attacks from a powerful quantum computer.  The <a href="https://arxiv.org/pdf/1710.10377v1.pdf">report of the group</a> contains 2 predictions for the growth of the power of a quantum computer: optimistic and less optimistic.  According to the first, the number of qubits of a quantum computer will double every 10 months.  A less optimistic forecast indicates a doubling of the number of quits every 20 months.  The figure below shows the graphs of both forecasts. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/j_/ag/d9/j_agd9is8gsscek9w-djuhllage.png"></div><br>  The algorithm for creating a digital signature based on elliptic curves ( <a href="https://en.bitcoin.it/wiki/Secp256k1">ECDSA</a> ) has been recognized as the most vulnerable to attacks by a quantum computer.  Thus, according to the <a href="https://arxiv.org/pdf/1710.10377v1.pdf">report of the group</a> , Bitcoin in its classic form can be cracked by 2027. <br><br><h3>  Maybe not so bad?  Public key is not stored in clear view </h3><br>  At the end of April 2017, an <a href="https://news.bitcoin.com/is-bitcoin-at-risk-as-google-and-ibm-aim-for-50-qubit-quantum-computers/">article is</a> published on bitcoin.com to answer the question of whether Bitcoin holders should be wary of its hacking using a quantum computer.  It says that in spite of the fact that asymmetric encryption is used in the Bitcoin blockchain, users do not have to fear for the safety of their coins.  The public key is not stored in clear text.  So, addresses for transferring coins are not public keys, but only the result of using the SHA-256 hash function.  The hash function performs one-way conversion and is therefore resistant to attacks from a quantum computer. <br><br><h3>  The public key becomes known during the transaction. </h3><br>  The statement that the public key is not available in the clear, is not quite true.  Without going into small details, let us look at Bitcoin (BTC) as an example of how cryptocurrency is transferred from one person to another. <br><br>  Let Alice in her wallet on one of the Bitcoin addresses has 100 mBTC (1000 mBTC = 1 BTC).  She wants to translate 1 mBTC to Bob.  To do this, she indicates Bob’s Bitcoin address, transfer commission and Bitcoin address in her wallet to receive the change.  Let Alice specify 1 mBTC as a commission.  Thus, out of 100 mBTC Alice has, 1 mBTC is sent to Bob, 1 mBTC goes as a Bitcoin network commission and 98 mBTC is returned to Alice’s wallet. <br><br>  Now let's look at what happens at the level of the Bitcoin network.  Alice and Bob have purses containing addresses for storing coins.  One wallet may contain several Bitcoin addresses.  Addresses are generated when creating wallets.  Each address corresponds to a pair of keys created by the ECDSA algorithm: public and private.  During the transfer of coins, a transaction is created in which information on the number of coins transferred by Alice, Bob’s Bitcoin address, a signature made with Alice’s private key, Alice’s <b>public key,</b> and some other data is transmitted.  Further, the transaction <b>in an open (unencrypted) form is sent to the network</b> .  Network nodes, before accepting a transaction for processing, verify its signature using the public key.  If the signature is valid, they add the transaction information to the block.  Such an act of inclusion is called confirmation. <br><br>  The average time of generating a block in the Bitcoin network is 10 minutes.  The network aims to keep this time constant.  Before using the funds received, <a href="https://ru.bitcoinwiki.org/wiki/%25D0%259F%25D0%25BE%25D0%25B4%25D1%2582%25D0%25B2%25D0%25B5%25D1%2580%25D0%25B6%25D0%25B4%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D1%2582%25D1%2580%25D0%25B0%25D0%25BD%25D0%25B7%25D0%25B0%25D0%25BA%25D1%2586%25D0%25B8%25D0%25B8">it is recommended to</a> wait for 6 confirmations.  Thus, Bob, while observing the safety rules, will be able to use the funds received about an hour after their transfer. <br><br>  One of the features of the transfer of coins in the Bitcoin network is that it is not possible to transfer only part of the coins from a single address.  Coins are always transferred to the entire volume located on the Bitcoin address of the wallet, while the sender returns the change.  It can be obtained both on the address from which the coins were sent, and on any other.  Therefore, Alice must provide an address for delivery.  In a number of software operating the wallet, the delivery address is the shipping address. <br><br>  Strictly speaking, a transaction fee is not mandatory, but its absence may postpone the transaction for a long time.  The converse is also true: you can speed up the transaction a little by increasing the amount of commission.  At the time of this writing (January 2018), most software wallets offer to specify a commission of 1 mBTC.  There are a number of resources, for example, <a href="https://bitaps.com/ru/">this one</a> , which make it possible to estimate the time when a transaction is included in a block, depending on the amount of commission. <br><br><h4>  Use public key 1 time </h4><br>  From a security point of view, it is best to receive a change to a new address, the public key of which will be unknown to the network.  In this case, the key pair is used only once.  However, according to <a href="https://oxt.me/charts">statistics,</a> as of December 2017, about 41.34% of addresses are reused. <br><br><h4>  10 minutes to attack </h4><br>  However, sooner or later you will need to use the tools on the new address.  The public key is transmitted to the network in the clear.  Until a confirmation is received, the funds are still at the sender.  If an attacker gets a public key during a transaction, he will have about 10 minutes to get the private key using a quantum computer and try to conduct his transaction from the same address, setting a higher commission. <br><br><h4>  Static addresses are more vulnerable </h4><br>  In systems such as Ethereum, NXT, Ardor, and others, the public key also becomes known after the first transaction.  The situation is aggravated by the fact that tokens or smart contracts are tied to static addresses that can be attacked for a long time.  If the attack is successful, the attacker will be able to destroy the entire economic system based on these addresses. <br><br><h2>  Part 2. Solutions </h2><br><h3>  How to ensure resistance to attacks of a quantum computer? </h3><br>  Currently, there are several basic methods that provide protection against attacks from a quantum computer: <br><br><ul><li>  hash based cryptography; </li><li>  code-based cryptography; </li><li>  matrix based cryptography; </li><li>  cryptography based on multidimensional quadratic systems; </li><li>  cryptography based on the secret key. </li></ul><br>  With sufficiently long keys and security requirements, these protection methods are able to withstand both classic attacks and attacks using a quantum computer. <br><br>  The most studied is the use of digital signatures based on hash functions. <br><br>  As mentioned earlier, the hash function performs one-way message conversion.  The message is converted to a fixed-length hash value.  Using the hash function on the one hand should make it senseless to search for messages to get the same hash value.  On the other hand, the algorithm must be resistant to collisions: when 2 different messages correspond to the same hash value. <br><br>  <a href="http://savepearlharbor.com/%3Fp%3D222457">Grover’s quantum algorithm</a> can be used to try to find a collision or perform a preliminary attack to find the original message.  This will require <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2">O</span><span class="MJXp-mo" id="MJXp-Span-3" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-4"><span class="MJXp-mn" id="MJXp-Span-5" style="margin-right: 0.05em;">2</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-6" style="vertical-align: 0.5em;"><span class="MJXp-mtext" id="MJXp-Span-7">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-8">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-9">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-10">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-11">c</span><span class="MJXp-mrow" id="MJXp-Span-12"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-13">n</span></span><span class="MJXp-mrow" id="MJXp-Span-14"><span class="MJXp-mn" id="MJXp-Span-15">2</span></span></span></span><span class="MJXp-mo" id="MJXp-Span-16" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="10.593ex" height="3.021ex" viewBox="0 -987.6 4561 1300.8" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/409985/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiwhicV5S2AbHd7kWpP6Mrtjeiz3A#MJMATHI-4F" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/409985/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiwhicV5S2AbHd7kWpP6Mrtjeiz3A#MJMAIN-28" x="763" y="0"></use><g transform="translate(1153,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/409985/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiwhicV5S2AbHd7kWpP6Mrtjeiz3A#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/409985/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiwhicV5S2AbHd7kWpP6Mrtjeiz3A#MJMATHI-66" x="353" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/409985/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiwhicV5S2AbHd7kWpP6Mrtjeiz3A#MJMATHI-72" x="904" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/409985/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiwhicV5S2AbHd7kWpP6Mrtjeiz3A#MJMATHI-61" x="1355" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/409985/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiwhicV5S2AbHd7kWpP6Mrtjeiz3A#MJMATHI-63" x="1885" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/409985/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiwhicV5S2AbHd7kWpP6Mrtjeiz3A#MJMATHI-6E" x="2318" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/409985/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiwhicV5S2AbHd7kWpP6Mrtjeiz3A#MJMAIN-32" x="2919" y="0"></use></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/409985/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiwhicV5S2AbHd7kWpP6Mrtjeiz3A#MJMAIN-29" x="4171" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> O (2 ^ {\ frac {n} {2}}) </script>  operations.  Thus, to maintain 128-bit security, the required hash length is at least 256 bits.  SHA-256 can be selected as such a function. <br><br><h3>  Signature Lamport </h3><br>  One of the uses of the hash function in a digital signature is the Lamport signature.  It can be built on the basis of any one-way hash function.  The cryptostability of the algorithm is based on the cryptostability of the hash functions used. <br><br><div class="spoiler">  <b class="spoiler_title">Signature scheme</b> <div class="spoiler_text">  For the message <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-17"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-18">M</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.442ex" height="2.074ex" viewBox="0 -772.3 1051.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/409985/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiwhicV5S2AbHd7kWpP6Mrtjeiz3A#MJMATHI-4D" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> M </script>  long <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-19"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-20">m</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.04ex" height="1.523ex" viewBox="0 -535.3 878.5 655.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/409985/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiwhicV5S2AbHd7kWpP6Mrtjeiz3A#MJMATHI-6D" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3"> m </script>  keys are generated.  First, private keys are generated in pairs. <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-21"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-22">S</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23">K</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.565ex" height="2.074ex" viewBox="0 -772.3 1535 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/409985/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiwhicV5S2AbHd7kWpP6Mrtjeiz3A#MJMATHI-53" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/409985/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiwhicV5S2AbHd7kWpP6Mrtjeiz3A#MJMATHI-4B" x="645" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-4"> SK </script>  long <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-24"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-25">n</span></span></span><script type="math/tex" id="MathJax-Element-5"> n </script>  then, using the hash function, public key pairs are formed from the private keys <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-26"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-27">P</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-28">K</span></span></span><script type="math/tex" id="MathJax-Element-6"> PK </script>  .  The number of pairs of private and public keys is equal to the number of bits in the original message. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jn/dv/-2/jndv-2mqmumu2txujyuchyl611m.png"></div><br>  When performing the signature, the message is read bit by bit, and, depending on the value of the current bit, one of the private keys of the corresponding pair is selected.  Selected private keys are combined into a signature.  Next, the resulting signature and <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-29"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-30">m</span></span></span><script type="math/tex" id="MathJax-Element-7"> m </script>  public key pairs are sent to the addressee. <br><br><img src="https://habrastorage.org/webt/sp/bd/ze/spbdzeq9cdipwfwrodj2eq4r-0k.png"><br><br>  Signature verification is similar to the process of creating it.  The signature is broken into fragments by length. <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-31"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-32">n</span></span></span><script type="math/tex" id="MathJax-Element-8"> n </script>  which are then converted using the same hash function.  The message is read bit by bit and the value of the bit is chosen as the public key, which is compared with the received hash value. <br><br>  As a rule, before applying the signature, the original message is hashed to reduce its size.  Let SHA-256 be selected as the hash function, then <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-33"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-34">m</span><span class="MJXp-mo" id="MJXp-Span-35" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-36">n</span><span class="MJXp-mo" id="MJXp-Span-37" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-38">256</span></span></span><script type="math/tex" id="MathJax-Element-9"> m = n = 256 </script>  .  At the same time, the total length of the open (as well as the closed) key <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-39"><span class="MJXp-msubsup" id="MJXp-Span-40"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-41" style="margin-right: 0.05em;">L</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-42" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-43">P</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-44">K</span></span></span></span></span><script type="math/tex" id="MathJax-Element-10"> L_ {PK} </script>  it turns out to be: <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-45"><span class="MJXp-msubsup" id="MJXp-Span-46"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-47" style="margin-right: 0.05em;">L</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-48" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-49">P</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-50">K</span></span></span><span class="MJXp-mo" id="MJXp-Span-51" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-52">n</span><span class="MJXp-mo" id="MJXp-Span-53" style="margin-left: 0.267em; margin-right: 0.267em;">∗</span><span class="MJXp-mn" id="MJXp-Span-54">2</span><span class="MJXp-mo" id="MJXp-Span-55" style="margin-left: 0.267em; margin-right: 0.267em;">∗</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-56">m</span><span class="MJXp-mo" id="MJXp-Span-57" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-58">256</span><span class="MJXp-mo" id="MJXp-Span-59" style="margin-left: 0.267em; margin-right: 0.267em;">∗</span><span class="MJXp-mn" id="MJXp-Span-60">2</span><span class="MJXp-mo" id="MJXp-Span-61" style="margin-left: 0.267em; margin-right: 0.267em;">∗</span><span class="MJXp-mn" id="MJXp-Span-62">256</span><span class="MJXp-mo" id="MJXp-Span-63" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-64">128</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-65">K</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-66">B</span><span class="MJXp-mo" id="MJXp-Span-67" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-68">16</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-69">K</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-70">B</span><span class="MJXp-mo" id="MJXp-Span-71" style="margin-left: 0em; margin-right: 0.222em;">.</span></span></span><script type="math/tex;mode=display" id="MathJax-Element-11"> L_ {PK} = n * 2 * m = 256 * 2 * 256 = 128 KB = 16 KB. </script></p><br>  Signature length <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-72"><span class="MJXp-msubsup" id="MJXp-Span-73"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-74" style="margin-right: 0.05em;">L</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-75" style="vertical-align: -0.4em;">S</span></span></span></span><script type="math/tex" id="MathJax-Element-12"> L_S </script>  is: <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-76"><span class="MJXp-msubsup" id="MJXp-Span-77"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-78" style="margin-right: 0.05em;">L</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-79" style="vertical-align: -0.4em;">S</span></span><span class="MJXp-mo" id="MJXp-Span-80" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-81">n</span><span class="MJXp-mo" id="MJXp-Span-82" style="margin-left: 0.267em; margin-right: 0.267em;">∗</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-83">m</span><span class="MJXp-mo" id="MJXp-Span-84" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-85">64</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-86">K</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-87">B</span><span class="MJXp-mo" id="MJXp-Span-88" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-89">8</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-90">K</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-91">B</span><span class="MJXp-mo" id="MJXp-Span-92" style="margin-left: 0em; margin-right: 0.222em;">.</span></span></span><script type="math/tex;mode=display" id="MathJax-Element-13"> L_S = n * m = 64 KB = 8 KB. </script></p><br></div></div><br>  The signature of Lamport is a one-time (it remains safe only when it is used once), since during its execution and transfer, half of the private key becomes known.  Let the message length be 256 bytes and the hash length be 256. Before Alice publishes the message signature, no one knows 2 * 256 random numbers in the secret key.  Thus, no one can create the correct set of 256 numbers for the signature. <br><br>  After Alice publishes the signature, no one will yet know the remaining 256 numbers, and thus cannot create a signature for messages that have a different hash. <br><br>  The fact that Lamport's signature is one-time, combined with an impressive total signature and public key (24 KB with a message length of 256 bytes and a hash length of 256 bytes), makes its use in a public transaction block impractical. <br><br><h3>  Signature Vinernytsia </h3><br>  There are other one-time digital signature algorithms.  In the Winternitz signature, unlike the Lamport signature, the original message is signed, not bitwise, but blockwise.  The one-time Winternitz signature, like that of Lamport, can be built on the basis of any strong cryptographic function. <br><br><div class="spoiler">  <b class="spoiler_title">Signature scheme</b> <div class="spoiler_text">  Message <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-93"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-94">M</span></span></span><script type="math/tex" id="MathJax-Element-14"> M </script>  long <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-95"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-96">m</span></span></span><script type="math/tex" id="MathJax-Element-15"> m </script>  broken into fragments <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-97"><span class="MJXp-msubsup" id="MJXp-Span-98"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-99" style="margin-right: 0.05em;">M</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-100" style="vertical-align: -0.4em;">i</span></span></span></span><script type="math/tex" id="MathJax-Element-16"> M_i </script>  long <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-101"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-102">w</span></span></span><script type="math/tex" id="MathJax-Element-17"> w </script>  .  A private key is generated for each fragment. <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-103"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-104">S</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-105">K</span></span></span><script type="math/tex" id="MathJax-Element-18"> SK </script>  lengths <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-106"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-107">n</span></span></span><script type="math/tex" id="MathJax-Element-19"> n </script>  .  A hash operation is sequentially applied to each private key. <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-108"><span class="MJXp-msubsup" id="MJXp-Span-109"><span class="MJXp-mn" id="MJXp-Span-110" style="margin-right: 0.05em;">2</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-111" style="vertical-align: 0.5em;">w</span></span><span class="MJXp-mo" id="MJXp-Span-112" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mn" id="MJXp-Span-113">1</span></span></span><script type="math/tex" id="MathJax-Element-20"> 2 ^ w-1 </script>  times (rounds <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-114"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-115">R</span></span></span><script type="math/tex" id="MathJax-Element-21"> R </script>  ).  As a result of the operations performed, the corresponding public keys are obtained. <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-116"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-117">P</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-118">K</span></span></span><script type="math/tex" id="MathJax-Element-22"> PK </script>  same length <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-119"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-120">n</span></span></span><script type="math/tex" id="MathJax-Element-23"> n </script>  . <br><br><img src="https://habrastorage.org/webt/rg/co/3z/rgco3zidtwblb31xk3aasxa-prg.png"><br><br>  When signing, as in the generation of public keys, an iterative calculation of the hash over the private keys is performed.  The number of repetitions in each case depends on the message being signed.  As mentioned earlier, the message is divided into blocks of length. <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-121"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-122">w</span></span></span><script type="math/tex" id="MathJax-Element-24"> w </script>  .  The numerical value of this block <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-123"><span class="MJXp-msubsup" id="MJXp-Span-124"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-125" style="margin-right: 0.05em;">M</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-126" style="vertical-align: -0.4em;">i</span></span></span></span><script type="math/tex" id="MathJax-Element-25"> M_i </script>  and is the number of iterations that must be performed on the private keys to obtain the signature.  The connection of the received blocks will be the signature of this message. <br><br><img src="https://habrastorage.org/webt/-p/mc/u-/-pmcu-f-960xbnpef4r0upermvw.png"><br><br>  When checking the signature on fragments of its length <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-127"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-128">n</span></span></span><script type="math/tex" id="MathJax-Element-26"> n </script>  an iterative hash calculation is performed.  Number of rounds <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-129"><span class="MJXp-msubsup" id="MJXp-Span-130"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-131" style="margin-right: 0.05em;">R</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-132" style="vertical-align: -0.4em;">i</span></span></span></span><script type="math/tex" id="MathJax-Element-27"> R_i </script>  applying a hash function is defined as the difference between the number of iterations to obtain the public key and the numerical value of the message block, i.e. <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-133"><span class="MJXp-msubsup" id="MJXp-Span-134"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-135" style="margin-right: 0.05em;">R</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-136" style="vertical-align: -0.4em;">i</span></span><span class="MJXp-mo" id="MJXp-Span-137" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-msubsup" id="MJXp-Span-138"><span class="MJXp-mn" id="MJXp-Span-139" style="margin-right: 0.05em;">2</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-140" style="vertical-align: 0.5em;">w</span></span><span class="MJXp-mo" id="MJXp-Span-141" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mn" id="MJXp-Span-142">1</span><span class="MJXp-mo" id="MJXp-Span-143" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-msubsup" id="MJXp-Span-144"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-145" style="margin-right: 0.05em;">M</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-146" style="vertical-align: -0.4em;">i</span></span></span></span><script type="math/tex" id="MathJax-Element-28"> R_i = 2 ^ w-1 - M_i </script>  time.  Then the obtained values ​​are compared with the corresponding public key. <br><br><div class="spoiler">  <b class="spoiler_title">Example</b> <div class="spoiler_text">  I will illustrate the above with a small example.  Let the message be given <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-147"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-148">M</span></span></span><script type="math/tex" id="MathJax-Element-29"> M </script>  (in bit representation) lengths <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-149"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-150">m</span></span></span><script type="math/tex" id="MathJax-Element-30"> m </script>  , the parameter Vinternitsa <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-151"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-152">w</span></span></span><script type="math/tex" id="MathJax-Element-31"> w </script>  and some length hash function <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-153"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-154">n</span></span></span><script type="math/tex" id="MathJax-Element-32"> n </script>  : <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-155"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-156">M</span><span class="MJXp-mo" id="MJXp-Span-157" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-158">11000111</span><span class="MJXp-mspace" id="MJXp-Span-159" style="width: 0.222em; height: 0em;"></span><span class="MJXp-mn" id="MJXp-Span-160">01100111</span><span class="MJXp-mo" id="MJXp-Span-161" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-162">m</span><span class="MJXp-mo" id="MJXp-Span-163" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-164">16</span><span class="MJXp-mo" id="MJXp-Span-165" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mspace" id="MJXp-Span-166" style="width: 0.222em; height: 0em;"></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-167">w</span><span class="MJXp-mo" id="MJXp-Span-168" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-169">8</span><span class="MJXp-mo" id="MJXp-Span-170" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mspace" id="MJXp-Span-171" style="width: 0.222em; height: 0em;"></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-172">n</span><span class="MJXp-mo" id="MJXp-Span-173" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-174">256.</span></span></span><script type="math/tex;mode=display" id="MathJax-Element-33"> M = 11000111 \: 01100111, m = 16, \: w = 8, \: n = 256. </script></p><br>  We generate <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-175"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-176">m</span><span class="MJXp-mrow" id="MJXp-Span-177"><span class="MJXp-mo" id="MJXp-Span-178" style="margin-left: 0.111em; margin-right: 0.111em;">/</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-179">w</span><span class="MJXp-mo" id="MJXp-Span-180" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-181">2</span></span></span><script type="math/tex" id="MathJax-Element-34"> m / w = 2 </script>  private keys based on a pseudo-random number generator.  We apply to each private key <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-182"><span class="MJXp-msubsup" id="MJXp-Span-183"><span class="MJXp-mn" id="MJXp-Span-184" style="margin-right: 0.05em;">2</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-185" style="vertical-align: 0.5em;">w</span></span><span class="MJXp-mo" id="MJXp-Span-186" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mn" id="MJXp-Span-187">1</span><span class="MJXp-mo" id="MJXp-Span-188" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mrow" id="MJXp-Span-189"><span class="MJXp-mo" id="MJXp-Span-190" style="margin-left: 0em; margin-right: 0em;">$</span></span><span class="MJXp-mn" id="MJXp-Span-191">25</span></span></span><script type="math/tex" id="MathJax-Element-35"> 2 ^ w-1 = $ 25</script>  times the hash function, thereby obtaining <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-192"><span class="MJXp-mn" id="MJXp-Span-193">2</span></span></span><script type="math/tex" id="MathJax-Element-36"> 2 </script>  public keys that are combined into one common key length <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-194"><span class="MJXp-mn" id="MJXp-Span-195">2</span><span class="MJXp-mo" id="MJXp-Span-196" style="margin-left: 0.267em; margin-right: 0.267em;">∗</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-197">n</span><span class="MJXp-mo" id="MJXp-Span-198" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-199">512</span></span></span><script type="math/tex" id="MathJax-Element-37"> 2 * n = 512 </script>  bit.  Next for each message block <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-200"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-201">M</span></span></span><script type="math/tex" id="MathJax-Element-38"> M </script>  lengths <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-202"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-203">w</span></span></span><script type="math/tex" id="MathJax-Element-39"> w </script>  determine the number of hashing operations applied to the private key <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-204"><span class="MJXp-msubsup" id="MJXp-Span-205"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-206" style="margin-right: 0.05em;">R</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-207" style="vertical-align: -0.4em;">i</span></span></span></span><script type="math/tex" id="MathJax-Element-40"> R_i </script>  .  In this case, these will be the values. <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-208"><span class="MJXp-msubsup" id="MJXp-Span-209"><span class="MJXp-mn" id="MJXp-Span-210" style="margin-right: 0.05em;">11000111</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-211" style="vertical-align: -0.4em;">2</span></span><span class="MJXp-mo" id="MJXp-Span-212" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-msubsup" id="MJXp-Span-213"><span class="MJXp-mn" id="MJXp-Span-214" style="margin-right: 0.05em;">199</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-215" style="vertical-align: -0.4em;"><span class="MJXp-mn" id="MJXp-Span-216">10</span></span></span></span></span><script type="math/tex" id="MathJax-Element-41"> 11000111_2 = 199_ {10} </script>  and <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-217"><span class="MJXp-msubsup" id="MJXp-Span-218"><span class="MJXp-mn" id="MJXp-Span-219" style="margin-right: 0.05em;">01100111</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-220" style="vertical-align: -0.4em;">2</span></span><span class="MJXp-mo" id="MJXp-Span-221" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-msubsup" id="MJXp-Span-222"><span class="MJXp-mn" id="MJXp-Span-223" style="margin-right: 0.05em;">103</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-224" style="vertical-align: -0.4em;"><span class="MJXp-mn" id="MJXp-Span-225">10</span></span></span></span></span><script type="math/tex" id="MathJax-Element-42"> 01100111_2 = 103_ {10} </script>  respectively.  By performing a hash operation on private keys, we get a signature length <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-226"><span class="MJXp-mn" id="MJXp-Span-227">2</span><span class="MJXp-mo" id="MJXp-Span-228" style="margin-left: 0.267em; margin-right: 0.267em;">∗</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-229">n</span><span class="MJXp-mo" id="MJXp-Span-230" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-231">512</span></span></span><script type="math/tex" id="MathJax-Element-43"> 2 * n = 512 </script>  bit. <br><br>  To verify the signature divide it into parts of length <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-232"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-233">n</span></span></span><script type="math/tex" id="MathJax-Element-44"> n </script>  .  Over each part we produce <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-234"><span class="MJXp-msubsup" id="MJXp-Span-235"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-236" style="margin-right: 0.05em;">R</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-237" style="vertical-align: -0.4em;">i</span></span><span class="MJXp-mo" id="MJXp-Span-238" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-msubsup" id="MJXp-Span-239"><span class="MJXp-mn" id="MJXp-Span-240" style="margin-right: 0.05em;">2</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-241" style="vertical-align: 0.5em;">w</span></span><span class="MJXp-mo" id="MJXp-Span-242" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mn" id="MJXp-Span-243">1</span><span class="MJXp-mo" id="MJXp-Span-244" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-msubsup" id="MJXp-Span-245"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-246" style="margin-right: 0.05em;">M</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-247" style="vertical-align: -0.4em;">i</span></span></span></span><script type="math/tex" id="MathJax-Element-45"> R_i = 2 ^ w-1 - M_i </script>  hash operations  Those. <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-248"><span class="MJXp-mn" id="MJXp-Span-249">255</span><span class="MJXp-mo" id="MJXp-Span-250" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mn" id="MJXp-Span-251">199</span><span class="MJXp-mo" id="MJXp-Span-252" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mrow" id="MJXp-Span-253"><span class="MJXp-mo" id="MJXp-Span-254" style="margin-left: 0em; margin-right: 0em;">$</span></span><span class="MJXp-mn" id="MJXp-Span-255">5</span></span></span><script type="math/tex" id="MathJax-Element-46"> 255 - 199 = $ 5</script>  and <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-256"><span class="MJXp-mn" id="MJXp-Span-257">255</span><span class="MJXp-mo" id="MJXp-Span-258" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mn" id="MJXp-Span-259">103</span><span class="MJXp-mo" id="MJXp-Span-260" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mrow" id="MJXp-Span-261"><span class="MJXp-mo" id="MJXp-Span-262" style="margin-left: 0em; margin-right: 0em;">$</span></span><span class="MJXp-mn" id="MJXp-Span-263">15</span></span></span><script type="math/tex" id="MathJax-Element-47"> 255 - 103 = $ 15</script>  times accordingly.  If, as a result of the operations performed, the value obtained coincides with the public key, then the message is valid. <br></div></div><br>  When using SHA-256 as a hash function for the signature Winterternits, <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-264"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-265">m</span><span class="MJXp-mo" id="MJXp-Span-266" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-267">n</span><span class="MJXp-mo" id="MJXp-Span-268" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-269">256</span></span></span><script type="math/tex" id="MathJax-Element-48"> m = n = 256 </script>  . <br><br>  Let be <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-270"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-271">w</span><span class="MJXp-mo" id="MJXp-Span-272" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-273">8</span></span></span><script type="math/tex" id="MathJax-Element-49"> w = 8 </script>  bit.  Then the full size of the public key <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-274"><span class="MJXp-msubsup" id="MJXp-Span-275"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-276" style="margin-right: 0.05em;">L</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-277" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-278">P</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-279">K</span></span></span></span></span><script type="math/tex" id="MathJax-Element-50"> L_ {PK} </script>  and signatures <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-280"><span class="MJXp-msubsup" id="MJXp-Span-281"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-282" style="margin-right: 0.05em;">L</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-283" style="vertical-align: -0.4em;">S</span></span></span></span><script type="math/tex" id="MathJax-Element-51"> L_S </script>  are equal: <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-284"><span class="MJXp-msubsup" id="MJXp-Span-285"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-286" style="margin-right: 0.05em;">L</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-287" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-288">P</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-289">K</span></span></span><span class="MJXp-mo" id="MJXp-Span-290" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-msubsup" id="MJXp-Span-291"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-292" style="margin-right: 0.05em;">L</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-293" style="vertical-align: -0.4em;">S</span></span><span class="MJXp-mo" id="MJXp-Span-294" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-295">m</span><span class="MJXp-mrow" id="MJXp-Span-296"><span class="MJXp-mo" id="MJXp-Span-297" style="margin-left: 0.111em; margin-right: 0.111em;">/</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-298">w</span><span class="MJXp-mo" id="MJXp-Span-299" style="margin-left: 0.267em; margin-right: 0.267em;">∗</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-300">n</span><span class="MJXp-mo" id="MJXp-Span-301" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-302">256</span><span class="MJXp-mrow" id="MJXp-Span-303"><span class="MJXp-mo" id="MJXp-Span-304" style="margin-left: 0.111em; margin-right: 0.111em;">/</span></span><span class="MJXp-mn" id="MJXp-Span-305">8</span><span class="MJXp-mo" id="MJXp-Span-306" style="margin-left: 0.267em; margin-right: 0.267em;">∗</span><span class="MJXp-mn" id="MJXp-Span-307">256</span><span class="MJXp-mo" id="MJXp-Span-308" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-309">8</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-310">K</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-311">B</span><span class="MJXp-mo" id="MJXp-Span-312" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-313">1</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-314">K</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-315">B</span><span class="MJXp-mo" id="MJXp-Span-316" style="margin-left: 0em; margin-right: 0.222em;">.</span></span></span><script type="math/tex;mode=display" id="MathJax-Element-52"> L_ {PK} = L_S = m / w * n = 256/8 * 256 = 8 KB = 1 KB. </script></p><br>  The number of hash calculations in this case is: <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-317"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-318">P</span><span class="MJXp-mo" id="MJXp-Span-319" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mo" id="MJXp-Span-320" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-321"><span class="MJXp-mn" id="MJXp-Span-322" style="margin-right: 0.05em;">2</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-323" style="vertical-align: 0.5em;">w</span></span><span class="MJXp-mo" id="MJXp-Span-324" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mn" id="MJXp-Span-325">1</span><span class="MJXp-mo" id="MJXp-Span-326" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-327" style="margin-left: 0.267em; margin-right: 0.267em;">∗</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-328">m</span><span class="MJXp-mrow" id="MJXp-Span-329"><span class="MJXp-mo" id="MJXp-Span-330" style="margin-left: 0.111em; margin-right: 0.111em;">/</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-331">w</span><span class="MJXp-mo" id="MJXp-Span-332" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mo" id="MJXp-Span-333" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-334"><span class="MJXp-mn" id="MJXp-Span-335" style="margin-right: 0.05em;">2</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-336" style="vertical-align: 0.5em;">8</span></span><span class="MJXp-mo" id="MJXp-Span-337" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mn" id="MJXp-Span-338">1</span><span class="MJXp-mo" id="MJXp-Span-339" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-340" style="margin-left: 0.267em; margin-right: 0.267em;">∗</span><span class="MJXp-mn" id="MJXp-Span-341">256</span><span class="MJXp-mrow" id="MJXp-Span-342"><span class="MJXp-mo" id="MJXp-Span-343" style="margin-left: 0.111em; margin-right: 0.111em;">/</span></span><span class="MJXp-mn" id="MJXp-Span-344">8</span><span class="MJXp-mo" id="MJXp-Span-345" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-346">8160.</span></span></span><script type="math/tex;mode=display" id="MathJax-Element-53"> P = (2 ^ w-1) * m / w = (2 ^ 8-1) * 256/8 = 8160. </script></p><br>  For the case of <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-347"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-348">w</span><span class="MJXp-mo" id="MJXp-Span-349" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-350">16</span></span></span><script type="math/tex" id="MathJax-Element-54"> w = 16 </script>  this value increases to <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-351"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-352">P</span><span class="MJXp-mo" id="MJXp-Span-353" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mrow" id="MJXp-Span-354"><span class="MJXp-mo" id="MJXp-Span-355" style="margin-left: 0em; margin-right: 0em;">$</span></span><span class="MJXp-mn" id="MJXp-Span-356">104856</span></span></span><script type="math/tex" id="MathJax-Element-55"> P = $ 104856</script>  . <br></div></div><br>  The sizes of the public key and the signature, with the same parameters as in the example for the signature of Lamport, are equal to 1 KB.  In total, this is less than in the signature of Lamport (24 KB).  However, the number of hash calculations is 8160. This is undoubtedly a lot.  In addition, when verifying the signature, an average of half of this number of iterations is performed.  This makes this option signature inappropriate for use in the blockchain. <br><br>  There are several variants of the Winterternitz signature, including with the extension of the signature in order to increase reliability and reduce the number of applications of the hash function.  Their description is beyond the scope of this article.  Those who are interested can see more <a href="https://eprint.iacr.org/2017/965.pdf">here</a> .  The use of the Winternitz signature based on the national hash function GOST 34.11-12 can be viewed <a href="https://moluch.ru/archive/157/44376/">here</a> . <br><br><h3>  Merkle Tree (MSS) </h3><br>  One-time signatures can provide satisfactory cryptographic security; however, it is their disposability that can be a serious problem.  Let it be necessary to transfer savings from one address to another.  It turns out that when using one-time signatures, it will be necessary to transfer the entire amount of funds each time, and a new address will be needed for each transaction.  With each transaction you will need to publish a new public key.  In addition, the preservation in the blockchain of new transactions will gradually require more time to search for them. <br><br>  To solve the problem, the signature scheme is extended by holding several signatures based on several key pairs for each address.  The use of several signatures is performed on the basis of a binary hash tree - the Merkle tree. <br><br><div class="spoiler">  <b class="spoiler_title">Read more</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/fb/kg/l2/fbkgl2qgsmtpfjxidzttg-ku1oi.png"></div><br><br>  The calculation of the tree is made from leaves to the root.  Each leaf node of the tree is computed as a hash of the generated public key.  The remaining nodes are calculated by obtaining a hash from the concatenation (gluing) of the child nodes.  Thus, the whole tree is calculated to the root.  Let there be 4 pairs of keys, the Merkle tree is calculated by calculating 7 hashes (see the figure above). <br><br>  A feature of the Merkle tree is that the existence of any node or leaf can be cryptographically proven by calculating the root. <br><br>  The message signature is created using the private key from the selected key pair. <br><br>  Signature verification involves calculating the root based on the passed parameters and comparing with it as with a reusable public key.  These parameters are: <br><br><ul><li>  signature; </li><li>  root; </li><li>  one-time key, the closed part of which the message was signed; </li><li>  hashes from the tree, lying on the way from the selected sheet to the root. </li></ul><br>  When using one-time Merkle or Winternitz signatures, there is no need to transfer a separately selected one-time public key, since it can be obtained from the message signature.  It is enough to transfer its number reflecting its position in a tree.  For example, in the figure above, the transmitted parameters will be: signature, root, sheet number - 0 (the sheet number with the key <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-357"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-358">P</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-359">K</span><span class="MJXp-mn" id="MJXp-Span-360">1</span></span></span><script type="math/tex" id="MathJax-Element-56"> PK1 </script>  ) and hashes <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-361"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-362">H</span><span class="MJXp-mn" id="MJXp-Span-363">2</span></span></span><script type="math/tex" id="MathJax-Element-57"> H2 </script>  and <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-364"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-365">H</span><span class="MJXp-mn" id="MJXp-Span-366">6</span></span></span><script type="math/tex" id="MathJax-Element-58"> H6 </script>  .  When performing a signature verification, the public key will be obtained from it. <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-367"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-368">P</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-369">K</span><span class="MJXp-mn" id="MJXp-Span-370">1</span></span></span><script type="math/tex" id="MathJax-Element-59"> PK1 </script>  respectively hash <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-371"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-372">H</span><span class="MJXp-mn" id="MJXp-Span-373">1</span></span></span><script type="math/tex" id="MathJax-Element-60"> H1 </script>  .  Hashes <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-374"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-375">H</span><span class="MJXp-mn" id="MJXp-Span-376">1</span></span></span><script type="math/tex" id="MathJax-Element-61"> H1 </script>  and <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-377"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-378">H</span><span class="MJXp-mn" id="MJXp-Span-379">2</span></span></span><script type="math/tex" id="MathJax-Element-62"> H2 </script>  will calculate <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-380"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-381">H</span><span class="MJXp-mn" id="MJXp-Span-382">5</span></span></span><script type="math/tex" id="MathJax-Element-63"> H5 </script>  .  And hashes <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-383"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-384">H</span><span class="MJXp-mn" id="MJXp-Span-385">5</span></span></span><script type="math/tex" id="MathJax-Element-64"> H5 </script>  and <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-386"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-387">H</span><span class="MJXp-mn" id="MJXp-Span-388">6</span></span></span><script type="math/tex" id="MathJax-Element-65"> H6 </script>  will calculate the root <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-389"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-390">R</span></span></span><script type="math/tex" id="MathJax-Element-66"> R </script>  which can be compared with the value of the transferred root. <br></div></div><br>  The Merkle tree, compiled and calculated from public keys, allows instead of publishing the entire set of them to publish only the root of the tree.  This increases the size of the signature by including a part of the tree in the signature, but makes it possible using only 1 hash to verify many signatures.  So, at the depth of the tree <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-391"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-392">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-67-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-67"> N </script>  can sign <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-393"><span class="MJXp-msubsup" id="MJXp-Span-394"><span class="MJXp-mn" id="MJXp-Span-395" style="margin-right: 0.05em;">2</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-396" style="vertical-align: 0.5em;">n</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-68-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-68"> 2 ^ n </script>  posts. <br><br> Дерево Меркла для ключей на базе алгоритма эллиптических кривых используется в Биткойн и Ethereum, о последнем с рассмотрением дерева Меркла есть отличная <a href="https://geektimes.ru/post/294611/">статья</a> . <br><br><h3> Гипердеревья </h3><br> Основным недостатком базовой схемы Меркла является то, что количество доступных подписей ограничено, и все пары ключей одноразовых подписей должны быть сгенерированы до вычисления дерева Меркла. Генерация ключей и время подписывания растут экспоненциально относительно высоты дерева. Отсрочить генерацию новых ключей, а также увеличить количество доступных пар возможно при использовании гипердерева. <br><br><div class="spoiler">  <b class="spoiler_title">Read more</b> <div class="spoiler_text"> Гипердерево представляет собой структуру, состоящую из деревьев Меркла. В этой структуре по назначению выделяются 2 типа деревьев: дерево сертификации и дерево подписи. Дереву подписи соответствуют ключи, используемые для подписывания сообщений. Дереву сертификации соответствуют ключи для подписывания корней деревьев подписи. Таким образом, деревья подписи являются дочерними к дереву сертификации (см. рисунок ниже). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ot/oh/9u/otoh9uehpqiypbtbd_22ozhn4-y.png"></div><br><br> Для проверки подписи сообщения в этом случае передаются те же параметры, что и для обычного дерева Меркла, но с обоих деревьев. Таким образом, подпись и ее проверка становятся несколько сложнее, однако появляется возможность гибко расширять структуру. В то время как размер и количество подписей для каждого дополнительного дерева растет линейно, общий объем подписей гипердерева растет экспоненциально. <br><br> Нет необходимости строить гипердерево симметричным. Всегда можно дополнить его слоями новых деревьев подписи. Таким образом, подписи блока транзакций будут изначально небольшого размера, который будет возрастать по мере увеличения глубины гипердерева. <br></div></div><br><h3> Расширенная структура дерева Меркла (XMSS) </h3><br> Полное описание схемы выходит далеко за рамки данной статьи, подробнее можно прочесть <a href="https://eprint.iacr.org/2011/484.pdf">здесь</a> . Коснусь лишь базовых представлений и характеристик. Схема XMSS как и дерево Меркла позволяет расширять одноразовые подписи. Использование битовой маски с применением исключающего ИЛИ (XOR) дочерних узлов до конкатенации хешей в родительский узел позволяет повысить устойчивость к коллизиям применяемых хеш-функций. Так, при использовании SHA-256 в качестве хеш-функции в сочетании с расширенной схемой Винтерница с параметром безопасности (W-OTS+) позволяет увеличить безопасность с 128 до 196 бит. Согласно <a href="https://infoscience.epfl.ch/record/164526/files/NPDF-22.pdf">Ленстра</a> , 196-битной защиты достаточно, чтобы считать ее безопасной против атаки путем простого перебора до 2169 года. При всех достоинствах схемы XMSS ее основным недостатком является длительное время генерации ключа. <br><br> В настоящее время существуют и другие схемы расширения дерева Меркла ( <a href="https://www.cdc.informatik.tu-darmstadt.de/reports/reports/BDKOV07.pdf">GMSS</a> , <a href="http://www.cdc.informatik.tu-darmstadt.de/reports/reports/BCDDK06.pdf">CMSS</a> ), которые в сочетании с алгоритмами одноразовой подписи также могут быть использованы в блокчейне, устойчивом к атакам с применением квантового компьютера. <br><br><h2> Часть 3. Реализация идей </h2><br><h3> Проект квантово-устойчивого блокчена — QRL </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ww/ky/vj/wwkyvjpekrwginfpnbk9pjpbx9y.png"></div><br><br> Во второй половине 2016 года доктором наук П. Ватерлендом создается группа по разработке блокчейна устойчивого как классическим атакам, так и к атакам с применением квантового компьютера. По результатам разработки теоретической части в конце того же года в открытый доступ выложен главный документ разрабатываемого блокчейна — «белая книга» (white paper). В настоящий момент <a href="https://github.com/theQRL/Whitepaper/blob/master/QRL_Whitepaper_Russian.pdf">документ</a> доступен на нескольких языках, включая русский. <br><br><h3> Основные характеристики QRL </h3><br> <b><i>1. Схема подписи и безопасность</i></b> <br> Применяется схема подписи на основе алгоритма расширенной подписи Винтерница (W-OTS+, w = 16, SHA-256) на базе связных структур XMSS. Такой подход позволяет генерировать адреса с возможностью подписи, избегая длительной вычислительной задержки, наблюдаемой при создании гигантских конструкций XMSS. Обеспечивает 196-битную защиту с прогнозируемой безопасностью против атаки путем простого перебора до 2169 года. <br><br> <b><i>2. Алгоритм консенсуса — доказательство работы (proof-of-work)</i></b> <br> В первой итерации основной сети анонсирован алгоритм консенсуса proof-of-work. <br><br> <b><i>3. Плавающая комиссия</i></b> <br> Боʼльшие размеры транзакций по сравнению с другими блоками цепочки транзакций требуют оплаты для каждой транзакции. По мнению Ватерленда, рынки с искусственной комиссией (например, Биткойн) не нужны и противоречат идеалу открытого блокчейна. Каждая транзакция, если она сопровождается минимальной оплатой, должна быть такой же действительной, как и любая другая. Размер минимальной оплаты, приемлемой для майнеров, должен быть плавающим и устанавливаться рынком.  Those. узлы (майнеры) должны конкурентно устанавливать нижнюю границу оплаты между собой. Абсолютное минимальное значение будет соблюдаться на уровне протокола. Таким образом, майнеры будут заказывать транзакции из мемпула для включения в блок по своему усмотрению. <br><br> <b><i>4. Динамическое вычисление вознаграждения за блок</i></b> <br> Каждый новый созданный блок будет включать в себя первую транзакцию «coinbase», содержащую адрес майнинга, для которого вознаграждение будет определено как сумма вознаграждения за монетную ставку с общей суммой комиссий за транзакции внутри блока. <br><br> <b><i>5. Время нахождения блоков — 1 минута</i></b> <br> Время между блоками в сети Биткойн составляет примерно 10 минут. При требуемых 6-ти подтверждениях это дополнительно увеличивает время ожидания завершения транзакции. Более новые схемы блока цепочки транзакций, такие как Ethereum, улучшены в этом аспекте и выигрывают за счет более короткого времени нахождения блока без потери в безопасности или централизации майнеров из-за высокой скорости появления осиротевших/устаревших блоков. <br><br> Для QRL это время нахождение блока составляет 1 минуту. <br><br> <b><i>6. Адаптивный размер блока</i></b> <br> Во избежание возможных споров было смоделировано готовое адаптивное решение, базирующееся на предложении Bitpay, которое использует для увеличения размера блока множитель <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-397"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-398">x</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-69-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-69">x</script> средней величины <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-399"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-400">y</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-70-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-70"> y </script> последних <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-401"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-402">z</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-71-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-71">z</script> блоков. Использование средней величины не позволяет майнерам манипулировать, включая либо пустые, либо переполненные блоки для изменения среднего размера блока. <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-403"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-404">x</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-72-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-72">x</script>  and <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-405"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-406">z</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-73-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-73">z</script> будут тогда жесткими консенсусными правилами для сети, которым придется подчиняться. Таким образом, максимальный размер блока <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-407"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-408">b</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-74-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-74">b</script> можно просто вычислить как: <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-409"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-410">b</span><span class="MJXp-mo" id="MJXp-Span-411" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-412">x</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-413">y</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-75-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-75">b = xy</script>  . <br><br> <b><i>7. Денежная единица — квант</i></b> <br> Базовой единицей валюты является квант. Каждый квант делится на наименьшие элементы. Ниже представлены названия всех элементов в порядке возрастания: <br><table><tbody><tr><th>  Element </th><th>  Value </th></tr><tr><td align="center"> Шор </td><td align="center"><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-414"><span class="MJXp-mn" id="MJXp-Span-415">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-76-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-76">1</script></td></tr><tr><td align="center"> Накамото </td><td align="center"><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-416"><span class="MJXp-msubsup" id="MJXp-Span-417"><span class="MJXp-mn" id="MJXp-Span-418" style="margin-right: 0.05em;">10</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-419" style="vertical-align: 0.5em;">3</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-77-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-77">10^3</script></td></tr><tr><td align="center"> Бутерин </td><td align="center"><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-420"><span class="MJXp-msubsup" id="MJXp-Span-421"><span class="MJXp-mn" id="MJXp-Span-422" style="margin-right: 0.05em;">10</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-423" style="vertical-align: 0.5em;">6</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-78-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-78">10^6</script></td></tr><tr><td align="center"> Меркл </td><td align="center"><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-424"><span class="MJXp-msubsup" id="MJXp-Span-425"><span class="MJXp-mn" id="MJXp-Span-426" style="margin-right: 0.05em;">10</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-427" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-428">10</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-79-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-79">10^{10}</script></td></tr><tr><td align="center"> Лэмпорт </td><td align="center"><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-429"><span class="MJXp-msubsup" id="MJXp-Span-430"><span class="MJXp-mn" id="MJXp-Span-431" style="margin-right: 0.05em;">10</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-432" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-433">13</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-80-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-80">10^{13}</script></td></tr><tr><td align="center"> Квант </td><td align="center"><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-434"><span class="MJXp-msubsup" id="MJXp-Span-435"><span class="MJXp-mn" id="MJXp-Span-436" style="margin-right: 0.05em;">10</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-437" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-438">16</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-81-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-81">10^{16}</script></td></tr></tbody></table><br> Таким образом, каждая транзакция с участием части кванта на самом деле очень большое число единиц Шора. Плата за транзакцию рассчитывается и проводится в единицах Шора. <br><br> <b><i>8. Аккаунты и адреса</i></b> <br> Балансы пользователя хранится на аккаунтах. Каждый аккаунт является уникальным многократно используемым адресом блока цепочки транзакций, обозначенным строкой, начинающейся с «Q». <br><br> Адрес создается посредством выполнения SHA-256 по корню Меркла самого высокого дерева сертификации XMSS. К этому добавляется четырехбайтная контрольная сумма, образованная из первых четырех байтов двойного хеша SHA-256 корня Меркла, и буквы «Q». <br><br> Например, в псевдокоде Python это будет описано следующим образом: <br><br><pre><code class="python hljs">Q + sha256(merkle root) + sha256(sha256(merkle root))[: <span class="hljs-number"><span class="hljs-number">4</span></span>]</code> </pre> <br>  Typical account address: <br>  Qcea29b1402248d53469e352de662923986f3a94cf0f51522bedd08fb5e64948af479 <br><br> Каждый аккаунт имеет баланс, деноминированный в квантах, делимый вплоть до единственной единицы Шора. Адреса с каждой транзакцией используют новую пару ключей одноразовой подписи. Счетчик транзакций, называемый nonce, будет увеличиваться с каждой транзакцией, отправленной с аккаунта. Это позволяет кошелькам, которые не хранят всю цепочку блоков, отслеживать их местоположение в схеме подписи гипердерева с сохранением состояния. <br><br><h3> Текущее состояние проекта и планы на будущее </h3><br> После выпуска «белой книги» группа пополнилась несколькими новыми разработчиками и началась работа над воплощением задуманного в жизнь. На сайте проекта появились регулярные отчеты о проделанной работе. И к апрелю 2017 года уже была запущена тестовая сеть блокчейна QRL. Исходный код проекта выложен на Github. Проект активно обсуждается на Bitcointalk и Reddit. <br><br> В мае 2017 было проведено ICO в экосистеме Ethereum. Выпущен токен QRL стандарта ERC20. Всего было выпущено 65 млн. токенов. Из них в обращении находится 52 млн. токенов. Постепенно в течение 200 лет будет выпущено еще 40 млн. монет. Таким образом, общий объем эмиссии составит 105 млн. монет. При запуске основной сети эти токены можно будет обменять на QRL монеты в соотношении 1:1. В настоящий момент токены доступны для покупки на таких биржах как Bittrex, Upbit и Liqui. Котировки QRL, согласно сайту <a href="https://coinmarketcap.com/">coinmarketcap.com</a> , представлены на рисунках ниже. <br><br><img src="https://habrastorage.org/webt/yk/2c/6j/yk2c6jgezdhcmioanglx04yjgma.png"><br><br><img src="https://habrastorage.org/webt/bm/kf/rz/bmkfrzfzshhdgzgwp9j2ocd4iwm.png"><br><br> Запуск основной сети намечен на февраль-март 2018. <br><br> В дальнейшем планируется изменить алгоритм консенсуса с подтверждения работы на подтверждение доли (proof-of-stake). Ожидаемое безопасное время нахождения блоков будет составлять 15-30 секунд. <br><br><h2>  Conclusion </h2><br> Прогресс квантовых технологий запущен и его уже не остановить. По мере появления все более производительных квантовых машин спектр решаемых ими задач будет непрерывно расти. Взлом существующей криптозащиты, неприспособленной к атакам квантового компьютера, уже давно является одной из центральных тем множества <a href="http://www.etsi.org/news-events/events/1173-etsi-iqc-quantum-safe-workshop-2017">форумов по безопасности</a> . <br><br> QRL — первая блокчейн-технология, призванная решить эту проблему. В будущем, конечно, появятся и другие. Какая из них будет наиболее успешной — покажет время. <br><br><h2>  Thanks </h2><br> Автор выражает благодарность <a href="https://geektimes.ru/users/kamnik/" class="user_link">kamnik</a> за подготовку значительной части материала и, особенно, за техническую часть, а также <a href="https://geektimes.ru/users/sannx/" class="user_link">SannX</a> за конструктивную критику и правки. <br><br><h2>  Links </h2><br><ol><li> <a href="https://eax.me/shors-algorithm/">Алгоритм Шора</a> . </li><li> <a href="https://www-03.ibm.com/press/us/en/pressrelease/965.wss">Разложение числа 15 на простые множители на квантовом компьютере (IBM)</a> . </li><li> <a href="http://news.mit.edu/2016/quantum-computer-end-encryption-schemes-0303">Разложение числа 15 на простые множители на квантовом компьютере (MIT)</a> . </li><li> <a href="https://arxiv.org/pdf/1707.04344.pdf">Отчет об экспериментах на 51 кубитном компьютере</a> . </li><li> <a href="https://arxiv.org/pdf/1710.10377v1.pdf">Отчет Международной исследовательской группы об устойчивости Биткойна перед квантовым компьютером</a> . </li><li> <a href="https://en.bitcoin.it/wiki/Secp256k1">Использование алгоритма генерации ключей ECDSA в блокчейне Биткойна</a> . </li><li> <a href="https://news.bitcoin.com/is-bitcoin-at-risk-as-google-and-ibm-aim-for-50-qubit-quantum-computers/">Об устойчивости Биткойна к атакам квантового компьютера</a> . </li><li> <a href="https://ru.bitcoinwiki.org/wiki/%25D0%259F%25D0%25BE%25D0%25B4%25D1%2582%25D0%25B2%25D0%25B5%25D1%2580%25D0%25B6%25D0%25B4%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D1%2582%25D1%2580%25D0%25B0%25D0%25BD%25D0%25B7%25D0%25B0%25D0%25BA%25D1%2586%25D0%25B8%25D0%25B8">Подтверждение транзакции в сети Биткойн</a> . </li><li> <a href="https://bitaps.com/ru/">Информация о комиссиях в сети Bitcoin</a> . </li><li> <a href="https://oxt.me/charts">Статистика повторного использования Bitcoin-адресов</a> . </li><li> <a href="http://savepearlharbor.com/%3Fp%3D222457">Квантовый алгоритм Гровера</a> . </li><li> <a href="https://eprint.iacr.org/2017/965.pdf">Расширенная подпись Винтерница</a> . </li><li> <a href="https://moluch.ru/archive/157/44376/">Применение одноразовой подписи Винтерница на базе хеш-функции ГОСТ 34.11-12</a> . </li><li> <a href="https://geektimes.ru/post/294611/">Geektimes об Ethereum</a> . </li><li> <a href="https://eprint.iacr.org/2011/484.pdf">Схема XMSS</a> . </li><li> <a href="https://infoscience.epfl.ch/record/164526/files/NPDF-22.pdf">Ленстра. Выбор размеров криптографических ключей</a> . </li><li> <a href="https://www.cdc.informatik.tu-darmstadt.de/reports/reports/BDKOV07.pdf">GMSS</a> . </li><li> <a href="http://www.cdc.informatik.tu-darmstadt.de/reports/reports/BCDDK06.pdf">CMSS</a> . </li><li> <a href="https://coinmarketcap.com/">Курсы криптовалютных систем</a> . </li><li> <a href="http://www.etsi.org/news-events/events/1173-etsi-iqc-quantum-safe-workshop-2017">Ежегодный форум по постквантовой безопасности</a> . </li></ol><br><br><h3> Дополнительный материал </h3><br><ol><li> <a href="https://bitnovosti.com/2014/08/01/bitcoin-nsas-quantum-computer/">Опасен ли квантовый компьютер для Биткойна</a> . </li></ol><br><br><h3> Проект QRL </h3><br><ol><li> <a href="http://theqrl.org/">Сайт проекта</a> . </li><li> <a href="https://github.com/theQRL/Whitepaper/blob/master/QRL_Whitepaper_Russian.pdf">Белая книга</a> . </li><li>  <a href="https://www.youtube.com/watch%3Fv%3DCk-sHNNYFlQ">Presentation</a> . </li><li> <a href="https://medium.com/the-quantum-resistant-ledger">Блог</a> . </li><li> <a href="https://github.com/theQRL">Исходный код на GitHub</a> . </li><li> <a href="https://bitcointalk.org/index.php%3Ftopic%3D1730273">Ветка обсуждения на Bitcointalk</a> . </li></ol></div>