<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Valid SSL domain names for local Docker containers</title>
  <meta name="description" content="Using Docker in the development process has already become the de facto standard. Run the application with all its dependencies, using just one comman...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Valid SSL domain names for local Docker containers</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/0f/nk/vl/0fnkvlzglxdtf2dwegxn-atkobs.png" alt="preview"></p><br><p>  Using Docker in the development process has already become the de facto standard.  Run the application with all its dependencies, using just one command - it is becoming more and more familiar action.  If an application provides access using a web interface or some HTTP API, it is likely that the front-line container forwards its unique (among other applications that you are developing in parallel) to the host port, having knocked on which we can interact with the application in the container . </p><br><p>  And it works fine, until you have a whole zoo of applications, switching between them starts to cause some inconvenience, as you need to remember the scheme and the port, and somewhere to fix which ports for which application you once allocated, so as not there was a collision with time. </p><br><p> And then you also want to check the work on https - and you have to either use your root certificate, or always use <code>curl --insecure ...</code> , and when different commands work on applications - the number of steamers begins to increase exponentially. </p><br><p>  Faced with such a problem once again - the thought ‚ÄúStop it to endure!‚Äù Flashed in my head, and the result of working on a couple of days off was a service that solves this problem at the root, which will be discussed below.  For the impatient, traditionally - a <a href="https://localhost.tools/">reference</a> . </p><a name="habracut"></a><br><h3 id="mir-nas-spasyot-revers-proksi"><del>  World </del>  We will save the reverse proxy </h3><br><p>  In an amicable way, we need some kind of domain zone, all sub-domains from which will always resolve localhost (127.0.0.1).  A quick search put it on domains like <code>*.localho.st</code> , <code>*.lvh.me</code> , <code>*.vcap.me</code> and others, but how can you attach a valid SSL certificate to them?  Having fiddled with his root certificate, it was possible to start <code>curl</code> without errors, but not all browsers correctly accepted it, and continued to throw out the error.  In addition - I really did not want to "mess" with SSL. </p><br><p>  "Well, let's go on the other side!"  - and immediately a domain was acquired with the name <code>localhost.tools</code> , delegated to CloudFlare, the required resolution was configured (all sub-domains resolve <code>127.0.0.1</code> ): </p><br><pre> <code class="bash hljs">$ dig foo.localhost.tools | grep -v <span class="hljs-string"><span class="hljs-string">'^;\|^$'</span></span> foo.localhost.tools. 190 IN A 127.0.0.1</code> </pre> <br><p>  After that, <a href="https://certbot.eff.org/">certbot</a> was launched in a container that, at the entrance, receiving API KEY from CF using DNS records confirms ownership of the domain, and issues a valid SSL certificate at the output: </p><br><pre> <code class="bash hljs">$ docker run \ --entrypoint=<span class="hljs-string"><span class="hljs-string">""</span></span> \ -v <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(pwd)</span></span></span><span class="hljs-string">/cf-config.conf:/cf-credentials:ro"</span></span> \ -v <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(pwd)</span></span></span><span class="hljs-string">/cert:/out:rw"</span></span> \ -v <span class="hljs-string"><span class="hljs-string">"/etc/passwd:/etc/passwd:ro"</span></span> \ -v <span class="hljs-string"><span class="hljs-string">"/etc/group:/etc/group:ro"</span></span> \ certbot/dns-cloudflare:latest sh -c \ <span class="hljs-string"><span class="hljs-string">"certbot certonly \ --dns-cloudflare \ --dns-cloudflare-credentials '/cf-credentials' \ -d '*.localhost.tools' \ --non-interactive \ --agree-tos \ --email '</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$CF_EMAIL</span></span></span><span class="hljs-string">' \ --server 'https://acme-v02.api.letsencrypt.org/directory' \ &amp;&amp; cp -f /etc/letsencrypt/live/localhost.tools/* /out \ &amp;&amp; chown '</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(id -u)</span></span></span><span class="hljs-string">:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(id -g)</span></span></span><span class="hljs-string">' /out/*"</span></span></code> </pre> <br><blockquote>  The <code>./cf-config.conf</code> file contains authorization data on the CF, for more information, see the certbot documentation, <code>$CF_EMAIL</code> is an environment variable with your email </blockquote><p>  Ok, now we have a valid SSL certificate (even for 3 months, and only for subdomains of the same level).  It remains to somehow learn how to proxy all requests that come to lokalhost in the <strong>desired</strong> container. </p><br><p>  And here we come to the aid of <a href="https://traefik.io/">Traefik</a> (spoiler - it is beautiful).  By running it locally, flinging a docker socket into its container through the volume, it can proxy requests to the container that has the required <code>docker label</code> .  Thus, we do not need any additional configuration, except for launching the client to specify the desired label on the container (and docker network, but when running <em>without</em> docker-compose, even this is not necessary, although very desirable) to which we want to get <strong>domain name access and valid SSL</strong> ! </p><br><p>  Having done all this way, the light saw the docker-container with this most pre-configured Traefik and wildcard SSL certificate (yes, it is public). </p><br><h2 id="privatnyy-klyuch-ot-ssl-v-publichnom-konteynere">  SSL private key in a public container? </h2><br><p>  Yes, but I think that it is not scary, as it is on the domain zone, which always resolves the localhost.  MitM in this case does not make much sense in principle. </p><br><h2 id="chto-delat-kogda-sertifikat-protuhnet">  What to do when the certificate goes rotten? </h2><br><p>  Just pull off a fresh image by restarting the container.  The project has CI configured, which automatically, once a month (for the time being) updates the certificate and publishes a fresh image. </p><br><h2 id="hochu-poprobovat">  I want to try! </h2><br><p>  There is nothing easier.  First of all, make sure that local ports <code>80</code> and <code>443</code> free, and execute: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># –°–æ–∑–¥–∞—ë–º docker-—Å–µ—Ç—å –¥–ª—è –Ω–∞—à–µ–≥–æ —Ä–µ–≤–µ—Ä—Å-–ø—Ä–æ–∫—Å–∏ $ docker network create localhost-tools-network # –ó–∞–ø—É—Å–∫–∞–µ–º —Å–∞–º —Ä–µ–≤–µ—Ä—Å-–ø—Ä–æ–∫—Å–∏ $ docker run -d --rm \ -v /var/run/docker.sock:/var/run/docker.sock \ --network localhost-tools-network \ --name localhost.tools \ -p 80:80 -p 443:443 \ tarampampam/localhost # –ó–∞–ø—É—Å–∫–∞–µ–º nginx, –≥–æ–≤–æ—Ä—è –µ–º—É –æ—Ç–∫–ª–∏–∫–∞—Ç—å—Å—è –Ω–∞ "my-nginx.localhost.tools" $ docker run -d --rm \ --network localhost-tools-network \ --label "traefik.frontend.rule=Host:my-nginx.localhost.tools" \ --label "traefik.port=80" \ nginx:latest</span></span></code> </pre> <br><p>  And now we can test: </p><br><pre> <code class="bash hljs">$ curl -sS http://my-nginx.localhost.tools | grep Welcome &lt;title&gt;Welcome to nginx!&lt;/title&gt; &lt;h1&gt;Welcome to nginx!&lt;/h1&gt; $ curl -sS https://my-nginx.localhost.tools | grep Welcome &lt;title&gt;Welcome to nginx!&lt;/title&gt; &lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</code> </pre> <br><p>  As you can see - it works :) </p><br><h2 id="gde-zhivyot-dokumentaciya-opisanie">  Where does the documentation live? </h2><br><p>  Everything, as it is not difficult to guess, lives at <a href="https://localhost.tools/">https://localhost.tools</a> .  Moreover, the muzzle is responsive, and it knows how to look at whether the reverse proxy daemon is running locally, and display a list of containers running and available for interaction (if any). </p><br><h2 id="skolko-stoit">  How much is? </h2><br><p>  Not at all.  Totally.  Having done this thing for myself and my team, it came to the understanding that it could be useful to other developers / ops.  Moreover, only the domain name costs money, everything else is used without the need for payment. </p><br><blockquote>  PS Service is still in beta, therefore - if they find any shortcomings, typos, etc.  - just <a href="https://habr.com/ru/conversations/paramtamtam/">scribble in lichku</a> .  The programming and website development hubs are indicated for the reason that this approach may be useful primarily in these industries. </blockquote></div><p>Source: <a href="https://habr.com/ru/post/439806/">https://habr.com/ru/post/439806/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>