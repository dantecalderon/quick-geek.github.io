<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Forecasting again, part 2</title>
  <meta name="description" content="Today I will describe some more time series prediction properties. 

 Namely, the cyclical nature and complexity of the variant with similarity of seg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Forecasting again, part 2</h1><div class="post__text post__text-html js-mediator-article">  Today I will describe some more time series prediction properties. <br><br>  Namely, the cyclical nature and complexity of the variant with similarity of segments. <br><br><img src="https://habrastorage.org/webt/cs/7d/p8/cs7dp8f422kfxpzvl3o24tabpto.jpeg"><br><a name="habracut"></a><br>  Let's return to the schedule from the <a href="https://habr.com/ru/post/435590/">previous article</a> .  That graph is very periodic (see the picture further), and it would be correct to first predict it by calculating the cycles.  From using only the calculation of cyclicality, I got a forecast of a 4.1% error (mape) instead of 5% for the former experimental point. <br><br>  After calculating the cycles, we do the subtraction from the original values ‚Äã‚Äãof the graph, the values ‚Äã‚Äãof the forecast from the cycles, and the resulting graph of the error is already trying to predict the correlations.  As a result, for the same point I got already 3.7% error. <br><br>  The program and its source code for the current version <a href="https://github.com/victorprogrammist/forecasting_ver_001">here</a> .  Now it looks more like a standalone series prediction utility than testing a single method and a single graph.  And can perform the forecast for the last point for which there is no actual predicted value. <br><br><h4>  And now more about the algorithms and meanings </h4><br>  <b>ape</b> - Absolute percentage error - <b>abs (forecast-fact) / fact</b> <br>  <b>mape</b> - Mean absolute percentage error <br><br>  If we take several ape for the period and calculate the arithmetic average value, we get mape. <br><br>  By itself, the percentage of forecast error for an unknown graph says little.  Because it is not known how much the graph usually changes, and, accordingly, whether it is much predicted or little.  It is convenient to take for comparison the mape from the forecast, which is made from the assumption that the next value will be the same as the last known one. <br><br>  For the experimental point this value is 9.2%.  Let me remind you that there the figures were cited as a forecast for the day ahead.  Those.  fluctuations of the schedule per day is 9.2%.  As a result of the use of prediction, this error was reduced to 3.7%. <br><br>  This is how the studied graph looks like in a few days, with strong daily fluctuations: <br><br><img src="https://habrastorage.org/webt/kb/kc/lb/kbkclb3riq-la9heimozwykrz4m.png" alt="schedule"><br><br>  Obviously, if such a graph is tortured by correlations, then the correlation will see mostly daily fluctuations, while smaller nuances will be buried. <br><br>  This is how the forecast for the day ahead looks like: <br><br><img src="https://habrastorage.org/webt/bz/39/bp/bz39bpo3c4ihdqksqggypygltew.png" alt="another schedule"><br><br>  The actual graph, the blue forecast, the green border of three standard deviations of the forecast from the center are displayed in red - if the graph fluctuations had a <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2580%25D0%25B5%25D0%25B4%25D0%25BD%25D0%25B5%25D0%25BA%25D0%25B2%25D0%25B0%25D0%25B4%25D1%2580%25D0%25B0%25D1%2582%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5_%25D0%25BE%25D1%2582%25D0%25BA%25D0%25BB%25D0%25BE%25D0%25BD%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">standard distribution</a> , this would be 99% of the likely corridor of the graph. <br><br><h4>  Calculation of cycles </h4><br>  In order to make a prediction of <b>cycles, the Cicling</b> class was organized in the files <a href="">cicling.h</a> and <a href="">cicling.cpp</a> .  An object of this class accumulates N elements of averages, the number of which corresponds to the cycle length.  The averages are accumulated by a tunable formula, they are called moving averages. <br><br>  In my interpretation, this formula has an adjustment length, which is more convenient than if just a faceless coefficient.  This mechanism is contained in the compact class <b>MeanAdapt</b> in the file <a href="">dispersion.h</a> and <a href="">dispersion.cpp</a> . <br><br>  On average, the essence of the mechanism is as follows: <br><br><pre><code class="cpp hljs">cnt_vals = cnt_vals + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cnt_vals &gt; cnt_adapt) su = su - su / (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)cnt_adapt + new_value; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> su = su + new_value; mean = su / (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)min(cnt_vals, cnt_adapt);</code> </pre> <br>  In that class there is also a complication with a negative interpretation of cnt_adapt, if you are interested in looking at the sources. <br><br>  In general, in the <b>Cicling</b> class <b>there</b> are N elements of <b>adaptive</b> means, among them there is the current element, to which the next value is added, and the pointer moves to the next element of the means.  When the last element is reached, the pointer moves to the beginning.  And so in a circle.  More precisely, the class is simply made <b>ar_means [cnt_values% size_cicling]</b> , where cnt_values ‚Äã‚Äãis the number of added values. <br><br>  Before adding a new value to the current element of averages, the current average is subtracted from the new value, thereby forming the error value.  The <b>Cicling</b> class may recursively contain the next level of <b>Cicling * ne_level cyclicity</b> , if so, the error of the current level is passed on to sum the following cyclicities, otherwise the error is returned.  For the current schedule, the main cycles are daily - 24 hours and weekly - 168 hours. <br><br>  This forms the difference between the actual value transmitted and the current value of the cyclic averages.  If we apply zero to this mechanism in the opposite direction and add all the averages of the current step to it, but only without modifying the elements of <b>MeanAdapt</b> , we will get the prediction value from the assumption that the future error is zero.  We shift the current element of the medium to the next, all the same without modification, and again in the reverse order we give zero.  The result is a forecast graph based on the summation of all averages. <br><br>  For this mechanism, two questions remain: how to determine the frequency of possible cycles, and how to determine the best adaptation length. <br><br>  I did it just by searching through test data.  The program has a button for scanning cycles, which scans all possible periods of cycles with a dimension of up to two thousand, and gives the best of them. <br><br>  This best manual is added to the ‚ÄúPeriods of cycles‚Äù field and the next time the search is started, the cycles will already be scanned minus the new added cycle.  Only if you check on the current graph, then the best cyclicities are already entered in the field by default and will no longer be found.  Therefore, erase them and run. <br><br>  The length of the adaptation is also selected by enumeration, but there is no need to indicate anywhere, the program scans it again each time it is started, since  that's not for long.  The sequence of specifying periods in the Cycle Periods field is also unimportant, since  at startup, the best sequence will be selected. <br><br>  With cycles like everything.  They are considered, subtracted from the graph, we get the error graph. <br><br><h4>  My version of the implementation of the similarity of segments </h4><br>  This graph of errors represents fluctuations with an average close to zero ‚Äî plus and minus errors.  It may contain correlations, and may be the remaining random component.  To him already and apply the correlation of segments. <br><br>  And on this issue I will say that it is not the best option to count it according to Pearson's correlation.  For this there is a logical reasoning - this correlation rakes up under the semblance of different intensity graphics, although at different intensity the subsequent behavior does not mean at all that it will be the same, only with the transfer.  And practical indications - after the application of cycles, an attempt to apply the Pearson correlation only worsens the result.  And also when using it without cyclicity, it gets a worse prognosis than cycling does. <br><br>  As a result of experiments, I came to the conclusion that the best calculation of similarities is just a quadratic difference between the graphs.  If the graph is already minus the cycles, then the graph hangs around zero, and the quadratic difference between them is sufficient. <br><br>  If the cyclicity is not subtracted, then the quadratic difference is better but with the preliminary subtraction of the average: <br><br><img src="https://habrastorage.org/webt/k7/td/2t/k7td2tutn69ts5w7dih9tekgsvs.png" alt="sqrt (sum (((x-sum (x) / n) - (y - sum (y) / n) ^ 2) / n)"><br><br>  Although I am writing here that this is a correlation of segments, but in fact I mean the quadratic difference between them. <br><br>  In the demo program, you can choose different versions of similarities / correlations that I checked, and check them for other graphs you want.  Implementation of the calculation of similarities in the program is carried out by the <b>CorrSlide</b> class in the files <a href="">corr_slide.h</a> and <a href="">corr_slide.spp</a> .  Formulas of various similarities are <b>calculated</b> in the <b>CorrSlide :: Res</b> method <b>. CorrSlide :: get_res (...)</b> . <br><br>  In addition to the above different calculation options, this class includes optimization, so that you would not have to recalculate the calculation for adjacent segments of the properties described below. <br><br>  I made that for each position many different correlation lengths are scanned.  The first length is taken, say 6 points, the next version of the length is twice as long, i.e.  12, then the next 24, and so on ... For each length, a pack of the best of these segments is accumulated and considers the average forecast and variance.  Then, from all counted packs, each of which is responsible for a different length, the one that best predicts the current point is selected.  The one that has the smallest variance of the forecast is the best. <br><br>  It is wrong to assume that the longest segment will be the best.  Firstly, for a long segment it may not be enough of quite similar segments, or not at all.  And to take one best in likeness, as I mentioned in the previous article, would be wrong.  Secondly, the forecast may correlate from substantially closer values ‚Äã‚Äãto the predicted point, and the subsequent lengthening of the segment will not give a better answer, but will only dilute the pack of the best with unnecessary segments. <br><br>  But the shortest segment, as you know, the same will not be the best.  As a result, several packs of correlating segments of different lengths are simply collected, and it looks like which of the packs has the most specific prediction - the smallest variance. <br><br>  I also made a variant of calculating the similarity with increasing significance of values ‚Äã‚Äãcloser to the predicted point.  There for each increase in length twice, the segment, which was shorter in half, is added twice. <br><br><div class="spoiler">  <b class="spoiler_title">This is what it looks like ...</b> <div class="spoiler_text">  This is how it looks, the following amounts are the components of the correlation formulas: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CorrSlide::make_res_2() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i_len = <span class="hljs-number"><span class="hljs-number">0</span></span>; i_len &lt; c_lens<span class="hljs-number"><span class="hljs-number">-1</span></span>; ++i_len) { Calc&amp; calc = ar_calc_2[i_len]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i_len == <span class="hljs-number"><span class="hljs-number">0</span></span>) calc = ar_calc[i_len]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> calc = ar_calc_2[i_len<span class="hljs-number"><span class="hljs-number">-1</span></span>]; Calc&amp; calc_plus = ar_calc[i_len+<span class="hljs-number"><span class="hljs-number">1</span></span>]; calc.cnt += calc_plus.cnt; calc.su_s += calc_plus.su_s; calc.su_s_pow2 += calc_plus.su_s_pow2; calc.su_m += calc_plus.su_m; calc.su_m_pow2 += calc_plus.su_m_pow2; calc.su_s_m += calc_plus.su_s_m; calc.div_s = dbl(calc.cnt) * calc.su_s_pow2 - calc.su_s * calc.su_s; } }</code> </pre><br></div></div><br><h4>  And a little about emissions </h4><br>  Plus, I also made an exclusion mechanism.  In principle, outliers should actually be counted, as elements of a graph or as probable errors.  But they should be taken into account at the level of formation of the distributions characteristic of the current schedule.  Now I have based my calculations mainly on the principles of working correctly on standard distributions.  Therefore, the current version simply indicates how many extreme points to exclude.  It is indicated in the ‚ÄúNumber of emissions‚Äù field, and this is applied in several moments of the calculation, which significantly distorted the result. <br><br>  The same problem with distributions affects the coefficient of forecasting, about which I wrote in the previous article, it turns out not visual.  Analysis of these issues left on the next version of the program. <br><br><h4>  What happened in the end </h4><br>  As a result, all this diversity and disgrace leads to the fact that after subtracting cyclicality, this graph can be predicted a little better. <br><br>  If you try different versions of the length of such segments, the success of the forecast may vary somewhat.  Those.  The result is not stable.  If at the same time to use the similarity of the square deviation, then it in principle always improves the result after processing cyclicities, in contrast to the Pearson correlation.  Also slightly better results are obtained using the similarity lengths of multiples of 24 - the minimum cyclicity. <br><br>  The calculation is carried out quickly enough that you can specify that a thousand or more positions would be counted and look at the average forecast for this segment, make sure that the forecast is not only at the experimental point.  Although not everywhere so striking. <br><br>  For example, for the period of 1000 positions, with the prediction of each step 1 step forward, the result is: <br>  <b>average error for the selected period 1.76473%</b> <b><br></b>  <b>sred. error only by cycling 1.78332%</b> <b><br></b>  <b>sred.oshib provided that the forecast is the last known position 4.19216%</b> <br><br>  If the ‚ÄúNumber of forecast positions‚Äù field is left blank, then the calculation will be carried out for each position starting from ‚ÄúDate / position of the beginning of the forecast‚Äù until the end of the chart. <br><br>  If it is interesting to see the numbers that I gave regarding the experimental point, then in the default settings, you need to change ‚ÄúNumber of prediction positions‚Äù = 1, ‚ÄúNumber of one position‚Äù = 24. <br><br>  It is worth noting that all these improvements did not allow the forecasting of EURUSD to be shifted to the slightest bit.  It seems well, not at all dependent on its past history.  Although I will still check it with the next versions of the program. <br><br>  As mentioned, the program is universal, you can select your data files in it, and specify the predicted column and the date column if there is one.  The column separator can be a comma or a semicolon.  The program, if possible, provides descriptions of controls. <br><br><img src="https://habrastorage.org/webt/a0/hb/9-/a0hb9-vthg2tof935mwwflqm_ac.png" alt="How does the program look like"><br><br>  <a href="https://github.com/victorprogrammist/forecasting_ver_001">The program and its source</a> . <br><br>  For now, next time I will improve the result of forecasting with new properties. </div><p>Source: <a href="https://habr.com/ru/post/436738/">https://habr.com/ru/post/436738/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>