<div class="post__text post__text-html js-mediator-article"><p>  Analyzer: Slither <br>  Description: Open-source static analysis framework for Solidity <br>  githib: <a href="https://github.com/trailofbits/slither">https://github.com/trailofbits/slither</a> </p><br><p>  This is a static code analyzer written in python.  He is able to keep track of variables, calls, and detects <a href="https://github.com/trailofbits/slither">such a list of vulnerabilities</a> .  Each vulnerability has a link with a description, and if you are new to Solidity, it makes sense for you to familiarize yourself with everyone. </p><br><p>  Slither can work as a python module and provide the programmer with an interface for auditing according to its own plan.  A simple and illustrative example of <a href="https://github.com/trailofbits/slither/blob/master/examples/scripts/functions_writing.py">what slither can do can be seen here</a> . </p><br><p>  We will return to the analysis scenarios at the end of the article, but for now let's run Slither: </p><a name="habracut"></a><br><pre><code class="plaintext hljs">git clone https://github.com/trailofbits/slither.git cd slither docker build -t slither .</code> </pre> <br><p>  and try to analyze our contract. </p><br><p>  Go to the directory with constructor-eth-booking and try to run slither from the docker: </p><br><pre> <code class="bash hljs">$ docker run -v $(<span class="hljs-built_in"><span class="hljs-built_in">pwd</span></span>)/contracts:/slither/contracts slither contracts/flattened.sol</code> </pre> <br><p>  we get the error “Source file requires different compiler version”, and now we need to shove the version <code>solc=0.4.20</code> into the docker slither.  To do this, we rule the Slither Dockerfile itself, as indicated in Clause 2 <a href="https://habr.com/ru/post/438336/">in the introduction</a> , i.e.  somewhere at the end of the <a href="https://github.com/trailofbits/slither/blob/master/Dockerfile">Dockerfile</a> add the line: </p><br><pre> <code class="plaintext hljs">COPY --from=ethereum/solc:0.4.20 /usr/bin/solc /usr/bin</code> </pre> <br><p>  , rebuild the image, run, hooray, everything compiles. </p><br><p>  We see the output, warning messages about various “pragma” and incorrect names of variables like <code>Parameter '_price' of Booking.Booking (flattened.sol#73) is not in mixedCase</code> .  Analyzers give a lot of warnings, but we are looking for real bugs, and we will not pay attention to trifles.  Let's filter all messages about mixedCase, now it's not up to the style: </p><br><pre> <code class="plaintext hljs">$ docker run -v $(pwd)/contracts:/slither/contracts slither contracts/flattened.sol 2&gt;&amp;1 | fgrep -v 'mixedCase'</code> </pre> <br><p>  True programmers skip everything green, look everything red, and here’s what besides false-positives found in the Slither contract: </p><br><pre> <code class="plaintext hljs">Booking.refundWithoutCancellationFee (flattened.sol#243-250) sends eth to arbirary user Dangerous calls: - client.transfer(address(this).balance) (flattened.sol#249) Reference: https://github.com/trailofbits/slither/wiki/Vulnerabilities-Description#functions-that-send-ether-to-arbitrary-destinations INFO:Detectors: Booking.refundWithCancellationFee (flattened.sol#252-259) sends eth to arbirary user Dangerous calls: - owner.transfer(m_cancellationFee) (flattened.sol#257) - client.transfer(address(this).balance) (flattened.sol#258) Reference: https://github.com/trailofbits/slither/wiki/Vulnerabilities-Description#functions-that-send-ether-to-arbitrary-destinations</code> </pre> <br><p>  Now we are looking at what is wrong with this function in the contract: </p><br><pre> <code class="plaintext hljs"> /************************** PRIVATE **********************/ function refundWithoutCancellationFee() private { address client = m_client; m_client = address(0); changeState(State.OFFER); client.transfer(address(this).balance); } function refundWithCancellationFee() private { address client = m_client; m_client = address(0); changeState(State.CANCELED); owner.transfer(m_cancellationFee); client.transfer(address(this).balance); }</code> </pre> <br><p>  while, for example, the <code>refundWithoutCancellationFee()</code> function is called like this: </p><br><pre> <code class="plaintext hljs"> function rejectPayment() external onlyOwner onlyState(State.PAID) { refundWithoutCancellationFee(); } function refund() external onlyClient onlyState(State.PAID) { refundWithoutCancellationFee(); }</code> </pre><br><p>  Hmm, there are no formal errors: the calls are protected by all sorts of <code>onlyOwner</code> , but Slither swears that, supposedly, a broadcast is sent inside refundWithoutCancellationFee () without any checks.  And he is right, the function itself really has almost no limitations.  Let it be private, and it is called from the “rejectPayment ()” “refund ()” wrappers with the necessary restrictions, but in this form, if you finalize the contract, there is a great risk of forgetting about the restrictions and sticking the call of <code>refundWithoutCancellationFee()</code> to some other place, available to the attacker.  So, even if formally there is no vulnerability, the information turned out to be useful - this is at least the “warning” level, if the task is to develop the contract code further.  In this case, two functions from different participants use the same code, and this decision was made to save gas - the contract is a one-time, and the cost of its calculation is an important factor. </p><br><p>  I rechecked if it’s not just that Slither swears at any shipment, and transferred the body of the function directly to the above “rejectPayment ()” and “refund ()”, the warning disappeared, i.e.  Slither realized that now the air is not sent without checking addresses.  Great start! </p><br><p>  Now let's check how Slither watches the initialization of variables, for this we comment out two initializations: </p><br><pre> <code class="plaintext hljs">- m_fileHash = _fileHash; + // m_fileHash = _fileHash; - m_price = _price; + // m_price = _price;</code> </pre> <br><p>  the first is not very important, in terms of holes, except for wasting resources, because m_fileHash is not used anywhere, it is simply stored in the blockchain when creating a contract.  But m_price is used, and Slither correctly swears that m_price is not initialized anywhere, although it is used: </p><br><pre> <code class="plaintext hljs">Booking.m_price (flattened.sol#128) is never initialized. It is used in: - fallback (flattened.sol#144-156)</code> </pre> <br><p>  Well, this is a simple trick, as expected, everything worked fine. </p><br><p>  Now we will add to the contract a reentrant so beloved by all: we will change the state of the contract after an external call.  We make such changes: </p><br><pre> <code class="plaintext hljs"> function refundWithoutCancellationFee() private { address client = m_client; - m_client = address(0); - changeState(State.OFFER); - client.transfer(address(this).balance); + client.call.value(address(this).balance)(); + m_client = address(0); + changeState(State.OFFER); }</code> </pre> <br><p>  I had to replace transfer with a call, since  The option with transfer Slither does not swear due to the fact that transfer sends a call with a minimum of gas, and the callback is not possible (although when switching to the Constantinople fork in Ethereum, the price of gas was changed, and this re-enabled the reentrancy attack using <a href="https://github.com/ChainSecurity/constantinople-reentrancy">transfer</a> . </p><br><p>  Search result reentrancy: </p><br><pre> <code class="plaintext hljs">Reentrancy in Booking.refundWithoutCancellationFee (flattened.sol#243-253): External calls: - client.call.value(address(this).balance)() (flattened.sol#245) State variables written after the call(s): - m_client (flattened.sol#246)</code> </pre> <br><p>  Fine, at least it will not allow to change state variables after external calls, and it is very good. </p><br><p>  If you move through the list, the remaining vulnerabilities in the list either represent simply a search for specific methods in the code, or known patterns that, if you have access to the code markup performed by the python, work, of course, and reliably enough.  Those.  well-knows Slither patterns will not miss. </p><br><p>  Now, I will make changes that perfectly show the specifics of the work of static analyzers: </p><br><pre> <code class="plaintext hljs">- client.transfer(address(this).balance + for (uint i=0; i &lt; 1; i++) { + client.transfer(address(this).balance - 999999999999999999); + }</code> </pre> <br><p>  and the result: </p><br><pre> <code class="plaintext hljs">Booking.refundWithoutCancellationFee has external calls inside a loop: - client.transfer(address(this).balance - 999999999999999999) (flattened.sol#252) Reference: https://github.com/trailofbits/slither/wiki/Vulnerabilities-Description/_edit#calls-inside-a-loop</code> </pre> <br><p>  The cycle is executed once, and is degenerate - therefore the issued warning is false positive, and the absence of a warning about dangerous arithmetic is false negative.  Analysis of types, results of operations, counting calls - tasks are not for static analyzers.  Therefore, clearly understand what mistakes Slither will find and which ones you need to look for using other tools. </p><br><p>  We promised to mention the possibility of writing our own scripts for testing, and outputting any interesting information about the contract using the <code>--print</code> key.  From this point of view, Slither is an excellent tool for CI.  Developers of a large contract system know the names of security-critical variables: balances, commission sizes, flags, and can write a test script that will block any changes in the code that, for example, overwrite an important variable, or change state variables after an external call, and its perfectly predictable analysis is an excellent tool for use in hooks. <br>  The task of Slither is to rid you of stupid bugs, find familiar dangerous patterns and warn the developer.  In this variant, it is also good as a tool for a novice developer on Solidity, immediately prompting how to write the code on Solidity correctly. </p><br><h3 id="itogi">  Results </h3><br><p>  In my personal testing, I would put the Slither four, for versatility, simplicity and ease of use, as well as for simple and clear test scenarios and adaptability to CI. </p><br><p>  Slither confidently found the real WARNING, associated with the use of the function that sends the air, found all the bugs introduced.  He could not cope only with dynamic analysis, which formally should not be done, otherwise he would have to sacrifice universality, predictability and ease of use. </p><br><p>  In the next article we will deal with the analyzer Mythril, but the whole table of contents of articles that are ready or planned to write: </p><br><p>  Part 1. <a href="https://habr.com/ru/post/438336/">Introduction.</a>  <a href="https://habr.com/ru/post/438336/">Compilation, flattening, Solidity versions</a> <br>  Part 2. Slither (this article) <br>  Part 3. Mythril (in the process of writing) <br>  Part 4. Manticore (in the process of writing) <br>  Part 5. Echidna (in the process of writing) </p></div>