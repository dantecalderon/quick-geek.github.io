<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dynamic local exposure</title>
  <meta name="description" content="Hi, Habr! I present to you the translation of the article "Dynamic Local Exposure" by John Chapman. 


 In this article I will introduce a couple of i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Dynamic local exposure</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr!  I present to you the translation of the article <a href="https://john-chapman.github.io/2017/08/23/dynamic-local-exposure.html">"Dynamic Local Exposure"</a> by John Chapman. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e6/34f/499/4e634f499679d948a12c1ddcb5f40a0c.jpg" alt="image"></div><br>  In this article I will introduce a couple of ideas about dynamic local exposure in HDR rendering.  Bart Vronsky already has a <a href="https://bartwronski.com/2016/08/29/localized-tonemapping/">great article</a> on this topic and I highly recommend reading it right now if you have not done so already;  the ideas here are more based on his article.  At the end I included several other great links. <br><br><h2>  Low / High Dynamic Range </h2><br>  In the good old days (1990s), games were rendered directly in the displayed <b>LDR</b> (narrow dynamic range) format (gamma space, 8 bits).  It was simple and cheap, but, on the other hand, significantly hampered the creation of a truly photo-realistic picture. <br><br>  Currently, especially with the advent of <b>PBR</b> (physically-based rendering), games are rendered with a huge dynamic range in linear space with higher accuracy.  With this movement towards photorealism comes the real problem: how can we display the <b>HDR</b> image in the <b>LDR</b> ? <br><a name="habracut"></a><br><h2>  Global Auto Exposure </h2><br>  The standard approach to automatic exposure control is to measure the average (or average logarithmic) brightness of the scene, optionally with a <b>weight</b> function, preferring values ‚Äã‚Äãclose to the center of the image.  This can be done very effectively by using parallel reduction or by multiple <b>downsampling</b> in the <b>mipmap of</b> the <b>luminance buffer</b> (brightness buffer).  The latter approach has some advantages, which I will discuss in the next section. <br><br>  The average brightness is subsequently converted to an exposure value, for example, by calculating the reciprocal of the maximum permissible scene brightness: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Lavg = <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(textureLod(txLuminance, uv, <span class="hljs-number"><span class="hljs-number">99.0</span></span>).x); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> ev100 = log2(Lavg * <span class="hljs-number"><span class="hljs-number">100.0</span></span> / <span class="hljs-number"><span class="hljs-number">12.5</span></span>); ev100 -= uExposureCompensation; <span class="hljs-comment"><span class="hljs-comment">// optional manual bias float exposure = 1.0 / (1.2 * exp2(ev100));</span></span></code> </pre> <br>  <i>Obtained from the ISO standard for calculating speed based on saturation, for full explanation see <b>(3)</b></i> <br><br>  Since the potentially average brightness is unstable under dynamic conditions, it is usually smoothed over time using the exponential hysteresis function <b>(2)</b> : <br><br><pre> <code class="cpp hljs">Lavg = Lavg + (Lnew - Lavg) * (<span class="hljs-number"><span class="hljs-number">1.0</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(uDeltaTime * -uRate));</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Translator comment</b> <div class="spoiler_text">  This function should be used in the shader <b>downsampling</b> texture brightness and only during the calculation of the last <b>mip</b> level (1x1).  Further it will be written about, but in my opinion it is easy to lose sight of. <br></div></div><br>  Due to its global nature, this method suffers from strong shadowing or glare of image areas that have a deviation from the average brightness: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c1/72c/00c/7c172c00c8150c7570139969100e0df8.jpg" alt="image"><br><br>  Although this corresponds to the ability of the eye to adapt to changes in light levels, the overall effect is rather far from what we really perceive in the real world. <br><br><h2>  Local auto exposure </h2><br>  If we generate medium brightness using <b>downsampling</b> , we have access to lower mip levels for <b>luminance buffer (4)</b> to get local average brightness. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Lavg = <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(textureLod(txLuminance, uv, uLuminanceLod).x;</code> </pre><br>  <i>Please note that in order for this to work, the hysteresis should be used only in the last step (when recording 1x1 mip level), otherwise there will be artifacts.</i> <br><br>  In theory, this is a great idea: each area of ‚Äã‚Äãthe image can have a good exposure, while being in contrast with the neighboring areas.  However, in practice, a disgusting result is obtained: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/932/299/21a/93229921ad67b3bf7f7abcd75c930b88.jpg" alt="image"><br><br>  The most unpleasant are block ‚Äúhalos‚Äù, which are found in areas with high contrast: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f36/5ac/a41/f365aca4114770e1ab42133f3f51f4e2.jpg" alt="image"><br><br>  However, they can be smoothed either by pre-filtering the <b>luminance buffer</b> , or simply using bicubic sampling: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6cd/1fd/310/6cd1fd3100aa4fd6475d915702bd4005.jpg" alt="image"><br><br>  Still looks disgusting, but already better. <br><br>  Sampling different levels of mipmap in <b>luminance</b> changes the radius of the halo.  This parameter is useful for controlling the overall ‚Äúappearance‚Äù of the result, as well as for minimizing the halo effect, although at the expense of a general decrease in contrast (it becomes a border filter) or a loss of locality of exposure control: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/187/cff/7c6/187cff7c627b31b959be1fd3fe1b5c7a.gif" alt="image"><br><br>  Still, smoothing halos is not enough.  The result is generally not natural;  It looks like an extreme ‚ÄúHDR photo‚Äù style, unlike what a person sees.  However, by mixing global and local values, we can get the best of both worlds: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Llocal = <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(textureLod(txLuminance, uv, uLuminanceLod).x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Lglobal = <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(textureLod(txLuminance, uv, <span class="hljs-number"><span class="hljs-number">99.0</span></span>).x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> L = mix(Lglobal, Llocal, uLocalExposureRatio); <span class="hljs-comment"><span class="hljs-comment">// .. use L to compute the final exposure scale as before</span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/8ea/6d3/b31/8ea6d3b314ef803bb4c8c67b74fbbe6c.jpg" alt="image"><br><br>  By changing the blending factor, you can adjust the local exposure so that as a result, you can minimize artifacts and maximize perceived realism: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/589/416/d17/589416d1778f9aa34eb644c64e3b723d.gif" alt="image"><br><br><h2>  Automatic mixing ratio </h2><br>  Adjusting <b>the blending ratio</b> manually is normal in situations where we have absolute control over camera position, lighting, etc.  However, in many cases (for example, outdoor games with a dynamic change of day and night) this level of control is simply impossible.  In this case, it would be nice to generate <b>the mix ratio</b> automatically. <br><br>  In the image below, we have a wide dynamic range;  mostly medium-low brightness values ‚Äã‚Äãand several areas with high intensity (the sky in the windows): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e21/a01/858/e21a018589033b7b1d2394126423a0b2.jpg" alt="image"><br><br>  Without local exposure, the color of the sky is lost.  In this case, I would like a large <b>mixing ratio</b> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4e6/34f/499/4e634f499679d948a12c1ddcb5f40a0c.jpg" alt="image"><br><br>  Now consider the image below, which has a small dynamic range, mainly with a high brightness value: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eea/5c3/e48/eea5c3e48e46cee824f1eff98444a7b4.jpg" alt="image"><br><br>  In this case, the use of local exposure reduces the brightness of ‚Äúbright‚Äù areas too much: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/908/2d6/ec6/9082d6ec6fa0f0ae7c5c4557c38803f3.jpg" alt="image"><br><br>  Observation data hints at a simple method of mixing <b>local</b> and <b>global</b> values: if the difference between the average and maximum brightness of the scene is larger, then the mixing ratio of the local exposure should be greater.  Generating the <b>maximum brightness of the</b> scene can be done trivially during the calculation of brightness, using hysteresis to smooth the result in the same way as for the average value.  Therefore, we can extend the previous code snippet as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Llocal = <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(textureLod(txLuminance, uv, uLuminanceLod).x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Lglobal = <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(textureLod(txLuminance, uv, <span class="hljs-number"><span class="hljs-number">99.0</span></span>).x; <span class="hljs-comment"><span class="hljs-comment">// average in x float Lmax = exp(textureLod(txLuminance, uv, 99.0).y; // max in y float Lratio = min(saturate(abs(Lmax - Lglobal) / Lmax), uLocalExposureMax); float L = mix(Lglobal, Llocal, Lratio); // .. use L to compute the final exposure scale as before</span></span></code> </pre><br>  <i>Please note that we have <b>uLocalExposureMax</b> at the entrance to control the absolute maximum degree of influence of local exposure.</i>  <i>I have a good result gave <b>uLocalExposureMax &lt;0.3</b> .</i> <br><br><div class="spoiler">  <b class="spoiler_title">Final code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Llocal = <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(textureLod(txLuminance, uv, uLuminanceLod).x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Lglobal = <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(textureLod(txLuminance, uv, <span class="hljs-number"><span class="hljs-number">99.0</span></span>).x; <span class="hljs-comment"><span class="hljs-comment">// average in x float Lmax = exp(textureLod(txLuminance, uv, 99.0).y; // max in y float Lratio = min(saturate(abs(Lmax - Lglobal) / Lmax), uLocalExposureMax); float L = mix(Lglobal, Llocal, Lratio); float ev100 = log2(L * 100.0 / 12.5); ev100 -= uExposureCompensation; // optional manual bias float exposure = 1.0 / (1.2 * exp2(ev100)); vec3 result = hdrColor * exposure; result += bloom; //etc outColor.rgb = result;</span></span></code> </pre><br></div></div><br><h2>  Conclusion </h2><br>  The approach outlined above imposes some restrictions on when to measure the brightness of the scene.  Usually, the measurement is performed immediately after the passage of the lighting in order to avoid adaptation of <b>particle</b> effects, <b>bloom</b> , etc.  However, when local brightness is used, it is important that the real value that is involved in the exposure is represented in the <b>luminance map</b> .  This means that the brightness measurement must be done immediately before applying the exposure.  If this is unacceptable, then the solution will be to generate local brightness separately from the average and maximum values. <br><br>  Although I think that using local and global scene brightness together is the ‚Äúright‚Äù approach to creating a balanced, natural looking image, the quality of the result is obviously subjective.  Whether a similar method is suitable for a particular game depends entirely on the content and desired visual style.  I would be interested to hear other ideas on this. <br><br><h2>  Links </h2><br><ol><li>  <a href="https://bartwronski.com/2016/08/29/localized-tonemapping/">Localized Tonemapping</a> (Bart Wronski) </li><li>  <a href="https://placeholderart.wordpress.com/2014/12/15/implementing-a-physically-based-camera-automatic-exposure/">Implementing a Physically Based Camera</a> (Padraic Hennessy) </li><li>  <a href="https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf">Moving Frostbite to PBR</a> (S√©bastien Lagarde, et al.) </li><li>  <a href="https://mynameismjp.wordpress.com/2010/04/30/a-closer-look-at-tone-mapping/">A Closer Look at Tonemapping</a> (Matt Pettineo) </li><li>  <a href="https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch24.html">The Importance of Being Linear</a> (Larry Gritz, et al.) </li><li>  <a href="http://32ipi028l5q82yhj72224m8j.wpengine.netdna-cdn.com/wp-content/uploads/2016/03/GdcVdrLottes.pdf">Color Pipelines Advanced Techniques and Optimization of HDR / VDR</a> (Timothy Lottes) </li></ol><br>  <i>HDR images are taken from <a href="http://www.hdrlabs.com/sibl/archive.html">sIBL Archive</a> .</i> </div><p>Source: <a href="https://habr.com/ru/post/440018/">https://habr.com/ru/post/440018/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>