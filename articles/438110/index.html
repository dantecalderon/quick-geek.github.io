<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Rails + Postgres + bindings</title>
  <meta name="description" content="Hello friends. It's no secret that working on large projects with complex logic, Active Record becomes not a helper, but a burden. Imagine that you ne...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Rails + Postgres + bindings</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/7c3/ad8/8fb/7c3ad88fbd713cdc632d297b6927e495.jpg" alt="image"><br><br>  Hello friends.  It's no secret that working on large projects with complex logic, Active Record becomes not a helper, but a burden.  Imagine that you need to make a very complex query for PostgreSQL in a native way (on pure SQL), where there must be a certain number of variables.  But in Rails there is one unpleasant trifle, the functionality of executing native queries does not allow the use of named binding.  But there is a solution :) Tested and successfully implemented on a project with Rails API 5.2 + Ruby 2.6.0 + Postgres 11. <br><a name="habracut"></a><br>  So, a little more about the problem.  The main method that allows you to execute your own SQL queries is exec_query: <br><br><pre><code class="ruby hljs">sql = <span class="hljs-string"><span class="hljs-string">'SELECT id, name, desc FROM schema.news WHERE id=$1'</span></span> bindings = [[<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>]] new = ActiveRecord::Base.connection.exec_query(sql, <span class="hljs-string"><span class="hljs-string">'SQL'</span></span>, bindings).first</code> </pre> <br>  The example above shows that the formation of binders occurs, to put it mildly, in one place, when we are trying to get news from the database at number 100. Bindings cannot be named, but only numbered.  And this greatly complicates the reading and support of native queries.  Alternatively, you can use the find_by_sql method call for the model class: <br><br><pre> <code class="ruby hljs">sql = <span class="hljs-string"><span class="hljs-string">'SELECT id, name, desc FROM schema.news WHERE id=:id'</span></span> new = New.find_by_sql([sql, <span class="hljs-symbol"><span class="hljs-symbol">id:</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span>]).first</code> </pre> <br>  Here everything is more pleasant and clearer.  But the question is, it is more or less acceptable if you want to perform a simple query.  But if the request is really complicated, then to drive it through the model and Active Record itself is a big loss in speed (slow) and performance (it is consuming server resources).  Why there are no named binders when working with native queries is a mystery to me, but the solution is to write my own little wrapper that can work very easily with named binders, which I did. <br><br>  I give the code of a static class: <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># Class for work with SQL query. # Can use clean SQL with hash bindings. # Convert JSON fields to hash. # Can use if not need get model object! class SqlQuery # Create sql query with hash bindings # # </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> [String] sql SQL query # </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> [Hash] bind bindings data for query # # </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> [Array] executed SQL request data and return array with hashes def self.execute(sql, bind = {}) bindings = [] bind_index = 1 # Get all bindings if exist unless bind.empty? bind.each do |key, value| # Change name bind to $ bind sql.gsub!(/(?&lt;!:):#{key}(?=\b)/, "$#{bind_index}") bind_index += 1 # Add new bind data bindings &lt;&lt; [nil, value] end end # Execute query, convert to hash with symbol keys result = ActiveRecord::Base.connection.exec_query(sql, 'SQL', bindings).map(&amp;:symbolize_keys) # Convert JSON data to hash result.map do |v| next if v.nil? v.each do |key, val| v[key] = json_to_hash(val) end end end # Convert JSON to hash if correct data # # </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> [String] json string # </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> [Hash] return hash if json is correct or input data def self.json_to_hash(json) JSON.parse(json, symbolize_names: true) rescue json end end</span></span></code> </pre> <br>  As you can see from the code, everything is as simple as the corner of the house.  The query works like this: <br><br><pre> <code class="ruby hljs">sql = <span class="hljs-string"><span class="hljs-string">'SELECT id, name, desc FROM schema.news WHERE id=:id'</span></span> binding = { <span class="hljs-symbol"><span class="hljs-symbol">id:</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span> } new = SqlQuery.execute(sql, binding).first</code> </pre> <br>  The output is always only hash.  A little bit of explanation.  The execute method takes a query string and a hash with binding.  It is clear that the binding in the query and hash must match.  Then we loop over the hash with the bindings and replace them with numbered variables of the form $ 1, $ 2, etc. in the query itself, creating an array of numbered values ‚Äã‚Äãalong the way, where the first element of the array is $ 1, the second is $ 2, and so on.  After that, we execute the query using the standard exec_query method, running through the answer with the mapper and converting the keys in the hash into characters.  After that, we once again run the mapper on the answer, where we check each field value for the content of JSON in it.  If there is JSON and it is valid, then we convert it into a hash with keys with characters, if the field is not JSON, then we throw an exception in which we return the value back.  That's all. <br><br>  As you can see, it makes no sense to put hundreds of gems of sorts, squandering the overall performance in order to get the desired result.  You can write very many necessary solutions very quickly yourself, having spent a minimum of time and code.  I didn‚Äôt post a class on github, because I don‚Äôt see much sense in it <br><br>  Good luck to everyone, see you soon. <br><br>  Reprint from your own blog.  Original <a href="https://cleverman.org/post/rails-postgres-bindings">here</a> </div><p>Source: <a href="https://habr.com/ru/post/438110/">https://habr.com/ru/post/438110/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>