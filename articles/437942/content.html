<div class="post__text post__text-html js-mediator-article">  Hi, my name is Ilya.  I am an iOS developer at Tinkoff.ru.  In this article I will give a brief overview of the major changes in Swift 5. These changes are described in <a href="https://developer.apple.com/documentation/xcode_release_notes/xcode_10_2_beta_release_notes/swift_5_release_notes_for_xcode_10_2_beta">release notes</a> .  For those who have not yet reviewed, welcome under the cat! <br><br><img src="https://habrastorage.org/webt/q4/3j/s8/q43js8q_hzcqksv1pxzrd53ykug.png"><br><a name="habracut"></a><br><h4>  The size of the application will decrease! </h4><br>  Applications written in Swift 5 and compiled for iOS 12.2, watchOS 5.2, tvOS 12.2 will not include dynamic libraries for the Swift standard library and Swift SDK.  This means that the size of the application will decrease, though not by much.  If you believe <a href="https://twitter.com/BalestraPatrick/status/1088565310691647489">this tweet</a> , the size of the empty project was reduced from 2.4 MB to 24 KB.  Not a bad result for small applications, but for big ones there won't be much difference. <br><br><h4>  @dynamicCallable ( <a href="">SE-0216</a> ) </h4><br>  The <i>@dynamicCallable</i> attribute allows <i>you</i> to work with an object as a function.  Such objects are called functional objects or functors (you can read more <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D0%25BE%25D0%25BD%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BE%25D0%25B1%25D1%258A%25D0%25B5%25D0%25BA%25D1%2582">here</a> ).  Functional objects are in C ++, Python, JavaScript and in other languages, and in Swift they were added for compatibility with these languages.  The fact is that Swift now interacts well with API C and Objective-C and language developers want to add interaction with dynamic languages ​​- Python, JavaScript, Ruby and others. <br><br>  In order to make a type a functor, you need to add the <i>@dynamicCallable</i> attribute to its declaration.  Consider an example of a <i>Reducer</i> structure, with which you can add numbers in an array: <br><br><pre><code class="swift hljs">@dynamicCallable <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Reducer</span></span></span><span class="hljs-class"> </span></span>{ ... }</code> </pre> <br>  After which you need to implement one or both of the following methods: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dynamicallyCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(withArguments: ExpressibleByArrayLiteral)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dynamicallyCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(withKeywordArguments: ExpressibleByDictionaryLiteral)</span></span></span></span></code> </pre><br>  The first function allows you to access an object by passing an array as arguments.  The second function allows you to access the object by passing the same array as arguments, but using the names of the arguments. <br><br>  For example, the implementation of the first function for the <i>Reducer</i> structure would look like this: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dynamicallyCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(withArguments arguments: [Int])</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arguments.<span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, +) }</code> </pre><br>  Then apply this structure as follows: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> reducer = <span class="hljs-type"><span class="hljs-type">Reducer</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = reducer(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-comment"><span class="hljs-comment">// sum = 6</span></span></code> </pre><br>  Consider the implementation of the second method on the example of the <i>Comparator</i> structure, with which you can compare two numbers: <br><br><pre> <code class="swift hljs">@dynamicCallable <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comparator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dynamicallyCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(withKeywordArguments arguments: KeValuePairs&lt;String, Int&gt;)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">ComparisonResult</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lhs = arguments[<span class="hljs-string"><span class="hljs-string">"lhs"</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rhs = arguments[<span class="hljs-string"><span class="hljs-string">"rhs"</span></span>], lhs != rhs <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> .orderedSame } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs &gt; rhs ? .orderedDescending : .orderedAscending } }</code> </pre><br>  You can use this structure as follows: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> comparator = <span class="hljs-type"><span class="hljs-type">Comparator</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> comparisionResult = comparator(lhs: <span class="hljs-number"><span class="hljs-number">1</span></span>, rhs: <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-comment"><span class="hljs-comment">// comparisionResult = .orderedAscending</span></span></code> </pre><br><h4>  Attribute <a href="https://habr.com/ru/users/unknown/" class="user_link">unknown</a> in switch ( <a href="">SE-0192</a> ) </h4><br>  Many people know that when processing enumeration values, you need to describe all cases and try not to use default.  This requirement, although it adds a pinch of security, also has a drawback, since if you change the values ​​in the enumeration, you need to add their processing.  There is still a chance that the system framework will change some of the enumerations, and this is not processed in your application (So it was, for example, with <i>LABiometryType</i> ). <br><br>  The attribute <i><a href="https://habr.com/ru/users/unknown/" class="user_link">unknown is</a></i> added to Swift 5, which will allow to separate 2 different scenarios when processing an enumeration: <br><br><ul><li>  The code in default must be executed for all cases not processed in the switch. </li><li>  In switch, all cases are processed, and if new ones are added, then you need to use the code in default </li></ul><br>  Let's look at an example: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTTPMethod</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> post, <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>, put } <span class="hljs-comment"><span class="hljs-comment">// Без @unknown switch httpMethod { case .post: print("Post") case .get: print("Get") default: print("Put") } // С @unknown switch httpMethod { case .post: print("Post") case .get: print("Get") @unknown default: print("Unknown HTTP method") }</span></span></code> </pre><br><h4>  Getting rid of double Optional by calling a function with try?  ( <a href="">SE-0230</a> ) </h4><br>  Surely, many were faced with the fact that when calling a throwable function that returns an <i>Optional</i> using <i>try?</i>  , the result was a type wrapped in two <i>Optionals</i> .  This is not very convenient, and so in Swift 5, <i>try to</i> call <i>?</i>  in this case, returns a type wrapped in only one <i>Optional</i> . <br><br>  That's how it was before Swift 5: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? optionalObject?.foo() <span class="hljs-comment"><span class="hljs-comment">// type(of: result) = SomeType??</span></span></code> </pre><br>  This will be the case in Swift 5: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? optionalObject?.foo() <span class="hljs-comment"><span class="hljs-comment">// type(of: result) = SomeType?</span></span></code> </pre><br><h4>  Frequency check ( <a href="">SE-0225</a> ) </h4><br>  To check the multiplicity of one number to another, you can use the function <i>isMultiple (of :)</i> , instead of the remainder of the division (%): <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// Старый вариант let isEven = 4 % 2 == 0 // Новый вариант let isEvent = 4.isMultiple(of: 2)</span></span></code> </pre><br>  The change is minor, but it makes the code a bit clearer and makes it easier to search by code. <br><br><h4>  Counting the number of elements in the sequence with the condition ( <a href="">SE-0220</a> ) </h4><br>  In Swift 5, the Sequence type will add a <i>count</i> method <i>(where: (Element) -&gt; Bool) -&gt; Int</i> , which will allow counting the number of elements in a sequence that satisfy a given condition in one pass.  Before that, you had to use <i>filter</i> in conjunction with <i>count</i> .  This method will save the memory allocated when creating a new array in the <i>filter</i> method. <br><br>  Example: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> countOfZeroes = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: { $<span class="hljs-number"><span class="hljs-number">0</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> }) <span class="hljs-comment"><span class="hljs-comment">// countOfZeroes = 2</span></span></code> </pre><br><h4>  CompactMapValues ​​method in Dictionary ( <a href="">SE-0218</a> ) </h4><br>  This method combines <i>compactMap</i> from <i>Array</i> and <i>mapValues</i> from <i>Dictionary</i> .  As a result of calling this method, a dictionary with transformed values ​​is created, in which there are no values ​​equal to <i>nil</i> . <br><br>  Example: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dictionary = [<span class="hljs-string"><span class="hljs-string">"a"</span></span>: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>: <span class="hljs-string"><span class="hljs-string">"2"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>: <span class="hljs-string"><span class="hljs-string">"Number"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> resultDictionary = dictionary.compactMapValues { <span class="hljs-type"><span class="hljs-type">Int</span></span>($<span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-comment"><span class="hljs-comment">// resultDictionary = ["a": 1, "b": 2]</span></span></code> </pre><br><h4>  Raw strings ( <a href="">SE-0200</a> ) </h4><br>  Added the ability to write strings in which quotes and backslashes are used as ordinary characters and not as special characters.  To do this, you must add the # symbol at the beginning and at the end of the line. <br><br>  Example: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> string1 = #<span class="hljs-string"><span class="hljs-string">"Строка со словом "</span></span>в кавычках<span class="hljs-string"><span class="hljs-string">""</span></span># <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> string2 = #<span class="hljs-string"><span class="hljs-string">"Строка с \обратным слэшем"</span></span>#</code> </pre><br>  If during the creation of a string, the insertion of a variable is used, then after the backslash you need to add a # sign: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> string = #<span class="hljs-string"><span class="hljs-string">"Строка с переменной \#(variable)"</span></span>#</code> </pre><br>  If the line contains the # sign, then at the beginning and at the end of the line you need to add two ## signs: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> string = ##<span class="hljs-string"><span class="hljs-string">"Строка со знаком #"</span></span>##</code> </pre><br><h4>  Sequence protocol no longer contains associated type SubSequence ( <a href="">SE-0234</a> ) </h4><br>  The associative <i>SubSequence</i> type was moved from the <i>Sequence</i> protocol to the <i>Collection.</i> <i>Now</i> , all the methods in the <i>Sequence</i> that returned the <i>SubSequence</i> return a specific type.  For example, the <i>suffix</i> method now returns an <i>Array</i> .  Here is a complete list of the methods affected by this change: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dropFirst</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k: Int = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">DropFirstSequence</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Self</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dropLast</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k: Int = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Element</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">suffix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxLength: Int)</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Element</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prefix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxLength: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">PrefixSequence</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Self</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">while</span></span></span></span><span class="hljs-function"><span class="hljs-params"> predicate: </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(Element)</span></span></span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">rethrows</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">DropWhileSequence</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Self</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prefix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">while</span></span></span></span><span class="hljs-function"><span class="hljs-params"> predicate: </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(Element)</span></span></span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">rethrows</span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Element</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">split</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( maxSplits: Int = Int.</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">max</span></span></span></span><span class="hljs-function"><span class="hljs-params">, omittingEmptySubsequences: Bool = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">, whereSeparator isSeparator: </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(Element)</span></span></span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">rethrows</span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">ArraySlice</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Element</span></span>&gt;] }</code> </pre><br>  Now it will be easier to work with these methods. <br><br><h4>  Protocol Restrictions </h4><br>  Protocols now support constraints as classes that implement this protocol.  In other words, you can now specify that the protocol can only be implemented by a specific class.  For example: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Viewable</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIView</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Viewable</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Self</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIView</span></span></span><span class="hljs-class"> </span></span>{}</code> </pre><br>  The second record option is supported in Swift 4.2, but may cause a compilation error or in runtime.  In Swift 5, this error will not occur. <br><br><h3>  Conclusion </h3><br>  This is not the entire list of changes in Swift 5, only major changes are collected here.  In general, the changes presented are positive and make the language more understandable and flexible.  The main thing is that "Convert to current Swift syntax" should be painless. <br><br>  That's all, thanks for reading. </div>