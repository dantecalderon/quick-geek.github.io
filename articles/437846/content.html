<div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/hs/qs/un/hsqsunauoofydxhevo3-i1bs0nc.png"></p><br><p>  Thus, I described the structure of the system of controlled software accessories. </p><br><p> The simplified model includes the main process ( <code>bobaoskit.worker</code> ) and accessory scripts (using the <code>bobaoskit.sdk</code> and <code>bobaoskit.accessory</code> ).  From the main process comes a request to the accessory to control some fields.  From the accessory, in turn, there is a request to the principal on the status update. </p><br><p>  As an example, take the usual relay. </p><br><p>  When an incoming command is received, the relay may sometimes not change its position for various reasons (the equipment is stuck, etc.).  Accordingly, how many we will not send commands, the status will not change.  And, in another situation, the relay can change its state with a command from a third-party system.  In this case, its status will change, the accessory script may react to an incoming event of a status change and send a request to the main process. </p><a name="habracut"></a><br><h2 id="motivaciya">  Motivation </h2><br><p>  Having introduced Apple HomeKit to several objects, I began to look for something similar to Android, because  I only have a working iPad from iOS devices.  The main criterion was the ability to work in a local network, without cloud services.  Also, what was missing in HomeKit is the limited information.  For example, you can take a thermostat.  All his management is reduced to the choice of operating mode (off, heating, cooling and auto) and a given temperature.  Simpler is better, but in my opinion, not always.  Not enough diagnostic information.  For example, whether the air conditioner, convector, what ventilation parameters.  The air conditioner may not work due to an internal error.  Considering that this information can be considered, it was decided to write its own implementation. </p><br><p>  It was possible to look at options such as ioBroker, OpenHAB, home-assistant. <br>  But on node.js from the listed only ioBroker (while I am writing an article, I noticed that redis also participates in the process).  And by that moment I discovered how to organize interprocess communication and it was interesting to deal with redis, which has been heard recently. </p><br><p>  You can also pay attention to the following specification: </p><br><p>  → <a href="https://iot.mozilla.org/wot/">Web Thing API</a> </p><br><h2 id="ustroystvo">  Device </h2><br><p><img src="https://habrastorage.org/webt/jv/dm/9y/jvdm9y_wj-o1fchmsgfqzedaxpw.png"></p><br><p>  <code>Redis</code> helps interprocess communication, and also acts as a database for accessories. </p><br><p>  The <code>bobaoskit.worker</code> module happens a request queue (on top of <code>redis</code> using <code>bee-queue</code> ), executes a request, writes / reads from a database. </p><br><p>  In user scripts, the <code>bobaoskit.accessory</code> object listens to a separate <code>bee-queue</code> for this particular accessory, performs the prescribed actions, sends requests to the main process queue via the <code>bobaoskit.sdk</code> object. </p><br><h2 id="protokol">  Protocol </h2><br><p>  All requests and published messages are strings in <code>JSON</code> format, contain the field <code>method</code> and <code>payload</code> .  Fields are required, even if <code>payload = null</code> . </p><br><h3 id="zaprosy-k-bobaoskitworker">  Requests to <code>bobaoskit.worker</code> : </h3><br><ul><li>  method: <code>ping</code> , payload: <code>null</code> . </li><li>  method: <code>get general info</code> , payload: <code>null</code> </li><li>  method: <code>clear accessories</code> , payload: <code>null</code> , </li><li>  method: <code>add accessory</code> , <br>  payload: </li></ul><br><pre> <code class="plaintext hljs">{ id: "accessoryId", type: "switch/sensor/etc", name: "Accessory Display Name", control: [&lt;array of control fields&gt;], status: [&lt;array of status fields&gt;] }</code> </pre> <br><ul><li>  method: <code>remove accessory</code> , payload: <code>accessoryId/[acc1id, acc2id, ...]</code> </li><li>  method: <code>get accessory info</code> , payload: <code>null/accId/[acc1id, acc2id...]</code> <br>  In the <code>payload</code> field, you can send an accessory <code>null</code> / <code>id</code> <code>id</code> .  If sent <code>null</code> , then in response will come information about all existing accessories. </li><li>  method: <code>get status value</code> , payload: <code>{id: accessoryId, status: fieldId}</code> <br>  In the <code>payload</code> field, you can send an object of the form <code>{id: accessoryId, status: fieldId}</code> , (where the <code>status</code> field can be an array of fields), or <code>payload</code> can be an array of objects of this type. </li><li>  method: <code>update status value</code> , payload: <code>{id: accessoryId, status: {field: fieldId, value: value}</code> <br>  In the <code>payload</code> field, you can send an object of the form <code>{id: accessoryId, status: {field: fieldId, value: value}}</code> , (where the <code>status</code> field can be an array of <code>{field: fieldId, value: value}</code> ), or <code>payload</code> can be an array of objects such kind of. </li><li>  method: <code>control accessory value</code> , payload: <code>{id: accessoryId, control: {field: fieldId, value: value}}</code> . <br>  In the <code>payload</code> field, you can send an object of the form <code>{id: accessoryId, control: {field: fieldId, value: value}}</code> , (where the <code>control</code> field can be an array of <code>{field: fieldId, value: value}</code> ), or <code>payload</code> can be an array of objects such kind of. </li></ul><br><p>  In response to any request, if successful, a message of the following type is received: </p><br><p> <code>{ method: "success", payload: &lt;...&gt; }</code> </p> <br><p>  In case of failure: </p><br><p> <code>{ method: "error", payload: "Error description" }</code> </p> <br><p>  Messages to the <code>redis PUB/SUB</code> channel (defined in <code>config.json</code> ) are also published in the following cases: all accessories ( <code>clear accessories</code> ) are cleared;  <code>add accessory</code> ;  accessory removed ( <code>remove accessory</code> );  Accessory updated status ( <code>update status value</code> ). </p><br><p>  Broadcast messages also contain two fields: <code>method</code> and <code>payload</code> . </p><br><h2 id="klientskiy-sdk">  Client SDK </h2><br><h3 id="opisanie">  Description </h3><br><p>  The client SDK ( <code>bobaoskit.accessory</code> ) allows you to call the above methods from <code>js</code> scripts. </p><br><p>  Inside the module are two constructor objects.  The first creates an <code>Sdk</code> object to access the above methods, and the second creates an accessory - a wrapper on top of these functions. </p><br><pre> <code class="plaintext hljs">const BobaosKit = require("bobaoskit.accessory"); // Создаем объект sdk. // Не обязательно, // но если планируется много аксессуаров, // то лучше использовать общий sdk, const sdk = BobaosKit.Sdk({ redis: redisClient // optional job_channel: "bobaoskit_job", // optional. default: bobaoskit_job broadcast_channel: "bobaoskit_bcast" // optional. default: bobaoskit_bcast }); // Создаем аксессуар const dummySwitchAcc = BobaosKit.Accessory({ id: "dummySwitch", // required name: "Dummy Switch", // required type: "switch", // required control: ["state"], // requried. Поля, которыми можем управлять. status: ["state"], // required. Поля со значениями. sdk: sdk, // optional. // Если не определен, новый объект sdk будет создан // со следующими опциональными параметрами redis: undefined, job_channel: "bobaoskit_job", broadcast_channel: "bobaoskit_bcast" });</code> </pre> <br><p>  The sdk object supports <code>Promise</code> methods: </p><br><pre> <code class="plaintext hljs">sdk.ping(); sdk.getGeneralInfo(); sdk.clearAccessories(); sdk.addAccessory(payload); sdk.removeAccessory(payload); sdk.getAccessoryInfo(payload); sdk.getStatusValue(payload); sdk.updateStatusValue(payload); sdk.controlAccessoryValue(payload);</code> </pre> <br><p>  The <code>BobaosKit.Accessory({..})</code> object is a wrapper over the <code>BobaosKit.Sdk(...)</code> object. </p><br><p>  Further I will show how it turns around: </p><br><pre> <code class="plaintext hljs">// из исходного кода модуля self.getAccessoryInfo = _ =&gt; { return _sdk.getAccessoryInfo(id); }; self.getStatusValue = payload =&gt; { return _sdk.getStatusValue({ id: id, status: payload }); }; self.updateStatusValue = payload =&gt; { return _sdk.updateStatusValue({ id: id, status: payload }); };</code> </pre> <br><p>  Both objects are also <code>EventEmitter</code> . <br>  <code>Sdk</code> calls functions for <code>ready</code> and <code>broadcasted event</code> . <br>  <code>Accessory</code> calls functions on <code>ready</code> , <code>error</code> , <code>control accessory value</code> events. </p><br><h3 id="primer">  Example </h3><br><pre> <code class="plaintext hljs">const BobaosKit = require("bobaoskit.accessory"); const Bobaos = require("bobaos.sub"); // init bobaos with default params const bobaos = Bobaos(); // init sdk with default params const accessorySdk = BobaosKit.Sdk(); const SwitchAccessory = params =&gt; { let { id, name, controlDatapoint, stateDatapoint } = params; // init accessory const swAcc = BobaosKit.Accessory({ id: id, name: name, type: "switch", control: ["state"], status: ["state"], sdk: accessorySdk }); // по входящему запросу на переключение поля state // отправляем запрос в шину KNX посредством bobaos swAcc.on("control accessory value", async (payload, cb) =&gt; { const processOneAccessoryValue = async payload =&gt; { let { field, value } = payload; if (field === "state") { await bobaos.setValue({ id: controlDatapoint, value: value }); } }; if (Array.isArray(payload)) { await Promise.all(payload.map(processOneAccessoryValue)); return; } await processOneAccessoryValue(payload); }); const processOneBaosValue = async payload =&gt; { let { id, value } = payload; if (id === stateDatapoint) { await swAcc.updateStatusValue({ field: "state", value: value }); } }; // при входящем значении с шины KNX // обновляем поле state аксессуара bobaos.on("datapoint value", payload =&gt; { if (Array.isArray(payload)) { return payload.forEach(processOneBaosValue); } return processOneBaosValue(payload); }); return swAcc; }; const switches = [ { id: "sw651", name: "Санузел", controlDatapoint: 651, stateDatapoint: 652 }, { id: "sw653", name: "Щитовая 1", controlDatapoint: 653, stateDatapoint: 653 }, { id: "sw655", name: "Щитовая 2", controlDatapoint: 655, stateDatapoint: 656 }, { id: "sw657", name: "Комната 1", controlDatapoint: 657, stateDatapoint: 658 }, { id: "sw659", name: "Кинотеатр", controlDatapoint: 659, stateDatapoint: 660 } ]; switches.forEach(SwitchAccessory);</code> </pre> <br><h2 id="websocket-api">  WebSocket API </h2><br><p>  <code>bobaoskit.worker</code> listens on the WebSocket port defined in <code>./config.json</code> . </p><br><p>  Incoming requests are <code>JSON</code> strings, which must have the following fields: <code>request_id</code> , <code>method</code> and <code>payload</code> . </p><br><p>  API is limited to the following requests: </p><br><ul><li>  method: <code>ping</code> , payload: <code>null</code> </li><li>  method: <code>get general info</code> , payload: <code>null</code> , </li><li>  method: <code>get accessory info</code> , payload: <code>null/accId/[acc1Id, ...]</code> </li><li>  method: <code>get status value</code> , payload: <code>{id: accId, status: field1/[field1, ...]}/[{id: ...}...]</code> </li><li>  method: <code>control accessory value</code> , payload: <code>{id: accId, control: {field: field1, value: value}/[{field: .. value: ..}]}/[{id: ...}, ...]</code> </li></ul><br><p>  The <code>get status value</code> , <code>control accessory value</code> <code>get status value</code> methods take the <code>payload</code> field as a single object, or as an array.  The <code>control/status</code> fields inside the <code>payload</code> can also be one object or an array. </p><br><p>  The following events are sent from the server to all clients: </p><br><ul><li>  method: <code>clear accessories</code> , payload: null </li><li>  method: <code>remove accessory</code> , payload: accessory id </li><li>  method: <code>add accessory, payload</code> : {id: ...} </li><li>  method: <code>update status value, payload</code> : {id: ...} </li></ul><br><h2 id="dnssd">  dnssd </h2><br><p>  The application advertises the WebSocket port on the local network as a <code>_bobaoskit._tcp</code> service, thanks to the npm <code>dnssd</code> module. </p><br><h2 id="demo">  Demo </h2><br><iframe width="560" height="315" src="https://www.youtube.com/embed/C7Fogh08ICc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  There will be a separate article about how the application with the video is written and about the <code>flutter</code> impressions. </p><br><h2 id="posleslovie">  Afterword </h2><br><p>  Thus, it turned out a simple system for managing software accessories. <br>  Accessories can be opposed to objects from the real world: buttons, sensors, switches, thermostats, radio.  Since there is no standardization, you can implement any accessories by fitting into the model <code>control &lt; == &gt; update</code> . </p><br><p>  What could be done better: </p><br><ol><li>  A binary protocol would allow sending less data.  On the other hand, <code>JSON</code> faster in development and understanding.  The binary protocol also requires standardization. </li></ol><br><p>  That's all, I will be glad to any feedback. </p></div>