<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>bobaoskit - accessories, dnssd and websocket</title>
  <meta name="description" content="Thus, I described the structure of the system of controlled software accessories. 


 The simplified model includes the main process ( bobaoskit.worke...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>bobaoskit - accessories, dnssd and websocket</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/hs/qs/un/hsqsunauoofydxhevo3-i1bs0nc.png"></p><br><p>  Thus, I described the structure of the system of controlled software accessories. </p><br><p> The simplified model includes the main process ( <code>bobaoskit.worker</code> ) and accessory scripts (using the <code>bobaoskit.sdk</code> and <code>bobaoskit.accessory</code> ).  From the main process comes a request to the accessory to control some fields.  From the accessory, in turn, there is a request to the principal on the status update. </p><br><p>  As an example, take the usual relay. </p><br><p>  When an incoming command is received, the relay may sometimes not change its position for various reasons (the equipment is stuck, etc.).  Accordingly, how many we will not send commands, the status will not change.  And, in another situation, the relay can change its state with a command from a third-party system.  In this case, its status will change, the accessory script may react to an incoming event of a status change and send a request to the main process. </p><a name="habracut"></a><br><h2 id="motivaciya">  Motivation </h2><br><p>  Having introduced Apple HomeKit to several objects, I began to look for something similar to Android, because  I only have a working iPad from iOS devices.  The main criterion was the ability to work in a local network, without cloud services.  Also, what was missing in HomeKit is the limited information.  For example, you can take a thermostat.  All his management is reduced to the choice of operating mode (off, heating, cooling and auto) and a given temperature.  Simpler is better, but in my opinion, not always.  Not enough diagnostic information.  For example, whether the air conditioner, convector, what ventilation parameters.  The air conditioner may not work due to an internal error.  Considering that this information can be considered, it was decided to write its own implementation. </p><br><p>  It was possible to look at options such as ioBroker, OpenHAB, home-assistant. <br>  But on node.js from the listed only ioBroker (while I am writing an article, I noticed that redis also participates in the process).  And by that moment I discovered how to organize interprocess communication and it was interesting to deal with redis, which has been heard recently. </p><br><p>  You can also pay attention to the following specification: </p><br><p>  ‚Üí <a href="https://iot.mozilla.org/wot/">Web Thing API</a> </p><br><h2 id="ustroystvo">  Device </h2><br><p><img src="https://habrastorage.org/webt/jv/dm/9y/jvdm9y_wj-o1fchmsgfqzedaxpw.png"></p><br><p>  <code>Redis</code> helps interprocess communication, and also acts as a database for accessories. </p><br><p>  The <code>bobaoskit.worker</code> module happens a request queue (on top of <code>redis</code> using <code>bee-queue</code> ), executes a request, writes / reads from a database. </p><br><p>  In user scripts, the <code>bobaoskit.accessory</code> object listens to a separate <code>bee-queue</code> for this particular accessory, performs the prescribed actions, sends requests to the main process queue via the <code>bobaoskit.sdk</code> object. </p><br><h2 id="protokol">  Protocol </h2><br><p>  All requests and published messages are strings in <code>JSON</code> format, contain the field <code>method</code> and <code>payload</code> .  Fields are required, even if <code>payload = null</code> . </p><br><h3 id="zaprosy-k-bobaoskitworker">  Requests to <code>bobaoskit.worker</code> : </h3><br><ul><li>  method: <code>ping</code> , payload: <code>null</code> . </li><li>  method: <code>get general info</code> , payload: <code>null</code> </li><li>  method: <code>clear accessories</code> , payload: <code>null</code> , </li><li>  method: <code>add accessory</code> , <br>  payload: </li></ul><br><pre> <code class="plaintext hljs">{ id: "accessoryId", type: "switch/sensor/etc", name: "Accessory Display Name", control: [&lt;array of control fields&gt;], status: [&lt;array of status fields&gt;] }</code> </pre> <br><ul><li>  method: <code>remove accessory</code> , payload: <code>accessoryId/[acc1id, acc2id, ...]</code> </li><li>  method: <code>get accessory info</code> , payload: <code>null/accId/[acc1id, acc2id...]</code> <br>  In the <code>payload</code> field, you can send an accessory <code>null</code> / <code>id</code> <code>id</code> .  If sent <code>null</code> , then in response will come information about all existing accessories. </li><li>  method: <code>get status value</code> , payload: <code>{id: accessoryId, status: fieldId}</code> <br>  In the <code>payload</code> field, you can send an object of the form <code>{id: accessoryId, status: fieldId}</code> , (where the <code>status</code> field can be an array of fields), or <code>payload</code> can be an array of objects of this type. </li><li>  method: <code>update status value</code> , payload: <code>{id: accessoryId, status: {field: fieldId, value: value}</code> <br>  In the <code>payload</code> field, you can send an object of the form <code>{id: accessoryId, status: {field: fieldId, value: value}}</code> , (where the <code>status</code> field can be an array of <code>{field: fieldId, value: value}</code> ), or <code>payload</code> can be an array of objects such kind of. </li><li>  method: <code>control accessory value</code> , payload: <code>{id: accessoryId, control: {field: fieldId, value: value}}</code> . <br>  In the <code>payload</code> field, you can send an object of the form <code>{id: accessoryId, control: {field: fieldId, value: value}}</code> , (where the <code>control</code> field can be an array of <code>{field: fieldId, value: value}</code> ), or <code>payload</code> can be an array of objects such kind of. </li></ul><br><p>  In response to any request, if successful, a message of the following type is received: </p><br><p> <code>{ method: "success", payload: &lt;...&gt; }</code> </p> <br><p>  In case of failure: </p><br><p> <code>{ method: "error", payload: "Error description" }</code> </p> <br><p>  Messages to the <code>redis PUB/SUB</code> channel (defined in <code>config.json</code> ) are also published in the following cases: all accessories ( <code>clear accessories</code> ) are cleared;  <code>add accessory</code> ;  accessory removed ( <code>remove accessory</code> );  Accessory updated status ( <code>update status value</code> ). </p><br><p>  Broadcast messages also contain two fields: <code>method</code> and <code>payload</code> . </p><br><h2 id="klientskiy-sdk">  Client SDK </h2><br><h3 id="opisanie">  Description </h3><br><p>  The client SDK ( <code>bobaoskit.accessory</code> ) allows you to call the above methods from <code>js</code> scripts. </p><br><p>  Inside the module are two constructor objects.  The first creates an <code>Sdk</code> object to access the above methods, and the second creates an accessory - a wrapper on top of these functions. </p><br><pre> <code class="plaintext hljs">const BobaosKit = require("bobaoskit.accessory"); // –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç sdk. // –ù–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ, // –Ω–æ –µ—Å–ª–∏ –ø–ª–∞–Ω–∏—Ä—É–µ—Ç—Å—è –º–Ω–æ–≥–æ –∞–∫—Å–µ—Å—Å—É–∞—Ä–æ–≤, // —Ç–æ –ª—É—á—à–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –æ–±—â–∏–π sdk, const sdk = BobaosKit.Sdk({ redis: redisClient // optional job_channel: "bobaoskit_job", // optional. default: bobaoskit_job broadcast_channel: "bobaoskit_bcast" // optional. default: bobaoskit_bcast }); // –°–æ–∑–¥–∞–µ–º –∞–∫—Å–µ—Å—Å—É–∞—Ä const dummySwitchAcc = BobaosKit.Accessory({ id: "dummySwitch", // required name: "Dummy Switch", // required type: "switch", // required control: ["state"], // requried. –ü–æ–ª—è, –∫–æ—Ç–æ—Ä—ã–º–∏ –º–æ–∂–µ–º —É–ø—Ä–∞–≤–ª—è—Ç—å. status: ["state"], // required. –ü–æ–ª—è —Å–æ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏. sdk: sdk, // optional. // –ï—Å–ª–∏ –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω, –Ω–æ–≤—ã–π –æ–±—ä–µ–∫—Ç sdk –±—É–¥–µ—Ç —Å–æ–∑–¥–∞–Ω // —Å–æ —Å–ª–µ–¥—É—é—â–∏–º–∏ –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ redis: undefined, job_channel: "bobaoskit_job", broadcast_channel: "bobaoskit_bcast" });</code> </pre> <br><p>  The sdk object supports <code>Promise</code> methods: </p><br><pre> <code class="plaintext hljs">sdk.ping(); sdk.getGeneralInfo(); sdk.clearAccessories(); sdk.addAccessory(payload); sdk.removeAccessory(payload); sdk.getAccessoryInfo(payload); sdk.getStatusValue(payload); sdk.updateStatusValue(payload); sdk.controlAccessoryValue(payload);</code> </pre> <br><p>  The <code>BobaosKit.Accessory({..})</code> object is a wrapper over the <code>BobaosKit.Sdk(...)</code> object. </p><br><p>  Further I will show how it turns around: </p><br><pre> <code class="plaintext hljs">// –∏–∑ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ –∫–æ–¥–∞ –º–æ–¥—É–ª—è self.getAccessoryInfo = _ =&gt; { return _sdk.getAccessoryInfo(id); }; self.getStatusValue = payload =&gt; { return _sdk.getStatusValue({ id: id, status: payload }); }; self.updateStatusValue = payload =&gt; { return _sdk.updateStatusValue({ id: id, status: payload }); };</code> </pre> <br><p>  Both objects are also <code>EventEmitter</code> . <br>  <code>Sdk</code> calls functions for <code>ready</code> and <code>broadcasted event</code> . <br>  <code>Accessory</code> calls functions on <code>ready</code> , <code>error</code> , <code>control accessory value</code> events. </p><br><h3 id="primer">  Example </h3><br><pre> <code class="plaintext hljs">const BobaosKit = require("bobaoskit.accessory"); const Bobaos = require("bobaos.sub"); // init bobaos with default params const bobaos = Bobaos(); // init sdk with default params const accessorySdk = BobaosKit.Sdk(); const SwitchAccessory = params =&gt; { let { id, name, controlDatapoint, stateDatapoint } = params; // init accessory const swAcc = BobaosKit.Accessory({ id: id, name: name, type: "switch", control: ["state"], status: ["state"], sdk: accessorySdk }); // –ø–æ –≤—Ö–æ–¥—è—â–µ–º—É –∑–∞–ø—Ä–æ—Å—É –Ω–∞ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –ø–æ–ª—è state // –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å –≤ —à–∏–Ω—É KNX –ø–æ—Å—Ä–µ–¥—Å—Ç–≤–æ–º bobaos swAcc.on("control accessory value", async (payload, cb) =&gt; { const processOneAccessoryValue = async payload =&gt; { let { field, value } = payload; if (field === "state") { await bobaos.setValue({ id: controlDatapoint, value: value }); } }; if (Array.isArray(payload)) { await Promise.all(payload.map(processOneAccessoryValue)); return; } await processOneAccessoryValue(payload); }); const processOneBaosValue = async payload =&gt; { let { id, value } = payload; if (id === stateDatapoint) { await swAcc.updateStatusValue({ field: "state", value: value }); } }; // –ø—Ä–∏ –≤—Ö–æ–¥—è—â–µ–º –∑–Ω–∞—á–µ–Ω–∏–∏ —Å —à–∏–Ω—ã KNX // –æ–±–Ω–æ–≤–ª—è–µ–º –ø–æ–ª–µ state –∞–∫—Å–µ—Å—Å—É–∞—Ä–∞ bobaos.on("datapoint value", payload =&gt; { if (Array.isArray(payload)) { return payload.forEach(processOneBaosValue); } return processOneBaosValue(payload); }); return swAcc; }; const switches = [ { id: "sw651", name: "–°–∞–Ω—É–∑–µ–ª", controlDatapoint: 651, stateDatapoint: 652 }, { id: "sw653", name: "–©–∏—Ç–æ–≤–∞—è 1", controlDatapoint: 653, stateDatapoint: 653 }, { id: "sw655", name: "–©–∏—Ç–æ–≤–∞—è 2", controlDatapoint: 655, stateDatapoint: 656 }, { id: "sw657", name: "–ö–æ–º–Ω–∞—Ç–∞ 1", controlDatapoint: 657, stateDatapoint: 658 }, { id: "sw659", name: "–ö–∏–Ω–æ—Ç–µ–∞—Ç—Ä", controlDatapoint: 659, stateDatapoint: 660 } ]; switches.forEach(SwitchAccessory);</code> </pre> <br><h2 id="websocket-api">  WebSocket API </h2><br><p>  <code>bobaoskit.worker</code> listens on the WebSocket port defined in <code>./config.json</code> . </p><br><p>  Incoming requests are <code>JSON</code> strings, which must have the following fields: <code>request_id</code> , <code>method</code> and <code>payload</code> . </p><br><p>  API is limited to the following requests: </p><br><ul><li>  method: <code>ping</code> , payload: <code>null</code> </li><li>  method: <code>get general info</code> , payload: <code>null</code> , </li><li>  method: <code>get accessory info</code> , payload: <code>null/accId/[acc1Id, ...]</code> </li><li>  method: <code>get status value</code> , payload: <code>{id: accId, status: field1/[field1, ...]}/[{id: ...}...]</code> </li><li>  method: <code>control accessory value</code> , payload: <code>{id: accId, control: {field: field1, value: value}/[{field: .. value: ..}]}/[{id: ...}, ...]</code> </li></ul><br><p>  The <code>get status value</code> , <code>control accessory value</code> <code>get status value</code> methods take the <code>payload</code> field as a single object, or as an array.  The <code>control/status</code> fields inside the <code>payload</code> can also be one object or an array. </p><br><p>  The following events are sent from the server to all clients: </p><br><ul><li>  method: <code>clear accessories</code> , payload: null </li><li>  method: <code>remove accessory</code> , payload: accessory id </li><li>  method: <code>add accessory, payload</code> : {id: ...} </li><li>  method: <code>update status value, payload</code> : {id: ...} </li></ul><br><h2 id="dnssd">  dnssd </h2><br><p>  The application advertises the WebSocket port on the local network as a <code>_bobaoskit._tcp</code> service, thanks to the npm <code>dnssd</code> module. </p><br><h2 id="demo">  Demo </h2><br><iframe width="560" height="315" src="https://www.youtube.com/embed/C7Fogh08ICc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  There will be a separate article about how the application with the video is written and about the <code>flutter</code> impressions. </p><br><h2 id="posleslovie">  Afterword </h2><br><p>  Thus, it turned out a simple system for managing software accessories. <br>  Accessories can be opposed to objects from the real world: buttons, sensors, switches, thermostats, radio.  Since there is no standardization, you can implement any accessories by fitting into the model <code>control &lt; == &gt; update</code> . </p><br><p>  What could be done better: </p><br><ol><li>  A binary protocol would allow sending less data.  On the other hand, <code>JSON</code> faster in development and understanding.  The binary protocol also requires standardization. </li></ol><br><p>  That's all, I will be glad to any feedback. </p></div><p>Source: <a href="https://habr.com/ru/post/437846/">https://habr.com/ru/post/437846/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>