<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Swift compiler device. Part 2</title>
  <meta name="description" content="The second part of my story about the Swift compiler. We will begin to study the frontend, or rather those parts that are responsible for the initial ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Swift compiler device. Part 2</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/gb/ll/lc/gblllcop33qw16mals99ykfevfm.png"><br><p>  The second part of my story about the Swift compiler.  We will begin to study the frontend, or rather those parts that are responsible for the initial analysis and analysis of the source code. <a name="habracut"></a></p><br><p>  The first part of the article can be found <a href="https://habr.com/ru/company/e-Legion/blog/438204/">here</a> . </p><cut></cut><br><h1 id="frontend">  Frontend </h1><br><img src="https://habrastorage.org/webt/ol/fm/lq/olfmlqa1vogrofwbxiikyqogyr0.png" width="500" align="left"><br><p><br clear="all"></p><br><p>  The frontend's task is to generate an intermediate representation from the source code and transfer it to LLVM.  This process can be divided into 8 steps.  The result of almost every one of them can be output by passing a special parameter to the compiler. </p><br><p>  Below I will demonstrate the implementation of a compiler for a primitive "programming language" that contains only "scope" and number.  Its only function is to output a number (if it exists) to the console.  For example, as a result of executing this ‚Äúcode‚Äù the number 678 will be displayed: </p><br><pre><code class="plaintext hljs">{{{678}}}</code> </pre> <br><p>  This compiler is only needed to make it easier for you to understand what is happening at different stages.  On the implementation of this, but simple language, you can look at the example of <a href="http://llvm.org/docs/tutorial/index.html">Kaledoscope</a> . </p><br><p>  Each scope consists of an opening bracket, a content, and a closing bracket.  This can be written as: </p><br><pre> <code class="plaintext hljs">scope ::= open_brace x close_brace open_brace ::= "{" close_brace ::= "}"</code> </pre> <br><p>  The content may be the same scope, number, or nothing, indicated here <strong>:</strong> <strong><br></strong> <br></p><pre> <code class="plaintext hljs">scope ::= open_brace x close_brace x ::= scope | number | &lt;empty&gt; open_brace ::= "{" close_brace ::= "}"</code> </pre> <br><p>  Symbol |  means "or."  A number consists of one or more digits: </p><br><pre> <code class="plaintext hljs">scope ::= open_brace x close_brace x ::= scope | number | &lt;empty&gt; open_brace ::= "{" close_brace ::= "}" number ::= digit | number digit digit :: = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"</code> </pre> <br><p>  Such a record is called the Backus-Naur form (BNF), and the totality of all the rules is called the grammar of the language or syntax. </p><br><p>  There is also an extended BNF (RBNF).  Additional special characters have been added to it, for example, parentheses for grouping. </p><br><p>  Braces denote repetitions.  Such a record means that A is either empty or equal to any number of B: </p><br><pre> <code class="plaintext hljs">A ::= { B }</code> </pre> <br><p>  Brackets are used for conditional entry.  Such a record means that A is either empty or equal to B: </p><br><pre> <code class="plaintext hljs">A ::= [B]</code> </pre> <br><p>  Using the RBNF grammar compiler grammar can be converted to this form: </p><br><pre> <code class="plaintext hljs">scope ::= open_brace [scope | number] close_brace open_brace ::= "{" close_brace ::= "}" number ::= digit {digit} digit :: = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"</code> </pre> <br><p>  In addition to the parenthesis compiler, I will show how to use the Swift compiler to get the results of each of the steps using the simplest example: </p><br><pre> <code class="plaintext hljs">let x = 16</code> </pre> <br><p>  The code is so simple to make it easier to understand.  The grammar of a real programming language is much more complicated than the one given above.  Look at the Swift syntax on the official <a href="https://docs.swift.org/swift-book/ReferenceManual/AboutTheLanguageReference.html">site</a> . </p><br><h1 id="lexer">  Lexer </h1><br><p>  From the point of view of the compiler, the source code file is a stream of random characters, and maybe some kind of garbage.  Therefore, the first step is to convert these random characters into words that can be used in a programming language. </p><br><p>  This is done by a lexical analyzer (lexer / tokenizer).  The words he searches for are called lexemes or tokens (we will not go into unnecessary details and will take these terms as synonyms).  Therefore, this process is also called tokenization. </p><br><p>  Lexer analyzes according to the syntax of the language.  Scanning character by character, it matches the source code and the right side of the record, and then generates the corresponding token from the left side. </p><br><h3 id="primer-realizacii-leksera">  Lexer implementation example </h3><br><p>  The grammar allowed three tokens: an opening bracket, a closing bracket, and a number.  They are presented as a listing.  Like the list of possible errors: </p><br><pre> <code class="plaintext hljs">enum Token: CustomStringConvertible { case openBraceToken case closeBraceToken case number(Int) var description: String { switch self { case .openBraceToken: return "openBraceToken" case .closeBraceToken: return "closeBraceToken" case .number(let value): return "\(value)" } } } enum LexerError: Error { case unexpectedCharacted case invalidNumber }</code> </pre> <br><p>  The lexer itself stores the input string and the index of the current character: </p><br><pre> <code class="plaintext hljs">class Lexer { private let string: String private var index: String.Index private var currentCharacter: Character? { return index != string.endIndex ? string[index] : nil } init(string: String) { self.string = string index = string.startIndex }</code> </pre> <br><p>  The analysis is started by calling the <strong>startAnalyze ()</strong> method.  In it, a method is called in a loop to get the next token, which is added to the array.  At the end - interception of recognition errors: </p><br><pre> <code class="plaintext hljs">func startAnalyzing() -&gt; [Token] { var result: [Token] = [] do { while let token = try getNextToken() { result.append(token) } } catch LexerError.unexpectedCharacted { print("Unexpected character at index \(index.encodedOffset)") result = [] } catch LexerError.invalidNumber { print("Invalid number at index \(index.encodedOffset)") result = [] } catch { print("Unexpected error") result = [] } return result }</code> </pre> <br><p>  Getting a token consists of checking the current character and moving the index forward one or more characters: </p><br><pre> <code class="plaintext hljs">private func getNextToken() throws -&gt; Token? { guard let character = currentCharacter else { return nil } switch character { case "{": return getOpenBrace() case "}": return getCloseBrace() default: break } if let scalar = character.unicodeScalars.first, CharacterSet.decimalDigits.contains(scalar) { return try getNumber() } throw LexerError.unexpectedCharacted } private func getOpenBrace() -&gt; Token { moveIndex() return Token.openBraceToken } private func getCloseBrace() -&gt; Token { moveIndex() return Token.closeBraceToken }</code> </pre> <br><p>  If a digit is found, the <strong>getNumber ()</strong> method will be <strong>called</strong> to parse it.  It simply collects all the numbers in one line and converts it to an Int: </p><br><pre> <code class="plaintext hljs">private func getNumber() throws -&gt; Token { var numberString = "" while let character = currentCharacter, let scalar = character.unicodeScalars.first, CharacterSet.decimalDigits.contains(scalar) { numberString.append(character) moveIndex() } guard let number = Int(numberString) else { throw LexerError.invalidNumber } return Token.number(number) }</code> </pre> <br><p>  To run the lexer, you need to pass a line with the source code to it and call the <strong>startAnalyze ()</strong> method: </p><br><pre> <code class="plaintext hljs">let lexer = Lexer(string: "{{5678}}") let tokens = lexer.startAnalyzing()</code> </pre> <br><p>  The result is as expected: </p><br><pre> <code class="plaintext hljs">[openBraceToken, openBraceToken, 5678, closeBraceToken, closeBraceToken]</code> </pre> <br><p>  In Swift, the lexer is part of the parser, and you cannot get a list of tokens corresponding to the source code. </p><br><p>  Source: </p><br><ul><li>  <a href="">Lexer.h</a> </li><li>  <a href="">Lexer.cpp</a> </li></ul><br><h1 id="parser">  Parser </h1><br><p>  The parser performs parsing.  A sequence of tokens is passed to the input, and the result is an AST. </p><br><p>  AST is a graph in which the vertices are operators, and the leaves are their operands.  For example, the expression 1 + (2 * 3) consists of two operators: addition and multiplication.  The first operand of addition is 1, and the second is the result of product 2 and 3. The grouping brackets in AST are not used, since they are not necessary.  The graph itself determines the nesting of operations: </p><br><img src="https://habrastorage.org/webt/8f/s8/3f/8fs83fpfn-zhwsuwijgaxwttm2o.png" width="500" align="left"><br><p><br clear="all"></p><br><p>  Each node can be represented, for example, by a structure or enumeration containing child elements. </p><br><p>  During the formation of the tree, the parser checks the grammar of the language: is the correct sequence composed of "words"?  For example, the string <strong>"{{}"</strong> will be successfully parsed by the lexer, however it is incorrect because the second closing bracket is missing. </p><br><p>  The Swift parser is a recursive descending parser.  This means that he first finds the external entity, and then recursively analyzes its contents.  The ascending parser first finds the most nested entity, and then rises up. </p><br><h3 id="primer-realizacii-parsera">  Parser implementation example </h3><br><p>  There are a large number of types and implementations of parsers.  Below are the simplest implementation of the descending and ascending parser to illustrate the difference. </p><br><p>  A common feature of both parsers is the enumeration, which represents one of the errors and the AST node: </p><br><pre> <code class="plaintext hljs">indirect enum ASTNode: CustomStringConvertible { case brace(childNode: ASTNode?) case number(value: Int) var description: String { switch self { case let .brace(childNode?): return "brace(\(childNode.description))" case .brace(nil): return "brace(nil)" case let .number(value): return "\(value)" } } } enum ParserError: Error { case expectedOpenBrace case expectedCloseBrace case expectedNumber case expectedEndOfArray }</code> </pre> <br><h3 id="nishodyaschiy-parser">  Downstream parser </h3><br><p>  The descending parser stores an array of tokens and the index of the current token: </p><br><pre> <code class="plaintext hljs">class TopDownParser { private let tokens: [Token] private var index: Int private var currentToken: Token? { return index != tokens.endIndex ? tokens[index] : nil } init(tokens: [Token]) { self.tokens = tokens index = tokens.startIndex }</code> </pre> <br><p>  The only public method is parsing.  First, a pair of parentheses is called.  Since the root entity can only be a pair of brackets (the string <strong>"{} {}" is</strong> invalid), this is sufficient.  Further analysis will be performed recursively.  It only remains to check that the array of tokens is empty, and to produce interception of exceptions: </p><br><pre> <code class="plaintext hljs">func startParsing() -&gt; ASTNode? { var rootNode: ASTNode? do { rootNode = try parseBraces() guard currentToken == nil else { rootNode = nil throw ParserError.expectedEndOfArray } } catch ParserError.expectedCloseBrace { print("Expected close brace at index \(index)") } catch ParserError.expectedOpenBrace { print("Expected open brace at index \(index)") } catch ParserError.expectedEndOfArray { print("Expected end of tokens array at index \(index)") } catch { print("Unexpected error") } return rootNode }</code> </pre> <br><p>  When parsing brackets, the opening bracket is scanned first, then recursively - the contents inside the pair (if any), and at the end - the closing bracket. </p><br><p>  An important point: as soon as the parser sees the opening bracket, he believes that he has successfully found the next pair and can proceed to the content analysis.  That is why it goes from external entities to internal ones. </p><br><pre> <code class="plaintext hljs">private func parseBraces() throws -&gt; ASTNode? { try consumeOpenBrace() print("Pair found") let node: ASTNode? if let currentToken = self.currentToken, case .openBraceToken = currentToken { node = .brace(childNode: try parseBraces()) } else if let currentToken = self.currentToken, case let .number(value) = currentToken { node = .brace(childNode: .number(value: value)) try consumeNumber() } else { node = .brace(childNode: nil) } try consumeCloseBrace() return node }</code> </pre> <br><p>  A scan consists of checking a token and moving a current index: </p><br><pre> <code class="plaintext hljs">private func consumeOpenBrace() throws { if let currentToken = self.currentToken, case .openBraceToken = currentToken { print("Open brace found") moveIndex() } else { throw ParserError.expectedOpenBrace } }</code> </pre> <br><h3 id="voshodyaschiy-parser">  Upstream parser </h3><br><p>  Implementing an ascending parser is a bit more complicated.  He needs to keep his state, token stack and transition table between states. </p><br><p>  The state is presented as a listing.  It is necessary in order to take into account previous tokens and respond correctly to the emergence of a new one.  Since this example is very simple, it turned out that in the first state the parser parses the opening brackets, and in the second - the closing: </p><br><pre> <code class="plaintext hljs">class BottomUpParser { private enum State { case state1 case state2 }</code> </pre> <br><p>  The parser is initialized in the same way as the first.  There is no transition table as a separate entity.  For the sake of simplicity, its role will be played by switch: </p><br><pre> <code class="plaintext hljs">private let tokens: [Token] private var index: Int private var state: State = .state1 private var stack: [Token] = [] private var rootNode: ASTNode? private var currentToken: Token? { return index != tokens.endIndex ? tokens[index] : nil } init(tokens: [Token]) { self.tokens = tokens index = tokens.startIndex }</code> </pre> <br><p>  The analysis is also launched using the <strong>startParsing ()</strong> method.  In it, each token is processed in turn, and at the end a check is called that the stack is empty and the parsing is completed successfully: </p><br><pre> <code class="plaintext hljs">func startParsing() -&gt; ASTNode? { do { guard !tokens.isEmpty else { throw ParserError.expectedOpenBrace } while index != tokens.endIndex { try parseNextToken() moveIndex() } guard stack.isEmpty else { rootNode = nil throw ParserError.expectedCloseBrace } } catch ParserError.expectedCloseBrace { rootNode = nil print("Expected close brace at index \(index)") } catch ParserError.expectedOpenBrace { rootNode = nil print("Expected open brace at index \(index)") } catch ParserError.expectedEndOfArray { rootNode = nil print("Expected end of tokens array at index \(index)") } catch { rootNode = nil print("Unexpected error") } return rootNode }</code> </pre> <br><p>  It processes the next token in the switch, taking into account the current state.  If the opening bracket arrived and the state is 1, then it is added to the stack.  If the closing one - the parser checks if there is an opening bracket for it in the stack, then removes it from the stack and goes to state 2. The transition to the second state is also performed when the number is found. </p><br><p>  The parser continues to remove one item from the stack for each closing bracket.  If at this moment comes the opening bracket or number - this is an error in the input array. </p><br><p>  An important point: the ascending parser thinks that it found a pair only after, plunging down the hierarchy, it sees the closing bracket, provided that the opening pair is in the stack.  Only after that he will look for the essence that contains it, and so on up to the root.  That is why it is called ascending. </p><br><pre> <code class="plaintext hljs">private func parseNextToken() throws { guard let currentToken = currentToken else { return } switch (state, currentToken) { case (.state1, .openBraceToken): print("Open brace found") stack.append(.openBraceToken) case (.state1, .number(let value)): if stack.isEmpty { throw ParserError.expectedOpenBrace } else { consumeNumber(value: value) state = .state2 } case (.state1, .closeBraceToken): if stack.isEmpty { throw ParserError.expectedOpenBrace } else { consumeCloseBrace() state = .state2 } case (.state2, .closeBraceToken): if stack.isEmpty { throw ParserError.expectedEndOfArray } else { consumeCloseBrace() } case (.state2, .number), (.state2, .openBraceToken): if stack.isEmpty { throw ParserError.expectedEndOfArray } else { throw ParserError.expectedCloseBrace } } } private func consumeCloseBrace() { print("Close brace found") _ = stack.popLast() print("Pair found") if rootNode == nil { rootNode = .brace(childNode: nil) } else { rootNode = .brace(childNode: rootNode) } } private func consumeNumber(value: Int) { rootNode = .number(value: value) }</code> </pre> <br><p>  To start both parsers, you need to pass an array of tokens received from the lexer, and call the <strong>startParsing ()</strong> method: </p><br><pre> <code class="plaintext hljs">let parserTD = TopDownParser(tokens: tokens) let ast1 = parserTD.startParsing() let parserBU = BottomUpParser(tokens: tokens) let ast2 = parserBU.startParsing()</code> </pre> <br><p>  The result of both parsers was correct: </p><br><pre> <code class="plaintext hljs">brace(brace(5678))</code> </pre> <br><h3 id="ispolzovanie-parsera-swift">  Using the Swift parser </h3><br><p>  To run the Swift parser, you need to pass the <strong>-dump-parse</strong> flag to the compiler: </p><br><pre> <code class="plaintext hljs">swiftc -dump-parse main.swift</code> </pre> <br><p>  Real AST has a more complex structure than the parentheses parser.  But since it is small, it is easy to sort out and find the integer literal 16 and the constant <strong>x</strong> : </p><br><pre> <code class="plaintext hljs">(source_file (top_level_code_decl (brace_stmt (pattern_binding_decl (pattern_named 'x') (integer_literal_expr type='&lt;null&gt;' value=16)) )) (var_decl "x" type='&lt;null type&gt;' let storage_kind=stored))</code> </pre> <br><p>  This form of AST is an untyped tree.  Therefore, the constant x does not specify the type type = ''.  If you specify it explicitly - let x: Int = 16 the tree will change, but the type will not be registered anyway: <br></p><pre> <code class="plaintext hljs">(source_file (top_level_code_decl (brace_stmt (pattern_binding_decl (pattern_typed (pattern_named 'x') (type_ident (component id='Int' bind=none))) (integer_literal_expr type='&lt;null&gt;' value=16)) )) (var_decl "x" type='&lt;null type&gt;' let storage_kind=stored))</code> </pre> <br><p>  Source: </p><br><ul><li>  <a href="https://github.com/apple/swift/tree/master/include/swift/Parse">Parser headers</a> </li><li>  <a href="https://github.com/apple/swift/tree/master/lib/Parse">Parser implementation files</a> </li></ul><br><h1 id="sema">  Sema </h1><br><p>  The tree received from the parser is grammatically correct, but there may still be errors in it.  For example, during parsing it is impossible (impractical) to determine that a variable is declared before use.  This is a semantic analyzer.  It goes through the whole tree and assigns types to expressions, checks protocol support, synthesizes default initializers for structures, and more. </p><br><h3 id="ispolzovanie-semanticheskogo-analizatora-swift">  Using the Swift Semantic Analyzer </h3><br><p>  To launch the semantic analyzer, use the <strong>-dump-ast</strong> flag: </p><br><pre> <code class="plaintext hljs">swiftc -dump-ast main.swift</code> </pre> <br><p>  The result of the command: </p><br><pre> <code class="plaintext hljs">(source_file (top_level_code_decl (brace_stmt (pattern_binding_decl (pattern_named type='Int' 'x') (call_expr implicit type='Int' location=main.swift:1:9 range=[main.swift:1:9 - line:1:9] nothrow arg_labels=_builtinIntegerLiteral: (constructor_ref_call_expr implicit type='(_MaxBuiltinIntegerType) -&gt; Int' location=main.swift:1:9 range=[main.swift:1:9 - line:1:9] nothrow (declref_expr implicit type='(Int.Type) -&gt; (_MaxBuiltinIntegerType) -&gt; Int' location=main.swift:1:9 range=[main.swift:1:9 - line:1:9] decl=Swift.(file).Int.init(_builtinIntegerLiteral:) function_ref=single) (type_expr implicit type='Int.Type' location=main.swift:1:9 range=[main.swift:1:9 - line:1:9] typerepr='Int')) (tuple_expr implicit type='(_builtinIntegerLiteral: Int2048)' location=main.swift:1:9 range=[main.swift:1:9 - line:1:9] names=_builtinIntegerLiteral (integer_literal_expr type='Int2048' location=main.swift:1:9 range=[main.swift:1:9 - line:1:9] value=16)))) )) (var_decl "x" type='Int' interface type='Int' access=internal let storage_kind=stored))</code> </pre> <br><p>  The constant has <strong>type = 'Int'</strong> , as well as an access level.  Initializing the constant is a little more complicated.  Added constructor call <strong>_builtinIntegerLiteral</strong> .  If we present this tree in the form of Swift code, we get: </p><br><pre> <code class="plaintext hljs">internal let x: Int = Int(_builtinIntegerLiteral: 16)</code> </pre> <br><p>  The following example contains an error: </p><br><pre> <code class="plaintext hljs">let x: Bool = 16</code> </pre> <br><p>  If you pass it to the parser, it will not detect any deviations: </p><br><pre> <code class="plaintext hljs">(source_file (top_level_code_decl (brace_stmt (pattern_binding_decl (pattern_typed (pattern_named 'x') (type_ident (component id='Bool' bind=none))) (integer_literal_expr type='&lt;null&gt;' value=16)) )) (var_decl "x" type='&lt;null type&gt;' let storage_kind=stored))</code> </pre> <br><p>  But the semantic analyzer will indicate what is wrong with the code transmitted to it: </p><br><pre> <code class="plaintext hljs">error: cannot convert value of type 'Int' to specified type 'Bool' let x: Bool = 16</code> </pre> <br><p>  Obviously, the error was trying to assign an Int value to a constant of type Bool.  Swift does not allow this.  Thanks to the semantic analyzer. </p><br><p>  Source: </p><br><ul><li>  <a href="https://github.com/apple/swift/tree/master/lib/Sema">Sema</a> </li></ul><br><h1 id="clang-importer">  Clang importer </h1><br><p>  At this stage, the Clang modules are imported and the C and Objective-C API are mapped to the corresponding calls from Swift. </p><br><p>  Source: </p><br><ul><li>  <a href="https://github.com/apple/swift/tree/master/lib/ClangImporter">Clang importer</a> </li></ul><br><p>  Now we have a completely disassembled source code, which passed the initial verification.  But before proceeding to the generation of LLVM IR, you need to perform <a href="https://habr.com/ru/company/e-Legion/blog/438696/">Swift specific optimizations.</a> </p><br><p>  The full version of the source code can be found in the <a href="https://github.com/ildar-gilfanov/BraceCompiler">repository</a> . </p></div><p>Source: <a href="https://habr.com/ru/post/438664/">https://habr.com/ru/post/438664/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>