<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Making Game Boy Game Part 2</title>
  <meta name="description" content="A few weeks ago, I decided to work on a Game Boy game, the creation of which gave me great pleasure. Her working title is ‚ÄúAqua and Ashes‚Äù. The game h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Making Game Boy Game Part 2</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/849/ccb/9b1/849ccb9b1062f45b917d8771b08bf2c0.png" alt="image"></div><br>  A few weeks ago, I decided to work on a Game Boy game, the creation of which gave me great pleasure.  Her working title is ‚ÄúAqua and Ashes‚Äù.  The game has open source and is available on <a href="https://github.com/InvisibleUp/AquaAndAshes">GitHub</a> .  The previous part of the article is <a href="https://habr.com/ru/post/436330/">here</a> . <br><br><h2>  Fantastic sprites and where they live </h2><br>  In the last part, I finished rendering several sprites to the screen.  This was done in a very arbitrary and chaotic way.  In fact, I had to specify in the code what and where I want to display.  This made the creation of animation almost impossible, spent a lot of CPU time and complicated code maintenance.  I needed a better way. <br><br>  Specifically, I needed a system in which I could, for each individual animation, simply iterate the animation number, frame number, and timer.  If I needed to change the animation, I would just change the animation and reset the frame counter.  The animation procedure performed in each frame should simply select the appropriate sprites to display and throw them onto the screen without any effort on my part. <br><a name="habracut"></a><br>  And as it turned out, this problem is almost solved.  What I‚Äôm looking for is called <em>sprite mappings</em> .  Sprite maps are data structures that (roughly speaking) contain a list of sprites.  Each sprite card contains all the sprites for rendering a single object.  Also associated with them are <em>animation maps (animation mappings)</em> , which are lists of sprite maps with information on how to loop. <br><br>  It's pretty funny that back in May I added an animation map editor to the already ready sprite map editor of 16-bit Sonic games.  (It is <a href="https://github.com/InvisibleUp/Flex2">here</a> , you can study) It is not yet complete, because it is rather rough, painfully slow and inconvenient to use.  But from a technical point of view, it works.  And <em>it</em> seems to <em>me</em> that it is pretty cool ... (One of the reasons for the roughness was that I literally worked with the JavaScript framework for the first time.) Sonic is an old game, therefore it is ideal as a foundation for my new-old game. <br><br><h2>  Sonic 2 card format </h2><br>  I intended to use the editor in Sonic 2, because I wanted to create a hack for Genesis.  Sonic 1 and 3K are basically almost the same, but in order not to complicate things, I will limit myself to the story about the second part. <br><br>  First, let's look at the sprite maps.  Here's a pretty typical taile sprite, part of the blinking animation. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a1/5c7/1a0/6a15c71a0607d906333fe5e189c3b223.png"></div><br>  The Genesis console creates sprites a little differently.  A Genesis Tile (most programmers call it a ‚Äúpattern‚Äù) is 8x8 in size, just like on a Game Boy.  A sprite consists of a 4x4 rectangle in size, in many respects similar to the 8x16 sprites mode on the Game Boy, but more flexible.  The trick here is that these tiles should be in memory next to each other.  The developers of Sonic 2 wanted to reuse as many tiles as possible for the frame of the blinking Tails from the frame of the standing Tails.  Therefore Teylz is divided into 2 hardware sprites consisting of 3x2 tiles - one for the head, the other for the body.  They are shown in the figure below. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b3c/f35/4fd/b3cf354fd7f9f482b3e04ca5ab6b7ad3.png"></div><br>  The upper part of this dialog box is the attribute of hardware sprites.  It contains their position relative to the starting point (negative numbers are cut off; in fact, it is -16 and -12 for the first sprite and -12 for the second), the initial tile used in VRAM, the width and height of the sprite, as well as various status bits for mirror image sprite and palette. <br><br>  The bottom part shows the tiles as they are loaded from ROM to VRAM.  There is not enough space to store all Tail sprites in VRAM, so the necessary tiles have to be copied to memory in each frame.  They are called <em>Dynamic Pattern Load Cues</em> .  However, for now we can skip them, because they are almost independent of sprite cards, and therefore they can easily be added later. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e7/fc5/33b/8e7fc533b1b25a0ea1edcc785163f1ba.png"></div><br>  As for the animation, everything is a little simpler.  Sonic's animation map is a list of sprite maps with two pieces of metadata ‚Äî a speed value and an action performed after the animation ends.  The three most frequently used actions are: cycle through all frames, cycle through the last N frames, or transition to a completely different animation (for example, when moving from an animation of a standing Sonic to an animation of his impatient foot-stomping).  There are also a couple of commands that set the internal flags in the memory of objects, but not many objects use them.  (Now it occurred to me that you can set a bit in the object's RAM value when looping the animation. This will be useful for sound effects and other things.) <br><br>  If you look at the <a href="">disassembled code of Sonic 1</a> (the code of Sonic 2 is too large to link to it), you will notice that the link to the animation is not made by any ID.  Each object is given a list of animations, and the animation index is stored in memory.  To render a specific animation, the game takes an index, looks for it in the list of animations, and then renders it.  This makes the job a bit easier because you don‚Äôt need to scan the animations to find the one you want. <br><br><h2>  We clean the soup from the structures </h2><br>  Let's look at the types of cards: <br><br><ol><li>  Sprite cards: a list of sprites consisting of an initial tile, number of tiles, position, state of reflection (sprite is mirrored or not) and a palette. </li><li>  DPLC: a list of tiles from ROM that need to be loaded into VRAM.  Each element in the DPLC consists of an initial tile and a length;  each element is placed in VRAM after the latter. </li><li>  Animation maps: a list of animations consisting of a list of sprite maps, speed values, and cycle actions. </li><li>  List of animations: a list of pointers to the action of each animation. </li></ol><br>  Considering that we work with Game Boy, some simplifications can be made.  We know that there will always be two tiles in the 8x16 sprite cards.  However, everything else needs to be saved.  For now, we can completely abandon DPLC and just keep everything in VRAM.  This is a temporary solution, but, as I said, this problem will be easy to solve.  Finally, we can discard the speed value if we assume that each animation works at the same speed. <br><br>  Let's start to understand how to implement a similar system in my game. <br><br>  Check with the commit <a href="https://github.com/InvisibleUp/AquaAndAshes/commit/2e5e5b7436e824a1aa4265ffc971dc00425f7eae">2e5e5b7</a> ! <br><br>  Let's start with the sprite cards.  Each element in the map should mirror the OAM (Object Attribute Memory - Sprite VRAM) and thus a simple loop and memcpy will be enough to display the object.  Recall that <a href="http://gbdev.gg8.se/wiki/articles/Video_Display">an element in OAM consists of Y, X, the initial tile and the attribute byte</a> .  I just need to create a list of them.  Using the assembler pseudo-operator EQU, I prepared an attribute byte in advance so that I had a readable name for each possible combination of attributes.  (You may notice that in the previous commit I replaced the Y / X with a tile in the maps. This happened because I did not read the OAM specifications attentively. I also added a sprite counter to know how long the cycle would perform.) <br><br>  You will notice that the body and tail of the polar fox are stored separately.  If they were stored together, then there would be <em>more</em> redundancy, because each animation would have to be duplicated for each tail state.  And the scale of redundancy would quickly increase.  In Sonic 2, the same problem arose with Tails.  It was decided there by making Tails tails a separate object with its own state of animation and a timer.  I do not want to do this, because I do not want to solve the problem of maintaining the correct position of the tail relative to the fox. <br><br>  I solved the problem through animation maps.  If you look at my (only) animation map, then there are three pieces of metadata in it.  It indicates the number of animation cards, so I know when they will end.  (Sonic checks if the next animation is invalid, similar to the concept of the zero byte in lines C. The solution from Sonic frees the register, but adds a comparison that would work against me.) Of course, there is also a loop action.  (I turned the Sonic 2-byte scheme into a 1-byte number, in which bit 7 is the mode bit.) But I also have the number <em>of sprite cards</em> , and Sonic did not have it.  Having multiple sprite cards on one frame of animation allows me to reuse animations in several animations, which, I think, will save a lot of precious space.  You may also notice that the animations are duplicated for each direction.  This is done because the maps for each direction are different and must be added. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e9/e7d/240/8e9e7d2401e1a07d0c77e2f0c6c99e3d.png" alt="image"></div><br><h2>  Dance with registers </h2><br>  Check out <a href="">this file</a> at commit 1713848. <br><br>  Let's start by drawing a single sprite on the screen.  So, I confess, I lied.  Let me remind you that we can not write to the screen outside VBlank.  And this whole process is too long to fit into VBlank.  Therefore, we need to write the memory area we will allocate for the DMA.  In the end, it does not change anything, it is important to write to the right place. <br><br>  Let's start counting registers.  The GBZ80 processor has 6 registers, from A to E, H and L. H and L are special registers, so they are well suited for iterating through memory.  (Since they are used together, they are called HL.) In one opcode, I can write to the memory address contained in HL and add one to it.  It's hard to handle this.  You can use it either as a source or as a destination.  I used it as an address, and the combination of registers BC as a source, because it was most convenient.  We only have A, D and E. I need the register A for mathematical operations and the like.  What can DE be used for?  I use D as the loop counter, and E as the workspace.  And on this registers have ended. <br><br>  Let's say we have 4 sprites.  Register D (loop counter), we set the value to 4, register HL (addressee) - the address of the buffer OAM, and BC (source) - a place in the ROM, which stores our cards.  Now I would like to call memcpy.  However, there is a small problem.  Remember the X and Y coordinates?  They are indicated relative to the starting point, the center of the object is used for collisions and the like.  If we recorded them as they were, then each object would be displayed in the upper left corner of the screen.  It does not suit us.  To fix this, we need to add the X and Y coordinates of the object to the X and Y sprite. <br><br>  Brief note: I am talking about ‚Äúobjects‚Äù, but did not explain this concept to you.  An object is simply a set of attributes associated with an item in a game.  Attributes are position, speed, direction.  item description, etc.  I‚Äôm talking about this because I need to pull out the X and Y data from these objects. This will require a third set of registers pointing to the place in the RAM of the objects where the coordinates are.  And then we need to store X and Y somewhere. The same applies to the direction, because it helps us to determine which way the sprites are looking.  In addition, we need to render <em>all the</em> objects, so they also need a loop counter.  And we haven't gotten to the animations yet!  Everything gets out of control very quickly ... <br><br><h2>  Revision of the decision </h2><br>  So, I'm running too far ahead.  Let's go back and think about each piece of data that I need to track, and where to write it. <br><br>  To begin, let's divide this into ‚Äústages.‚Äù  Each stage should only receive data for the next, with the exception of the last, which performs the copy. <br><br><ol><li>  Object (cycle) - determines whether the object should be rendered, and renders it. </li><li>  List of animations - determines which animation to display.  Also gets the attributes of the object. </li><li>  Animation (loop) - determines which list of maps to use, and renders each map from it. </li><li>  Map (cycle) - iteratively passes through each sprite in the list of sprites </li><li>  Sprite - copies sprite attributes to OAM buffer </li></ol><br>  For each of the stages, I listed the variables they need, the roles they play and the places to store them.  This table looks like this. <br><br><table><tbody><tr><th>  Description </th><th>  The size </th><th>  Stage </th><th>  Using </th><th>  From where </th><th>  A place </th><th>  Where </th></tr><tr><td>  OAM buffer </td><td>  2 </td><td>  Sprite </td><td>  Pointer </td><td>  HL </td><td>  HL </td><td></td></tr><tr><td>  Source maps </td><td>  2 </td><td>  Sprite </td><td>  Pointer </td><td>  BC </td><td>  BC </td><td></td></tr><tr><td>  Current byte </td><td>  one </td><td>  Sprite </td><td>  Workspace </td><td>  Source maps </td><td>  E </td><td></td></tr><tr><td>  X </td><td>  one </td><td>  Sprite </td><td>  Variable </td><td>  Hiram </td><td>  A </td><td></td></tr><tr><td>  Y </td><td>  one </td><td>  Sprite </td><td>  Variable </td><td>  Hiram </td><td>  A </td><td></td></tr><tr><td colspan="7"></td></tr><tr><td>  Start of the animation map </td><td>  2 </td><td>  Sprite map </td><td>  Pointer </td><td>  Stack3 </td><td>  DE </td><td></td></tr><tr><td>  Source maps </td><td>  2 </td><td>  Sprite map </td><td>  Pointer </td><td>  [DE] </td><td>  BC </td><td></td></tr><tr><td>  Remaining sprites </td><td>  one </td><td>  Sprite map </td><td>  Scratch </td><td>  Source maps </td><td>  D </td><td></td></tr><tr><td>  OAM buffer </td><td>  one </td><td>  Sprite map </td><td>  Pointer </td><td>  HL </td><td>  HL </td><td>  Stack1 </td></tr><tr><td colspan="7"></td></tr><tr><td>  Start of the animation map </td><td>  2 </td><td>  Animation </td><td>  Workspace </td><td>  BC / Stack3 </td><td>  BC </td><td>  Stack3 </td></tr><tr><td>  Remaining cards </td><td>  one </td><td>  Animation </td><td>  Workspace </td><td>  Start of animation </td><td>  Hiram </td><td></td></tr><tr><td>  Total number of cards </td><td>  one </td><td>  Animania </td><td>  Variable </td><td>  Start of animation </td><td>  Hiram </td><td></td></tr><tr><td>  Direction of the object </td><td>  one </td><td>  Animation </td><td>  Variable </td><td>  Hiram </td><td>  Hiram </td><td></td></tr><tr><td>  Cards per frame </td><td>  one </td><td>  Animation </td><td>  Variable </td><td>  Start of animation </td><td>  NOT USED!!! </td><td></td></tr><tr><td>  Frame number </td><td>  one </td><td>  Animation </td><td>  Variable </td><td>  Hiram </td><td>  A </td><td></td></tr><tr><td>  Map pointer </td><td>  2 </td><td>  Animation </td><td>  Pointer </td><td>  AnimStart + Dir * TMC + MpF * F # </td><td>  BC </td><td>  DE </td></tr><tr><td>  OAM buffer </td><td>  2 </td><td>  Animation </td><td>  Pointer </td><td>  Stack1 </td><td>  HL </td><td></td></tr><tr><td colspan="7"></td></tr><tr><td>  Start animation table </td><td>  2 </td><td>  List of animations </td><td>  Workspace </td><td>  Set hard </td><td>  DE </td><td></td></tr><tr><td>  Object source </td><td>  2 </td><td>  List of animations </td><td>  Pointer </td><td>  HL </td><td>  HL </td><td>  Stack2 </td></tr><tr><td>  Frame number </td><td>  one </td><td>  List of animations </td><td>  Variable </td><td>  Object source </td><td>  Hiram </td><td></td></tr><tr><td>  Animation number </td><td>  one </td><td>  List of animations </td><td>  Workspace </td><td>  Object source </td><td>  A </td><td></td></tr><tr><td>  X object </td><td>  one </td><td>  List of objects </td><td>  Variable </td><td>  Object source </td><td>  Hiram </td><td></td></tr><tr><td>  Y object </td><td>  one </td><td>  List of animations </td><td>  Variable </td><td>  Object source </td><td>  Hiram </td><td></td></tr><tr><td>  Direction of the object </td><td>  one </td><td>  List of animations </td><td>  Variable </td><td>  Obj src </td><td>  Hiram </td><td></td></tr><tr><td>  Start of the animation map </td><td>  2 </td><td>  List of animations </td><td>  Pointer </td><td>  [Anim Table + Anim #] </td><td>  BC </td><td></td></tr><tr><td>  OAM buffer </td><td>  2 </td><td>  List of animations </td><td>  Pointer </td><td>  DE </td><td>  Stack1 </td><td></td></tr><tr><td colspan="7"></td></tr><tr><td>  Object source </td><td>  2 </td><td>  Object cycle </td><td>  Pointer </td><td>  Set hard / stack2 </td><td>  HL </td><td></td></tr><tr><td>  Remaining objects </td><td>  one </td><td>  Object cycle </td><td>  Variable </td><td>  Is calculated </td><td>  B </td><td></td></tr><tr><td>  Active bit field of the object </td><td>  one </td><td>  Object cycle </td><td>  Variable </td><td>  Is calculated </td><td>  C </td><td></td></tr><tr><td>  OAM buffer </td><td>  2 </td><td>  Object cycle </td><td>  Pointer </td><td>  Set hard </td><td>  DE </td><td></td></tr></tbody></table><br>  Yes, very confusing.  To be perfectly honest, I made this table only for the post, in order to explain more clearly, but it has already begun to be useful.  I will try to explain it. We will start from the end and we will get to the very beginning.  You will see every piece of data that I start with: the source of the object, the OAM buffer, and the pre-calculated loop variables.  In each cycle, we begin with this and only this, except that the source of the object is updated in each cycle. <br><br>  For each object that we render, it is necessary to determine the displayed animation.  While we are doing this, you can also save the attributes X, Y, Frame # and Direction, before incrementing the object pointer to the next object and saving them to the stack, to take back on exit.  We use the animation number in conjunction with the hard-coded animation table in the code to determine where the animation map begins.  (I simplify here, implying that each object has the same animation table. This limits me to 256 animations per game, but I can hardly surpass this value.) We can also write the OAM buffer to save several registers. <br><br>  After extracting the animation map, we need to find where the list of sprite maps is for the given frame and direction, as well as how many maps we need to render.  You may notice that the map variable per frame is not used.  It happened because I didn‚Äôt think and set a constant value of 2. I need to fix this.  We also need to extract the OAM buffer from the stack.  You may also notice a complete lack of cycle control.  It is executed in a separate, much simpler sub-procedure, which allows you to get rid of juggling registers. <br><br>  After that, everything becomes quite simple.  The map is a bunch of sprites, so we loop around them and draw them with the saved X and Y coordinates. However, we again save the OAM pointer to the end of the sprite list so that the next map starts where we finished. <br><br>  What was the final result of all this?  Exactly the same as before: waving a tail in the dark by a polar fox.  But adding new animations or sprites is now much easier.  In the next part I will talk about complex backgrounds and parallax scrolling. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19f/cc5/431/19fcc54315854aa3dd7eafcad60c7c38.png" alt="image"></div><br><h2>  Part 4. Parallax Background </h2><br>  Let me remind you that at the current stage we have animated sprites on a solid black background.  If I do not plan to make an arcade game of the 70s, then this is clearly not enough.  I need some kind of background image. <br><br>  In the first part, when I was drawing graphics, I also created several background tiles.  It's time to use them.  We will have three "basic" types of tiles (sky, grass, and earth) and two transitional tiles.  All of them are loaded into VRAM and ready to use.  Now we just have to write them in the background. <br><br><h2>  Background </h2><br>  The backgrounds for the Game Boy are stored in memory in a 32x32 array of 8x8 tiles.  Every 32 bytes correspond to one line of tiles. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d4/f70/972/3d4f70972bfc10421deaf1d18809e4f6.png"></div><br>  While I plan to repeat the same <em>column of</em> tiles in the whole space of 32x32.  This is great, but it creates a small problem: I will need to set <em>each</em> tile 32 times in a row.  Write it will be a long time. <br><br>  Instinctively, I decided to use the REPT command to add 32 bytes / string, and then use memcpy to copy the background in VRAM. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">REPT</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span> db BG_SKY ENDR REPT <span class="hljs-number"><span class="hljs-number">32</span></span> db BG_GRASS ENDR ...</code> </pre> <br>  However, this will mean that you have to allocate 256 bytes for just one background, which is quite a lot.  This problem is exacerbated if we recall that copying a previously created background map with memcpy will not allow adding other types of columns (for example, gates, obstacles) without significant complexity and a heap of wasted ROM cartridge. <br><br>  So instead, I decided to define one column entirely as follows: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">db</span></span> BG_SKY, BG_SKY, BG_SKY, ..., BG_GRASS</code> </pre> <br>  and then use a simple loop to copy each item of this list 32 times.  (See <a href=""><code>—Ñ—É–Ω–∫—Ü–∏—é LoadGFX</code> file of commit 739986a</a> .) <br><br>  The convenience of this approach is that later I can add a queue to write something like this: <br><br><pre> <code class="hljs perl">BGCOL_Field: db BG_SKY, ... BGCOL_LeftGoal: db BG_SKY, ... BGCOL_RightGoal: db BG_SKY, ... ... BGMAP_overview: db <span class="hljs-number"><span class="hljs-number">1</span></span> dw BGCOL_LeftGoal db <span class="hljs-number"><span class="hljs-number">30</span></span> dw BGCOL_Field db <span class="hljs-number"><span class="hljs-number">1</span></span> dw BGCOL_RightGoal db $FF</code> </pre> <br>  If I decide to draw a BGMAP_overview, it will draw 1 LeftGoal column, after which there will be 30 Field columns and 1 RightGoal column.  If <code>BGMAP_overview</code> is in RAM, then I can change it on the fly depending on the camera position in X. <br><br><h2>  Camera and position </h2><br>  Oh yeah, the camera.  This is an important concept that I haven‚Äôt talked about yet.  Here we are dealing with a set of coordinates, so before talking about the camera, we first analyze all this. <br><br>  We need to work with two coordinate systems.  The first is the <em>screen coordinates</em> .  This is a 256x256 area that can be contained in the Game Boy's VRAM console.  We can scroll the visible part of the screen within these 256x256, but when it goes beyond the boundaries, it collapses. <br><br>  The width I need is more than 256 pixels, so I‚Äôll add <em>world coordinates</em> , which in this game will be 65536x256 sized.  (I do not need an extra height for Y, because the game takes place on a flat field.) This system is completely separate from the screen coordinates system.  All physics and collisions should be performed in world coordinates, because otherwise objects will collide with objects on other screens. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56c/557/fd6/56c557fd66ec77707c4083b6f38565f4.png"></div><br>  <i>Comparison of screen and world coordinates</i> <br><br>  Since the positions of all objects are represented in world coordinates, before rendering they need to be converted to screen coordinates.  At the very left edge of the world, world coordinates coincide with screen ones.  If we need to display things on the screen to the right, then we need to take everything in world coordinates and move it to the left so that they are in screen coordinates. <br><br>  To do this, we will set the variable ‚Äúcamera X‚Äù, which is defined as the left edge of the screen in the world.  For example, if <code>camera X</code> is 1000, then we can see the world coordinates of 1000-1192, because the visible screen is 192 pixels wide. <br><br>  To process objects, we simply take their position on X (for example, 1002), subtract the camera position equal to 1000, and draw the object in the position specified by the difference (in our case, 2).  For a background that is <em>not</em> in the world coordinates, but is already described in screen ones, we set the position equal to the lower byte of the variable <code>camera X</code>  Due to this, the background will scroll left and right along with the camera. <br><br><h2>  Parallax </h2><br>  The system we created looks pretty flat.  Each background layer moves at the same speed.  It does not feel three-dimensional, and we need to fix it. <br><br>  A simple way to add 3D simulation is called parallax scrolling (parallax scrolling).  Imagine that you are driving down the road and are very tired.  The Game Boy got batteries, and you have to look out the car window.  If you look at the ground next to you, you will see.  that it is moving at a speed of 70 miles per hour.  However, if you look at the fields in the distance, it will seem that they are moving much slower.  And if you look at very distant mountains, then they seem to barely move. <br><br>  We can simulate this effect with three sheets of paper.  If on one sheet to draw a mountain range, on the second - the field, and on the third - the road, and impose them on each other so.  so that each layer is visible, it will be an imitation of what we see from the car window.  If we want to move the "car" to the left, then we move the topmost sheet (with the road) far to the right, the next one is slightly to the right, and the last one is slightly to the right. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d4d/b52/691/d4db5269121565e6eda63ce5e240d96e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce4/c39/8db/ce4c398dbae155b1da618016c83d440f.png"></div><br>  However, when implementing such a system on a Game Boy, there is a small problem.  The console has only one background layer.  This is analogous to the fact that we have only one sheet of paper.  You cannot create a parallax effect with just one sheet of paper.  Or can it? <br><br><h2>  H-Blank </h2><br>  The Game Boy screen is rendered line by line.  As a result of emulating the behavior of <a href="https://www.youtube.com/watch%3Fv%3DQ8ph2OVqZeM">old CRT TVs,</a> there is a slight delay between each line.  What if we can somehow take advantage of it?  It turns out that Game Boy has a special hardware interrupt specifically for this purpose. <br><br>  Similar to the VBlank interrupt, which we constantly used to wait for the end of the frame to write to VRAM, there is an HBlank interrupt.  By setting bit 6 of the register at <code>$FF41</code> , turning on the <code>LCD STAT</code> interrupt and writing down the line number at <code>$FF45</code> , we can order the Game Boy to start the <code>LCD STAT</code> interrupt when he is going to draw the specified line (and when he is in HBlank). <br><br>  During this time, we can change any VRAM variables.  This is not a <em>lot of</em> time, so we cannot change more than a couple of registers, but we still have some possibilities.  We want to change the horizontal scrolling register at <code>$FF43</code> .  At the same time, everything on the screen below the specified line will move by a certain amount of shift, creating a parallax effect. <br><br>  If you go back to the example of the mountain, you can see a potential problem.  Mountains, clouds and flowers are not flat lines!  We cannot move the selected line up and down during the drawing process;  if we choose it, it remains the same at least until the next HBlank.  That is, we can only cut along straight lines. <br><br>  To solve this problem, we have to get a little smarter.  We can declare any line in the background as a line that nothing can cross, and therefore change the modes of the objects above and below it, and the player will not be able to notice anything.  For example, this is where these lines are in a scene with a mountain. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f3/371/46a/7f337146a97de76d1c7647ec0d0d78db.png"></div><br>  Here I made cuts right above and below the mountain.  Everything from the top to the first line is moving slowly, everything to the second line is moving at an average speed, and everything below this line is moving fast.  This is a simple but clever trick.  And having learned about it, you can notice it in many retro games, mainly for Genesis / Mega Drive, but also on other consoles too.  One of the most obvious examples is the <a href="https://youtu.be/6znkZOa5EBE%3Ft%3D1196">part of the cave</a> from Mickey Mania.  You can see that the stalagmites and stalactites in the background are divided <em>exactly</em> along the horizontal line with an obvious black border between the layers. <br><br>  I implemented the same thing in my background.  However, there is one trick.  Suppose that the foreground moves at one-to-one speed coinciding with the camera movement, and the background speed is one third of the pixel movement of the camera, that is, the background moves as one third of the foreground.  But, of course, a third pixel does not exist.  So I need to move the background by one pixel for every three pixels of motion. <br><br>  If they worked with computers capable of mathematical calculations, they would take the camera position, divide it by 3, and make this value a background offset.  Unfortunately, the Game Boy is not able to perform division, not to mention the fact that software division is a very slow and painful process.  Adding a device for dividing (or multiplying) into a weak CPU for a portable entertainment console in the 80s did not seem to be a cost-effective step, so we will have to invent another way. <br><br>  In the code, I did the following: instead of reading the position of the camera from a variable, I demanded that it increase or decrease.  Thanks to this, with every third increment I can perform the increment of the background position, and with every first increment - the increment of the foreground position.  This complicates scrolling to a position from the other edge of the field a bit (the easiest way is to simply reset the position of the layers after a certain transition), but it saves us from having to divide. <br><br><h2>  Result </h2><br>  After <em>all this,</em> I got the following: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/47d/f64/3a2/47df643a2bd620cf8899b3601162748b.gif"></div><br>  To play the Game Boy, this is actually pretty cool.  As far as I know, not all of them have parallax scrolling implemented as follows. </div><p>Source: <a href="https://habr.com/ru/post/436918/">https://habr.com/ru/post/436918/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>