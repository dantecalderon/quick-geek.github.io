<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>CS 2018 New Year's competition</title>
  <meta name="description" content="Introduction 
 Already in October 2018, we happily remembered the Advent calendar with the tasks of 2017 (conditions here ) and began to think what ca...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>CS 2018 New Year's competition</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  Already in October 2018, we happily remembered the Advent calendar with the tasks of 2017 (conditions <a href="https://yadi.sk/i/XDl3LYEI6xl54A">here</a> ) and began to think what can be done this year.  Of the several worthy ideas, we chose the option in which we would select diverse ‚Äúcatchy‚Äù tasks, combined with a beautiful New Year's story. <br><br>  All that remained was nothing: in fact, pick up tasks, write a story, make a website with a leaderboard, beautiful and tightly knit with Yandex.Contest, and start in early December :-) <br><br><h4>  Result </h4><br>  As you know, appetite comes with eating, and we plunged into the process of working out the content of the tasks and their technical implementation.  Each successful find inspired for further improvements.  As a result, a separate server was raised for one of the tasks, another was optimized (we don‚Äôt have the exact answer), we recorded the music ourselves, restored the distributions ‚Äî we didn‚Äôt get bored at all! <br><br>  The result was: <br><br><ul><li>  <a href="https://yadi.sk/i/37JsO740bKU6dg">11 tasks</a> (+1 bonus) of varying difficulty, all with verification in the Contest; </li><li>  <a href="https://advent.compscicenter.ru/">external site for members</a> ; </li><li>  11 days (from December 7 to December 17 inclusive) to solve problems. </li></ul><br><h4>  Interesting facts and stories </h4><br>  780 participants registered, 333 people started to solve, 203 people successfully passed at least two tasks. <br><br>  Initially, we estimated the net time to solve all problems at seven days for an unprepared participant and at two days for a very experienced (aka fresh graduate of the CS center).  The first Santa Claus assistant, who correctly solved all eleven tasks, did it in about a day, two more coped with the second! <br><br>  A letter from one of the participants: ‚ÄúGood afternoon!  Because of your contest, I stopped the office (40 people) specifically the second task about Santa Claus coffee, give another hint, please.  We are all very tormented. " <br><br><h4>  Analysis of tasks </h4><br><a name="habracut"></a><br>  Conditions <a href="https://yadi.sk/i/37JsO740bKU6dg">here</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Problem D ‚ÄúMusical Message‚Äù (Mikhail Plotkin)</b> <div class="spoiler_text">  It is very easy to solve the problem, having a minimal music education. <br>  An attempt to find a solution in the rhythmic pattern did not lead to success.  The next idea was to sit at the piano and pick up the melody you listened to.  It turned out la, do, mi, si, la, re, salt, mi.  In the treble clef like this: <br><br><img src="https://habrastorage.org/webt/r3/eg/tz/r3egtz3eoe8r2knzpzvipsphaoy.png"><br><br>  After the first three notes there was a small pause, as if dividing the musical phrase into two words.  It only remained to write the notes in the traditional letter notation (A = la, B = si, C = do, D = pe, E = mi, F = fa, G = salt) and two words opened: ACE BADGE. <br><br>  Without any knowledge of musical literacy to solve the problem more difficult.  For example, one could use any sound processing program and find out either the notes themselves or the frequencies of sounds in hertz, and then find which frequencies correspond to which notes. <br><br>  The task required to write the letters together without separators, so the answer is: ACEBADGE. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Problem F "Bag of snowflakes" (Mikhail Plotkin)</b> <div class="spoiler_text">  The area of ‚Äã‚Äãthe original triangle is 1. Next, at the <i>nth</i> step, t_n of triangles are added, each of which has area s_n.  The total area of ‚Äã‚Äãthe resulting figure is expressed as the sum of an infinite series: <br>  S = 1 + Œ£ (t_n * s_n), the sum of <i>n</i> from 0 to ‚àû (1) <br>  At the zero step t_0 = 3, s_0 = 1/9, since the triangle has 3 sides, each of which has a triangle with a side 3 times smaller than the original, and therefore an area 9 times smaller than the area of ‚Äã‚Äãthe original triangle. <br>  At each next step, each side turns into 4 sides, three times smaller, i.e. <br>  t_n = t_ {n-1} * 4 = t_0 * 4n = 3 * 4n, <br>  s_n = s_ {n-1} * (1/9) = s_0 * (1/9) ^ n = 1/9 * (1/9) ^ n. <br><br>  Therefore, the required area: <br>  S = 1 + Œ£ (t_n * s_n) = 1 + 1/3 * Œ£ ((4/9) ^ n), the sum of <i>n</i> from 0 to ‚àû (2) <br><br>  The second term is the sum of an infinitely decreasing geometric progression.  To calculate it, we use the school formula. <br>  Œ£ ((4/9) ^ n) = 1 / (1 - 4/9) = 9/5. <br><br>  Substituting into formula (2), we get the answer: <br>  S = 1 + 1/3 * 9/5 = 8/5 = 1.6 <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Problem G and L ‚ÄúThe route is built‚Äù (Artem Romanov)</b> <div class="spoiler_text">  Thanks to Artem <a href="https://habr.com/ru/users/mehrunesartem/" class="user_link">mehrunesartem</a> for the solution!  By the way, the graph that was used in task G is built on the London Underground scheme :) <br><br>  To solve this problem, we use a modified version of the search in width.  Let's create an imaginary vertex (source), from which we will draw ribs of zero weight at each vertex of the graph.  Each state is uniquely determined by the path from the source.  Additionally, we will store the elapsed time and the resulting joy. <br><br>  Make a priority queue with a fixed size in which we place the states.  As an estimate of the states in the queue, we will use the ratio of the resulting happiness to the elapsed time.  This estimate is not correct, but showed good results in this task. <br>  At each step, we will get the state with the best estimate from the queue and place the states formed from it into the queue.  With this approach, it will take a long time to get the final result. <br><br>  To speed up the decision we will look for an answer in stages.  At each step to find the next vertex in the path, we will clear the queue and place the current state in it.  Then we will do a fixed number of steps, simultaneously updating the state that gives the greatest amount of joy.  As the next vertex of the path, we take the vertex following the last vertex of the current state in the path of the received state giving the greatest amount of joy.  We repeat the done actions as long as we can improve the current state. <br><br>  Possible improvements <br><br><ol><li>  Use the best heuristics. </li><li>  With such an implementation of the algorithm, superfluous states will appear, since at each step we will add all the states that could be obtained from the current one.  To prevent this, you can use the Dijkstra algorithm for each vertex of the graph to construct the shortest path tree to all other vertices and make transitions not in one step, but along the constructed tree until we reach the vertices in which we have never been. </li></ol><br>  These changes did not provide significant improvements, most likely due to the fact that there was only one closed test, and not a group of different generated tests. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Problem I "Bears-digitizers" (Alexander Samofalov)</b> <div class="spoiler_text"> Let's look at the <a href="">source code of the service</a> . <br><br>  A list of all available user IDs can be obtained at <code>/data</code> . <br>  If there is an id, then the data can be obtained using a request to the address <code>/data/id</code> . <br>  To access the data, the service requires a token for authentication.  We have an available <a href="">token</a> , but it has expired, and the service no longer accepts it. <br><br>  Let's see in the code <a href="">how these tokens are generated</a> .  The token is obtained by encrypting JSON like <code>{ ‚ÄúuserId‚Äù : ‚Äúid‚Äù, expireDate: ‚Äúdate‚Äù}</code> and then encoding it to base64.  The service uses RSA for encryption, and the public key can be obtained by requesting the address <code>/key</code> . <br><br>  Let's make a query: e = 30593, n = 66043. Because  n small enough, then we can easily calculate the private key. <br><br>  To do this, decompose n into simple factors: 211 * 313. <br>  Calculate <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F_%25D0%25AD%25D0%25B9%25D0%25BB%25D0%25B5%25D1%2580%25D0%25B0">the Euler function</a> of n: œÜ (n) = (211 - 1) (313 - 1) = 65520. <br>  We obtain d = e-1 (mod œÜ (n)) = 257. <br>  The inverse element of the module can be calculated using the <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2595%25D0%25B2%25D0%25BA%25D0%25BB%25D0%25B8%25D0%25B4%25D0%25B0">advanced Euclidean algorithm</a> . <br><br>  Having calculated the private key, we will decipher the token available to us. <br>  We get the following JSON: <code>{"userId":"448f0a79-e2d8-4ccd-9009-53858914dcaa","expireDate":"2018-12-06T14:38:00.898026+00:00"}</code> <br><br>  Note that the <a href="">service is enough</a> for the user with the given userId to exist and expireDate to be less than the current time on the server. <br>  That is, knowing userId, we can generate a new valid token. <br>  To do this, take expireDate large enough to pass the test ‚Äî for example, <br>  <code>{"userId":"448f0a79-e2d8-4ccd-9009-53858914dcaa","expireDate":"2100-01-01T12:00:00.000000+00:00"}</code> . <br><br>  We encrypt our new token with a public key. <br>  Making a request to <code>/data</code> , we find out that the user has created messages with identifiers from 1 to 4. <br>  Let's go through them all. <br>  Among them is a wonderful phrase: the <b>New Year is knocking on the door, open to him soon!</b>  . <br></div></div><br>  <i>Tips for solving some other problems (by Artem Romanov)</i> <br><br><div class="spoiler">  <b class="spoiler_title">Task A "Safe with letters"</b> <div class="spoiler_text">  You may notice that every twenty steps you get the same figure. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Task B "The Secret of the Professor"</b> <div class="spoiler_text">  Sort the words in descending popularity.  You may notice that each subsequent word occurs at approximately 2, 3, 4, etc.  times less than the most popular word.  Now you can recover the answer. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Task C "Computer Disaster"</b> <div class="spoiler_text">  Think of the programming language Whitespace. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Task J "Bengal"</b> <div class="spoiler_text">  Possible accommodation: <br><img src="https://habrastorage.org/webt/pt/j-/9d/ptj-9djasony25z65dx34eohca0.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Task K "Frosty pattern"</b> <div class="spoiler_text">  To solve this problem, you can choose any convenient triangle, for example, the right one, and calculate the answer for it. <br></div></div><br><h4>  Thanks </h4><br>  The whole process from the idea to the implementation of the drive and coordinated by Katya Lebedeva.  The tasks helped her to compile Katya Artamonova, Alina Mozhina, Sasha Komissarov and me.  Lesha Tolstikov wrote three complex checkers, Sasha Komissarov together with Sergey Zherevchuk made a server, Svyaty and Seyozha selflessly in a short time made a beautiful website with tight integration with tasks: each participant could see his progress and leaderboards. <br></div><p>Source: <a href="https://habr.com/ru/post/438570/">https://habr.com/ru/post/438570/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>