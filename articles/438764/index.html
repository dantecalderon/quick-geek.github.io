<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Chromium Sixth Check, Afterword</title>
  <meta name="description" content="At the beginning of 2018 a series of articles appeared in our blog dedicated to the sixth verification of the source code of the Chromium project. The...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Chromium Sixth Check, Afterword</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e3e/0f3/36b/e3e0f336b600672c601b8849d274d251.png" alt="strict unicorn"></div><br>  At the beginning of 2018 a series of articles appeared in our blog dedicated to the sixth verification of the source code of the Chromium project.  The cycle includes 8 articles on errors and recommendations for their prevention.  Two articles provoked a heated discussion, and until now I have received occasional comments on the topics covered in them.  Perhaps we should give some additional explanations and, as they say, dot the i. <br><a name="habracut"></a><br>  A year has passed since the writing of the series of articles devoted to the next verification of the source code of the Chromium project: <br><br><ol><li>  <a href="https://habr.com/ru/company/pvs-studio/blog/347536/">Chromium: the sixth project check and 250 bugs</a> </li><li>  <a href="https://habr.com/ru/company/pvs-studio/blog/347594/">Beautiful Chromium and gnarled memset</a> </li><li>  <a href="https://habr.com/ru/company/pvs-studio/blog/347668/">break and fallthrough</a> </li><li>  <a href="https://habr.com/ru/company/pvs-studio/blog/347746/">Chromium: memory leaks</a> </li><li>  <a href="https://habr.com/ru/company/pvs-studio/blog/347826/">Chromium typos</a> </li><li>  <a href="https://habr.com/ru/company/pvs-studio/blog/347938/">Chromium: using unreliable data</a> </li><li>  <a href="https://habr.com/ru/company/pvs-studio/blog/348098/">Why is it important to check that the malloc function returned</a> </li><li>  <a href="https://habr.com/ru/company/pvs-studio/blog/348134/">Chromium: other errors</a> </li></ol><br>  <a href="https://habr.com/ru/company/pvs-studio/blog/347594/">Memset</a> and <a href="https://habr.com/ru/company/pvs-studio/blog/348098/">malloc</a> articles provoked and continue to provoke discussions that seem strange to me.  Apparently there was some misunderstanding due to the fact that I did not clearly formulated my thoughts.  I decided to return to these articles and make some clarifications. <br><br><h2>  memset </h2><br>  Let's start with the article about <i>memset</i> , since everything is simple here.  There were disputes about how best to initialize the structure.  Quite a lot of programmers have written that it is better to give a recommendation to write not: <br><br><pre><code class="cpp hljs">HDHITTESTINFO hhti = {};</code> </pre> <br>  And so: <br><br><pre> <code class="cpp hljs">HDHITTESTINFO hhti = { <span class="hljs-number"><span class="hljs-number">0</span></span> };</code> </pre> <br>  Arguments: <br><br><ol><li>  The {0} construct is easier to see when reading a code than {}. </li><li>  The {0} construct is more intuitive than {}.  That is, 0 suggests that the structure is filled with zeros. </li></ol><br>  Accordingly, I am offered to change this example of initialization in the article.  I do not agree with the arguments and do not plan to make changes to the article.  Now I justify my position. <br><br>  About visibility.  I think this is a matter of taste and habit.  I do not think that the presence of 0 inside the curly brackets fundamentally changes the situation. <br><br>  But with the second argument, I do not agree.  Writing the form {0} gives reason to misinterpret the code.  For example, you can calculate that if you replace 0 with 1, all fields will be initialized to ones.  Therefore, this style of writing is more harmful than useful. <br><br>  In the PVS-Studio analyzer, there is even a related diagnosis <a href="https://www.viva64.com/ru/w/v1009/">V1009</a> on this topic, which I will describe now. <br><br>  <b>V1009.</b>  <b>Check the array initialization.</b>  <b>Only the first element is initialized explicitly.</b> <br><br>  The analyzer detected a possible error related to the fact that when declaring an array, a value was specified for only one element.  Thus, the remaining elements will be initialized implicitly by zero or the default constructor. <br><br>  Consider an example of a suspicious code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arr[<span class="hljs-number"><span class="hljs-number">3</span></span>] = {<span class="hljs-number"><span class="hljs-number">1</span></span>};</code> </pre> <br>  Perhaps the programmer expected that <i>arr</i> would consist of one units, but this is not the case.  The array will consist of the values ‚Äã‚Äã1, 0, 0. <br><br>  Correct code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arr[<span class="hljs-number"><span class="hljs-number">3</span></span>] = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>};</code> </pre> <br>  Such confusion may occur due to the similarity with the <i>arr = {0}</i> construct, which initializes the entire array to zero. <br><br>  If in your project such constructions are actively used, you can disable this diagnostics. <br><br>  It is also not recommended to neglect the visibility of the code. <br><br>  For example, the code for coding color values ‚Äã‚Äãis written as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> White[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">0xff</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Black[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">0x00</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Green[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span> };</code> </pre> <br>  Due to the implicit initialization, all colors are set correctly, but it is better to rewrite the code more clearly: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> White[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">0xff</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Black[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Green[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span> };</code> </pre> <br><h2>  malloc </h2><br>  Before reading further, I ask you to refresh the contents of the article ‚Äú <a href="https://habr.com/ru/company/pvs-studio/blog/348098/">Why it is important to check that the malloc function returned</a> ‚Äù.  This article spawned a lot of discussion and criticism.  Here are some of the discussions: <a href="https://www.reddit.com/r/cpp/comments/7uj99c/why_it_is_important_to_check_what_the_malloc/">reddit.com/r/cpp</a> , <a href="https://www.reddit.com/r/C_Programming/comments/7ukaxh/why_it_is_important_to_check_what_the_malloc/">reddit.com/r/C_Programming</a> , <a href="https://habr.com/company/pvs-studio/blog/348098/">habr.com</a> .  Occasionally they write to me about this article in the mail and now. <br><br>  The article is criticized by readers for the following points: <br><br>  <b>1. If</b> <b><i>malloc</i></b> <b>returned</b> <b><i>NULL</i></b> <b>, then it is better to terminate the program immediately than to write a bunch of</b> <b><i>if</i></b> <b>-s and try to somehow handle the lack of memory, which often makes it impossible to execute the program.</b> <br><br>  I didn‚Äôt at all urge to fight the consequences of the lack of memory until recently, by sending the error higher and higher.  If the application is allowed to complete the work without warning, then let it be.  All that is needed is a single check immediately after <i>malloc</i> or using <i>xmalloc</i> (see the next paragraph). <br><br>  I objected and warned about the absence of checks, because of which the program continues to work "as if nothing had happened."  This is completely different.  This is dangerous because it leads to undefined behavior, data corruption, and so on. <br><br>  <b>2. Not told about the solution, which is to write a wrapper function for memory allocation, followed by testing or using existing functions, such as</b> <b><i>xmalloc</i></b> <b>.</b> <br><br>  I agree, I missed this moment.  When writing an article, I just did not think about how to correct the situation.  It was more important for me to convey to the reader what the danger of a lack of verification is.  How to correct a mistake is already a question of taste and implementation details. <br><br>  The <i>xmalloc</i> function <i>is</i> not part of the standard C library (see " <a href="https://stackoverflow.com/questions/7590254/what-is-the-difference-between-xmalloc-and-malloc">What is the difference between xmalloc and malloc?</a> ").  However, this function may be declared in other libraries, for example, in the GNU utils library ( <a href="https://gcc.gnu.org/onlinedocs/libiberty/index.html">GNU libiberty</a> ). <br><br>  The essence of the function is that the program terminates if memory cannot be allocated.  The implementation of this function may look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xmalloc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* p = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!p) { <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"fatal: out of memory (xmalloc(%zu)).\n"</span></span>, s); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(EXIT_FAILURE); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; }</code> </pre> <br>  Accordingly, by calling <i>xmalloc</i> everywhere, instead of <i>malloc,</i> you can be sure that there will be no undefined behavior in the program due to any use of the null pointer. <br><br>  Unfortunately, <i>xmalloc is</i> also not a panacea for all ills.  It must be remembered that the use of <i>xmalloc is</i> unacceptable when it comes to writing code libraries.  I will talk about this later. <br><br>  <b>3. The most comments were of the following form: ‚Äúin practice,</b> <b><i>malloc</i></b> <b>never returns</b> <b><i>NULL</i></b> <b>‚Äù.</b> <br><br>  Fortunately, I am not the only one who understands that this is the wrong approach.  I really liked this <a href="https://habr.com/ru/company/pvs-studio/blog/348098/">comment</a> in my support: <br><br>  <i>From the experience of discussing such a topic, it seems that there are two sects on the Internet.</i>  <i>The adherents of the first are firmly convinced that under Linux, malloc never returns NULL.</i>  <i>The adherents of the second are firmly convinced that if the memory in the program could not be allocated, but nothing can be done in principle, you just need to fall.</i>  <i>It is impossible to convince them in any way.</i>  <i>Especially when these two sects intersect.</i>  <i>One can only take it for granted.</i>  <i>And it doesn‚Äôt matter which core resource the discussion is on.</i> <br><br>  I thought and decided to follow the advice and will not try to persuade :).  Let's hope that these development teams write only non-critical programs.  If, for example, some data gets messed up in the game or the game crashes, it's not scary. <br><br>  The only thing that is important is that the developers of libraries, databases, etc. do not do this. <br><br><h2>  Appeal to the developers of libraries and responsible code </h2><br>  If you are developing a library or other responsible code, then always check the value of the pointer returned by the <i>malloc / realloc</i> function and return the error code to the outside if memory could not be allocated. <br><br>  In libraries, you cannot call the <i>exit</i> function if memory allocation failed.  For the same reason, <i>xmalloc</i> cannot be used.  For many applications, it is unacceptable to just take them and crash them.  Because of this, for example, the database may be corrupted.  Data that has been considered for many hours may be lost.  Because of this, the program may be exposed to the denial of service vulnerabilities, when instead of somehow correctly processing the increasing load, the work of a multi-threaded application simply terminates. <br><br>  It is impossible to assume how and in which projects the library will be used.  Therefore, it should be assumed that the application can solve very important tasks.  And just ‚Äúkill‚Äù him by calling <i>exit</i> , is no good.  Most likely, such a program is written taking into account the possibility of a lack of memory and can do something in this case.  For example, a certain CAD system cannot allocate sufficient memory buffer for the next operation due to severe memory fragmentation.  But this is not a reason for it to end in emergency mode with data loss.  The program can give the opportunity to save the project and restart itself in the normal mode. <br><br>  In no case can one rely on the fact that <i>malloc</i> can always allocate memory.  It is not known on which platform and how the library will be used.  If on one platform the lack of memory is exotic, then on the other it can be a very common situation. <br><br>  You can‚Äôt hope that if <i>malloc</i> returns <i>NULL</i> , the program will crash.  Anything can happen.  As I described in the <a href="https://habr.com/ru/company/pvs-studio/blog/348098/">article</a> , the program can write data not at zero address at all.  As a result, some data may be corrupted, leading to unpredictable consequences.  Even <i>memset is</i> dangerous.  If the data is filled in the reverse order, then at first some data will be corrupted, and only then the program will fall.  But the fall may happen too late.  If at the time of the <i>memset</i> function in parallel streams corrupted data will be used, the consequences can be fatal.  You can get a corrupt transaction in the database or send a command to delete "unnecessary" files.  Anything can happen.  I suggest the reader to fantasize on his own what the use of garbage in memory may lead to. <br><br>  Thus, the library has only one correct way of working with <i>malloc</i> functions.  It is necessary DIRECTLY to check that the function has returned, and if this is NULL, then return the error status. <br><br><h2>  Additional links </h2><br><ol><li>  <a href="https://github.com/gperftools/gperftools/wiki/OOM-handling">OOM handling</a> . </li><li>  Fun with NULL pointers: <a href="https://lwn.net/Articles/342330/">part 1</a> , <a href="https://lwn.net/Articles/342420/">part 2</a> . </li><li>  What Every C Programmer Should Know About Undefined Behavior: <a href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html">part 1</a> , <a href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html">part 2</a> , <a href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_21.html">part 3</a> . </li></ol><br><p> <a href="https://habr.com/ru/company/pvs-studio/blog/438756/"><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br>  If you want to share this article with an English-speaking audience, then please use the link to the translation: Andrey Karpov.  <a href="https://habr.com/ru/company/pvs-studio/blog/438756/">Sixth Chromium Check, Afterword</a> . </div><p>Source: <a href="https://habr.com/ru/post/438764/">https://habr.com/ru/post/438764/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>