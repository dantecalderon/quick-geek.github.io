<div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/re/x9/nq/rex9nqzmrtcwxfesouowufue66q.jpeg"></div><br>  Which <em>needle</em> search method is faster?  Go through a straw, or accidentally look for it? <br><br>  I believe that the best way is to experiment, unfortunately I don’t have haystacks, but there is a basic programming knowledge, an Arduino microcontroller, a convenient environment for writing code, so everyone can repeat. <br><a name="habracut"></a><br><h4>  Step One “Comprehension” </h4><br>  What data do I want to get?  The time spent on finding the right solution.  The only execution does not suit because of the specifics of the experiment, you need to check the method several times, then the time of interest is the average.  Determined with this.  The next step is how many and which variables to declare.  We need a separate variable for each method to store the sum of times, let's call it: <br><br>  “Time_poslMetod” and “Time_randMetod”. <br><br>  Need a constant about the number of iterations: <br><br>  #define Iter 1000 <br><br>  The output value is obtained by dividing the first by the number of iterations. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Iter 10000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> cell 100 uint8_t potenArr[cell]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// СТОГ uint8_t needle = 0; // Иголка uint32_t startTime = 0; // время начала поиска uint32_t endTime = 0; // время завершения поиска uint32_t calculationStartTime = 0; uint32_t calculationEndTime = 0; uint32_t Time_poslMetod = 0; uint32_t Time_randMetod = 0;</span></span></span></span></code> </pre> <br><h4>  Step Two “Write Code” </h4><br>  The For loop will cope with the number of iterations, inside it we will “throw” a <em>needle</em> into a haystack, perform a search, measure the time for each method separately, save time in the “global” (Time_poslMetod / Time_randMetod) variable (for the future). <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Проводим испытания Iter раз for(uint32_t j = 0; j &lt;= Iter; j++){ // Очищаем массив с предыдущим значением cleanArr(); // Бросаем иглу в стог needle = random(cell + 1); potenArr[needle] = 1; // Ищем иглу двумя методами и сохраняем время для каждого poslMetod(); randMetod(); }</span></span></code> </pre><br>  Here are my methods. <br><br>  Serial method: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poslMetod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ startTime = millis(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cell; i++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(potenArr[i] == <span class="hljs-number"><span class="hljs-number">1</span></span>){ endTime = millis() - startTime; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } Time_poslMetod += endTime; }</code> </pre><br>  Before we begin, we memorize the time, in order to subtract it from the time the search was completed.  Run through the array (stack) from the first element to the last.  When we find the <em>needle,</em> we record the time, end the search, add the time to the “global” (Time_poslMetod) variable and exit the method. <br><br>  Random method: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randMetod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ startTime = millis(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;){ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r = random(cell + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(potenArr[r] == <span class="hljs-number"><span class="hljs-number">1</span></span>){ endTime = millis() - startTime; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } Time_randMetod += endTime; }</code> </pre><br>  The difference is that we check the random element of the array (place in the stack), we rely on luck until we are lucky and find the <em>needle</em> , so we use an infinite loop, the main thing is that we have an exit condition, so do not worry.  When we find the <em>needle</em> , we record the time, we complete the search, we add the time to the “global” (Time_randMetod) variable and exit the method. <br><br>  It can be noted that the method does not guarantee us any guarantee that it is faster, it looks even slower in this vein, because if luck is not on our side, we may well make more than 100 checks of the stack locations and fail, while as in the sequential method, 100 checks would have meant that we checked the entire stack and would have accurately found the needle having spent the maximum time for this method.  Still, I'm for the experiment, so let's continue. <br><br>  Putting it all together, polishing the code, making the output convenient for understanding: <br><br><div class="spoiler">  <b class="spoiler_title">Complete code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Iter 10000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> cell 100 uint8_t potenArr[cell]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// СТОГ uint8_t needle = 0; // Иголка, будем присваивать ей случайное значение для номера массива uint32_t startTime = 0; // время начала поиска uint32_t endTime = 0; // время завершения поиска uint32_t calculationStartTime = 0; uint32_t calculationEndTime = 0; uint32_t Time_poslMetod = 0; uint32_t Time_randMetod = 0; void poslMetod(); void randMetod(); void cleanArr(); void DataOutPrint(); void setup() { randomSeed(analogRead(A0)); Serial.begin(115200); } void loop() { Time_poslMetod = 0; Time_randMetod = 0; Serial.println(" "); Serial.println("Start"); calculationStartTime = millis(); // Проводим испытания Iter раз for(uint32_t j = 0; j &lt;= Iter; j++){ // Очищаем массив с предыдущим значением cleanArr(); // Рандомим иглу и кидаем ее в стог needle = random(cell + 1); potenArr[needle] = 1; // Ищем эту иглу двумя способами и сохраняем время для каждого poslMetod(); randMetod(); } // Выводим среднее время для каждого метода DataOutPrint(); delay(2000); } void poslMetod(){ startTime = millis(); for(uint16_t i = 0; i &lt; cell; i++){ if(potenArr[i] == 1){ endTime = millis() - startTime; break; } } Time_poslMetod += endTime; } void randMetod(){ startTime = millis(); for(;;){ uint16_t r = random(cell + 1); if(potenArr[r] == 1){ endTime = millis() - startTime; break; } } Time_randMetod += endTime; } void cleanArr(){ for(uint16_t i = 0; i &lt; cell; i++){ potenArr[i] = 0; } } void DataOutPrint(){ calculationEndTime = (millis() - calculationStartTime)/1000; float OUTposl = (float)Time_poslMetod/Iter; float OUTrand = (float)Time_randMetod/Iter; Serial.println(" "); Serial.print("Number of iterations = "); Serial.println(Iter); Serial.print("Time for calculate (sec) = "); Serial.println(calculationEndTime); Serial.print("Posledovatelniy metod - AverageTime (ms) = "); Serial.println(OUTposl,3); Serial.print("Randomniy metod - AverageTime (ms) = "); Serial.println(OUTrand,3); }</span></span></span></span></code> </pre><br></div></div><br><h4>  Step Three “Analysis of Results” </h4><br>  We get: <br><br><img src="https://habrastorage.org/webt/4q/at/vb/4qatvb61ehgttrqdq4qp0q28lxe.jpeg"><br><br>  Honestly, I'm surprised at the results.  Putting money on the fact that the times will be close, I would have lost. <br><br>  Just what I was afraid of happened, luck turned away from me (us).  That would be to check how things would be if choosing each next cell in a stack, we would not have already checked.  In the meantime, we will keep in mind that studying programming, mathematics, and exact sciences is useful for reducing the time for boring routine operations, leaving time for something fun. </div>