<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We are looking for a needle in a stack without using well-known algorithms.</title>
  <meta name="description" content="Which needle search method is faster? Go through a straw, or accidentally look for it? 

 I believe that the best way is to experiment, unfortunately ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>We are looking for a needle in a stack without using well-known algorithms.</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/re/x9/nq/rex9nqzmrtcwxfesouowufue66q.jpeg"></div><br>  Which <em>needle</em> search method is faster?  Go through a straw, or accidentally look for it? <br><br>  I believe that the best way is to experiment, unfortunately I don‚Äôt have haystacks, but there is a basic programming knowledge, an Arduino microcontroller, a convenient environment for writing code, so everyone can repeat. <br><a name="habracut"></a><br><h4>  Step One ‚ÄúComprehension‚Äù </h4><br>  What data do I want to get?  The time spent on finding the right solution.  The only execution does not suit because of the specifics of the experiment, you need to check the method several times, then the time of interest is the average.  Determined with this.  The next step is how many and which variables to declare.  We need a separate variable for each method to store the sum of times, let's call it: <br><br>  ‚ÄúTime_poslMetod‚Äù and ‚ÄúTime_randMetod‚Äù. <br><br>  Need a constant about the number of iterations: <br><br>  #define Iter 1000 <br><br>  The output value is obtained by dividing the first by the number of iterations. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Iter 10000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> cell 100 uint8_t potenArr[cell]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// –°–¢–û–ì uint8_t needle = 0; // –ò–≥–æ–ª–∫–∞ uint32_t startTime = 0; // –≤—Ä–µ–º—è –Ω–∞—á–∞–ª–∞ –ø–æ–∏—Å–∫–∞ uint32_t endTime = 0; // –≤—Ä–µ–º—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø–æ–∏—Å–∫–∞ uint32_t calculationStartTime = 0; uint32_t calculationEndTime = 0; uint32_t Time_poslMetod = 0; uint32_t Time_randMetod = 0;</span></span></span></span></code> </pre> <br><h4>  Step Two ‚ÄúWrite Code‚Äù </h4><br>  The For loop will cope with the number of iterations, inside it we will ‚Äúthrow‚Äù a <em>needle</em> into a haystack, perform a search, measure the time for each method separately, save time in the ‚Äúglobal‚Äù (Time_poslMetod / Time_randMetod) variable (for the future). <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// –ü—Ä–æ–≤–æ–¥–∏–º –∏—Å–ø—ã—Ç–∞–Ω–∏—è Iter —Ä–∞–∑ for(uint32_t j = 0; j &lt;= Iter; j++){ // –û—á–∏—â–∞–µ–º –º–∞—Å—Å–∏–≤ —Å –ø—Ä–µ–¥—ã–¥—É—â–∏–º –∑–Ω–∞—á–µ–Ω–∏–µ–º cleanArr(); // –ë—Ä–æ—Å–∞–µ–º –∏–≥–ª—É –≤ —Å—Ç–æ–≥ needle = random(cell + 1); potenArr[needle] = 1; // –ò—â–µ–º –∏–≥–ª—É –¥–≤—É–º—è –º–µ—Ç–æ–¥–∞–º–∏ –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤—Ä–µ–º—è –¥–ª—è –∫–∞–∂–¥–æ–≥–æ poslMetod(); randMetod(); }</span></span></code> </pre><br>  Here are my methods. <br><br>  Serial method: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poslMetod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ startTime = millis(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cell; i++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(potenArr[i] == <span class="hljs-number"><span class="hljs-number">1</span></span>){ endTime = millis() - startTime; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } Time_poslMetod += endTime; }</code> </pre><br>  Before we begin, we memorize the time, in order to subtract it from the time the search was completed.  Run through the array (stack) from the first element to the last.  When we find the <em>needle,</em> we record the time, end the search, add the time to the ‚Äúglobal‚Äù (Time_poslMetod) variable and exit the method. <br><br>  Random method: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randMetod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ startTime = millis(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;){ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r = random(cell + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(potenArr[r] == <span class="hljs-number"><span class="hljs-number">1</span></span>){ endTime = millis() - startTime; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } Time_randMetod += endTime; }</code> </pre><br>  The difference is that we check the random element of the array (place in the stack), we rely on luck until we are lucky and find the <em>needle</em> , so we use an infinite loop, the main thing is that we have an exit condition, so do not worry.  When we find the <em>needle</em> , we record the time, we complete the search, we add the time to the ‚Äúglobal‚Äù (Time_randMetod) variable and exit the method. <br><br>  It can be noted that the method does not guarantee us any guarantee that it is faster, it looks even slower in this vein, because if luck is not on our side, we may well make more than 100 checks of the stack locations and fail, while as in the sequential method, 100 checks would have meant that we checked the entire stack and would have accurately found the needle having spent the maximum time for this method.  Still, I'm for the experiment, so let's continue. <br><br>  Putting it all together, polishing the code, making the output convenient for understanding: <br><br><div class="spoiler">  <b class="spoiler_title">Complete code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Iter 10000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> cell 100 uint8_t potenArr[cell]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// –°–¢–û–ì uint8_t needle = 0; // –ò–≥–æ–ª–∫–∞, –±—É–¥–µ–º –ø—Ä–∏—Å–≤–∞–∏–≤–∞—Ç—å –µ–π —Å–ª—É—á–∞–π–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –Ω–æ–º–µ—Ä–∞ –º–∞—Å—Å–∏–≤–∞ uint32_t startTime = 0; // –≤—Ä–µ–º—è –Ω–∞—á–∞–ª–∞ –ø–æ–∏—Å–∫–∞ uint32_t endTime = 0; // –≤—Ä–µ–º—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø–æ–∏—Å–∫–∞ uint32_t calculationStartTime = 0; uint32_t calculationEndTime = 0; uint32_t Time_poslMetod = 0; uint32_t Time_randMetod = 0; void poslMetod(); void randMetod(); void cleanArr(); void DataOutPrint(); void setup() { randomSeed(analogRead(A0)); Serial.begin(115200); } void loop() { Time_poslMetod = 0; Time_randMetod = 0; Serial.println(" "); Serial.println("Start"); calculationStartTime = millis(); // –ü—Ä–æ–≤–æ–¥–∏–º –∏—Å–ø—ã—Ç–∞–Ω–∏—è Iter —Ä–∞–∑ for(uint32_t j = 0; j &lt;= Iter; j++){ // –û—á–∏—â–∞–µ–º –º–∞—Å—Å–∏–≤ —Å –ø—Ä–µ–¥—ã–¥—É—â–∏–º –∑–Ω–∞—á–µ–Ω–∏–µ–º cleanArr(); // –†–∞–Ω–¥–æ–º–∏–º –∏–≥–ª—É –∏ –∫–∏–¥–∞–µ–º –µ–µ –≤ —Å—Ç–æ–≥ needle = random(cell + 1); potenArr[needle] = 1; // –ò—â–µ–º —ç—Ç—É –∏–≥–ª—É –¥–≤—É–º—è —Å–ø–æ—Å–æ–±–∞–º–∏ –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤—Ä–µ–º—è –¥–ª—è –∫–∞–∂–¥–æ–≥–æ poslMetod(); randMetod(); } // –í—ã–≤–æ–¥–∏–º —Å—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –º–µ—Ç–æ–¥–∞ DataOutPrint(); delay(2000); } void poslMetod(){ startTime = millis(); for(uint16_t i = 0; i &lt; cell; i++){ if(potenArr[i] == 1){ endTime = millis() - startTime; break; } } Time_poslMetod += endTime; } void randMetod(){ startTime = millis(); for(;;){ uint16_t r = random(cell + 1); if(potenArr[r] == 1){ endTime = millis() - startTime; break; } } Time_randMetod += endTime; } void cleanArr(){ for(uint16_t i = 0; i &lt; cell; i++){ potenArr[i] = 0; } } void DataOutPrint(){ calculationEndTime = (millis() - calculationStartTime)/1000; float OUTposl = (float)Time_poslMetod/Iter; float OUTrand = (float)Time_randMetod/Iter; Serial.println(" "); Serial.print("Number of iterations = "); Serial.println(Iter); Serial.print("Time for calculate (sec) = "); Serial.println(calculationEndTime); Serial.print("Posledovatelniy metod - AverageTime (ms) = "); Serial.println(OUTposl,3); Serial.print("Randomniy metod - AverageTime (ms) = "); Serial.println(OUTrand,3); }</span></span></span></span></code> </pre><br></div></div><br><h4>  Step Three ‚ÄúAnalysis of Results‚Äù </h4><br>  We get: <br><br><img src="https://habrastorage.org/webt/4q/at/vb/4qatvb61ehgttrqdq4qp0q28lxe.jpeg"><br><br>  Honestly, I'm surprised at the results.  Putting money on the fact that the times will be close, I would have lost. <br><br>  Just what I was afraid of happened, luck turned away from me (us).  That would be to check how things would be if choosing each next cell in a stack, we would not have already checked.  In the meantime, we will keep in mind that studying programming, mathematics, and exact sciences is useful for reducing the time for boring routine operations, leaving time for something fun. </div><p>Source: <a href="https://habr.com/ru/post/439336/">https://habr.com/ru/post/439336/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>