<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The performance of the trading platform on a simple example</title>
  <meta name="description" content="In this article I want to talk in popular science about the optimization of response time in trading platforms of exchanges and banks (HFT). For refer...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>The performance of the trading platform on a simple example</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/ek/hb/e1/ekhbe1j_jv2gufmgexvlsgre-si.png"><br><p>  In this article I want to talk in popular science about the optimization of response time in trading platforms of exchanges and banks (HFT).  For reference, we are talking about times from hundreds of nanoseconds to hundreds of microseconds.  For most other applications, many of the following optimization methods are irrelevant simply due to the absence of such stringent requirements. </p><br><p>  We usually consider performance in units of bandwidth.  For example in Gigaflop.  The optimization task in such cases is reduced to performing the maximum number of calculations per unit time or solving the problem in the shortest time.  The design of the processor is designed primarily to achieve the maximum number of calculations per unit of time and standard optimization techniques for the same. </p><br><p>  However, there are applications where response time is more important, for example, trading platforms in computer trading (HFT), search engines, robotics and telecom.  The response time is the execution time of a ‚Äúsingle‚Äù operation of this type, for example, from receiving a package with current quotes from the exchange to sending an order to an exchange transaction.  In fact, response time and throughput (the number of operations of this type per unit of time) are closely related, but the difference is fundamental.  Increasing the bandwidth can often be done simply by adding hardware (more servers), but it is problematic to improve the response time in this way (except for peak loads). </p><a name="habracut"></a><br><p>  Several different methods are used to optimize response time.  Some improve both response time and throughput, while others improve one at the expense of the other.  For example, to improve throughput, buffering is typical to process an array of packets at a time.  Obviously, for the response time to a single packet, such an approach is harmful. </p><br><p>  In trading platforms, the stability of response time is also very important.  Most of the profits and losses occur during sharp market movements, accompanied by abnormally high activity.  The platform must withstand such loads.  Any plugging can lead to tangible losses. </p><br><p>  In general, such low-level response time optimization is a complex topic that requires a good understanding of the network stack, the operating system kernel, processor and platform performance, and efficient thread synchronization.  My task is to explain all these complex things with a simple and clear example. </p><cut><br><h4>  Office work </h4><br><p>  Let's use the following analogy.  Imagine a group of people working in an office.  Communication takes place through the exchange of messages on paper (letters).  Each letter contains the addressee, the sender and the task.  Letters are placed on certain tables in the office.  There are workers whose task is to receive letters from the outside world and put them on the tables.  Others pick up letters from the tables and pass them on to decision makers.  Each decision maker works only with a certain type of letters (or tasks). </p><br><p>  The decision maker reads the letters intended for him and decides whether the task will be completed, postponed or ignored.  Tasks for execution are added to a separate table.  Special workers pick up letters from this table and distribute them to performers.  Some letters must be answered outside the office, for example, a confirmation will be sent to the external sender. </p><br><p>  To be closer to reality, let's complicate the conditions a little more.  For example, an office is a complex network of rooms and corridors and different types of workers can only go to certain places where they have access.  As the mathematicians say, without breaking the generality, let us assume that our office, under normal conditions, processes 200 messages per day with an average message processing time of 5 minutes. </p><br><p>  So, our task is to minimize the processing time of messages.  It is desirable that the maximum processing time does not exceed the average of more than, say, twice.  That is, bursts of activity must be efficiently handled. </p><br><p>  So where do we start?  The simplest thing is to hire more workers to process more messages.  Not bad to look for fast workers, then the processing time will be reduced.  Suppose we hired Usain Bolt and other Olympic finalists.  Perhaps the processing time decreased to 2 minutes.  But it is obvious that in this direction there is nowhere to go any further.  Faster no one runs.  The limit is reached.  Comparing these approaches with a computer, hiring people is buying additional hardware (servers, processors, cores) to increase the number of execution threads.  Hiring athletes is similar to buying the fastest possible iron (the maximum frequency in the first place). </p><br><p>  Perhaps the layout of our office is not optimal.  Enough space must be provided for workers to work efficiently.  Maybe expand the corridors, and then people have to give way to each other losing precious time?  Let's expand.  Let's also slightly increase the rooms so that people do not crowd at the approach to the tables.  It's like buying a server with a lot of cores and more memory and I / O bandwidth. </p><br><p>  In addition, we can go to the express service instead of regular mail to exchange messages with the outside world.  In computer terms, this is similar to the selection and optimization of network equipment and the network stack of the operating system.  All this is an additional cost, but we will assume that they will definitely pay off. </p><br><p>  So, after the innovations, our message processing time dropped to, say, one minute.  You can still train workers to improve the process of communication and execution.  Perhaps it will give 15 percent with the right motivation.  So we reached 51 seconds.  This is similar to software optimization. </p><br><p>  The next step is to avoid collisions of our fast-running workers.  Probable bottleneck - the approach to the tables.  It is desirable that workers have instant and simultaneous access to the tables they need.  You can sort the messages on the tables when laying out (put in separate folders) to speed up access.  Messages may also have different priority.  In the program it is an analogue of thread synchronization.  Streams should have unlimited parallel and fastest access to data.  Fixing problems with synchronization of threads often gives a huge increase in system bandwidth and helps to improve response time.  In terms of processing bursts of activity, the influence of the optimal synchronization algorithm is generally difficult to overestimate. </p><br><p>  In addition, workers may sometimes find themselves in front of a closed door.  Other minor problems of this property may cause inconvenience and delay.  It is desirable to fulfill the following conditions: the number of people in a given room never exceeds its capacity, the speed of the workers is not limited by anything, no actions that are not related to the main job and no outsider fits into the work process.  In computer terms, this means that the number of threads never exceeds the number of available cores, the platform is configured for maximum frequency / performance, economy modes are disabled, Turbo mode is enabled and the kernel of the operating system and other applications are isolated and (almost) does not affect the trading platform. </p><br><p>  Now it's time to consider even more attentively the conditions in the office.  Do the doors open easily?  Is the floor slipping?  This is about the same as the analysis of interaction with the operating system.  If there is nothing to improve, you can try to avoid using some parts.  For example, instead of sending letters through the office, why not try throwing them from window to window?  Say uncomfortable?  Maybe uncomfortable, but quickly.  This is analogous to using the kernel bypass approach in a network stack. </p><br><p>  Instead of using the operating system's network stack, kernel bypass executes the network stack in user space.  This helps to get rid of unnecessary copies of data between the system and user stack and the delay in executing the message receiving flow.  In kernel bypass, the receive stream usually waits actively.  He does not sit on the operating system lock, but continuously checks the lock variable until it gives him permission to execute. </p><br><p> In fact, if we started throwing messages through the windows, let's do it effectively.  The most reliable option is to pass it through the window from hand to hand.  This principle is used in the TCP protocol.  This is not the fastest option.  UDP allows you to simply throw a message without confirmation.  It's faster.  No waiting is required.  Do you think this is the limit?  No, you can still learn to throw through the window so that the letter falls right on the right table and in the right folder.  This approach is called remote direct memory access (RDMA).  I think we lowered the processing time of seconds to 35. </p><br><p>  Or maybe build an office from scratch instead of adapting the existing one to our needs?  Such that provided ideal working conditions.  Perhaps this will improve the response time of seconds to 20, or even less.  Own office design is the use of the field programmable gate array (FPGA).  FPGA is something like a processor whose hardware is programmed to solve a specific problem.  A conventional processor is encoded to execute a specific set of instructions on certain types of data, and the execution flow (not to be confused with the application flow) is also fixed.  Unlike the processor, FPGAs are not pre-programmed for the instruction set, data types, and execution flow.  They are programmed for a specific task and, in such a state, are capable of executing it only (until subsequent reprogramming).  Effective FPGA programming is not an easy task.  Making changes to the program may also require a lot of effort.  And although the FPGA does not imply the hiring of Usain Bolt (the frequencies are much lower than the processor ones), but the unlimited parallelism in the execution of instructions makes it possible to achieve lower message processing times than on the processor. </p><br><p>  So in conclusion, I will recommend the performance analysis tools for software.  Intel VTune TM Amplifier and Intel Processor Trace technology will help you see in detail where and why CPU time is spent. </p><br><p>  If you are interested in the topic, you can read my articles on the Intel Developer Zone (in English), which also contains practical technical tips to optimize response time. </p><br><ul><li>  https://software.intel.com/en-us/articles/optimizing-computer-applications-for-latency-part-1-configuring-the-hardware </li><li>  https://software.intel.com/en-us/articles/optimizing-computer-applications-for-latency-part-2-tuning-applications </li></ul></cut></div><p>Source: <a href="https://habr.com/ru/post/437626/">https://habr.com/ru/post/437626/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>