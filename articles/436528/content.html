<div class="post__text post__text-html js-mediator-article"> All with the last holidays! <br><br>  After the holidays, we decided to dedicate our first article to Linux, that is, under our wonderful course <a href="https://otus.pw/rEwm/">“Linux Administrator”</a> , which we have included in the cohort of the most dynamic courses, that is, with the most relevant materials and practices.  Well and, accordingly, we offer interesting articles and <a href="https://otus.pw/4xd3/">an open lesson</a> . <br><br>  <i>Article author: Matteo Croce</i> <i><br></i>  <i>Original title: <a href="https://developers.redhat.com/blog/2018/12/03/network-debugging-with-ebpf/">Network debugging with eBPF (RHEL 8 Beta)</a></i> <br><br>  <b>Introduction</b> <br><br>  Working with the network is an exciting experience, but it is not always possible to avoid problems.  Troubleshooting can be tricky, as well as trying to reproduce the wrong behavior that happens “in the field”. <br><br>  Fortunately, there are tools that can help with this: network namespaces, virtual machines, <code>tc</code> and <code>netfilter</code> .  Simple network settings can be reproduced using network namespaces and veth devices, while more complex settings require connecting the virtual machines with a software bridge and using standard network tools, such as <code>iptables</code> or <code>tc</code> , to simulate incorrect behavior.  If there is a problem with ICMP responses generated when the SSH server <code>iptables -A INPUT -p tcp --dport 22 -j REJECT --reject-with icmp-host-unreachable</code> , <code>iptables -A INPUT -p tcp --dport 22 -j REJECT --reject-with icmp-host-unreachable</code> in the correct namespace can help solve the problem. <br><br>  This article describes how to troubleshoot complex network issues with <a href="https://lwn.net/Articles/740157/">eBPF (extended BPF)</a> , an advanced version of Berkeley Packet Filter.  eBPF is a relatively new technology, the project is at an early stage, so the documentation and the SDK are not yet ready.  But let's hope for improvements, especially since XDP (eXpress Data Path) comes with <a href="https://developers.redhat.com/blog/2018/11/15/red-hat-enterprise-linux-8-beta-is-here/">Red Hat Enterprise Linux 8 Beta</a> , which you can download and run right now. <br><br>  eBPF will not solve all the problems, but it is still a powerful tool for network debugging that deserves attention.  I am sure it will play a really important role in the future of networking. <br><br><img src="https://habrastorage.org/webt/qf/la/jo/qflajolwk-bjp2zwjzpnixmqlma.png"><a name="habracut"></a><br><br>  <b>Problem</b> <br><br>  I debugged the <a href="https://developers.redhat.com/blog/tag/open-virtual-network/">Open vSwitch (OVS)</a> network problem, which involved a very complex installation: some TCP packets were scattered and delivered in the wrong order, and virtual machine bandwidth dropped from a stable 6 Gb / s to 2-4 Gb / s fluctuating.  The analysis showed that the first TCP packet of each connection with the PSH flag was sent in the wrong order: only the first and only one per connection. <br><br>  I tried to reproduce this setting with two virtual machines and, after a lot of reference articles and search queries, I found that neither <code>iptables</code> nor <code>nftables</code> could manipulate TCP flags, while <code>tc</code> could, but only overwrite flags and interrupt new connections and TCP generally. <br><br>  It might have been possible to solve the problem using a combination of <code>iptables</code> , <code>conntrack</code> and <code>tc</code> , but I decided that this was a great job for eBPF. <br><br>  <b>What is eBPF?</b> <br><br>  eBPF is an enhanced version of Berkeley Batch Filter.  She brings a lot of improvements to BPF.  In particular, it allows you to write in memory, and not just read, so packages can not only be filtered, but also edited. <br><br>  Often, eBPF is simply called BPF, and BPF itself is called cBPF (classic (classic) BPF), so the word “BPF” can be used to mean both versions, depending on the context: in this article, I always talk about the extended version. <br><br>  “Under the hood” of eBPF is a very simple virtual machine that can run small pieces of bytecode and edit some memory buffers.  EBPF has limitations that protect it from malicious use: <br><br><ul><li>  Cycles are prohibited so that the program always ends at a specific time; </li><li>  It can access memory only through the stack and the scratch buffer; </li><li>  Only authorized kernel functions can be called. </li></ul><br>  The program can be loaded into the kernel in various ways using <a href="http://www.brendangregg.com/ebpf.html">debugging and tracing</a> .  In our case, we are interested in the work of eBPF with network subsystems.  There are two ways to use the eBPF program: <br><br><ul><li>  Connected via XDP to the beginning of the RX path of the physical or virtual network card; </li><li>  Connected via <code>tc</code> to qdisc in the input or output. </li></ul><br>  To create an eBPF program to connect, just write the code in C and convert it to bytecode.  Below is a simple example using XDP: <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">SEC</span></span>("<span class="hljs-selector-tag"><span class="hljs-selector-tag">prog</span></span>") <span class="hljs-selector-tag"><span class="hljs-selector-tag">int</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">xdp_main</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">struct</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">xdp_md</span></span> *<span class="hljs-selector-tag"><span class="hljs-selector-tag">ctx</span></span>) { void *data_end = (void *)(uintptr_t)ctx-&gt;data_end; void *data = (void *)(uintptr_t)ctx-&gt;data; struct ethhdr *eth = data; struct iphdr *iph = (struct iphdr *)(eth + 1); struct icmphdr *icmph = (struct icmphdr *)(iph + 1); <span class="hljs-comment"><span class="hljs-comment">/* sanity check needed by the eBPF verifier */</span></span> if (icmph + 1 &gt; data_end) return XDP_PASS; <span class="hljs-comment"><span class="hljs-comment">/* matched a pong packet */</span></span> if (eth-&gt;h_proto != ntohs(ETH_P_IP) || iph-&gt;protocol != IPPROTO_ICMP || icmph-&gt;type != ICMP_ECHOREPLY) return XDP_PASS; if (iph-&gt;ttl) { <span class="hljs-comment"><span class="hljs-comment">/* save the old TTL to recalculate the checksum */</span></span> uint16_t *ttlproto = (uint16_t *)&amp;iph-&gt;ttl; uint16_t old_ttlproto = *ttlproto; <span class="hljs-comment"><span class="hljs-comment">/* set the TTL to a pseudorandom number 1 &lt; x &lt; TTL */</span></span> iph-&gt;ttl = bpf_get_prandom_u32() % iph-&gt;ttl + 1; <span class="hljs-comment"><span class="hljs-comment">/* recalculate the checksum; otherwise, the IP stack will drop it */</span></span> csum_replace2(&amp;iph-&gt;check, old_ttlproto, *ttlproto); } <span class="hljs-selector-tag"><span class="hljs-selector-tag">return</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">XDP_PASS</span></span>; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">char</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">license</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SEC</span></span>("<span class="hljs-selector-tag"><span class="hljs-selector-tag">license</span></span>") = "<span class="hljs-selector-tag"><span class="hljs-selector-tag">GPL</span></span>";</code> </pre> <br>  The fragment above, without expressions <code>include</code> , helpers, and an optional code, is an XDP program that changes the TTL of the received ICMP echo replies, namely pongs, to a random number.  The main function receives the <code>xdp_md</code> structure, which contains two pointers to the beginning and end of the packet. <br><br>  To compile our code into eBPF bytecode, a compiler with appropriate support is required.  Clang supports it and creates an eBPF bytecode by refining bpf as a target at compile time: <br><br><pre> <code class="bash hljs">$ clang -O2 -target bpf -c xdp_manglepong.c -o xdp_manglepong.o</code> </pre> <br>  The command above creates a file that, at first glance, seems like a regular object file, but upon closer inspection, it turns out that the specified type of computer will be Linux eBPF, and not the native type of operating system: <br><br><pre> <code class="bash hljs">$ readelf -h xdp_manglepong.o ELF Header: Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2<span class="hljs-string"><span class="hljs-string">'s complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: REL (Relocatable file) Machine: Linux BPF &lt;--- HERE [...]</span></span></code> </pre> <br>  Having received the wrapper of a regular object file, the eBPF program is ready to be loaded and connected to the device via XDP.  This can be done using <code>ip</code> from the <code>iproute2</code> package with the following syntax: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ip -force link set dev wlan0 xdp object xdp_manglepong.o verbose</span></span></code> </pre> <br>  This command specifies the target interface wlan0 and, thanks to the -force option, overwrites any existing eBPF code that has already been loaded.  After downloading the eBPF bytecode, the system behaves as follows: <br><br><pre> <code class="bash hljs">$ ping -c10 192.168.85.1 PING 192.168.85.1 (192.168.85.1) 56(84) bytes of data. 64 bytes from 192.168.85.1: icmp_seq=1 ttl=41 time=0.929 ms 64 bytes from 192.168.85.1: icmp_seq=2 ttl=7 time=0.954 ms 64 bytes from 192.168.85.1: icmp_seq=3 ttl=17 time=0.944 ms 64 bytes from 192.168.85.1: icmp_seq=4 ttl=64 time=0.948 ms 64 bytes from 192.168.85.1: icmp_seq=5 ttl=9 time=0.803 ms 64 bytes from 192.168.85.1: icmp_seq=6 ttl=22 time=0.780 ms 64 bytes from 192.168.85.1: icmp_seq=7 ttl=32 time=0.847 ms 64 bytes from 192.168.85.1: icmp_seq=8 ttl=50 time=0.750 ms 64 bytes from 192.168.85.1: icmp_seq=9 ttl=24 time=0.744 ms 64 bytes from 192.168.85.1: icmp_seq=10 ttl=42 time=0.791 ms --- 192.168.85.1 ping statistics --- 10 packets transmitted, 10 received, 0% packet loss, time 125ms rtt min/avg/max/mdev = 0.744/0.849/0.954/0.082 ms</code> </pre> <br>  Each package passes through eBPF, which ultimately makes some changes and decides whether to drop the package or skip. <br><br>  <b>How eBPF can help</b> <br><br>  Returning to the original network problem, we recall that we had to mark several TCP flags, one per connection, and neither <code>iptables</code> nor <code>tc</code> could do this.  Writing code for this scenario is a snap: configure two virtual machines connected by an OVS bridge, and simply connect eBPF to one of the virtual VM devices. <br><br>  This sounds like a great solution, but it’s worth considering that XDP only supports the processing of received packets, and connecting eBPF to the <code>rx</code> path of the receiving virtual machine will not have any effect on the switch. <br><br>  To solve this problem, eBPF must be loaded using <code>tc</code> and connected to the output VM path, because <code>tc</code> can download and connect eBPF programs to qdisk.  To mark packets leaving the host, eBPF must be connected to the output qdisk. <br><br>  When loading an eBPF program, there are some differences between the <code>XDP</code> and <code>tc</code> API: the default is different section names, the type of the structure of the main function argument is different, the return values ​​are different.  But it's not a problem.  Below is a fragment of a program marking TCP when it is attached to a tc action: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RATIO 10 SEC(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"action"</span></span></span><span class="hljs-meta">) int bpf_main(struct __sk_buff *skb) { void *data = (void *)(uintptr_t)skb-&gt;data; void *data_end = (void *)(uintptr_t)skb-&gt;data_end; struct ethhdr *eth = data; struct iphdr *iph = (struct iphdr *)(eth + 1); struct tcphdr *tcphdr = (struct tcphdr *)(iph + 1); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* sanity check needed by the eBPF verifier */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((void *)(tcphdr + 1) &gt; data_end) return TC_ACT_OK; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* skip non-TCP packets */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (eth-&gt;h_proto != __constant_htons(ETH_P_IP) || iph-&gt;protocol != IPPROTO_TCP) return TC_ACT_OK; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* incompatible flags, or PSH already set */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (tcphdr-&gt;syn || tcphdr-&gt;fin || tcphdr-&gt;rst || tcphdr-&gt;psh) return TC_ACT_OK; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (bpf_get_prandom_u32() % RATIO == 0) tcphdr-&gt;psh = 1; return TC_ACT_OK; } char _license[] SEC(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"license"</span></span></span><span class="hljs-meta">) = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"GPL"</span></span></span><span class="hljs-meta">;</span></span></code> </pre> <br>  Compilation into bytecode is done as shown in the XDP example above using the following: <br><br><pre> <code class="bash hljs">clang -O2 -target bpf -c tcp_psh.c -o tcp_psh.o</code> </pre> <br>  But the download is different: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># tc qdisc add dev eth0 clsact # tc filter add dev eth0 egress matchall action bpf object-file tcp_psh.o</span></span></code> </pre> <br>  The eBPF is now loaded in the right place and the packages leaving the VM are marked.  Checking the packets received in the second VM, we will see the following: <br><br><img src="https://habrastorage.org/webt/iz/kd/dq/izkddqprcvumlcgvdxvtzrecbmg.png"><br><br>  <code>tcpdump</code> confirms that the new eBPF code is working, and about 1 out of every 10 TCP packets have the PSH flag set.  Only 20 lines of C code were needed to selectively mark TCP packets leaving a virtual machine, reproduce the error that occurs “in combat”, and all without recompiling or even restarting!  This greatly simplified the verification of the <a href="https://github.com/openvswitch/ovs/commit/9b4f08cdcaf253175edda088683bdd3db9e4c097">Open vSwitch fix</a> , which could not be achieved with the help of other tools. <br><br>  <b>Conclusion</b> <br><br>  eBPF is a fairly new technology, and the community has a clear opinion about its implementation.  It is also worth noting that projects based on eBPF, for example <a href="https://lwn.net/Articles/747551/">bpfilter</a> , are becoming more and more popular, and as a result, many equipment suppliers are beginning to implement eBPF support directly into network cards. <br><br>  eBPF will not solve all the problems, so do not abuse them, but it still remains a very powerful tool for network debugging and deserves attention.  I am sure he will play an important role in the future of networks. <br><br>  <b>THE END</b> <br><br>  We are waiting for your comments here, as well as welcome to visit our <a href="https://otus.pw/4xd3/">open lesson</a> , where, if anything, you can also ask questions. </div>