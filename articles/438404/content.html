<div class="post__text post__text-html js-mediator-article">  The idea that in the development of any more or less complex business logic, priority should be given to the composition of objects, rather than inheritance being popular among software developers of various types.  On the next wave of popularity of the functional programming paradigm, launched by the success of ReactJS, the talk about the benefits of compositional solutions came to the front end.  In this post there are some layouts on the shelves of the theory of the composition of objects in Javascript, a specific example, its analysis and the answer to the question how much semantic elegance costs to the user (spoiler: quite a lot). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f30/874/502/f308745025666d09822337569aad1b1c.jpg" alt="V. Kandinsky - Composition X"><br>  <i>Wassily Kandinsky - "Composition X"</i> <br><a name="habracut"></a><br>  The years of successful development of an object-oriented approach to development, mostly in the academic field, have led to a noticeable imbalance in the mind of the average developer.  Thus, in most cases, the first thought, if necessary, to generalize for a number of diverse entities any behavior is the creation of the parent class and the inheritance of this behavior.  This approach, when abused, leads to several problems that complicate the project and inhibit development. <br><br>  First, the base class overloaded with logic becomes <a href="https://en.wikipedia.org/wiki/Fragile_base_class">fragile</a> — a small change in its methods can fatally affect derived classes.  One way to circumvent this situation is to distribute the logic into several classes, forming a more complex inheritance hierarchy.  In this case, the developer gets another problem - the logic of the parent classes is duplicated in the heirs by necessity, in cases of intersection between the functional of the parent classes, but, importantly, not complete. <br><br> <a href="https://mail.mozilla.org/pipermail/es-discuss/2013-June/031614.html"><img src="https://habrastorage.org/getpro/habr/post_images/fc2/3fa/4ac/fc23fa4ac64d720585bded474be46303.png" alt="image"></a> <br>  <a href="https://mail.mozilla.org/pipermail/es-discuss/2013-June/031614.html">mail.mozilla.org/pipermail/es-discuss/2013-June/031614.html</a> <br><br>  Finally, creating a fairly deep hierarchy, the user, when using any entity, is forced to pull all its ancestors along with all their dependencies, regardless of whether he is going to use their functionality or not.  This problem of over-dependence on the environment has been called the problem of the gorilla and banana by Joe Armstrong, the creator of Erlang: <br><br><blockquote>  I think the languages ​​are not functional languages.  This is why we’re carrying around.  It is a gorilla holding a banana and the entire jungle. </blockquote><br>  To solve all these problems, the composition of objects is intended as an alternative to class inheritance.  The idea is not new, but does not find a complete understanding among the developers.  The situation in the world of frontend is slightly better, where the structure of software projects is often quite simple and does not stimulate the creation of a complex object-oriented relationship scheme.  However, blindly following the precepts of the Gang of Four, recommending that composition be preferred to inheritance, can also play a cruel joke with a great developer inspired by wisdom. <br><br>  Transferring definitions from the “Design Patterns” to the dynamic world of Javascript, you can generally speak of three types of object composition: <b>aggregation</b> , <b>concatenation</b> and <b>delegation</b> .  It should be said that this division and, in general, the concept of an object composition has a purely technical nature, while within the meaning of these terms have intersections, which causes confusion.  For example, class inheritance in Javascript is implemented on the basis of delegation (prototype inheritance).  Therefore, it is better to back up each of the cases with live code samples. <br><br>  <b>Aggregation</b> is an enumerated union of objects, each of which can be obtained using a unique access identifier.  Examples are arrays, trees, graphs.  A good example from the world of web development is the DOM tree.  The main quality of this type of composition and the reason for its creation is the possibility of conveniently applying some handler to each child element of the composition. <br><br>  A synthetic example is an array of objects that in turn define a style for an arbitrary visual element. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> styles = [  { <span class="hljs-attr"><span class="hljs-attr">fontSize</span></span>: <span class="hljs-string"><span class="hljs-string">'12px'</span></span>, <span class="hljs-attr"><span class="hljs-attr">fontFamily</span></span>: <span class="hljs-string"><span class="hljs-string">'Arial'</span></span> },  { <span class="hljs-attr"><span class="hljs-attr">fontFamily</span></span>: <span class="hljs-string"><span class="hljs-string">'Verdana'</span></span>, <span class="hljs-attr"><span class="hljs-attr">fontStyle</span></span>: <span class="hljs-string"><span class="hljs-string">'italic'</span></span>, <span class="hljs-attr"><span class="hljs-attr">fontWeight</span></span>: <span class="hljs-string"><span class="hljs-string">'bold'</span></span> },  { <span class="hljs-attr"><span class="hljs-attr">fontFamily</span></span>: <span class="hljs-string"><span class="hljs-string">'Tahoma'</span></span>, <span class="hljs-attr"><span class="hljs-attr">fontStyle</span></span>: <span class="hljs-string"><span class="hljs-string">'normal'</span></span>} ];</code> </pre> <br>  Each of the style objects can be extracted by its index without losing information.  In addition, using Array.prototype.map () you can handle all stored values ​​in a specified way. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getFontFamily = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> s.fontFamily; styles.map(getFontFamily) <span class="hljs-comment"><span class="hljs-comment">//["Arial","Verdana","Tahoma"]</span></span></code> </pre> <br>  <b>Concatenation</b> involves extending the functionality of an existing object by adding new properties to it.  Thus, for example, state reducer work in Redux.  The data received for updating are recorded in the state object, expanding it.  Data on the current state of the object, in contrast to the aggregation, is lost if it is not saved. <br><br>  Returning to the example, alternately applying the above settings to the visual element, you can form the final result by concatenating the parameters of the objects. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> concatenate = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, s</span></span></span><span class="hljs-function">) =&gt;</span></span> ({…a, …s}); styles.reduce(concatenate, {}) <span class="hljs-comment"><span class="hljs-comment">//{fontSize:"12px",fontFamily:"Tahoma",fontStyle:"normal",fontWeight:"bold"}</span></span></code> </pre> <br>  Values ​​of a more specific style will eventually overwrite previous states. <br><br>  When <b>delegating</b> , as you can easily guess, one object is delegated to another.  Delegates, for example, are prototypes in Javascript.  Instances of heir objects redirect calls to parent methods.  If there is no required property or method in the array instance, it will redirect this call to Array.prototype, and if necessary, further to the Object.prototype.  Thus, the inheritance mechanism in Javascript is built on the basis of the prototype delegation chain, which technically is (surprise) a composition option. <br><br>  The union of an array of style objects through delegation can be done as follows. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> delegate = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(a), b); styles.reduceRight(delegate, {}) <span class="hljs-comment"><span class="hljs-comment">//{"fontSize":"12px","fontFamily":"Arial"} styles.reduceRight(delegate, {}).fontWeight //bold</span></span></code> </pre> <br>  As you can see, the delegate properties are not accessible by enumeration (for example, using Object.keys ()), but are accessible only by explicit reference.  The fact that it gives us - at the end of the post. <br><br>  Now to the specifics.  A good example of a case that encourages a developer to use composition instead of inheritance is in Michael <a href="https://medium.com/code-monkey/object-composition-in-javascript-2f9b9077b5e6">Object</a> ’s <a href="https://medium.com/code-monkey/object-composition-in-javascript-2f9b9077b5e6">Object Composition in Javascript</a> .  Here the author considers the process of creating a hierarchy of role-playing characters.  Initially, two types of characters are required - a warrior and a magician, each of which has a certain amount of health and has a name.  These properties are common and can be moved to the Character class of the parent. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Character</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.health = <span class="hljs-number"><span class="hljs-number">100</span></span>; } }</code> </pre> <br>  The warrior is distinguished by the fact that he is able to strike, while spending his endurance, and the magician - the ability to cast spells, reducing the amount of mana. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fighter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Character</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(name); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.stamina = <span class="hljs-number"><span class="hljs-number">100</span></span>; } fight() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.name}</span></span></span><span class="hljs-string"> takes a mighty swing!`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.stamina -  ; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Character</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(name); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mana = <span class="hljs-number"><span class="hljs-number">100</span></span>; } cast() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.name}</span></span></span><span class="hljs-string"> casts a fireball!`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mana -  ; } }</code> </pre> <br>  Having created the classes Fighter and Mage, the heirs of Character, the developer faces an unexpected problem when the need arises to create the Paladin class.  The new character is distinguished by an enviable ability to both fight and conjure.  Offhand, I see a couple of solutions that differ in the same lack of grace. <br><br><ol><li>  You can make Paladin the heir of Character and implement both the methods of fight () and cast () in it from scratch.  In this case, the DRY principle is grossly violated, because each of the methods will be duplicated during creation and will subsequently need constant synchronization with the methods of the Mage and Fighter classes to track changes. </li><li>  The fight () and cast () methods can be implemented at the level of the Charater class so that all three types of characters have them.  This is a slightly more pleasant solution, but in this case, the developer must override the fight () method for the mage and the cast () method for the warrior, replacing them with empty plugs. </li></ol><br>  In any of the options, sooner or later you have to face the problems of inheritance, voiced at the beginning of the post.  They can be solved with a functional approach to the implementation of the characters.  It is enough to push off not from their types, but from their functions.  In the end, we have two key features that determine the abilities of the characters - the ability to fight and the ability to conjure.  These features can be set using factory functions that extend the state that defines the character (an example of composition is concatenation). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> canCast = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">cast</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">spell</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${state.name}</span></span></span><span class="hljs-string"> casts </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${spell}</span></span></span><span class="hljs-string">!`</span></span>); state.mana -  ; } }) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> canFight = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">fight</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${state.name}</span></span></span><span class="hljs-string"> slashes at the foe!`</span></span>); state.stamina -  ; } })</code> </pre> <br>  Thus, a character is determined by a set of these features, and initial properties, both general (by name and health), and private (endurance and mana). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fighter = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = { name, <span class="hljs-attr"><span class="hljs-attr">health</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">stamina</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(state, canFight(state)); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mage = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = { name, <span class="hljs-attr"><span class="hljs-attr">health</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">mana</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(state, canCast(state)); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> paladin = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = { name, <span class="hljs-attr"><span class="hljs-attr">health</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">mana</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">stamina</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(state, canCast(state), canFight(state)); }</code> </pre> <br>  Everything is beautiful - the action code is reused; you can easily add any new character without touching the previous ones and without inflating the functionality of any one object.  To find a fly in the proposed solution, it suffices to compare the performance of the solution based on inheritance (read delegation) and decisions based on concatenation.  Let's create a million army of copies of the created characters. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> inheritanceArmy = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000000</span></span>; i++) { inheritanceArmy.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Fighter(<span class="hljs-string"><span class="hljs-string">'Fighter'</span></span> + i)); inheritanceArmy.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mage(<span class="hljs-string"><span class="hljs-string">'Mage'</span></span> + i)); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> compositionArmy = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000000</span></span>; i++) { compositionArmy.push(fighter(<span class="hljs-string"><span class="hljs-string">'Fighter'</span></span> + i)); compositionArmy.push(mage(<span class="hljs-string"><span class="hljs-string">'Mage'</span></span> + i)); }</code> </pre> <br>  And we compare the costs of memory and computation between inheritance and composition, which are necessary for creating objects. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/158/509/b8f/158509b8fb1d5dc214b2728f72145565.png" alt="image"><br><br>  On average, a solution using composition by concatenation requires 100–150% more resources.  The presented results were obtained in the NodeJS environment; you can see the results for the browser engine by running this <a href="https%253A%252F%252Fjsbench.me%252Fbejrj7ec0w">test</a> . <br><br>  The advantage of the solution based on inheritance-delegation can be explained by saving memory due to the lack of implicit access to the delegate properties, as well as disabling some engine optimizations for dynamic delegates.  In turn, a concatenation based solution uses the very expensive Object.assign () method, which strongly affects its performance.  Interestingly, Firefox Quantum shows diametrically opposed Chromium results - the second solution works much faster in Gecko. <br><br>  Of course, it is worth relying on the results of performance tests only when solving quite laborious tasks associated with creating a large number of complex infrastructure objects — for example, when working with a virtual element tree or developing a graphic library.  In most cases, the structural beauty of the solution, its reliability and simplicity are more important, and a small difference in performance does not play a big role (operations with DOM elements will take much more resources). <br><br>  In conclusion, it is worth noting that the types of composition considered are not the only and mutually exclusive.  Delegation can be implemented using aggregation, and class inheritance using delegation (as is done in JavaScript).  In essence, any combination of objects will be one form or another of the composition, and ultimately only the simplicity and flexibility of the resulting solution is important. </div>