<div class="post__text post__text-html js-mediator-article">  Good day to all! <br><br>  Next week, the next <a href="https://otus.pw/GHFW/">Linux Administrator</a> group will start, and therefore we held a number of events.  One of them is an open lesson on SSH / NC / Socat: tips &amp; tricks.  On it we remembered what ssh is, its history and purpose.  We considered various options for its use: remote, local port forwarding, secure copy, socks proxy, reverse proxy.  We actually tried the nc and socat utilities in the virtual lab. <br><br>  The webinar was conducted by an experienced system administrator <a href="https://otus.pw/Ztsa/">Vladimir Drozdetsky</a> - infrastructure developer letundra.com, exposcan.ru, crispmessenger.com. <br><br>  We offer you a detailed description of the past event. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/n7jxFK9SMsk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>  <b>Remember what SSH is</b> <br><br>  SSH (English Secure Shell) is a “secure shell”, an application layer network protocol.  It allows you to remotely control the operating system and perform tunneling of TCP connections (for example, for transferring files).  SSH is similar in functionality to the Telnet and rlogin protocols, but it differs from them because it encrypts all traffic, including passwords that are transmitted.  The SSH-2 protocol specification is contained in RFC 4251. <br><br>  Let's look at the various options for using SSH, both standard and non-standard.  The following stand will help us with this: <br><br><img src="https://habrastorage.org/webt/mi/d9/2a/mid92ankvqf8pgggjz7orphgps4.png"><br><br>  The stand presents four virtual machines that are located behind the firewall.  All actions will be performed with the machine Node-1. <br><br>  <b>Creating an SSH key</b> <b><br></b> <br>  In order to use an SSH key, you must first create it.  For this, a special utility that is absolutely in any Linux distribution is suitable: <br><br><pre><code class="plaintext hljs">ssh-keygen -t RSA -N otuslinux -f ~/.ssh/otus</code> </pre> <br><ul><li>  -t - which encryption algorithm to use; </li><li>  -N - encryption key (convenient argument, if you need to create a key without encrypting and responding to various ssh-keygen requests); </li><li>  -f - in which file to save the key. </li></ul><br>  <b>SSH-ssh-server settings</b> <br><br>  For further work, you will need to edit the / etc / ssh / sshd_config file and restart the ssh server.  Here you should pay attention to the following options: <br><br>  <code>RSAAuthentication yes</code> (is RSA authentication allowed); <br>  <code>PubkeyAuthentication yes</code> (is key authentication allowed); <br>  <code>AuthorizedKeysFile %h/.ssh/authorized_keys</code> (the path to the public part of the key); <br>  <code>PasswordAuthentication yes</code> (whether authentication is allowed). <br><br>  To copy the key to the server, proceed as follows: <br><br>  <code>ssh-copy-id -i /path/to/pub/key user@server</code> (copy the public part of the key to the remote server, the public key will be copied on the way to the% h / .ssh / authorized_keys file) <br><br>  In order to avoid connecting the encryption key again every time when connecting to a remote server, we can use ssh-agent.  For this: <br><br>  <code>eval $(ssh-agent -s)</code> (eval is part of POSIX. Its interface can also be a shell. The key in the agent will be stored in decrypted form). <br><br>  <code>ssh-add ~/.ssh/our_private_key</code> (Add a private key). <br><br>  In this case: <br><br><ul><li>  -i - specify the location of the public key; </li><li>  user - username on the remote server; </li><li>  server - the target server's ip or dns. </li></ul><br>  For ease of connecting to a remote server, we can describe the connection parameters in the ssh config file, which is located along the path ~ / .ssh / config <br><br>  Thus, we get the following SSH config file: <br><br><pre> <code class="bash hljs">Host myserver HostName ip/hostname Port 22/??? User username IdentityFile ~/.ssh/id_rsa</code> </pre> <br>  Everything is simple here: <br><br><ul><li>  Host is the name of our connection; </li><li>  HostName - server name; </li><li>  Port - ssh port </li><li>  User - username; </li><li>  IdentityFile - ssh-key. </li></ul><br>  <b>SSH SCP</b> <br><br>  Go ahead.  The easiest way to use SSH is to copy a file from one machine to a remote one.  For this we use the SCP (Secure Copy Protocol) utility.  With its help, you can copy a directory or file from a local server to a remote server, and vice versa: <br><br>  <code>scp test.txt username@server:/some/directory</code> (Copying a file from a local server to a remote server). <br>  <code>scp username@server:test.txt /some/directory</code> (Copying a file from a remote server to a local server). <br>  <code>scp -r dir_name username@server:/some/directory</code> (Copying a folder from a local server to a remote one). <br><br>  Here: <br><br><ul><li>  username - username; </li><li>  server - server address; </li><li>  / some / server - directory where you copy; </li><li>  dir_name - folder name; </li><li>  -r - use recursively. </li></ul><br>  <b>Ssh tunnel proxy</b> <br><br>  Now let's consider an option how to forward a port to a local machine from a remote one.  Take for example the classic case, that is, a bunch, when we have an “evil security agent” and one server with a web application, the ssh and https port is watching the world, and we really want to connect to the MySQL server. <br><br>  So: <br><br>  <code>ssh -f -N -L 9906:127.0.0.1:3306 user@server</code> (Just our case with MySQL) <br><br>  As a result, we can connect to the local port 9906 using the mysql client and get to our “secret” server. <br><br>  <code>ssh -D 8080 -q -C -N -f servername</code> (Proxy traffic through SOCKS through port 8080) <br><br>  With this command we create socks5 proxy server using ssh.  To check its performance, we can use the following command: <br><br><pre> <code class="plaintext hljs">curl -x socks5h://server-with-proxy:8080 https://test.domain</code> </pre><br>  A classic example of port forwarding with ssh is when the server to which you want to connect is located behind naty.  The following command will help us connect to this server: <br><br>  <code>ssh -f -N -R 2255:localhost:22 username@servername</code> (forwarding from remote server to local). <br><br>  On the remote server will open port 2255, which will be redirected to port 22 of our server for natom.  To connect to such a server, we can use the command: <br><br><pre> <code class="plaintext hljs">ssh -p 2255 username@localhost</code> </pre><br>  Note that: <br><br><ul><li>  -f - send ssh to background; </li><li>  -N - do not execute the command on the remote host; </li><li>  -L - forwarding of the local port (local port: local machine: remote port); </li><li>  -R - port on the remote machine; </li><li>  -q - silent mode; </li><li>  -D - defines the local dynamic routing of application-level ports; </li><li>  -C - request for data compression. </li></ul><br>  <b>Netcat (nc)</b> <br><br>  Our next stop is Netcat, a Unix utility that allows you to establish TCP and UDP connections, receive data from there and transfer them.  Despite its usefulness and simplicity, this utility is not included in any standard and is not supplied as part of any distribution.  Accordingly, it is necessary to install it by hand. <br><br>  One of the interesting features of Netcat (nc) is the ability to scan ports: <br><br>  <code>nc -vn ipaddress 22</code> (single port scan); <br>  <code>nc -v ipaddress 10-55</code> (port range scan); <br>  <code>nc -l 4444</code> (open and listen to port 4444); <br>  <code>nc servername 4444</code> (connect to the server on the desired port). <br><br>  After opening the port and connecting to it, we get a small network chat =). <br><br>  Next, we consider the possibility of transferring files using the nc utility.  For this we will be helped by the following command: <br><br> <code>cat test_file | pv -b | nc -l 4444</code>  <code>cat test_file | pv -b | nc -l 4444</code> (open the port and transfer the file to it through the pipe, the pv utility with the -b option is used to display the progress of the file transfer in bytes). <br><br> <code>nc servername 4444 | pv -b &gt; filename</code>  <code>nc servername 4444 | pv -b &gt; filename</code> (connect to the server to get the file, pv -b is used in the same way). <br><br>  We can complicate our pipe by adding file archiving on the fly: <br><br> <code>tar -czf - /path/to/ | pv -b | nc -l 4444</code>  <code>tar -czf - /path/to/ | pv -b | nc -l 4444</code> (archiving folders on the fly and sending); <br>  n <code>c servername 4444 | pv -b &gt; file.tar.gz</code>  <code>c servername 4444 | pv -b &gt; file.tar.gz</code> (receive archive sent). <br><br>  A not very obvious nc feature is the creation of just an http server. <br><br><pre> <code class="plaintext hljs">while true; do nc -lp 80 &lt; index.html; done</code> </pre> <br>  Please note that in order to use port 80, you must have root-rights. <br><br>  Also note that: <br><br><ul><li>  -l - specify the listen mode; </li><li>  -n - do not use DNS queries; </li><li>  -v - verbose output. </li></ul><br>  <b>Socat</b> <br><br>  It is also a useful utility that allows you to establish TCP connections between machines, redirect ports, etc. It works on the principle of Netcat: it opens two bidirectional connections, can transmit data, streams, etc. However, it has one interesting feature.  For example, with the help of Socat we can map COM ports to TCP ports, etc. <br><br>  Examples of Socat work: <br><br>  <code>socat -u FILE:file_name TCP-LISTEN:5778,reuseaddr</code> # send file; <br> <code>socat -u TCP:192.168.1.48:5778 STDOUT | pv -r &gt; file_name</code>  <code>socat -u TCP:192.168.1.48:5778 STDOUT | pv -r &gt; file_name</code> # get file; <br>  <code>socat TCP-LISTEN:80,fork TCP:ubuntunode-4:80</code> # redirecting the port of the remote server to the local port; <br>  <code>socat TCP-LISTEN:1234,reuseaddr EXEC:/bin/bash</code> # Open remote shell =); <br>  <code>socat - TCP:server_with_remote_shell:1234</code> # Connect to the remote shell of the remote server. <br><br>  Small transcript: <br><br><ul><li>  -u - use unidirectional mode; </li><li>  FILE - indicate that we use the file; </li><li>  TCP-LISTEN - we listen to tcp-port; </li><li>  reuseaddr - allows other sockets to communicate with the same address, even if it is used; </li><li>  fork - after the connection is established, the channel is processed in the child process; </li><li>  TCP is a type of connection. </li></ul><br>  <b>Should I watch the video version now?</b> <br><br>  Of course, yes, because in the description everything is presented thesis.  In addition, in the webinar topics are disclosed in more detail, plus for some of them additional examples and implementation options are given.  Thus, if you are interested in this topic, look at the open lesson in full and repeat all the steps following <a href="https://otus.pw/Ztsa/">Vladimir Drozdetsky</a> for maximum mastering of the material.  And do not forget to leave your comments. <br><br>  We, in turn, do not say goodbye and invite you to the course <a href="https://otus.pw/95WC/">"Linux Administrator"</a> ! </div>