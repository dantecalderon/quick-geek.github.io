<div class="post__text post__text-html js-mediator-article">  Greetings  I want to show you one of the ways how to realize the free movement of particles in the specified range.  To accomplish this task I will use ReactJS.  But the algorithm itself will still be common, and you can use it anywhere. <br><br><img src="https://habrastorage.org/webt/zd/pv/v-/zdpvv-bnd2890swktobga8c1fyi.png" alt="image"><br><a name="habracut"></a><br>  At the end of the article, we will create <a href="https://codepen.io/vital-pavlenko/pen/wNRMvp">such a thing</a> with you. <br><br><h2>  Wrong way </h2><br>  The first thing that comes to mind to solve this problem is simply random X and Y. Let's see what happens. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/vital-pavlenko/embed/preview/WPLJrz" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Here we just randomly shift every second between -50 to 50 in X and Y: <br><br><pre><code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() * <span class="hljs-number"><span class="hljs-number">100</span></span> - <span class="hljs-number"><span class="hljs-number">50</span></span></code> </pre> <br>  A smooth transition is carried out using the transition properties of css: <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">transition</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">transform</span></span> 1<span class="hljs-selector-tag"><span class="hljs-selector-tag">s</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">linear</span></span>;</code> </pre> <br>  As you can see - it turned out not quite what we wanted.  Of course, you can configure it so that the shift is added to an existing position, then it will be more like the truth.  But still we need to go a little bit on the other side. <br><br><h2>  The right way </h2><br>  The previous method seems so curved for several reasons: <br><br><ol><li>  In reality, a particle cannot change its direction so drastically. </li><li>  A particle for each period of time must pass a certain distance </li></ol><br>  And this suggests that randomization requires exactly the direction in which the particle will move, and in a certain range of degrees, so that there are no sharp turns.  So we will solve the first problem. <br><br>  And to solve the second problem, we will indicate in advance the step to which the particle should be moved during the time interval. <br><br>  Now we have to remember the basic course of trigonometry.  We know the length <code>l</code> and the angle <code>deg</code> .  Need to find <code>X</code> and <code>Y</code> <br><br><img src="https://habrastorage.org/webt/pm/1r/f3/pm1rf3lr2pugqoys9m-ualevk78.png" alt="image"><br><br><blockquote>  <i><b>sin</b> is the ratio of the opposite side to the hypotenuse.</i> <br>  <i><b>cos</b> is the ratio of the adjacent side to the hypotenuse.</i> <br></blockquote><br>  We get the following formulas for calculation: <br><br><pre> <code class="javascript hljs">x = cos(deg) * l y = sin(deg) * l</code> </pre><br>  But there is one thing.  In javaScript <code>Math.sin</code> takes an angle in radians (a <i>value from -1 to 1</i> ).  Therefore, before forwarding an angle, you must first convert it to radians. <br><br><pre> <code class="javascript hljs">deg(рад) = deg(гр) * Pi / <span class="hljs-number"><span class="hljs-number">180</span></span></code> </pre> <br>  We write a function that will receive an angle at the input, and the distance to which the particle should be moved.  And the function will return the object <code>{ x, y }</code> with our values ​​for the shift. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getShift</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">deg, step</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: +(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.cos(deg * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI / <span class="hljs-number"><span class="hljs-number">180</span></span>) * step).toFixed(), <span class="hljs-attr"><span class="hljs-attr">y</span></span>: +(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sin(deg * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI / <span class="hljs-number"><span class="hljs-number">180</span></span>) * step).toFixed(), }; };</code> </pre><br>  Let's test what our function will output.  Suppose we move a particle by <code>10px</code> each time.  Let's see what <code>getShift</code> returns for different angles. <br><br><img src="https://habrastorage.org/webt/vo/uf/pp/voufppqrdsvi9nacugdsrfa-y4a.png" alt="image"><br><br><pre> <code class="javascript hljs">getShift(<span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-comment"><span class="hljs-comment">// {x: 9, y: 5} getShift(90, 10); // {x: 0, y: 10} getShift(135, 10); // {x: -7, y: 7} getShift(210, 10); // {x: -9, y: -5} getShift(-30, 10); // {x: 9, y: -5}</span></span></code> </pre><br>  Well, it seems to be true, do you agree? <br><br>  Now let's try to fix our first written application. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/vital-pavlenko/embed/preview/Odroqw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Already not bad!  It remains to implement the framework for which the particle can not fly.  Since now most likely after some time the blue circle will fly off the screen. <br><br>  In order to make the framework, you will need to add a new constant.  And also add one condition.  Here we have a while loop.  If there is a limit on the way, then we will turn the corner until we turn it away from the frame. <br><br>  For clarity, add a yellow square, beyond which the circle can not fly.  Here's what happened: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/vital-pavlenko/embed/preview/xMmJNo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Our algorithm is completely ready to use.  The next step is the implementation of this algorithm on ReactJS using its capabilities. <br><br><h3>  We transfer the algorithm to ReactJS </h3><br>  When transferring our application to ReactJS, we will set the following tasks: <br><br><ol><li>  Create a <code>MovingPart</code> wrapper <code>MovingPart</code> in which you can throw anything. </li><li>  In the state we will store the values ​​X and Y, since only they are needed to redraw the component. </li><li>  Outside, in a component we will prokidyvat interval, the border for which it is impossible to go and the step to which the element will move in one time interval. </li><li>  Let's draw a little beautiful with several components of <code>MovingPart</code> , in order to roughly imagine where this can be applied in real life. </li></ol><br>  As a result, we get the following example: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/vital-pavlenko/embed/preview/wNRMvp" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Initial data will be taken from the <code>data</code> array. <br><br>  After that we describe the component <code>MovingPart</code> : <br><br><ul><li>  <b>The interval (interval), distance (distance) and shift in one step (step) are</b> obtained from outside of props; </li><li>  <b>The maximum rotation during movement (maxRotate) and the current angle of displacement (deg) are</b> determined inside the element; </li><li>  <b>The x and y values ​​are</b> moved to the component state; </li><li>  <b>The getShift method is</b> defined as the internal method of the component. </li></ul><br>  After that, using the cycle of the <code>map</code> render all the elements, wrapping them with our created component <code>MovingPart</code> . <br><br>  Thanks for attention!  This was my first article on Habré, I hope it will be useful.  Try, experiment. </div>