<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Neutralinojs - what are you? Or UNIX way, where they did not expect</title>
  <meta name="description" content="Recently, I accidentally stumbled upon a simple advertising note "Neutralinojs - an alternative to Electron, which consumes less memory" , telling tha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Neutralinojs - what are you? Or UNIX way, where they did not expect</h1><div class="post__text post__text-html js-mediator-article"><p>  Recently, I accidentally stumbled upon a simple <a href="https://habr.com/ru/post/438130/">advertising note "Neutralinojs - an alternative to Electron, which consumes less memory"</a> , telling that there is such a cool thing as Neutralinojs.  The note, as it should be, is very short and does not carry any useful information, except for the advertising slogan "Better than &lt;something popular&gt;!" </p><br><p>  Roughly understanding how Electron and NW.js work and not finding absolutely no mention of the principle of operation of this new and super-cool "miracle beast" in the article, I began research. </p><br><p>  Actually presenting the results of my micro-research! </p><br><p> <a href="https://habr.com/ru/post/438402/"><img src="https://habrastorage.org/webt/6g/7z/se/6g7zserouh1jwnx-tk30di9mbou.png"></a> </p><br><p>  Since I consider any new technology as a possible tool, I immediately asked a few questions: </p><br><ul><li>  Why does it eat at times less memory? </li><li>  What gives more buns? </li><li>  Why should I use this miracle? </li></ul><br><h1 id="pochemu-ne-zhryom-pamyat">  Why don't we eat memory? </h1><br><p>  Having rummaged in source codes and two rather informative pictures about architecture, I understood that this project works exactly according to the very UNIX Way, which is loved by all Linux users.  The project's philosophy is simple: why invent a new bicycle if you can use it already ready? </p><a name="habracut"></a><br><p>  What are the disadvantages of Electron: </p><br><ul><li>  We carry with Chrome </li><li>  We carry with us Node.js </li><li>  We drag a layer with us so that the two previous ones work together </li></ul><br><p>  Instead, everything is done like this: </p><br><ul><li>  We <strong>don't</strong> drag chrome </li><li>  We <strong>do not</strong> drag Node.js </li><li>  We only drag a layer between <em>some kind of</em> browser and <em>some kind of</em> OS. </li></ul><br><p>  Let's see how exactly this is implemented. </p><br><h2 id="arhitektura">  Architecture </h2><br><p><img src="https://habrastorage.org/webt/m7/eu/b1/m7eub1eezyf_o_3jio79jibwgfo.png"></p><br><p>  The whole project consists of 2 parts: server and client. </p><br><p>  <strong>The server</strong> starts immediately and is a real partisan in the rear of the OS.  He can store data, open files, write to files, run <del>  cryptors </del>  shell commands  Actually, it does everything that can be needed, provides an API for the operating system and communicates via HTTP with the <em>client</em> .  He also gives the client everything he needs to display on the screen.  Pretty standard server functionality. </p><br><p>  For each operating system, a C ++ server was forked and modified by a file.  Under the Mac have not yet found that the fork, so there is no support. </p><br><p>  <strong>Customers</strong> can be 3 types: </p><br><ul><li> <code>cloud</code> - Any program that knows the port on which the server is running can execute commands. </li><li>  <code>browser</code> - The server itself starts the process of a standard system browser with the required URL.  Here the server requires a special TOKEN, which itself inserts into the rendered HTML pages. </li><li>  <code>window</code> - The server starts a special render process that simply displays the system WebView.  Here you also need a token </li></ul><br><p>  Here it should be noted that the server can work simultaneously with only one type of client, and you need to specify the type of client in the config using the <code>mode</code> field. </p><br><p>  As you can see, nothing superfluous.  By itself, the application on this "framework" consists of the source code, which is obtained by the client as static, and the server itself, which can set either the browser or WebView to the desired URL.  This is what true DRY means! </p><br><h1 id="kakie-plyushki">  What are the buns? </h1><br><p>  Of the buns, of course, less memory consumption.  Since neither Node.js nor Chrome is carrying with it, the data delivered to the client is very small in volume.  Also, the developers insist that you do not need to download some incomprehensible builders, you do not need to spend time on compilation and all that. </p><br><p>  Actually, from the pros, that's all, now let's move on to the minuses. </p><br><blockquote>  I just want to make a reservation that the project is very young, lives just over 5 months, but it already proudly carries version 1.1.0, so I think that I have the right to evaluate the product as already ready, and present it the same requirements as to the competitors. </blockquote><br><h2 id="bolyachki-nwjs">  Sores NW.js </h2><br><p>  Here we immediately have a fan of problems that gently migrated from NW.js. </p><br><p>  The first and most noticeable to the user is the delivery of the application.  In order for the client to launch our program on his computer, he needs to have 2 main things: <code>neutralino.exe</code> and the <code>app/</code> folder.  Inside the folder are stored all the settings (like the server mode and window title) and the <code>index.html</code> , which is given to the client.  The easiest way is to give the user a zip-archive and tell which program to use, but users will still find out what to do wrong, how to do it and what to break. </p><br><p>  To solve this problem in the NW was created by the builder, who knew how to pack everything in exe, along with the ICO and archives.  SFX archives were a less obvious solution, but antiviruses, in principle, look askance at them, so it is also not a very good option.  The developers themselves are planning to make their own packer, but so far only rumors have been circulating about it. </p><br><p>  The second problem is the entry point.  This is always <code>index.html</code> .  You cannot do anything about it and even specify another file.  All the scripts that the application needs should be loaded in this <code>index.html</code> .  The problem is not very big, but it reduces the flexibility of the system at times. </p><br><h2 id="kakoy-to-brauzer">  <em>Some kind of</em> browser </h2><br><p>  It's still worse than NW.js or Electron.  If in the latter we know for sure the version of the browser that will display our application, then in principle we cannot be sure that the OS will provide us with a WebView that can work with JS.  That is, we return to the dashing zero and tinker in all possible ways to get to the very IE 8, which will be the standard WebView on Windows. </p><br><p>  This limits our application in terms of displaying and playing some media files, and this is the main function of applications developed on the principle of "Web for Desktop". </p><br><h2 id="api">  API </h2><br><p>  As the authors strive for minimalism, the API provided by the server does not differ in a variety of methods.  I would even say no different forethought.  All this nebuystvo described in the same <a href="https://neutralino.js.org/docs/">meager documentation</a> . </p><br><p>  The only one who can communicate with the system is the Neutralino server, then we must somehow communicate with it.  The communication channel is one-way - HTTP.  In fact, all that we are given to use in JS is just a wrapper around the server REST API. </p><br><p>  The whole API can be divided into 3 parts: working with <em>Storage</em> , strongly basic working with FS (read only, delete and create - no frills) and calling system windows and commands. </p><br><p>  And now let's go over the most API design available from JS. </p><br><p>  Let's start with callbacks.  Since we have <em>some kind of</em> browser, then ES5, and accordingly Promise, will not work.  And since developers don‚Äôt tolerate Node.js, they don‚Äôt want to use Node-like callbacks.  Therefore, each method has 2 callbacks: one for the <em>result</em> and the other for error handling, the format of which, by the way, is not known. </p><br><p>  At the expense of the results: most of the commands, for example, working with OS, pass an object with a <code>stdout</code> field, inside which there is a string.  As you already understood, reading large files and even less processing them in any Buffer-like object will fail.  In system windows, the result is in a different format; an object with a <code>file</code> field is used there.  The question "why, in principle, objects with one field are needed" remains unanswered. </p><br><p>  Now for Storage.  In it there are such entities as bucket'y, which are saved as JSON-files next to the source code of the application.  At the same time, in order to write data to some bucket, we have to transfer an object with the name of the bucket and its new content.  To get the data, we pass only the string - the name of the bucket.  No hint of similarity with the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Storage">standard Storage interface</a> , why do we make our bike ... </p><br><p>  Well, let's talk a little about OS integration.  Recall that Electron and even NW offered the possibility of creating their own Context Menu, allowed to hide the window and even create an icon in the tray.  This is just not all.  And, given the architecture of the solution, never will be.  Only the browser and only the REST API, only hardcore. </p><br><h1 id="dlya-chego-mozhno-ispolzovat">  What can I use? </h1><br><p>  For a long time I thought that if you just need to transfer the registration form from the site to the desktop application, then you can use NW.js and not bathe.  If you need something more complicated, something that requires integration with the system in graphic terms, then it is Electron.  Yes, each has its own drawbacks, but these are at least some products on which you can make your application. </p><br><p>  But Netralinojs can also be used.  For example, some chat will work quite well, only on the server you will need to configure CORS.  Any small graphic generator of text configs will be quite good for yourself.  For myself, I see this framework only as a platform for small GUI utilities that will need to be run infrequently and not for long.  I think you can also remember from your professional activity at least one small product that could work on such a minimalistic platform. </p><br><h1 id="vyvod">  Conclusion </h1><br><p>  The framework is actually very, very raw.  His minimalism may be his strong point, but as soon as features are needed that go beyond the API, you will have to switch to either Electron or NW.js. </p><br><p>  I really hope that v1.1.0 is not the last, and that the developers still redo many flaws in the design of their API and provide more flexible options for setting up and behavior of the application.  I also hope that they will still find a static server on the pros, which could be forked and used on a Mac. </p><br><p>  Well, and references, to make it more clear: </p><br><ul><li>  <a href="https://neutralino.js.org/">https://neutralino.js.org/</a> - Project site </li><li>  <a href="https://neutralino.js.org/docs/">https://neutralino.js.org/docs/</a> - JS API documentation </li><li>  <a href="https://github.com/neutralinojs/neutralinojs">https://github.com/neutralinojs/neutralinojs</a> - GitHub Repository </li><li>  <a href="https://github.com/neutralinojs/evaluation">https://github.com/neutralinojs/evaluation</a> - Comparison of Hello World with competitors from developers </li><li>  <a href="https://medium.com/%40shalithasuranga/neutralinojs-2019-roadmap-a93bf9dcd959">Neutralinojs 2019 - Roadmap</a> - Official Refinement Plan </li></ul></div><p>Source: <a href="https://habr.com/ru/post/438402/">https://habr.com/ru/post/438402/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>