<div class="post__text post__text-html js-mediator-article">  A long time ago, when I was just starting to learn PHP and the subtleties of compiling MySQL queries (2011), I had the idea to write a wrapper for MySQLi like Doctrine to simplify the syntax for accessing the database.  In the yard already in 2019 and decided to share his bike on the topic of ORM. <br><br>  And so, this is DBX - MySQL database engine for PHP based on the MySQLi library based on queries of the type of structural description of tables and database fields as a regular array with the function of static query caching and auto-updating of the static hash. <br><a name="habracut"></a><br>  Contrary to the universal love of PDO, it was precisely the lightweight MySQLi functionality that was programmed softer and simpler and more succinctly fit into the proposed DBX API.  I didn’t even use composer, because I don’t have a single project where I use third-party dependencies other than self-dependencies. <br><br>  Actually, consider an example of declaring the structure of the simplest test database and its tables.  First, let's connect the library with the class itself and send the authorization data with the database host: <br><br><pre><code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">require_once</span></span> <span class="hljs-string"><span class="hljs-string">'./DBX.php'</span></span>; $dbx_data = [<span class="hljs-string"><span class="hljs-string">'localhost'</span></span>, <span class="hljs-string"><span class="hljs-string">'root'</span></span>, <span class="hljs-string"><span class="hljs-string">'root'</span></span>, <span class="hljs-string"><span class="hljs-string">'dbx_test'</span></span>, <span class="hljs-string"><span class="hljs-string">'8889'</span></span>];</code> </pre> <br>  Now imagine that we need to describe and create a table in the database using the syntax of a regular PHP array: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">/** * CREATE TABLE EXAMPLE */</span></span> $table_1 = <span class="hljs-string"><span class="hljs-string">'example'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// table name $query_1 = 'c'; // create table sql $fields_1 = [ 'field_id' =&gt; [ 'type' =&gt; 'num', // int 'auto' =&gt; true, // auto increment 'length' =&gt; 255, 'fill' =&gt; true // not null ], 'field_text' =&gt; [ 'type' =&gt; 'text', // varchar 'length' =&gt; 255, 'fill' =&gt; true ], 'field_date' =&gt; [ 'type' =&gt; 'time', // TIMESTAMP 'value' =&gt; date('Ym-d') ] ]; </span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">?&gt;</span></span></span></span></code> </pre><br>  Here the syntax is simple.  I did not use strong typing and just selected the values ​​TEXT, NUMBER and TYMESTAMP.  Of course, for a more “steering” table structure, the key ID field with auto-increment is used (I haven’t seen cases in real projects when the task of auto-increment and key prevents the design of queries and table connections).  To indicate whether the field can be empty, specify the parameter fill =&gt; true. <br><br>  DataBaseX request types are very simple and contain basic methods like select, insert, delete, update, drop, truncate, and so on. <br><br>  For example, a query to create a table: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// perform queries $dbx::query("c", $table_1, $fields_1);</span></span></code> </pre><br>  Or a query for adding data and column structure might look like this: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// fields values for table_1 example $fields_2 = [ 'field_id' =&gt; [ 'value' =&gt; 456 ], 'field_text' =&gt; [ 'value' =&gt; 'I have to add into my table' ], 'field_date' =&gt; [ 'value' =&gt; date('Ym-d') ] ]; // perform queries $dbx::query('i', $table_1, $fields_2);</span></span></code> </pre><br>  The structure of the array allows you to once describe the database and later only manipulate the value fields to change the data that is used to form queries. <br><br>  Here is an example update instruction, which I will abolish in the following example: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// fields values for table_1 example $fields_3 = [ 'field_id' =&gt; [ 'value' =&gt; 456 ], 'field_text' =&gt; [ 'new_value' =&gt; 'I was updated', 'criterion_field' =&gt; 'field_id', 'criterion_value' =&gt; 456 ], 'field_date' =&gt; [ 'value' =&gt; date('Ym-d') ] ]; // perform queries $dbx::query('u', $table_1, $fields_3);</span></span></code> </pre><br>  It seemed to me that using the criterion_field and criterion_value fields complicates the system, so I created a query that automatically either adds data to the database, if they have not yet been created, or updates the existing data.  I called this query INJECT QUERY and it is called with the “in” prefix: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// fields values for table_1 example $fields_2 = [ 'field_id' =&gt; [ 'value' =&gt; 0 ], 'field_text' =&gt; [ 'value' =&gt; 'Yo if field_id = 0 it\'s an insert or if id exists it\'s an update' ], 'field_date' =&gt; [ 'value' =&gt; date('Ym-d') ] ]; // perform queries $dbx::query('in', $table_1, $fields_2);</span></span></code> </pre><br>  It works on a low level like this: <br><br><pre> <code class="php hljs">INSERT INTO `revolver__comments` (`field_id`, `field_content`) VALUES (<span class="hljs-string"><span class="hljs-string">'5'</span></span>, <span class="hljs-string"><span class="hljs-string">'TEST UPDATE'</span></span>) ON DUPLICATE KEY UPDATE `field_id`=<span class="hljs-string"><span class="hljs-string">'5'</span></span>, `field_content`=<span class="hljs-string"><span class="hljs-string">'TEST UPDATE'</span></span>;</code> </pre><br>  All other queries are simplest and it makes no sense to describe them (see the examples in the index.php test file), but I cannot but show how the SELECT query works: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">// perform queries $dbx::query('s|field_id|asc|100|0', $table_1, $fields_1); </span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">?&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">&lt;?php</span></span></span><span class="hljs-comment"> // print structure print '&lt;h2&gt;DBX STRUCTURE&lt;/h2&gt;'; print '&lt;pre&gt;&lt;code&gt;'; print_r( $fields_1 ); print '&lt;/code&gt;&lt;/pre&gt;'; // print result print '&lt;h2&gt;DBX QUERY RESULT&lt;/h2&gt;'; print '&lt;pre&gt;&lt;code&gt;'; print_r( $dbx::$result ); print '&lt;/code&gt;&lt;pre&gt;&lt;hr /&gt;'; </span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">?&gt;</span></span></span></span></code> </pre><br>  Here, using the prefix "s", you can group the query parameters <b>s | field_id ( <i>order</i> ) | asc ( <i>direction</i> ) | 100 ( <i>limit</i> ) | 0 ( <i>offset</i> )</b> . <br><br>  Among other things, DBX has such a distinction as the built-in file cache based on JSON statics.  Each change request (INSERT, UPDATE, DELETE, TRUNCATE) causes a hash in the cache hash table and automatically updates the static cache, which makes it possible not to think about the load on SELECT queries. <br><br>  In the future, I plan to develop the DBX engine and expand the capabilities of the SQL query designer with the UNION and JOIN configuration system, as well as add new database support from MySQL 8 on the JSON type structure. <br><br>  Now DBX is used in my <a href="https://github.com/xShiftx/RevolveR_CMS">RevolveR</a> content management system and shows good characteristics (the entire site, provided there is an updated cache, is initialized with a single query to the database and consumes about 0.7 Mb of the interpreter’s memory).  And it is also very convenient for me to see the entire database structure in one separate file, which speeds up the development and design of new modules. <br><br>  <b>Project repository: <a href="https://github.com/xShiftx/Revolver_DBX">DBX v1.1.1 on GitHub</a> .</b> </div>