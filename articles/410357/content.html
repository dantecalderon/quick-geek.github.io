<div class="post__text post__text-html js-mediator-article">  Hello everyone, here I want to tell you about the sound signal analysis algorithm that allows you to parse the signal into separate waves, of course, it does not give 100% accuracy, but nevertheless the result is pretty good in my opinion. <br><br><img src="http://ipic.su/7yypcM" alt="image"><br><a name="habracut"></a><br>  The work on any music is best seen: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/FmlwJFqKPH4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  And links to other examples of different genres.  Metaldeth-Tornado of souls: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/V2ZH03-GQPA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Out of Touch: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/cUPQbZB99Tk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  So for the expansion you need to do the following steps: <br><br>  - From the original signal you need to get 8 intermediate signals; <br>  - From these intermediate signals and the original signal you need to get 8 signals - layers, which can be divided into separate waves; <br>  - Calculate how much in each layer of waves and what is their amplitude. <br><br>  Now more about each stage: in order to get an intermediate signal, you need to take a derivative of the original signal.  In essence, this is a derivative of a discrete function.  To find it for each moment of the original signal you need to set 1 parameter: the period for which this derivative is located.  The value of the derivative is the coefficient of the slope in a given interval, you can find for example the method of least squares. <br><br>  It is required to calculate 8 intermediate signals with 8 different periods.  The simplest set of periods: 4, 8, 16, 32, 64, 128, 256, 512. When the period is specified, for each sample of the signal, the derivative is calculated using the least squares formula.  It is like a moving average, only here is not a moving average but a sliding derivative of the current interval. <br><br>  Thus, 8 derived signals and 1 source signal are obtained.  Now each of the 8 derived signals needs to be integrated.  In this case, this means that each subsequent sample is equal to the sum of all previous samples.  After that, 8 intermediate layers are obtained. <br><br>  The next step is to obtain layers that can be disassembled into separate waves.  So now you need to get 8 layers.  Layers are calculated as follows: <br><br>  layer0 = intermediate0-ref signal <br>  layer1 = intermediate1-intermediate0 <br>  layer2 = intermediate2-intermediate1 <br>  layer3 = intermediate3-intermediate2 <br>  layer4 = intermediate4-intermediate3 <br>  layer5 = intermediate5-intermediate4 <br>  layer6 = intermediate6-intermediate5 <br>  layer7 = intermediate7-intermediate6 <br>  layer8 = intermediate7 <br><br>  The last layer is not a difference, but is simply equal to the last intermediate signal. <br><br>  You can try differently, namely, to calculate the subsequent intermediate signals from the previous intermediate ones.  But in the current program uses 1 option. <br><br>  Now, to break down the layers into separate waves, you just need to count the areas where the values ​​increase and where they decrease.  Actually the duration of the sections is their wavelength.  Signal areas where signal values ​​are constant must be simply skipped.  To find the amplitude of the signal in the spectrum in a certain interval, you need to add all the amplitudes of the waves multiplied by their length. <br><br><img src="http://ipic.su/7yyp7M" alt="image"><br><br>  The code that calculates the intermediate signal looks like this: <br><br>  here wavesize is the number of samples <br>  signal [] - the array with the source signal <br>  SY = 0, SX = 0, SXX = 0, SXY = 0, Ky = 0 - variables of type float <br>  Step2 = STEP / 2 where STEP is the period (4,8,16,32,64,128,256,512) <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=Step2;i&lt;wavesize-Step2;i++){ SY=<span class="hljs-number"><span class="hljs-number">0</span></span>,SX=<span class="hljs-number"><span class="hljs-number">0</span></span>,SXX=<span class="hljs-number"><span class="hljs-number">0</span></span>,SXY=<span class="hljs-number"><span class="hljs-number">0</span></span>,Ky=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=i-Step2,fromZ=<span class="hljs-number"><span class="hljs-number">0</span></span>;j&lt;i+Step2;j++,fromZ++){ SX+=fromZ; SY+=signal[j]; SXX+=fromZ*fromZ; SXY+=fromZ*signal[j]; } Ky=<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>((STEP)*SXY-SX*SY)/<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>((STEP)*SXX-SX*SX); OutSignal[i]=OutSignal[i<span class="hljs-number"><span class="hljs-number">-1</span></span>]+Ky; }</code> </pre> <br>  To subtract one signal from another, simply subtract each sample from each. <br>  For example, for layer 0: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;wavesize<span class="hljs-number"><span class="hljs-number">-1</span></span>;i++) layer0[i]=OutSignal0[i]-Signal[i];</code> </pre> <br>  If you add up all the layers, and take the last one with the opposite sign, you get the original signal, thus multiplying some layer, it is possible to make a frequency filter.  The next question is how to calculate the amplitudes of specific harmonics.  The fact is that in a constant interval, for example = 4000 samples, there can be a lot of short waves and relatively few long ones. <br><br>  You can certainly find the average amplitudes for each layer and fold.  But this method is not very good since the long waves are very small, and their amplitude is usually very large, and a strong non-uniformity of amplitude towards low frequencies is obtained. <br><br>  In the program that displays the color music on the links, the amplitude of each harmonic is calculated as: wave amplitude * its length.  Still, unevenness arises, but not as strong as in the case of averaging. <br><br>  In general, I don’t think that a person perceives sound as a decomposition into a spectrum, rather a sound consists of sound images that consist of waves of different lengths.  Accordingly, the volume of a sound is rather the average volume of all the waves of which the sound consists.  But so far it is not clear what parameters make up the sound image, perhaps the average frequency, standard deviation or something else. </div>