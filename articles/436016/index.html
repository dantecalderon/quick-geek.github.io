<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>IVR with voice recognition on Asterisk - fast, easy, free</title>
  <meta name="description" content="Creating an IVR based on Asterisk, with DTMF recognition and employee names (based on Voicer from a respected antirek ) and connecting to an existing ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>IVR with voice recognition on Asterisk - fast, easy, free</h1><div class="post__text post__text-html js-mediator-article">  Creating an IVR based on Asterisk, with DTMF recognition and employee names (based on Voicer from a respected <a href="https://habr.com/ru/users/antirek/" class="user_link">antirek</a> ) and connecting to an existing PBX. <br><a name="habracut"></a><br>  The upcoming new year brought to the company, where I work, (not) good news - an ancient server with an IVR system and a PCI-card for 4 analog ports from Dialogic died.  Suddenly, it turned out that modern systems do not have PCI slots, the old ones are not friendly with the new versions of the OS and it is not known how long they will live, and the license is only for a specific old version of the program. <br>  So the idea was born to raise IVR without a fee (and for free) on a virtual machine with Asterisk. <br><br>  Total, we need: <br><br><ul><li>  Existing PBX with subscribers </li><li>  The virtual machine (in the example, ubuntu 18.04 lts). </li><li>  Registration for any of the voice recognition services: wit.ai, google or Yandex </li><li>  Minimal knowledge of Linux systems </li><li>  Desire to deal with Asterisk </li></ul><br>  If all items successfully completed - you can proceed.  The first step is to install asterisk itself, voice prompts for the test, as well as nodejs and npm. <br><br><pre><code class="bash hljs">apt install nodejs asterisk npm asterisk-core-sounds-ru-gsm</code> </pre> <br>  Next, we need the voicer recognition service and the process manager to start it: <br><br><pre> <code class="bash hljs">npm install voicer -g npm install pm2 -g</code> </pre> <br>  Create folders and configuration for voicer: <br><br><pre> <code class="bash hljs">mkdir -p /etc/voicer/data</code> </pre> <br>  And we will write down the configuration in the /etc/voicer/config.js file, adding our login / password and key (developer_key) to the desired service.  In my case, wit.ai was chosen - free, accurate enough for our tasks. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { <span class="hljs-attr"><span class="hljs-attr">agi</span></span>: { <span class="hljs-attr"><span class="hljs-attr">port</span></span>: <span class="hljs-number"><span class="hljs-number">3000</span></span> }, <span class="hljs-attr"><span class="hljs-attr">web</span></span>: { <span class="hljs-attr"><span class="hljs-attr">port</span></span>: <span class="hljs-number"><span class="hljs-number">3100</span></span>, <span class="hljs-attr"><span class="hljs-attr">auth</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">username</span></span>: <span class="hljs-string"><span class="hljs-string">'–ò–ú–Ø_–ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–Ø'</span></span>, <span class="hljs-attr"><span class="hljs-attr">password</span></span>: <span class="hljs-string"><span class="hljs-string">'–ü–ê–†–û–õ–¨_–ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–Ø'</span></span>, <span class="hljs-attr"><span class="hljs-attr">realm</span></span>: <span class="hljs-string"><span class="hljs-string">'–ù–ê–ó–í–ê–ù–ò–ï_–ö–û–ú–ü–ê–ù–ò–ò'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">processing</span></span>: { <span class="hljs-attr"><span class="hljs-attr">totalAttempts</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">playGreeting</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">playBeepBeforeRecording</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-comment"><span class="hljs-comment">//use system beep }, asterisk: { sounds: { onErrorBeforeFinish: 'invalid', onErrorBeforeRepeat: 'invalid', greeting: 'beep' }, recognitionDialplanVars: { status: 'RECOGNITION_RESULT', target: 'RECOGNITION_TARGET' } }, record: { directory: '/tmp', type: 'wav', duration: 3, }, recognize: { directory: '/tmp', type: 'witai', // ['yandex', 'google', 'witai'] options: { developer_key: 'XXXXXXXXXXXXXXXXXXX' } }, lookup: { type: 'file', options: { dataFile: '/etc/voicer/data/peernames.json' } }, logger: { console: { colorize: true }, file: { filename: '/var/log/voicer.log', json: false } } };</span></span></code> </pre><br>  Next we need to create a service to start voicer.  This will be the /etc/init.d/voicer file: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh ### BEGIN INIT INFO # Provides: voicer # Required-Start: $network $syslog $named # Required-Stop: $network $syslog $named # Default-Start: 2 3 4 5 # Default-Stop: 0 1 6 # Short-Description: Start/stop voicer ### END INIT INFO set -e if [ -z "$1" ] ; then echo "Usage: $0 [start|stop|restart]" exit 0 fi if [ "$1" = "start" ] ; then VOICER_CONFIGFILE=/etc/voicer/config pm2 start voicer elif [ "$1" = "stop" ] ; then pm2 stop voicer elif [ "$1" = "restart" ] ; then $0 stop sleep 5 $0 start fi</span></span></code> </pre><br>  Well, activate it: <br><br><pre> <code class="bash hljs">systemctl daemon-reload systemctl <span class="hljs-built_in"><span class="hljs-built_in">enable</span></span> voicer systemctl start voicer</code> </pre> <br>  It should be noted that voicer will add recorded files to the / tmp folder and it would be nice to clean it periodically.  Create a simple script for this and add it to /etc/cron.daily <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh rm /tmp/*.wav</span></span></code> </pre><br>  Well, now there is a more difficult part - to configure asterisk itself.  Since we already have PBX and all clients use it, we do not need most of the configuration.  We delete (or store in a dark cool dry place ‚Äî optional) from the / etc / asterisk folder everything except asterisk.conf, modules.conf and sip.conf.  And we add the sip.conf configuration in the following lines, adding the values ‚Äã‚Äãwe need for: <br><br><ul><li>  fromdomain - server address from asterisk </li><li>  host - PBX address </li><li>  fromuser: secret and defaultuser: remotesecret - login: password pairs exchanged between asterisk and PBX </li></ul><br><pre> <code class="bash hljs">[main_link] fromdomain=xxx.xxx.xxx.xxx host=xxx.xxx.xxx.yyy insecure=port port=5060 realm=asterisk sendrpid=pai fromuser=111 secret=111 defaultuser=222 remotesecret=222 qualify=yes <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>=friend disallow=all allow=alaw context=main_link promiscredir=yes dtmfmode=auto</code> </pre><br>  Here you should pay attention to the mode in which the dtmf commands work in your PBX.  Consider that they can be processed by different methods for external calls from PBX (for example, from the city or from a mobile phone) and internal calls between subscribers of your PBX.  In my case, in the first version these were inband dtmf signals, in the second one - rfc2833.  But auto handled it.  Also, you can expect interesting features of interaction with your PBX - you will have to find out by personal experience what is required, for example, to save caller ID of the calling (external) subscriber when returning a call from IVR to PBX (sendrpid line). <br><br>  And there is one more configuration file left.  The most important.  Dialplan, he's extensions.conf.  In it, you definitely need to specify your external number (to which people will call), the secretary‚Äôs number (to which the default calls will go) and the way to your voice prompts. <br><br><pre> <code class="bash hljs">[general] static=yes writeprotect=no [globals] [main_link] exten =&gt; –í–ê–®_–í–ù–ï–®–ù–ò–ô_–ù–û–ú–ï–†,1,Goto(ivr_tree,s,1) [ivr_tree] ;allow direct dialing to internal users exten =&gt; _40XX,1,Background(custom/common/SoedinyauVas) ;check user voice existance same =&gt; n,Set(exists=<span class="hljs-variable"><span class="hljs-variable">${STAT(e,${ASTDATADIR}</span></span>/sounds/custom/<span class="hljs-variable"><span class="hljs-variable">${EXTEN}</span></span>.vox)}) same =&gt; n,Playback(custom/<span class="hljs-variable"><span class="hljs-variable">${IF($[ ${exists}</span></span> = 1 ] ? <span class="hljs-variable"><span class="hljs-variable">${EXTEN}</span></span> : Sotrudnik)}) same =&gt; n,Transfer(SIP/<span class="hljs-variable"><span class="hljs-variable">${EXTEN}</span></span>@–ê–î–†–ï–°_–°–¢–ê–ù–¶–ò–ò) ;start intro exten =&gt; s,1,Answer() same =&gt; n,Set(CHANNEL(language)=ru) same =&gt; n,Background(custom/common/Welcome) ;start recognition same =&gt; n,AGI(agi://localhost:3000) same =&gt; n,GotoIf($[<span class="hljs-variable"><span class="hljs-variable">${RECOGNITION_RESULT}</span></span>=SUCCESS]?:default) same =&gt; n,Background(custom/common/SoedinyauVas) ;check user voice existance same =&gt; n,Set(exists=<span class="hljs-variable"><span class="hljs-variable">${STAT(e,${ASTDATADIR}</span></span>/sounds/custom/<span class="hljs-variable"><span class="hljs-variable">${RECOGNITION_TARGET}</span></span>.vox)}) ;play user name or default name same =&gt; n,Playback(custom/<span class="hljs-variable"><span class="hljs-variable">${IF($[ ${exists}</span></span> = 1 ] ? <span class="hljs-variable"><span class="hljs-variable">${RECOGNITION_TARGET}</span></span> : Sotrudnik)}) same =&gt; n,Transfer(SIP/<span class="hljs-variable"><span class="hljs-variable">${RECOGNITION_TARGET}</span></span>@–ê–î–†–ï–°_–°–¢–ê–ù–¶–ò–ò) same =&gt; n,Hangup() ;default route same =&gt; n(default),Transfer(SIP/4001@–ê–î–†–ï–°_–°–¢–ê–ù–¶–ò–ò)</code> </pre><br>  This example uses posts with greetings, employee names, and the phrase ‚Äúconnect you.‚Äù  At the same time, a hint for an employee is searched by his number, and if it is not there, it is simply pronounced ‚Äúwith an employee‚Äù.  I recommend these kind of hints to order studios - speech synthesis systems, alas, are not perfect and their pronunciation of your company name and the names of the employees is only suitable for entertainment.  40XX - numbers in the company, 4001 - secretary. <br><br>  The peculiarity of this situation is that our PBX deals with calls.  Thus, instead of the usual Dial command, we use the Transfer command - and then the incoming call after the IVR completely leaves the asterisk and frees the PBX sip channels (their number is often hard fixed by the license).  In most cases, the Transfer team is advised to use the name of the direction (main_link), but for my PBX it was only a direct indication of the station address. <br><br>  It's time to add users to the recognition system.  To do this, go to the address of our server and port 3100, after which we register there the names, surnames and numbers of employees. <br><br>  Now our asterisk can receive incoming calls, recognize DTMF signals, recognize employees and redirect to their internal numbers.  It remains only to convince the station that it needs to send incoming calls to our server.  Depending on the manufacturer, these settings may be completely diverse, but the desired path will contain the words ARS and call routing.  But that's another story. </div><p>Source: <a href="https://habr.com/ru/post/436016/">https://habr.com/ru/post/436016/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>