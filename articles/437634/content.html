<div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/967/b65/9d2/967b659d291d3021a9a93f68b4b305b2.jpg"></div><br><ol><li>  <a href="https://habr.com/ru/post/437634/">Selection of components</a> </li><li>  <a href="https://habr.com/ru/post/437634/">Starting Network Interfaces</a> </li><li>  <a href="https://habr.com/ru/post/437634/">Install an 802.11ac access point (5 GHz)</a> </li><li>  <a href="https://habr.com/ru/post/437634/">Configuring a virtual SSID using hostapd</a> </li></ol><br>  For the last ten years, I have bought cheap network equipment and put <a href="https://dd-wrt.com/">DD-WRT</a> on it in order to return “functions” at the cost of more than $ 500 removed from the Linux kernel, on which the stock firmware is based. <br><br>  Despite unstable assemblies, uncorrected errors and <a href="http://www.wi-fiplanet.com/columns/article.php/3816236">disputes</a> , DD-WRT is still preferable to stock firmware.  But now worthy components are cheaper than ever, and the DIY community has moved to Linux without exception (I am looking at you, Mr. Raspberry), so why not put together your own wireless router once and for all? <br><a name="habracut"></a><br><a name="1"></a><h1>  Selection of components </h1><br>  First you need to decide on the platform: <a href="https://en.wikipedia.org/wiki/X86">x86</a> or <a href="https://en.wikipedia.org/wiki/ARM_architecture">ARM</a> ?  I will not <a href="https://www.allaboutcircuits.com/news/understanding-the-differences-between-arm-and-x86-cores/">discuss in detail the key differences</a> , but in short: the former has better performance, and the latter is cheaper and more energy efficient.  Raspberry Pi boards (and analogues) are extremely cheap and probably more powerful than most wireless commercial routers, but x86 platforms are widespread and have an advantage due to standardized form factors and expansion ports. <br><br>  Of course, the most important thing is the chipset.  Today, the de facto standards are <a href="https://en.wikipedia.org/wiki/IEEE_802.11n">802.11n</a> (2.4 GHz) and <a href="https://en.wikipedia.org/wiki/IEEE_802.11ac">802.11ac</a> (5 GHz), but choosing drivers for Linux is <a href="https://wireless.wiki.kernel.org/en/users/drivers">another task</a> , especially with support for the AP mode (access point).  In short, if you do not want problems, choose <a href="https://wikidevi.com/wiki/Qualcomm_Atheros">Atheros</a> chipsets.  The <a href="https://wireless.wiki.kernel.org/en/users/drivers/ath9k">ath9k</a> and <a href="https://wireless.wiki.kernel.org/en/users/drivers/ath10k">ath10k drivers are</a> well supported, you can easily find them with USB and / or mini-PCIe interfaces. <br><br>  At least one network interface controller (NIC) is the minimum necessary, and choose RAM and storage to your liking. <br><br><h2>  List of materials </h2><br>  Having sacrificed price and power consumption, I chose the x86 platform for a modular, relatively powerful configuration available for upgrade. <br><br>  <i>If you do not need ARM, then the fan is not required.</i> <br><br><ul><li>  <a href="http://www.amazon.com/Gigabyte-Built-Celeron-Motherboard-GA-J1900N-D3V/dp/B00IW99S4A" rel="nofollow noopener">Gigabyte GA-J1900N-D3V</a> (J1900 four-core 2 GHz Celeron, two NICs) </li><li>  <a href="http://www.amazon.com/AIRETOS-AEX-QCA9880-NX-802-11ac-Extended-Temperature/dp/B00OJPJVV6" rel="nofollow noopener">Airetos AEX-QCA9880-NX</a> (dual-band 802.11ac, MIMO) </li><li>  <a href="http://www.amazon.com/Crucial-DDR3-1333-PC3-10600-CT2K2G3S1339M-CT2C2G3S1339M/dp/B008LTBIGW" rel="nofollow noopener">4 GB RAM</a> (DDR3-LP, 1333 MHz, 1.35 V) </li><li>  <a href="http://www.amazon.com/KZ-B22-mini-Express-MiniCard-Extender/dp/B008P1I28I" rel="nofollow noopener">MPCIe extension</a> </li><li>  <a href="http://www.amazon.com/MITXPC-MX500-Industrial-Mini-ITX-WallMount/dp/B01B575EMA" rel="nofollow noopener">MX500 mini-ITX housing</a> </li><li>  <a href="http://www.amazon.com/Super-Power-Supply%25C2%25AE-WZR-HP-G450H-TL-WR1043ND/dp/B00E9DN2D6" rel="nofollow noopener">Three 6dBi RP-SMA dual-band antennas + RP-SMA</a> cable </li><li>  <a href="http://www.amazon.com/PicoPSU-90-Adapter-Power-Kit-Cyncronix/dp/B00316T5S8" rel="nofollow noopener">Picopsu-90</a> </li><li>  Spare HDD 2.5 ” </li></ul><br>  The case is spacious, with two prepared holes for the AC / DC plug.  The installation of the motherboard, RAM and Pico-PSU went smoothly: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ad/455/84b/7ad45584b277d11fa3f1a7b119759ebc.jpg"><br>  <i><font color="gray">Iron porn</font></i> <br><br>  The most difficult was the installation of mini-PCIe WiFi, because the board only supports half-size cards: the mPCIe extender came to the rescue.  I took a 20 cm FFC cable (included) to connect both sides of the adapter and secured the mini-PCIe to the chassis using double-sided tape. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/db1/c7a/8f7/db1c7a8f756c70176d86ce9441d5cf7a.jpg"><img src="https://habrastorage.org/getpro/habr/post_images/5bb/b09/5c7/5bbb095c759ac5cd9be3cf316070ab22.jpg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/3a4/e91/9b8/3a4e919b817344fdc03d98bb1e9d001f.jpg"><br>  <i><font color="gray">Mini-PCIe extender</font></i> <br><br>  Fortunately, the case comes with three pre-cut holes for the antennas.  Here is the final result: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/967/b65/9d2/967b659d291d3021a9a93f68b4b305b2.jpg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c3d/82d/a98/c3d82da9842de641d8d3a4dec3cfe517.jpg"><br><br><a name="2"></a><h1>  Software </h1><br>  It is clear that we put Linux.  Depending on the hardware, this could be an optimized distribution like <a href="https://www.raspbian.org/">Raspbian</a> (for Raspberry Pi) or any other Linux distribution that you like.  Since I have been using Ubuntu for many years, I chose <a href="https://www.ubuntu.com/download/server">Ubuntu Server 18.04 LTS</a> , with which I am accustomed to work and who have long-term support. <br><br>  <i>The rest of this article assumes that you are using a distribution based on Debian.</i> <br><br>  If the installation went fine and you entered the console, we define the interface names: <br><br><pre><code class="bash hljs">$ ip -br a | awk <span class="hljs-string"><span class="hljs-string">'{print $1}'</span></span> lo enp1s0 enp2s0 wlp5s0</code> </pre> <br>  There are two embedded NICs on the motherboard: these are <code>enp1s0</code> and <code>enp2s0</code> .  The wireless card is displayed as <code>wlp5s0</code> and supports AP mode, as expected: <br><br><pre> <code class="bash hljs">$ iw list ... Supported interface modes: * managed * AP * AP/VLAN * monitor * mesh point</code> </pre> <br>  Now we can outline what we need: we will install the first NIC as a WAN port, and the second will be connected to the wireless interface: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e6/f00/dd4/5e6f00dd4994b5dc252d70dda1d325ec.png"><br><br><h2>  Network </h2><br>  If you have Ubuntu 18.04, then we will immediately get rid of <code>netplan</code> to return to the support of / etc / network / interfaces: <br><br><pre> <code class="bash hljs">$ sudo apt-get install ifupdown bridge-utils $ sudo systemctl stop networkd-dispatcher $ sudo systemctl <span class="hljs-built_in"><span class="hljs-built_in">disable</span></span> networkd-dispatcher $ sudo systemctl mask networkd-dispatcher $ sudo apt-get purge nplan netplan.io</code> </pre> <br>  As a DHCP / DNS server, choose <a href="https://wiki.debian.org/HowTo/dnsmasq">dnsmasq</a> : <br><br><pre> <code class="bash hljs">$ sudo apt-get install dnsmasq</code> </pre> <br>  Since we will start and configure the <code>dnsmasq</code> process via the <code>post-up</code> hook, do not forget to disable the daemon at boot time: <br><br><pre> <code class="bash hljs">$ sudo sed -i <span class="hljs-string"><span class="hljs-string">"s/^ENABLED=1$/ENABLED=0/g"</span></span> /etc/default/dnsmasq</code> </pre> <br>  We will write a <b>preliminary</b> configuration of network interfaces in accordance with the diagram, including the minimum <code>dnsmasq</code> setting: <br><br><pre> <code class="bash hljs">$ cat /etc/network/interfaces <span class="hljs-comment"><span class="hljs-comment"># Loopback auto lo iface lo inet loopback # WAN interface auto enp1s0 iface enp1s0 inet dhcp # Bridge (LAN) auto br0 iface br0 inet static address 192.168.1.1 network 192.168.1.0 netmask 255.255.255.0 broadcast 192.168.1.255 bridge_ports enp2s0 post-up /usr/sbin/dnsmasq \ --pid-file=/var/run/dnsmasq.$IFACE.pid \ --dhcp-leasefile=/var/lib/misc/dnsmasq.$IFACE.leases \ --conf-file=/dev/null \ --interface=$IFACE --except-interface=lo \ --bind-interfaces \ --dhcp-range=192.168.1.10,192.168.1.150,24h pre-down cat /var/run/dnsmasq.$IFACE.pid | xargs kill</span></span></code> </pre> <br>  <i>Documentation <code>/etc/network/interfaces</code> <a href="http://manpages.ubuntu.com/manpages/bionic/man5/interfaces.5.html">here</a></i> <br><br>  As you can see from the <code>post-up</code> section, dnsmasq starts as soon as the bridge rises.  Its configuration is performed only with command line arguments ( <code>--conf-file=/dev/null</code> ), and the process will stop when the interface is disabled. <br><br>  The <code>bridge_ports</code> interface is not specifically specified in the <code>wlp5s0</code> , because <code>hostapd</code> will add it to the bridge automatically (brctl may refuse to do this before hostapd is running to change the interface mode). <br><br>  <i>See <code>dnsmasq</code> <a href="http://manpages.ubuntu.com/manpages/xenial/man8/dnsmasq.8.html">documentation</a> .</i> <br><br>  Now you can restart the network ( <code>sudo service networking restart</code> ) or simply reboot to verify that the network configuration settings are correct. <br><br>  Please note: although at the moment we can get DHCP from <code>enp2s0</code> , we will not have <b>either a wireless connection</b> (more on this later) <b>or internet access</b> (see below). <br><br><h2>  Routing </h2><br>  At this stage, you need to route packets between the LAN ( <code>enp2s0</code> ) and WAN interfaces ( <code>enp1s0</code> ) and enable <a href="https://www.tldp.org/HOWTO/IP-Masquerade-HOWTO/ipmasq-background2.1.html">network address translation</a> . <br><br>  Enable packet forwarding is easy: <br><br><pre> <code class="bash hljs">$ sudo sysctl -w net.ipv4.ip_forward=1 $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"net.ipv4.ip_forward=1"</span></span> | sudo tee -a /etc/sysctl.conf</code> </pre> <br>  <i>The last command ensures that the configuration is maintained until the next reboot.</i> <br><br>  Network address translation is another matter; you usually have to deal with (or rather, fight) <code>iptables</code> .  Fortunately, the stone age is long over, and the guys from FireHol put a lot of effort, adding the necessary level of abstraction: <br><br><pre> <code class="bash hljs">$ sudo apt-get install firehol</code> </pre> <br>  FireHOL is a state-of-the-art protected firewall language, its configuration is easily understood and accessible.  You no longer need to write <code>iptables</code> statements: the configuration file itself is translated into <code>iptables</code> statements and is applied as it should.  No daemon in the background. <br><br>  The inclusion of network address translation for local network interfaces with the addition of minimum firewall rules is done simply: <br><br><pre> <code class="bash hljs">$ cat /etc/firehol/firehol.conf version 6 <span class="hljs-comment"><span class="hljs-comment"># Accept all client traffic on WAN interface enp1s0 wan client all accept # Accept all traffic on LAN interface br0 lan server all accept client all accept # Route packets between LAN and WAN router lan2wan inface br0 outface enp1s0 masquerade route all accept</span></span></code> </pre> <br>  <i>FireHOL is written by people for people documentation is <a href="https://firehol.org/guides/firehol-welcome/">here</a> .</i> <br><br>  You can check the settings by manually running <code>firehol</code> ( <code>sudo firehol start</code> ) and connecting the laptop to the LAN port: <b>now you can get online</b> if the WAN port is connected. <br><br>  Before rebooting, <b>do not forget to</b> edit <code>/etc/default/firehol</code> to allow the launch of FireHol at boot: <br><br><pre> <code class="bash hljs">$ sudo sed -i -E <span class="hljs-string"><span class="hljs-string">"s/^START_FIREHOL=.+$/START_FIREHOL=YES/g"</span></span> /etc/default/firehol</code> </pre> <br>  <i>I will not go into the details of the whole <code>firehol</code> syntax, the configuration file explains itself, I recommend to consult the <a href="https://firehol.org/documentation/">documentation</a> in the case of more complex settings.</i>  <i>If you really wonder what <code>firehol</code> did with <code>iptables</code> , just type <code>sudo firehol status</code> on the command line.</i> <br><br><h2>  Wireless access point </h2><br>  Obviously, we will manage the access point using <a href="https://wiki.gentoo.org/wiki/Hostapd">hostapd</a> : <br><br><pre> <code class="bash hljs">$ sudo apt-get install hostapd</code> </pre> <br>  Below you will find the minimum and almost no explanation for the 802.11 n / 2.4 Ghz / WPA2-AES configuration file: <br><br><pre> <code class="bash hljs">$ cat /etc/hostapd/hostapd-simple.conf <span class="hljs-comment"><span class="hljs-comment">#### Interface configuration #### interface=wlp5s0 bridge=br0 driver=nl80211 ##### IEEE 802.11 related configuration ##### ssid=iCanHearYouHavingSex hw_mode=g channel=1 auth_algs=1 wmm_enabled=1 ##### IEEE 802.11n related configuration ##### ieee80211n=1 ##### WPA/IEEE 802.11i configuration ##### wpa=2 wpa_key_mgmt=WPA-PSK rsn_pairwise=CCMP wpa_passphrase=YouCantGuess</span></span></code> </pre> <br>  <i><code>hostpad.conf</code> documentation <code>hostpad.conf</code> <a href="https://gist.github.com/renaudcerrato/db053d96991aba152cc17d71e7e0f63c">see</a> <code>/usr/share/doc/hostapd/examples/hostapd.conf</code></i> . <br><br>  The described configuration can be tested manually: <br><br><pre> <code class="bash hljs">$ sudo hostapd /etc/hostapd/hostapd-simple.conf</code> </pre> <br>  If everything goes well, a <b>wireless connection will appear</b> .  If you are satisfied with the result, <b>do not forget</b> to change the configuration in order to start <code>hostapd</code> as soon as the interface rises (as shown below). <br><br>  <b>Here is your final <code>/etc/network/interfaces:</code></b> <br><br><pre> <code class="bash hljs">$ cat /etc/network/interfaces <span class="hljs-comment"><span class="hljs-comment"># Loopback auto lo iface lo inet loopback # WAN interface auto enp1s0 iface enp1s0 inet dhcp # Bridge (LAN) auto br0 iface br0 inet static address 192.168.1.1 network 192.168.1.0 netmask 255.255.255.0 broadcast 192.168.1.255 bridge_ports enp2s0 post-up /usr/sbin/hostapd \ -P /var/run/hostapd.$IFACE.pid \ -B /etc/hostapd/hostapd-simple.conf post-up /usr/sbin/dnsmasq \ --pid-file=/var/run/dnsmasq.$IFACE.pid \ --dhcp-leasefile=/var/lib/misc/dnsmasq.$IFACE.leases \ --conf-file=/dev/null \ --interface=$IFACE --except-interface=lo \ --bind-interfaces \ --dhcp-range=192.168.1.10,192.168.1.150,24h pre-down cat /var/run/dnsmasq.$IFACE.pid | xargs kill pre-down cat /var/run/hostapd.$IFACE.pid | xargs kill</span></span></code> </pre> <br><a name="3"></a><h1>  Install an 802.11ac access point (5 GHz) </h1><br><h2>  Passive scan </h2><br>  According to the <a href="http://www.airetos.com/products/aex-qca9880-nx/">Airetos AEX-QCA9880-NX</a> documentation, the chipset supports 802.11ac, so that we can leave the crowded 2.4 GHz channels to the heavenly 5 GHz. <br><br>  Let's see which frequencies are supported: <br><br><pre> <code class="plaintext hljs">$ iw list ... Frequencies: * 2412 MHz [1] (20.0 dBm) * 2417 MHz [2] (20.0 dBm) * 2422 MHz [3] (20.0 dBm) * 2427 MHz [4] (20.0 dBm) * 2432 MHz [5] (20.0 dBm) * 2437 MHz [6] (20.0 dBm) * 2442 MHz [7] (20.0 dBm) * 2447 MHz [8] (20.0 dBm) * 2452 MHz [9] (20.0 dBm) * 2457 MHz [10] (20.0 dBm) * 2462 MHz [11] (20.0 dBm) * 2467 MHz [12] (disabled) * 2472 MHz [13] (disabled) * 2484 MHz [14] (disabled) ... Frequencies: * 5180 MHz [36] (17.0 dBm) (no IR) * 5200 MHz [40] (17.0 dBm) (no IR) * 5220 MHz [44] (17.0 dBm) (no IR) * 5240 MHz [48] (17.0 dBm) (no IR) * 5260 MHz [52] (23.0 dBm) (no IR, radar detection) * 5280 MHz [56] (23.0 dBm) (no IR, radar detection) * 5300 MHz [60] (23.0 dBm) (no IR, radar detection) * 5320 MHz [64] (23.0 dBm) (no IR, radar detection) * 5500 MHz [100] (23.0 dBm) (no IR, radar detection) * 5520 MHz [104] (23.0 dBm) (no IR, radar detection) * 5540 MHz [108] (23.0 dBm) (no IR, radar detection) * 5560 MHz [112] (23.0 dBm) (no IR, radar detection) * 5580 MHz [116] (23.0 dBm) (no IR, radar detection) * 5600 MHz [120] (23.0 dBm) (no IR, radar detection) * 5620 MHz [124] (23.0 dBm) (no IR, radar detection) * 5640 MHz [128] (23.0 dBm) (no IR, radar detection) * 5660 MHz [132] (23.0 dBm) (no IR, radar detection) * 5680 MHz [136] (23.0 dBm) (no IR, radar detection) * 5700 MHz [140] (23.0 dBm) (no IR, radar detection) * 5720 MHz [144] (23.0 dBm) (no IR, radar detection) * 5745 MHz [149] (30.0 dBm) (no IR) * 5765 MHz [153] (30.0 dBm) (no IR) * 5785 MHz [157] (30.0 dBm) (no IR) * 5805 MHz [161] (30.0 dBm) (no IR) * 5825 MHz [165] (30.0 dBm) (no IR) ...</code> </pre> <br>  In the above list, we see that the chipset supports channels 1-14 (2.4 GHz) and channels 36-165 (5 GHz), but did you notice the flag <code>no IR</code> ? <br><br>  The <code>no IR</code> flag indicates <i>no-initiating-radiation</i> (i.e., <i>passive scanning</i> ).  This means that this mode is prohibited in the case when the device first initiates radiation (including <b>beacons</b> ).  In other words, <b>you cannot launch an access point on these channels</b> ! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/03f/743/e75/03f743e7505714ae9864dcce2b5b4964.gif"></div><br><br><h2>  Regulatory requirements </h2><br>  The above situation is explained by the <a href="https://wireless.wiki.kernel.org/en/developers/regulatory/statement">Linux regulatory requirements</a> that govern the use of the radio frequency spectrum <a href="https://en.wikipedia.org/wiki/List_of_WLAN_channels">depending on the country</a> . <br><br>  But wait! <br><br>  I live in the US, and the link says that I have the right to initiate radiation on channels 36-48, so what's the matter?  Let's see which regulation domain is currently used: <br><br><pre> <code class="plaintext hljs">$ iw reg get country 00: DFS-UNSET (2402 - 2472 @ 40), (N/A, 20), (N/A) (2457 - 2482 @ 40), (N/A, 20), (N/A), NO-IR (2474 - 2494 @ 20), (N/A, 20), (N/A), NO-OFDM, NO-IR (5170 - 5250 @ 80), (N/A, 20), (N/A), NO-IR (5250 - 5330 @ 80), (N/A, 20), (0 ms), DFS, NO-IR (5490 - 5730 @ 160), (N/A, 20), (0 ms), DFS, NO-IR (5735 - 5835 @ 80), (N/A, 20), (N/A), NO-IR (57240 - 63720 @ 2160), (N/A, 0), (N/A)</code> </pre> <br>  The output shows that the <i>world</i> domain is now active (or not established), that is, the <b>minimum values ​​allowed in each country</b> . <br><br>  Unfortunately, manually setting the <code>sudo iw reg set</code> domain will fail, because the domain is sewn into the EEPROM: <br><br><pre> <code class="plaintext hljs">$ dmesg | grep EEPROM [ 12.123068] ath: EEPROM regdomain: 0x6c</code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5de/5a9/ae2/5de5a9ae216cf2c3f2f9416b4ffa54bc.gif"></div><br><h2>  Patch! </h2><br>  Fortunately, regulatory requirements are handled at the driver level, so they can be easily changed: we find the patch in the <a href="https://github.com/openwrt/openwrt/blob/master/package/kernel/mac80211/patches/ath/402-ath_regd_optional.patch">Open-WRT source code</a> . <br><br>  First of all, do not forget to connect the source code repository from <code>/etc/apt/sources.list</code> : <br><br><pre> <code class="bash hljs">$ cat /etc/apt/sources.list ... deb-src http://us.archive.ubuntu.com/ubuntu/ bionic main restricted ...</code> </pre> <br>  Then prepare the environment by installing the necessary dependencies: <br><br><pre> <code class="bash hljs">$ sudo apt-get install build-essential fakeroot $ sudo apt-get build-dep linux</code> </pre> <br>  Download your kernel sources: <br><br><pre> <code class="bash hljs">$ apt-get <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> linux</code> </pre> <br>  Since the <a href="https://github.com/openwrt/openwrt/blob/master/package/kernel/mac80211/patches/ath/402-ath_regd_optional.patch">original</a> Open-WRT patch cannot be applied “as is” to the Ubuntu core tree due to subtle differences in the build system, I had to fix it: <br><br><pre> <code class="bash hljs">$ VERSION=$(uname -r) $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> linux-<span class="hljs-variable"><span class="hljs-variable">${VERSION%%-*}</span></span> $ wget -O - https://gist.github.com/renaudcerrato/02de8b2e8dc013bc71326defd2ef062c/raw/a2db325e520e6442c8c12f7599d64ac1b7596a3e/402-ath_regd_optional.patch | patch -p1 -b</code> </pre> <br>  Everything is ready for assembly: <br><br><pre> <code class="bash hljs">$ fakeroot debian/rules clean $ fakeroot debian/rules binary-generic</code> </pre> <br>  If there are no problems, then now you can install the fixed kernel over the previous one: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> .. $ sudo dpkg -i linux*.deb</code> </pre> <br>  Reboot, and voila: <br><br><pre> <code class="bash hljs">$ sudo iw reg <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> US $ iw list ... Frequencies: * 5180 MHz [36] (17.0 dBm) * 5200 MHz [40] (17.0 dBm) * 5220 MHz [44] (17.0 dBm) * 5240 MHz [48] (17.0 dBm) * 5260 MHz [52] (23.0 dBm) (radar detection) * 5280 MHz [56] (23.0 dBm) (radar detection) * 5300 MHz [60] (23.0 dBm) (radar detection) * 5320 MHz [64] (23.0 dBm) (radar detection) * 5500 MHz [100] (23.0 dBm) (radar detection) * 5520 MHz [104] (23.0 dBm) (radar detection) * 5540 MHz [108] (23.0 dBm) (radar detection) * 5560 MHz [112] (23.0 dBm) (radar detection) * 5580 MHz [116] (23.0 dBm) (radar detection) * 5600 MHz [120] (23.0 dBm) (radar detection) * 5620 MHz [124] (23.0 dBm) (radar detection) * 5640 MHz [128] (23.0 dBm) (radar detection) * 5660 MHz [132] (23.0 dBm) (radar detection) * 5680 MHz [136] (23.0 dBm) (radar detection) * 5700 MHz [140] (23.0 dBm) (radar detection) * 5720 MHz [144] (23.0 dBm) (radar detection) * 5745 MHz [149] (30.0 dBm) * 5765 MHz [153] (30.0 dBm) * 5785 MHz [157] (30.0 dBm) * 5805 MHz [161] (30.0 dBm) * 5825 MHz [165] (30.0 dBm) ...</code> </pre> <br>  <i>In order to avoid automatic updating, you may need to <a href="https://help.ubuntu.com/community/PinningHowto">fix the version of the Linux kernel</a> .</i> <br><br><h2>  Configuration </h2><br>  The new <code>hostapd</code> configuration <code>hostapd</code> will be pretty simple: <code>hw_mode=a</code> includes 5 GHz bands, and <code>ieee80211ac=1</code> includes 802.11ac (VHT).  The option <code>ieee80211d=1</code> indicating <code>country_code=US</code> specifies the regulatory domain under which we operate. <br><br>  To maximize bandwidth, <code>ht_capab</code> and <code>vht_capab</code> should reflect the capabilities of the equipment: <br><br><pre> <code class="bash hljs">$ iw list ... Band 1: Capabilities: 0x19e3 RX LDPC HT20/HT40 Static SM Power Save RX HT20 SGI RX HT40 SGI TX STBC RX STBC 1-stream Max AMSDU length: 7935 bytes DSSS/CCK HT40 ... Band 2: VHT Capabilities (0x338001b2): Max MPDU length: 11454 Supported Channel Width: neither 160 nor 80+80 RX LDPC short GI (80 MHz) TX STBC RX antenna pattern consistency TX antenna pattern consistency</code> </pre> <br>  Given this, <b>here is the final</b> <code>hostapd.conf</code> : <br><br><pre> <code class="bash hljs">$ cat /etc/hostapd/hostapd.conf <span class="hljs-comment"><span class="hljs-comment">#### Interface configuration #### interface=wlp5s0 bridge=br0 driver=nl80211 ##### IEEE 802.11 related configuration ##### ssid=iCanHearYouHavingSex hw_mode=a channel=0 auth_algs=1 wmm_enabled=1 country_code=US ieee80211d=1 ieee80211h=0 ##### IEEE 802.11n related configuration ##### ieee80211n=1 ht_capab=[HT40+][SHORT-GI-20][SHORT-GI-40][TX-STBC][RX-STBC1][DSSS_CK-40][LDPC][MAX-AMSDU-7935] ##### IEEE 802.11ac related configuration ##### ieee80211ac=1 vht_capab=[MAX-MPDU-11454][RXLDPC][SHORT-GI-80][TX-STBC-2BY1][RX-STBC-1][MAX-A-MPDU-LEN-EXP7][TX-ANTENNA-PATTERN][RX-ANTENNA-PATTERN] vht_oper_chwidth=1 ##### WPA/IEEE 802.11i configuration ##### wpa=2 wpa_key_mgmt=WPA-PSK rsn_pairwise=CCMP wpa_passphrase=YouCantGuess</span></span></code> </pre> <br>  <i><code>hostpad.conf</code> documentation <code>hostpad.conf</code> <a href="https://gist.github.com/renaudcerrato/db053d96991aba152cc17d71e7e0f63c">see</a> <code>/usr/share/doc/hostapd/examples/hostapd.conf</code></i> . <br><br>  At this stage, the wireless router is fully operational, and if more complicated configuration is needed, then you can now dive into configuration files. <br><br><a name="4"></a><h1>  Configuring a virtual SSID using hostapd </h1><br>  Regardless of whether you want to configure a guest access point or a dedicated wireless network for your VPN, at some point you will have to configure a virtual SSID. <br><br><h2>  Diagram </h2><br>  Based on the <a href="https://habr.com/ru/post/437634/">current configuration</a> , here is an updated diagram of what we want to get.  Assuming <code>wlp5s0</code> is a physical wireless interface, the virtual SSID will work on the <code>wlan0</code> virtual interface using its own <code>192.168.2.0/24</code> subnet: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/096/450/32b/09645032b28e7310ad93b2109efb0860.png"><br><br><h2>  Training </h2><br>  First, verify that your wireless device supports multiple SSIDs: <br><br><pre> <code class="bash hljs">$ iw list ... valid interface combinations: * <span class="hljs-comment"><span class="hljs-comment">#{ AP, mesh point } &lt;= 8, total &lt;= 8, #channels &lt;= 1, STA/AP BI must match ...</span></span></code> </pre> <br>  As you can see, the chipset supports up to eight access points on one channel.  This means that you can configure up to seven virtual SSIDs, and all of them will work on the same channel. <br><br><h2>  Network interface </h2><br>  According to the documentation in hostapd.conf, there is a strict connection between the MAC address of the physical interface and the BSSID of the virtual interfaces: <br><br><blockquote>  hostapd will generate a BSSID mask based on the BSSIDs that are configured.  <b>hostapd will verify that dev_addr &amp; MASK == dev_addr</b> .  The address of the radio must be changed before the hostapd.  If you are using the BSSID, you can use it (eg, swap the locally administered bit) <br><br>  BSSIDs are specified using the 'bssid' parameter. <br><br>  If an explicit BSSID is specified, it must be chosen such that it: <br>  - results in a valid MASK that covers it and the dev_addr <br>  - the address of the radio is not the same. <br>  - BSSID </blockquote><br>  To meet these requirements and allow <code>hostapd</code> automatically assign the BSSID of the virtual interface (s), we’ll update the MAC address of the physical wireless interface to zero the four least significant bits.  That's enough for 15 virtual BSSIDs - a lot more than necessary. <br><br>  First we define the current MAC address: <br><br><pre> <code class="bash hljs">$ ip addr show wlp5s0 | grep link | awk <span class="hljs-string"><span class="hljs-string">'{print $2}'</span></span> 44:c3:06:00:03:eb</code> </pre> <br>  If you clear the last four bits and set the <a href="https://en.wikipedia.org/wiki/MAC_address">U / L bit</a> , you’ll get the MAC address <code>46:c3:06:00:03:e0</code> . <br><br>  Now we will update the configuration in order to set the correct MAC address right before the interface is loaded, and also announce the virtual wireless interface in accordance with our diagram: <br><br><pre> <code class="bash hljs">$ cat /etc/network/interfaces ... <span class="hljs-comment"><span class="hljs-comment"># Physical Wireless auto wlp5s0 iface wlp5s0 inet manual pre-up ip link set dev wlp5s0 address 46:c3:06:00:03:e0 # Virtual Wireless allow-hotplug wlan0 iface wlan0 inet static address 192.168.2.1 network 192.168.2.0 netmask 255.255.255.0 broadcast 192.168.2.255 post-up /usr/sbin/dnsmasq \ --pid-file=/var/run/dnsmasq-wlan0.pid \ --conf-file=/dev/null \ --interface=wlan0 --except-interface=lo \ --bind-interfaces \ --dhcp-range=192.168.2.10,192.168.2.150,24h post-down cat /var/run/dnsmasq-wlan0.pid | xargs kill ...</span></span></code> </pre> <br>  Fine.  I use <code>dnsmasq</code> as a DHCP server - feel free to replace it with something you like.  Please note that for the virtual interface to work correctly, <code>allow-hotplug</code> is required. <br><br><h2>  Access Point Configuration </h2><br>  Now the simplest thing: add a virtual SSID to the current <code>hostapd</code> configuration.  Just add this <b>to the end of the</b> existing <code>hostapd.conf</code> file: <br><br><pre> <code class="bash hljs">$ cat /etc/hostapd/hostapd.conf ... <span class="hljs-comment"><span class="hljs-comment">### Virtual SSID(s) ### bss=wlan0 ssid=MyVirtualSSID wpa=2 wpa_key_mgmt=WPA-PSK rsn_pairwise=CCMP wpa_passphrase=you_cant_guess</span></span></code> </pre> <br>  In the example above, I applied WPA2 encryption, but most of the radio interface options are available (for example, <code>channel</code> ).  You can add more virtual SSIDs by simply adding lines in the configuration file, according to the declared and properly configured virtual interfaces. <br><br>  Now we reboot and we see our new SSID along with the new wireless interface (note the MAC address): <br><br><pre> <code class="bash hljs">$ ip addr show wlan0 | grep link | awk <span class="hljs-string"><span class="hljs-string">'{print $2}'</span></span> 46:c3:06:00:03:e1</code> </pre> <br>  <b>That's it guys!</b> </div>