<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>AI and 2048. Part 1: Monte-Carlo Method</title>
  <meta name="description" content="‚Äú2048‚Äù in a few weeks turns 5 years old, which means it's time to write something dedicated to this wonderful game. 

 Particularly informative is the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>AI and 2048. Part 1: Monte-Carlo Method</h1><div class="post__text post__text-html js-mediator-article"> <a href="https://habr.com/ru/company/edison/blog/437118/"><img width="690" height="313" src="https://habrastorage.org/webt/7u/sw/lm/7uswlmwcbpmdfhrcmk0-qgp38iu.png"></a> <br><br>  ‚Äú2048‚Äù in a few weeks turns 5 years old, which means it's time to write something dedicated to this wonderful game. <br><br>  Particularly informative is the theme of independent play of artificial intelligence in a puzzle.  Ways of realization are the most different and today we will analyze the relatively easy ones.  Namely, we will teach the computer mind to collect the powers of two using the Monte Carlo method. <a name="habracut"></a><br><br><blockquote> <a href="https://www.edsd.com/" title="EDISON Software - web-development"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISON Software - web-development"></a> <br clear="right">  The article was written with the support of the EDISON Software company, which <a href="https://www.edsd.com/portfolio/mobile-applications">develops mobile applications</a> and provides <a href="https://www.edsd.com/portfolio/software-testing">software testing services</a> . </blockquote><br>  The inspiration for this work was the discussion on stackoverflow, where <a href="https://stackoverflow.com/questions/22342854/what-is-the-optimal-algorithm-for-the-game-2048">smart guys offered effective ways of playing computer games</a> .  Apparently, the best way is the minimax method with alpha-beta clipping and in a couple of days the next publication will be devoted to it. <br><br>  Casino-method proposed by the user stackoverflow <a href="https://stackoverflow.com/users/632039/ronenz"><img width="14" height="14" src="https://habrastorage.org/webt/eo/fj/at/eofjat4aio6bqe8i7xfdcg1iswo.png"></a>  <a href="https://stackoverflow.com/users/632039/ronenz">Ronenz</a> in the framework of the above discussion.  The whole next section is a translation from its publication. <br><br><h1>  Monte Carlo method </h1><br>  I became interested in the idea of ‚Äã‚ÄãAI for this game, in which <b>there</b> is <b>no hard-coded intelligence</b> (that is, there are no heuristics, scoring, etc.).  The AI ‚Äã‚Äãmust "know" only the rules of the game and "understand" the game.  This distinguishes it from the majority of AI (such as in this topic), since the gameplay is, in fact, a brute force driven by the scoring function, reflecting the human understanding of the game. <br><br><h2>  AI algorithm </h2><br>  I found a simple, but surprisingly good game algorithm: to determine the next move for a given field condition, the AI ‚Äã‚Äãplays the game in RAM, making <b>random moves</b> until the game ends in defeat.  This is done several times, while the final score is tracked.  Then the average final score is calculated taking into account the initial progress.  The initial move that showed the highest average result is selected as the actually selected move. <br><br>  With 100 runs for each initial move, the AI ‚Äã‚Äãgets to tile 2048 in 80% of cases and tile 4096 in 50% of cases.  When using 10,000 runs, 2048 is obtained in 100% of cases, 70% for 4096 and about 1% for 8192. <br><img align="right" width="352" height="524" src="https://habrastorage.org/webt/81/bo/mg/81bomgvnk-q3jy4jae0ux6ljutk.png"><br clear="left">  <a href="http://ronzil.github.io/2048-AI/">View in action</a> <br><br>  The best result achieved is shown in the screenshot: <br><br>  An interesting fact for this algorithm is that although games with randomly performed moves are expectedly rather bad, nevertheless, the choice of the best (or least bad, if you will) move leads to a very good gameplay: a typical Monte Carlo AI game can score 70,000 points for 3000 moves, but games with a random game in memory from any given position give an average of 340 additional points for about 40 additional moves before a loss.  (You can verify this yourself by running the AI ‚Äã‚Äãand opening the debug console.) <br><br>  This graph illustrates this concept: the blue line shows the score of the game after each turn.  The red line shows the <b>best</b> result of the algorithm, arbitrarily making moves from this position until the end of the game.  In fact, the red values ‚Äã‚Äã‚Äúpull up‚Äù the blue ones, since they are the best offers of the algorithm.  Interestingly, the red line is just a little above the blue line at each point, but the blue line narrows the gap more and more. <br><br><div style="text-align:center;"><img width="666" height="425" src="https://habrastorage.org/webt/ws/u5/j4/wsu5j4-k1wxxdzuk9ambg9amtv0.png"></div><br>  I find it rather surprising that the algorithm actually does not necessarily foresee a good gameplay, and nevertheless selects the moves that it (the good process) produces. <br><br>  Later, I discovered that this method can be classified as <a href="http://en.wikipedia.org/wiki/Monte-Carlo_tree_search">a Monte Carlo search algorithm</a> . <br><br><h2>  Implementation and links </h2><br>  First I created a JavaScript version that can be <a href="http://ronzil.github.io/2048-AI/">seen in action here</a> .  This version is able to run 100 runs in a reasonable time.  Open the console for more information.  ( <a href="https://github.com/ronzil/2048-AI">source</a> ) <br><br>  Later, to play around, I used the highly optimized @nneonneo infrastructure and implemented my version in C ++.  This version allows up to 100,000 runs per turn and even 1,000,000 if you are ready to wait.  Assembly instructions are attached.  Everything works in the console, and also has a remote control for playback in the web version.  ( <a href="https://github.com/ronzil/2048-ai-cpp">source</a> ) <br><br><h2>  results </h2><br>  Surprisingly, an increase in the number of runs does not drastically improve the gameplay.  It seems that this strategy has a limit of 80,000 points with a tile of 4,096 and all the lesser results very close to reaching tile 8,192. Increasing the number of runs from 100 to 100,000 increases the chances of reaching this limit (from 5% to 40%), but not overcomes it. <br><br>  Performing 10,000 runs with a temporary increase of up to 1,000,000 near critical positions made it possible to overcome this barrier in less than 1% of cases with the achievement of the maximum number of points scored at 129892 and tile 8192. <br><br><h2>  Improvements and optimizations </h2><br>  After implementing this algorithm, I tried many improvements, including the use of minimum or maximum estimates or a combination of minimum, maximum and average values.  I also tried to use depth: instead of trying to perform K runs per turn, I tried K moves for a list of moves of a given length (for example, ‚Äúup, up, left‚Äù) and selected the first move from the list of moves with the best win. <br><br>  Later, I implemented a scoring tree, which took into account the conditional probability that he would be able to complete a move after a given list of moves. <br><br>  However, none of these ideas showed a real advantage over the simple first idea.  I left commented code for these ideas in C ++ source code. <br><br>  I added the Deep Search mechanism, which temporarily increased the number of runs to 1,000,000, when any of the runs accidentally managed to reach the next highest tile.  This has led to an improvement in time indicators. <br><br>  I would be interested to know if anyone has any other improvement ideas that support the independence of AI from the subject area? <br><br><h1>  Variants and clones 2048 </h1><br>  For the sake of interest, I also implemented the AI ‚Äã‚Äãin the form of a bookmarklet, connecting it to the game controls.  This allows you to work with the original game, and with many of its variations. <br><br>  This is possible due to the domain-independent nature of AI.  Some of the options are quite original, such as a hexagonal clone. <br><br><table><tbody><tr><td>  This translation is complete, but not only for the sake of this publication was started.  Before the colic, I wanted to test various ideas for AI in 2048 myself. To this end, I implemented the game in Excel by writing an application with macros.  The implementation on VBA itself is not a feat - it‚Äôs googling, you can quickly find out with a dozen different eccentric articles.  But not only to concoct 2048 in the form of spreadsheets, but also to realize a computer independent game - this has not come across to me so far. <br></td></tr></tbody></table><br><h1>  2048.xlsm </h1><br>  The Excel application itself <a href="https://drive.google.com/open%3Fid%3D1Nrf6WrAsaWLcMAToXLkBa-sr0YLRBDts">can be downloaded from the Google disk</a> . <br><br>  The image is clickable - a full-size image will open. <br><br> <a href=""><img width="690" height="313" src="https://habrastorage.org/webt/7u/sw/lm/7uswlmwcbpmdfhrcmk0-qgp38iu.png"></a> <br><br>  Briefly on the interface and application functionality. <br><br>  To start playing, you need to click on the button " <b>User: start the game</b> ."  When you press this button again, the inscription changes from " <b>User: start the game</b> " to " <b>User: complete the game</b> " and back, that is, at any time you can stop the game and then start it again.  When you stop the game, you can manually change the alignment on the field, improving or worsening your position in order to test or test some ideas. <br><br>  During the game itself, you can make moves in two ways: <br><br><ul><li>  <b>Keyboard:</b> just by pressing the up, down, left, right keys. </li><li>  <b>Using the mouse:</b> clicking on the cells with large arrows pointing to the right direction. </li></ul><br>  The " <b>New Field</b> " button clears the playing field and randomly places "two" and "four" on it. <br><br>  The most interesting thing is that the Monte-Carlo method was implemented, precisely in the form in which it was proposed by the guy from stackoverflow.  At each position, the computer in memory goes through random branches for each first move (‚Äúup‚Äù, ‚Äúdown‚Äù, ‚Äúleft‚Äù, ‚Äúright‚Äù) until it results in a loss.  The statistically most favorable direction is highlighted in red in a special table below.  You can use it as a hint if you see that your own game comes to a standstill and you need to somehow save yourself.  ;) <br><br>  Above the table are checkboxes with analysis options.  At the moment, only Monte-Carlo is solved, the rest will be added in the coming days (according to the results of which there will be more habrastation with updating the excel application and explanations on the theory). <br><br>  There is also an " <b>AI: game</b> " button.  Clicking on it, the computer assistant will make one move in accordance with the Monte Carlo method or some other method selected in the switch group (the minimax and neural network will work in this list a little later). </div><p>Source: <a href="https://habr.com/ru/post/437118/">https://habr.com/ru/post/437118/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>