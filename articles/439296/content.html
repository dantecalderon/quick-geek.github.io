<div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c08/1b3/996/c081b39962bb7c19db0632cddbc3560f.jpg" alt="image"></div><br><br>  The physicist Lev Landau played a mental game with Soviet numbers [ <a href="https://doi.org/10.1007/s00283-017-9743-9">1</a> ].  The plates had the form of two numbers, a dash, two more numbers and some letters. <br><br><h3>  Rules of the game </h3><br>  His game was to apply mathematical operators to numbers on either side of the dash so that the dash could be replaced with an equal sign.  For example, if you take the license plate 44-74, one of the solutions would be <br><br>  <b>four!</b>  <b>+ 4 = 7 * 4</b> <br><br>  Please note that we can insert operators such as <b>!</b>  , <b>+</b> and <b>*</b> , but without adding numbers. <br><br>  Is there a solution for every possible license plate?  It depends on which operators you allow to use. <br><br>  You can trivialize the game by applying the fractional part {x} operation to both sides, since the fractional part of the integer is zero.  You can prohibit the fractional operator on the grounds that this is clearly not a mathematical operation of high school, or simply prohibit it, because it makes the game uninteresting. <a name="habracut"></a><br><blockquote>  <em><font color="#999999">The translation was made with the support of the company <a href="https://www.edsd.com/">EDISON Software</a> , which <a href="https://www.edsd.com/about/investing-in-products">invests in promising start-ups</a> , as well as <a href="https://www.edsd.com/cloud-services-and-mobile-applications-in-java">develops various cloud services</a> .</font></em> </blockquote><br><h3>  Universal solution </h3><br>  It turns out that there is a universal solution, starting with the observation that <br><br>  √ (n + 1) = sec arctan √ n. <br><br>  If one side is more than the other one, the formula above gives an immediate solution.  For example, the license plate solution 89-88 would be <br><br>  √89 = sec arctan√88. <br><br>  If the difference is greater, the formula can be applied repeatedly.  For example, we could apply the formula twice to get <br><br>  √ (n + 2) = sec arctan√ (n + 1) = sec arctan sec arctan√ n <br><br>  and therefore a possible solution for 35-37 is <br><br>  sec arctan sec arctan √35 = √37. <br><br><h3>  Kolmogorov complexity </h3><br>  Given that a solution is always possible, we can make the game more interesting by finding the simplest solution.  We have an intuitive idea of ​​what it means.  With our example 44-74, the first solution <br><br>  four!  + 4 = 7 * 4 <br><br>  simpler than a universal solution <br><br>  sec arctan sec arctan ... √44 = √74 <br><br>  which would require the use of sections and arctangents 30 times. <br><br>  The Kolmogorov complexity of an object is the length of the shortest computer program for creating an object.  We could calculate the Kolmogorov complexity of the functions applied to the numbers on each side in order to measure how complex the solution is. <br><br>  To find out, we need to specify what kind of programming language we have, and this is not as easy as it sounds.  If we think of mathematical notation as a programming language, do we want to count!  as one character and arctan as 6 characters?  It does not seem right.  If we wrote “arctan” as “atn”, we would use fewer characters without creating another solution. <br><br><h3>  Python code complexity </h3><br>  To make things more objective, we could consider the length of real computer programs, rather than presenting mathematical notation as a programming language.  Let's say we chose Python.  Then here are a couple of functions that compute our two license plate solutions 44-74. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> math <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sqrt, cos, atan <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> sec = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: <span class="hljs-number"><span class="hljs-number">1</span></span>/cos(x) y = sqrt(<span class="hljs-number"><span class="hljs-number">44</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">30</span></span>): y = sec(atan(y)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sqrt(<span class="hljs-number"><span class="hljs-number">77</span></span>)</code> </pre> <br>  We could measure the complexity of our functions f and g by counting the number of characters in each.  But there are still difficulties. <br><br>  What about imports?  Its length must be reckoned with f because it uses all the imported operators, but g used a shorter operator, which only imported sqrt.  More fundamentally, are we cheating by even importing a library? <br><br>  In addition, the above two functions do not give exactly the same result due to limited accuracy.  We can imagine that our imported functions are infinitely accurate, but then we don’t actually use Python, but rather an idealized version of Python. <br><br>  What about the cycle?  This introduced new numbers, 3 and 0, and therefore violates the rules of the Landau game.  So should we unroll the loop before we calculate the complexity? <br><br><h3>  Thought experiment </h3><br>  Kolmogorov complexity is a very useful concept, but it is more of a thought experiment than what you can calculate in practice.  We can imagine the shortest program for calculating something, but we rarely know that we really found such a program.  All that we can know in practice is the upper limits. <br><br>  Theoretically, you can list all Turing machines of a given length or all Python programs of a given length and find the shortest one that performs this task, but the list grows exponentially with increasing length. <br><br>  However, it is possible to calculate the duration of specific programs if we are dealing with some of the difficulties mentioned above.  We could make the Landau game a game for two, seeing who can offer a simpler solution in a fixed amount of time. <br><br><h3>  Back to Landau </h3><br>  If we allow sine and degree in our set of operators, then B.S.  Gorobets have a universal solution.  For n ≥ 6, n!  multiple of 360, and so <br><br>  sin (n!) ° = 0. <br><br>  And if n is less than 6, its two-digit representation starts from zero, so we can multiply the numbers to get zero. <br><br>  If we prohibit transcendental functions, we block the trick of Gorobets and we have functions, the length of which we can objectively measure in a programming language. </div>