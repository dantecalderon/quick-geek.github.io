<div class="post__text post__text-html js-mediator-article">  Object Oriented Paradigm is the standard for application software.  Relational DBMS is a standard for storing data in application software.  Yes, you can write in Haskell and store data exclusively in ClickHouse.  But talking about the mainstream. <br><br>  The ORM allows you to <s>pull an owl on a globe</s> to pretend that there is no RDBMS and the data is stored in an object model that is more suitable for OOP.  There remains a “small” such problem — this abstraction, like many others, “flows”.  Where in the object model there is a link to another object in the foreign key and id database.  At the moment of the materialization of the entity, we face a choice: <br><br><ol><li>  Download everything and drop out of memory / timeout </li><li>  Explicitly indicate which dependencies we want to download and which ones do not, and violate the principle </li><li>  Load dependencies implicitly on demand with Lazy Load and get performance problems somewhere in the called code. </li></ol><br>  Which leg should you cut off: left or right? <br><br>  <b>TLDR Lazy Load is not so bad if used only for writing and not used when reading.</b>  <b>But everything is not so simple and there are a lot of nuances.</b> <br><a name="habracut"></a><br>  Over time, I came to the conclusion that Lazy Load and / or the dependence of entities on the implementation of ORM is the lesser of evils under certain conditions. <br><br><h3>  In the read subsystem, always read only DTO </h3><br>  In 90% of cases, problems with Lazy Load arise precisely when reading.  We get a list of entities, run over it in a cycle and start to select all the necessary data.  We receive a shaft of inquiries to a DB.  In this case, most often the only thing that needs to be done is to get the data, serialize it and send it back as JSON.  Why, then, load entities at all?  There is no need to add this data to the change tracker UOW, to read the whole entity along with the “extra” fields.  Instead, you can always write either <code>Select</code> or <code><a href="http://docs.automapper.org/en/stable/Queryable-Extensions.html">ProjectTo</a></code> .  Lazy Load is not required, because the C # code from <code>Select</code> will be translated to SQL and executed on the database side. <br><br><a name="interfaces"></a><h3>  What if my logic is not translated to SQL? </h3><br>  I recommend to keep <a href="https://docs.microsoft.com/en-us/ef/core/querying/client-eval">Client Evaluation</a> off.  First, you can "help" and add support for the necessary functions <a href="http://anthonygiretti.com/2018/01/11/entity-framework-core-2-scalar-function-mapping/">directly in the subd</a> .  Not the worst option if it is a question of simple calculations, but not business rules.  Option number two: select the interface from the entity and implement it in essence and in the DTO. <br><br>  For example, there are two fields in the database: “price without discount” and “price with discount”.  If the “discount price” field is filled, then use it; if not, then use the field with the regular price.  Add another rule.  When you buy 3 products you pay only for the 2 most expensive, while the usual discounts are also taken into account. <br><br>  The implementation may be: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IHasProductPrice</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span> BasePrice { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span>? SalePrice { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Product</span></span>: <span class="hljs-title"><span class="hljs-title">IHasProductPrice</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... a lot of code public decimal BasePrice { get; protected set;} public decimal? SalePrice { get; protected set;} } public class ProductDto: IHasProductPrice { public decimal BasePrice { get; set;} public decimal? SalePrice { get; set;} } public static class ProductCalculator { public static void decimal Calculate(IEnumerable&lt;IHasProductPrice&gt; prices) }</span></span></code> </pre><br><h3>  The Lazy Load write subsystem is not so bad </h3><br>  In the write subsystem, on the contrary, quite often only the id for writing is not enough.  All sorts of checks are not rarely forced to read the essence of the whole, because the object paradigm involves the combination of data and operations on them within the object of the class and its invariant.  If DDD is used in the project, then write / change operations should be performed through the aggregation root, which means only on one object and its dependencies.  A large number of queries can occur only when working with related collections. <br><br><h3>  Related collections in aggregates </h3><br>  If there is too much data in the aggregate, this may indicate design problems.  Typical aggregation roots are basket, order, package.  People usually do not work with data from thousands of rows, so loading the entire associated collection may not be the most productive, but not lethal operation.  But if there are thousands of objects in the collection, it is possible that there really is no such aggregation root and it was invented by the developers, because it was very easy to do this with the help of improvised tools. <br><br><h3>  What if there are thousands of entries in the aggregate </h3><br>  Pass the <code>DbContext</code> to the <a href="https://docs.microsoft.com/en-us/ef/core/modeling/constructors">constructor</a> and read from it only the necessary data in the context of the operation.  Yes, we break the DIP.  Either that or not to use the unit at all in this case. <br><br><h3>  Mass operations </h3><br>  Importing a 10,000-line file is an excellent target for Lazy Load.  Here, the ChangeTracker brakes are also added to all the problems of the read subsystem.  For mass recording, you need to use separate <a href="https://github.com/borisdj/EFCore.BulkExtensions">tools</a> .  I prefer Batch Extensions, because again you can do without creating entities.  For especially severe cases, there are good old stored procedures and even <a href="https://docs.microsoft.com/en-us/sql/t-sql/statements/bulk-insert-transact-sql%3Fview%3Dsql-server-2017">special DBMS tools</a> . <br><br><h3>  Life hacking </h3><br>  If you want to implement a mass operation and an ordinary one, you need to start with a mass one.  A normal operation is just a special case of a mass, the code in the sequence is only one element. </div>