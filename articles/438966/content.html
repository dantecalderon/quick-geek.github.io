<div class="post__text post__text-html js-mediator-article">  Hello again! <br><br>  <a href="https://habr.com/ru/company/ostrovok/blog/436992/">Last time</a> we talked about choosing a tool in <a href="https://ostrovok.ru/%3Futm_source%3Dhabr%26utm_medium%3Dpr%26utm_campaign%3Dbozhok_feb19">Ostrovok.ru</a> for solving the problem of proxying a large number of requests to external services, without putting anyone at the same time.  The article ended with the choice of <a href="http://www.haproxy.org/">Haproxy</a> .  Today I will share the nuances that I had to face when using this solution. <br><br><img src="https://habrastorage.org/webt/ns/mz/sb/nsmzsbtu2c1rgib_avecisgyrlk.jpeg"><br><a name="habracut"></a><br><h3>  Haproxy configuration </h3><br>  The first difficulty was that the <code>maxconn</code> option of Haproxy is different depending on the context: <br><br><ul><li>  <a href="http://cbonte.github.io/haproxy-dconv/1.9/configuration.html">maxconn (performance tuning);</a> </li><li>  <a href="http://cbonte.github.io/haproxy-dconv/1.9/configuration.html">maxconn (bind options);</a> </li><li>  <a href="http://cbonte.github.io/haproxy-dconv/1.9/configuration.html">maxconn (server and default-server options).</a> </li></ul><br>  Out of habit, I set up only the first option ( <code>performance tuning</code> ).  This is what the documentation says about this option: <br><blockquote>  Sets the number of concurrent connections to &lt;number&gt;.  It <br>  is equivalent to the command-line argument "-n".  Proxies will stop accepting <br>  connections when this limit is reached. <br></blockquote><br>  It would seem - what you need.  However, when I stumbled upon the fact that new connections to the proxy did not pass immediately, I began to read the documentation more carefully, and there I already found the second parameter ( <code>bind options</code> ): <br><blockquote>  Limits of concurrent connections.  Extraneous <br>  connections will remain in the system backlog until a connection is <br>  released.  If unspecified, maxconn. <br></blockquote><br>  So, <code>frontends maxconn</code> go, then look for <code>frontends maxconn</code> : <br><blockquote>  Fix the maximum number of concurrent connections on a frontend <br>  ... <br>  By default, this value is set to 2000. <br></blockquote><br>  Great, what you need.  Add to the configuration: <br><br><pre> <code class="apache hljs"><span class="hljs-attribute"><span class="hljs-attribute">global</span></span> daemon maxconn 524288 ... defaults mode http maxconn 524288</code> </pre><br>  The next gag was that Haproxy is single threaded.  I am very used to the model in Nginx, so this nuance has always depressed me.  But you should not despair - Willy ( <i>Willy Tarreau - the developer of Haproxy</i> ) understood what he was doing, so he added the option - <code>nbproc</code> . <br><br>  However, right in the documentation says: <br><blockquote>  USING MULTIPLE PROCESSES <br>  IS HARDER TO DEBUG AND IS REALLY DISCOURAGED. <br></blockquote>  This option can really cause headaches if you need to: <br><br><ul><li>  limit the number of requests / connections to the servers (since you already have not one process with one counter, but many processes, and each has its own counter); </li><li>  collect statistics from the Haproxy control socket; </li><li>  enable / disable backends via a control socket; </li><li>  ... maybe something else.  ¯ \ _ (ツ) _ / ¯ </li></ul><br>  Nevertheless, the gods granted us multi-core processors, so I would like to use them to the maximum.  In my case, there were four cores in two physical cores.  For Haproxy, I selected the first core, and it looked like this: <br><br><pre> <code class="apache hljs"> <span class="hljs-attribute"><span class="hljs-attribute">nbproc</span></span> 4 cpu-map 1 0 cpu-map 2 1 cpu-map 3 2 cpu-map 4 3</code> </pre><br>  Using the <a href="http://cbonte.github.io/haproxy-dconv/1.9/configuration.html">cpu-map,</a> we link the Haproxy processes to a specific kernel.  The OS scheduler no longer needs to think about where to schedule the work of Haproxy, thereby keeping the <code>content switch</code> in the cold, and the cpu cache warm. <br><br><h4>  There are many buffers, but not in our case. </h4><br><ul><li>  <a href="http://cbonte.github.io/haproxy-dconv/1.9/configuration.html">tune.bufsize</a> - in our case it was not necessary to start it, but if you have errors with the code <code>400 (Bad Request)</code> , then perhaps this is your case. </li><li>  <a href="&amp;xid=17259,15700022,15700043,15700186,15700191,15700248,15700252&amp;usg=ALkJrhhLOccdirmHq9W7To-DORpPQY8ZXA#tune.">tune.http.cookielen</a> - if you distribute large cookies to users, it may make sense to raise this buffer to prevent damage during transmission over the network. </li><li>  <a href="&amp;xid=17259,15700022,15700043,15700186,15700191,15700248,15700252&amp;usg=ALkJrhhLOccdirmHq9W7To-DORpPQY8ZXA#tune.">tune.http.maxhdr</a> is another possible source of 400 response codes in case you have a lot of headers. </li></ul><br><h4>  Now consider the lower level stuff. </h4><br>  <a href="http://cbonte.github.io/haproxy-dconv/1.9/configuration.html">tune.rcvbuf.client</a> / <a href="http://cbonte.github.io/haproxy-dconv/1.9/configuration.html">tune.rcvbuf.server</a> , <a href="http://cbonte.github.io/haproxy-dconv/1.9/configuration.html">tune.sndbuf.client</a> / <a href="http://cbonte.github.io/haproxy-dconv/1.9/configuration.html">tune.sndbuf.server</a> - the documentation says the following: <br><blockquote>  The size of the available memory is set. <br></blockquote><br>  But for me, the obvious is better than the implicit, so I screwed up the values ​​of these options to be confident in the future. <br><br>  And one more parameter, not related to buffers, but rather important - <a href="http://cbonte.github.io/haproxy-dconv/1.9/configuration.html">tune.maxaccept</a> . <br><blockquote>  Sets the maximum number of consecutive connections <br>  row before switching to other work.  In single process mode, higher numbers <br>  give better performance at high connection rates.  However in multi-process <br>  modes, keeping a bit of fairness between processes <br>  increase performance. <br></blockquote><br>  In our case, quite a lot of requests to the proxy are generated, so I raised this value to accept more requests at once.  However, as stated in the documentation, it is worth testing that in multi-threaded mode the load is as evenly distributed as possible between processes. <br><br>  All parameters together: <br><br><pre> <code class="apache hljs"> <span class="hljs-attribute"><span class="hljs-attribute">tune</span></span>.bufsize 16384 tune.http.cookielen 63 tune.http.maxhdr 101 tune.maxaccept 256 tune.rcvbuf.client 33554432 tune.rcvbuf.server 33554432 tune.sndbuf.client 33554432 tune.sndbuf.server 33554432</code> </pre><br><h4>  What does not happen much is timeouts.  What would we do without them? </h4><br><ul><li>  <a href="http://cbonte.github.io/haproxy-dconv/1.9/configuration.html">timeout connect</a> - time to establish a connection with the backend.  If the connection with the backend is not very, then it is better to disable it by this timeout until the network returns to normal. </li><li>  <a href="http://cbonte.github.io/haproxy-dconv/1.9/configuration.html">timeout client</a> - timeout for transmission of the first bytes of data.  Well helps to disconnect those who make requests "in reserve". </li></ul><br><div class="spoiler">  <b class="spoiler_title">Kulstori about HTTP client in Go</b> <div class="spoiler_text">  Go has a regular HTTP client that has the ability to keep a pool of connections to servers.  So there was one interesting story in which the above described timeout and connection pool in the HTTP client took part.  Once a developer complained that he periodically has 408 errors from a proxy.  We looked into the client code and saw the following logic there: <br><br><ul><li>  trying to take a free established connection from the pool; </li><li>  if it does not work, we launch the installation of a new connection in Gorutin; </li><li>  check the pool again; </li><li>  if there is a free in the pool, we take it, and add a new one to the pool, if not, use a new one. </li></ul><br>  Already understand what the salt? <br><br>  If the client has established a new connection, but has not used it, then after five seconds the server closes it, and the matter ends.  The client, on the other hand, catches it only when he already takes a connection from the pool and tries to use it.  It is worth keeping this in mind. <br></div></div><br><ul><li>  <a href="http://cbonte.github.io/haproxy-dconv/1.9/configuration.html">timeout server</a> - the maximum waiting time for a response from the server. </li><li>  <a href="http://cbonte.github.io/haproxy-dconv/1.9/configuration.html">timeout client-fin</a> / <a href="http://cbonte.github.io/haproxy-dconv/1.9/configuration.html">timeout server-fin</a> - here we are protected from semi-closed connections so as not to save them in the table of the operating system. </li><li>  <a href="&amp;xid=17259,15700022,15700043,15700186,15700191,15700248,15700252&amp;usg=ALkJrhhLOccdirmHq9W7To-DORpPQY8ZXA#timeout%20">timeout http-request</a> is one of the most useful timeouts.  Allows you to chop off slow clients who can not issue an HTTP request in the time allotted to them. </li><li>  <a href="&amp;xid=17259,15700022,15700043,15700186,15700191,15700248,15700252&amp;usg=ALkJrhhLOccdirmHq9W7To-DORpPQY8ZXA#timeout%20">timeout http-keep-alive</a> - specifically in our case, if the <code>keep-alive</code> connection hangs without requests for more than 50 seconds, then, most likely, something went wrong, and the connection can be covered up, thereby freeing up memory for something new light </li></ul><br>  All timeouts together: <br><br><pre> <code class="apache hljs"><span class="hljs-attribute"><span class="hljs-attribute">defaults</span></span> mode http maxconn 524288 timeout connect 5s timeout client 10s timeout server 120s timeout client-fin 1s timeout server-fin 1s timeout http-request 10s timeout http-keep-alive 50s</code> </pre><br><h4>  Logging  Why so hard? </h4><br>  As I wrote earlier, most of the time I use Nginx in my solutions, therefore I am spoiled by its syntax and ease of modifying the log formats.  I especially liked the killer feature - to format the logs in the form of json, then to parsit them with any standard library. <br><br>  What do we have in Haproxy?  This feature is also there, only you can write only in syslog, and the configuration syntax is a bit more wrapped up. <br>  Immediately give an example of the configuration with comments: <br><br><pre> <code class="apache hljs"><span class="hljs-comment"><span class="hljs-comment"># выносим все, что касается ошибок или событий, в отдельный лог (по аналогии с # error.log в nginx) log 127.0.0.1:2514 len 8192 local1 notice emerg # здесь у нас что-то вроде access.log log 127.0.0.1:2514 len 8192 local7 info</span></span></code> </pre><br>  Special pain deliver such moments: <br><ul><li>  short variable names, and especially their combinations like% HU or% fp </li><li>  The format can not be split into several lines, so you have to write a wrapper in one line.  difficult to add / remove new / unnecessary items </li><li>  for some variables to work, they need to be explicitly declared through the capture request header </li></ul><br>  As a result, in order to get something interesting, you have to have such a footcloth: <br><br><pre> <code class="apache hljs"><span class="hljs-attribute"><span class="hljs-attribute">log</span></span>-format '{<span class="hljs-string"><span class="hljs-string">"status"</span></span>:<span class="hljs-string"><span class="hljs-string">"%ST"</span></span>,<span class="hljs-string"><span class="hljs-string">"bytes_read"</span></span>:<span class="hljs-string"><span class="hljs-string">"%B"</span></span>,<span class="hljs-string"><span class="hljs-string">"bytes_uploaded"</span></span>:<span class="hljs-string"><span class="hljs-string">"%U"</span></span>,<span class="hljs-string"><span class="hljs-string">"hostname"</span></span>:<span class="hljs-string"><span class="hljs-string">"%H"</span></span>,<span class="hljs-string"><span class="hljs-string">"method"</span></span>:<span class="hljs-string"><span class="hljs-string">"%HM"</span></span>,<span class="hljs-string"><span class="hljs-string">"request_uri"</span></span>:<span class="hljs-string"><span class="hljs-string">"%HU"</span></span>,<span class="hljs-string"><span class="hljs-string">"handshake_time"</span></span>:<span class="hljs-string"><span class="hljs-string">"%Th"</span></span>,<span class="hljs-string"><span class="hljs-string">"request_idle_time"</span></span>:<span class="hljs-string"><span class="hljs-string">"%Ti"</span></span>,<span class="hljs-string"><span class="hljs-string">"request_time"</span></span>:<span class="hljs-string"><span class="hljs-string">"%TR"</span></span>,<span class="hljs-string"><span class="hljs-string">"response_time"</span></span>:<span class="hljs-string"><span class="hljs-string">"%Tr"</span></span>,<span class="hljs-string"><span class="hljs-string">"timestamp"</span></span>:<span class="hljs-string"><span class="hljs-string">"%Ts"</span></span>,<span class="hljs-string"><span class="hljs-string">"client_ip"</span></span>:<span class="hljs-string"><span class="hljs-string">"%ci"</span></span>,<span class="hljs-string"><span class="hljs-string">"client_port"</span></span>:<span class="hljs-string"><span class="hljs-string">"%cp"</span></span>,<span class="hljs-string"><span class="hljs-string">"frontend_port"</span></span>:<span class="hljs-string"><span class="hljs-string">"%fp"</span></span>,<span class="hljs-string"><span class="hljs-string">"http_request"</span></span>:<span class="hljs-string"><span class="hljs-string">"%r"</span></span>,<span class="hljs-string"><span class="hljs-string">"ssl_ciphers"</span></span>:<span class="hljs-string"><span class="hljs-string">"%sslc"</span></span>,<span class="hljs-string"><span class="hljs-string">"ssl_version"</span></span>:<span class="hljs-string"><span class="hljs-string">"%sslv"</span></span>,<span class="hljs-string"><span class="hljs-string">"date_time"</span></span>:<span class="hljs-string"><span class="hljs-string">"%t"</span></span>,<span class="hljs-string"><span class="hljs-string">"http_host"</span></span>:<span class="hljs-string"><span class="hljs-string">"%[capture.req.hdr(0)]"</span></span>,<span class="hljs-string"><span class="hljs-string">"http_referer"</span></span>:<span class="hljs-string"><span class="hljs-string">"%[capture.req.hdr(1)]"</span></span>,<span class="hljs-string"><span class="hljs-string">"http_user_agent"</span></span>:<span class="hljs-string"><span class="hljs-string">"%[capture.req.hdr(2)]"</span></span>}'</code> </pre><br><h4>  Well, it would seem, little things, but pleasant </h4><br>  Above, I described the format of the log, but not so simple.  To deposit some items in it, such as: <br><br><ul><li>  http_host </li><li>  http_referer, </li><li>  http_user_agent, </li></ul><br>  you must first capture this data from the request ( <a href="http://cbonte.github.io/haproxy-dconv/1.9/configuration.html">capture</a> ) and place it in the array of captured values. <br><br>  Here is an example: <br><br><pre> <code class="apache hljs"><span class="hljs-attribute"><span class="hljs-attribute">capture</span></span> request header Host len 32 capture request header Referer len 128 capture request header User-Agent len 128</code> </pre><br>  As a result, we can now access the elements we need in the following way: <br>  <code>%[capture.req.hdr(N)]</code> , where N is the sequence number of the capture group definition. <br>  In the above example, the Host header is numbered 0, and the User-Agent is numbered 2. <br><br>  Haproxy has a feature: it resolves the DNS addresses of the backends at startup and, if it cannot crack one of the addresses, it drops the death of the brave. <br><br>  In our case, this is not very convenient, since there are many backends, we do not manage them, and it is better to get 503 from Haproxy than the entire proxy server refuses to start because of one supplier.  The following option helps us in this: <a href="http://cbonte.github.io/haproxy-dconv/1.9/configuration.html">init-addr</a> . <br><br>  A line taken straight from the documentation allows us to go through all the available methods for resolving an address and, in the case of a file, simply put it off until later and go further: <br><br><pre> <code class="apache hljs"><span class="hljs-attribute"><span class="hljs-attribute">default</span></span>-server init-addr last,libc,none</code> </pre> <br>  And finally - my favorite: the choice of the backend. <br>  The syntax of the Haproxy backend selection configuration is familiar to everyone: <br><br><pre> <code class="apache hljs"><span class="hljs-attribute"><span class="hljs-attribute">use_backend</span></span> &lt;backend1_name&gt; if &lt;condition1&gt; use_backend &lt;backend2_name&gt; if &lt;condition2&gt; default-backend &lt;backend3&gt;</code> </pre><br>  But the right word is somehow not very.  I have already described all the backends in an automated way (see <a href="https://habr.com/ru/company/ostrovok/blog/436992/">previous article</a> ), it would be possible to generate <code>use_backend</code> here <code>use_backend</code> , a bad thing is not tricky, but I did not want to.  As a result, there was another way: <br><br><pre> <code class="apache hljs"> <span class="hljs-attribute"><span class="hljs-attribute">capture</span></span> request header Host len 32 capture request header Referer len 128 capture request header User-Agent len 128 # выставляем переменную host_present если запрос пришел с заголовком Host acl host_present hdr(host) -m len gt 0 # вырезаем из заголовка префикс, который идентичен имени бэкенда use_backend %[req.hdr(host),lower,field(1,'.')] if host_present # а если с заголовками не срослось, то отдаем ошибку default_backend default backend default mode http server no_server 127.0.0.1:65535</code> </pre><br>  Thus, we have standardized the names of backends and URLs that can be accessed by them. <br><br>  Now compile from the above examples into one file: <br><br><div class="spoiler">  <b class="spoiler_title">Full configuration version</b> <div class="spoiler_text"><pre> <code class="apache hljs"> <span class="hljs-attribute"><span class="hljs-attribute">global</span></span> daemon maxconn 524288 nbproc 4 cpu-map 1 0 cpu-map 2 1 cpu-map 3 2 cpu-map 4 3 tune.bufsize 16384 tune.comp.maxlevel 1 tune.http.cookielen 63 tune.http.maxhdr 101 tune.maxaccept 256 tune.rcvbuf.client 33554432 tune.rcvbuf.server 33554432 tune.sndbuf.client 33554432 tune.sndbuf.server 33554432 stats socket /run/haproxy.sock mode 600 level admin log /dev/stdout local0 debug defaults mode http maxconn 524288 timeout connect 5s timeout client 10s timeout server 120s timeout client-fin 1s timeout server-fin 1s timeout http-request 10s timeout http-keep-alive 50s default-server init-addr last,libc,none log 127.0.0.1:2514 len 8192 local1 notice emerg log 127.0.0.1:2514 len 8192 local7 info log-format '{<span class="hljs-string"><span class="hljs-string">"status"</span></span>:<span class="hljs-string"><span class="hljs-string">"%ST"</span></span>,<span class="hljs-string"><span class="hljs-string">"bytes_read"</span></span>:<span class="hljs-string"><span class="hljs-string">"%B"</span></span>,<span class="hljs-string"><span class="hljs-string">"bytes_uploaded"</span></span>:<span class="hljs-string"><span class="hljs-string">"%U"</span></span>,<span class="hljs-string"><span class="hljs-string">"hostname"</span></span>:<span class="hljs-string"><span class="hljs-string">"%H"</span></span>,<span class="hljs-string"><span class="hljs-string">"method"</span></span>:<span class="hljs-string"><span class="hljs-string">"%HM"</span></span>,<span class="hljs-string"><span class="hljs-string">"request_uri"</span></span>:<span class="hljs-string"><span class="hljs-string">"%HU"</span></span>,<span class="hljs-string"><span class="hljs-string">"handshake_time"</span></span>:<span class="hljs-string"><span class="hljs-string">"%Th"</span></span>,<span class="hljs-string"><span class="hljs-string">"request_idle_time"</span></span>:<span class="hljs-string"><span class="hljs-string">"%Ti"</span></span>,<span class="hljs-string"><span class="hljs-string">"request_time"</span></span>:<span class="hljs-string"><span class="hljs-string">"%TR"</span></span>,<span class="hljs-string"><span class="hljs-string">"response_time"</span></span>:<span class="hljs-string"><span class="hljs-string">"%Tr"</span></span>,<span class="hljs-string"><span class="hljs-string">"timestamp"</span></span>:<span class="hljs-string"><span class="hljs-string">"%Ts"</span></span>,<span class="hljs-string"><span class="hljs-string">"client_ip"</span></span>:<span class="hljs-string"><span class="hljs-string">"%ci"</span></span>,<span class="hljs-string"><span class="hljs-string">"client_port"</span></span>:<span class="hljs-string"><span class="hljs-string">"%cp"</span></span>,<span class="hljs-string"><span class="hljs-string">"frontend_port"</span></span>:<span class="hljs-string"><span class="hljs-string">"%fp"</span></span>,<span class="hljs-string"><span class="hljs-string">"http_request"</span></span>:<span class="hljs-string"><span class="hljs-string">"%r"</span></span>,<span class="hljs-string"><span class="hljs-string">"ssl_ciphers"</span></span>:<span class="hljs-string"><span class="hljs-string">"%sslc"</span></span>,<span class="hljs-string"><span class="hljs-string">"ssl_version"</span></span>:<span class="hljs-string"><span class="hljs-string">"%sslv"</span></span>,<span class="hljs-string"><span class="hljs-string">"date_time"</span></span>:<span class="hljs-string"><span class="hljs-string">"%t"</span></span>,<span class="hljs-string"><span class="hljs-string">"http_host"</span></span>:<span class="hljs-string"><span class="hljs-string">"%[capture.req.hdr(0)]"</span></span>,<span class="hljs-string"><span class="hljs-string">"http_referer"</span></span>:<span class="hljs-string"><span class="hljs-string">"%[capture.req.hdr(1)]"</span></span>,<span class="hljs-string"><span class="hljs-string">"http_user_agent"</span></span>:<span class="hljs-string"><span class="hljs-string">"%[capture.req.hdr(2)]"</span></span>}' frontend http bind *:80 http-request del-header X-Forwarded-For http-request del-header X-Forwarded-Port http-request del-header X-Forwarded-Proto capture request header Host len 32 capture request header Referer len 128 capture request header User-Agent len 128 acl host_present hdr(host) -m len gt 0 use_backend %[req.hdr(host),lower,field(1,'.')] if host_present default_backend default backend default mode http server no_server 127.0.0.1:65535 resolvers dns hold valid 1s timeout retry 100ms nameserver dns1 127.0.0.1:53</code> </pre><br></div></div><br>  Thanks to those who read to the end.  However, this is not all.  Next time, we will consider lower-level things concerning the optimization of the system itself, in which Haproxy works, so that it and our operating system are comfortable together, and there is enough hardware for everyone. <br><br>  See you! </div>