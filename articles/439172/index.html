<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Extending the assert () macro to implement minimal error handling</title>
  <meta name="description" content="‚ÄúSire, I invented protection from the dragon.‚Äù He is not afraid of us anymore! It is triggered by the flapping of the wings of the dragon and includes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Extending the assert () macro to implement minimal error handling</h1><div class="post__text post__text-html js-mediator-article">  ‚ÄúSire, I invented protection from the dragon.‚Äù  He is not afraid of us anymore!  It is triggered by the flapping of the wings of the dragon and includes a loud siren, so that everyone can hear that the dragon is approaching. <br>  ‚ÄúDoes this defense do anything else?‚Äù <br>  - No, why?  We will be warned! <br>  - Yes ... Eaten by the siren howl ... And yet ... remind me when we have planned outages of electricity? ... <br><br><h3>  Description of the problem </h3><br>  This method does not claim to the concept of error handling in complex and complex projects.  Rather, it is an example of what can be done with minimal resources. <br><a name="habracut"></a><br>  A good rule is to assume that no assert () should work during the execution of a program.  And if at least one assert () worked when testing the application, then you need to send this error to the developer.  But what if the application is not fully tested?  And assert () will work for the client?  Send error to developer?  Abort program execution?  In reality, this will be a release version of the application and the standard assert () will simply be disabled.  There is also a question about the internal contradiction of the system: assert () should be a lot, which would be easier to detect errors, but assert () should be less to interrupt the user and his work with the application less.  I would not particularly like to ‚Äúfall‚Äù if it depends on the stability of work how many people use the application and if assert () was essentially insignificant (requiring correction, but allowing, for example, quite successfully to continue working). <br><br>  Such reflections make it necessary to modify assert () c / c ++.  And define your macros that extend the functionality of the standard assert () - and by adding minimal error handling.  Let such macros be. <br><br>  <b>VERIFY_EXIT (Condition);</b> <b><br></b>  <b>VERIFY_RETURN (Condition, ReturnValue);</b> <b><br></b>  <b>VERIFY_THROW (Condition, Exception);</b> <b><br></b>  <b>VERIFY_DO (Condition) {/ * fail block * /};</b> <br><br>  (These macros can be called differently. For example, VERIFY_OR_EXIT (), VERIFY_OR_RETURN (), VERIFY_OR_THROW (), VERIFY_OR_DO (). Or vice versa in a more abbreviated version.) <br><br>  These macros, firstly, have an implementation for both the debug compilation version and the release version.  That allows them to have a behavior in the release version of the program.  Those.  perform actions not only during testing, but also with the user. <br><br><h3>  Macro Description </h3><br>  (The description of macros is approximate, their other design is also possible.) <br><br>  1) <b>VERIFY_EXIT (Condition);</b> <br><br>  Checks the <b>Condition Condition</b> and if it is false, it calls the standard assert () (debug version), and also leaves the current function (debug and release version). <br><br>  2) <b>VERIFY_RETURN (Condition, ReturnValue);</b> <br><br>  Checks the <b>Condition Condition</b> and if it is false, it calls the standard assert () (debug version), and also returns from the current function returning the value <b>ReturnValue</b> (debug and release version). <br><br>  3) <b>VERIFY_THROW (Condition, Exception);</b> <br><br>  Checks the <b>Condition Condition</b> and if it is false, it calls the standard assert () (debug version), and also throws an <b>Exception exception</b> (debug and release versions). <br><br>  4) <b>VERIFY_DO (Condition) {/ * fail block * /};</b> <br><br>  Checks the <b>Condition Condition</b> and if it is false, it calls the standard assert () (debug version), and also performs a block of operations ( <b>fail block</b> ) or an operation immediately following the macro (debug and release versions). <br><br>  For all macros it is important: <br><br><ul><li>  In all cases, <b>Condition</b> must be true for the macro to ‚Äúpass through‚Äù and false to activate the minimum error handling path. </li><li>  Each of the macros implements some minimal error handling method.  This is necessary to implement the behavior in case of errors that were not detected during testing, but occurred to the user.  Depending on the implementation, you can tell the developer about the error that occurred with the client, but also each implementation provides a minimal way to recover from an error. </li></ul><br><h3>  Macro patterns </h3><br>  Of course, the most interesting, entropy supermen (heroes of reducing errors in programs), is the use of these macros. <br><br>  1) Pre and post conditions. <br><br>  The first use is pre and post conditions.  Let me remind you that pre conditions check the state of the program (input arguments, object state, variables used) for compliance with the necessary requirements of the code fragment being executed.  Post conditions (they are less common in programs) are designed to verify that we have achieved the desired result and the state of the objects remain valid for the current code fragment. <br><br>  The use of the proposed straight line macros - we register each check in a separate macro.  We select macros based on what kind of error handling we need.  (VERIFY_EXIT () - error handling with exit from this function, VERIFY_RETURN () - error handling with returning some value, VERRIFY_THROW () - error handling with exception generation, etc.) <br><br>  You can also add or use the VERIFY () macro, which will not do any error handling.  This can be useful, for example, in post conditions at the end of a function. <br><br>  These macros are completely self-sufficient, if you use the principles of clean code and allocate a sufficient number of functions to implement atomic actions.  Each function can check the state of an object, input arguments, etc.  to perform your atomic action. <br><br>  2) Transaction semantics. <br><br>  Also, these macros can be used to implement code with transaction semantics.  Such semantics is understood as: 1) gradual preparation for the operation with verification of the results of each of the preparation stages;  2) the implementation of the action only if all the stages of preparation were successful;  3) refusal to fulfill, if some conditions are not met at the preparation stage (with possible rollback from performance). <br><br>  3) Designing the code with a possible extension. <br><br>  This is especially true for libraries and general code, which may initially be developed within one context of execution conditions, and later may begin to be used with other conditions (start to use differently).  In this case, these macros can describe the "boundaries" of the functionality of the code.  Determine what was initially viewed as an error, and what was a successful implementation.  (This approach is close to the classic pre post conditions.) Of course, I write ‚Äúboundaries‚Äù in quotes, because  These boundaries can be revised, but it is important to determine (or rather transfer to future developers) knowledge about the permissible boundaries of code design. <br><br><h3>  Implementation of macros </h3><br>  I suppose that the majority of developers already have an average level that the implementation of these macros will not cause problems.  But if you need information, then I will give some important points. <br><br>  Macros must be representable as a single statement.  What can be done with the help of do {} while (false) or similar constructs.  For example: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> VERFY_EXIT(cond) \ do{bool _= (bool)(cond); assert(_); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(!_) {return;}} while(false) \ </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*end macro VERIFY_EXIT()*/</span></span></span></span></code> </pre> <br>  Then you can write the following code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) VERIFY_EXIT(a%<span class="hljs-number"><span class="hljs-number">2</span></span>==<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Of course, this is only one of the possibilities of implementation.  You can also implement macros in other ways. <br><br>  PS Successful battle with entropy, supermen! </div><p>Source: <a href="https://habr.com/ru/post/439172/">https://habr.com/ru/post/439172/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>