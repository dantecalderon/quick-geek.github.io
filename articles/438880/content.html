<div class="post__text post__text-html js-mediator-article">  Hi, Habr!  I present to you the translation of the article <a href="https://tylermcginnis.com/var-let-const/">“var vs let vs const in JavaScript”</a> by Tyler McGinnis. <br><br><img src="https://cdn-images-1.medium.com/max/2600/1*bPIf2_HXNUG4O_tSvWKYsg.png" alt="image"><br><br>  In this article you will learn 2 new ways to create variables in Javascript (ES6), let and const.  Throughout this article, we will look at the difference between <i>var</i> , <i>let</i> and <i>const</i> , as well as related topics such as: “function scope versus block scope”, “raising” of variables, and immunity. <br><a name="habracut"></a><br>  If you prefer a video, watch this (original in English): <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/6vBYfLCE9-Q" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  ES2015 (or ES6) introduced us to 2 new ways to create variables, <i>let</i> and <i>const</i> .  But before we delve into the differences between <i>var</i> , <i>let</i> and <i>const</i> , there are some topics that you should learn first.  These are the declaration of variables and their initialization, the scope (a particular scope of the function) and “elevation”. <br><br><h3>  Variable declaration and initialization </h3><br>  Variable declaration introduces a new identifier. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> declaration</code> </pre> <br>  Above, we create a new identifier which we call the “declaration”.  In Javascript, when created, variables are initialized with the value <i>undefined</i> .  This means that if we try to print our variable, we get <i>undefined</i> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> declaration <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(declaration)</code> </pre> <br>  And so, we deduced a variable <i>declaration</i> and we received <i>undefined</i> . <br><br>  Compared to declaring a variable, initializing a variable is when you first set the value of this variable. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> declaration <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(declaration) <span class="hljs-comment"><span class="hljs-comment">// undefined declaration = 'Это инициализация переменной'</span></span></code> </pre> <br>  And so, here we initialized the variable <i>declaration by</i> writing a string to it. <br><br>  This leads us to the next concept, scope. <br><cut><br><h3>  Area of ​​visibility </h3><br>  Scope characterizes where variables and functions can be accessed within our program.  In Javascript, there are 2 types of scopes - a <b>global scope</b> , and a <b>function scope</b> .  According to the official specification, <br><blockquote>  “If a variable declaration occurs inside a function declaration, the variable is defined in the local scope of this function ...” </blockquote>  This means that if you create a variable with <i>var</i> , the scope of this variable will be the function in which it was created and will only be available inside this function or any other nested function. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> date = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> date } getDate() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(date) <span class="hljs-comment"><span class="hljs-comment">// NOT OK: Reference Error</span></span></code> </pre> <br>  Above, we tried to access the variable outside the function in which it was declared.  Since the scope of the <i>date</i> variable is the <i>getDate</i> function, it is available only inside this function or in any other function nested in <i>getDate</i> (as shown below). <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> date = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">formatDate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> date.toDateString().slice(<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-comment"><span class="hljs-comment">// OK } return formatDate() } getDate() console.log(date) // NOT OK: Reference Error</span></span></code> </pre> <br>  Now let's take a look at a more advanced example.  Let's say we have an array of prices and we need a function that accepts this array, as well as a <i>discount</i> variable, and returns us a new array of prices with discounts.  The ultimate goal might look something like this: <br><br><pre> <code class="javascript hljs">discountPrices([<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">300</span></span>], <span class="hljs-number"><span class="hljs-number">.5</span></span>)</code> </pre> <br>  And the implementation might look something like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discountPrices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prices, discount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> discounted = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; prices.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> discountedPrice = prices[i] * (<span class="hljs-number"><span class="hljs-number">1</span></span> - discount) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> finalPrice = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(discountedPrice * <span class="hljs-number"><span class="hljs-number">100</span></span>) / <span class="hljs-number"><span class="hljs-number">100</span></span> discounted.push(finalPrice) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> discounted }</code> </pre> <br>  It looks simple enough, but what does this have to do with the scope of the block?  Take a look at this <i>for</i> loop.  Are variables declared inside it available outside of it?  It turns out available. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discountPrices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prices, discount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> discounted = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; prices.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> discountedPrice = prices[i] * (<span class="hljs-number"><span class="hljs-number">1</span></span> - discount) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> finalPrice = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(discountedPrice * <span class="hljs-number"><span class="hljs-number">100</span></span>) / <span class="hljs-number"><span class="hljs-number">100</span></span> discounted.push(finalPrice) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i) <span class="hljs-comment"><span class="hljs-comment">// 3 console.log(discountedPrice) // 150 console.log(finalPrice) // 150 return discounted }</span></span></code> </pre> <br>  If JavaScript is the only programming language that you know, you can not worry about it.  However, if you come to JavaScript from another programming language, in particular a programming language that blocks visibility, you are probably a little concerned about what is happening here. <br><br>  It is not broken, it just works a little weird.  There is really no reason to access <i>i</i> , <i>discountPrice</i> and <i>finalPrice</i> outside of the <i>for</i> loop.  It does not do us any good and can even harm us in some situations.  However, since variables are declared using <i>var</i> , they are included in the scope of the function and you can access them. <br><br>  Now we have discussed the declaration and initialization of variables, as well as scopes, another thing we need to figure out before we dive into the analysis of the differences between <i>let</i> and <i>const</i> , this is “elevation”. <br><br><h3>  “Raising” </h3><br>  Remember, earlier it was said “In Javascript, when created, variables are initialized with the value undefined“.  It turns out that it means “lifting”.  The JavaScript interpreter sets declared variables to <i>undefined</i> during the phase called “Creation”. <br><br>  For a more detailed look at the creation, elevation, and scope areas, read this article: <a href="https://tylermcginnis.com/ultimate-guide-to-execution-contexts-hoisting-scopes-and-closures-in-javascript/">“The Ultimate Guide to Hoisting, Scoping, and Closures in JavaScript</a> . <a href="https://tylermcginnis.com/ultimate-guide-to-execution-contexts-hoisting-scopes-and-closures-in-javascript/">”</a> <br><br>  Let's take a look at the previous example and see how “raising” affects it. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discountPrices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prices, discount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> discounted = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> discountedPrice = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> finalPrice = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> discounted = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; prices.length; i++) { discountedPrice = prices[i] * (<span class="hljs-number"><span class="hljs-number">1</span></span> - discount) finalPrice = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(discountedPrice * <span class="hljs-number"><span class="hljs-number">100</span></span>) / <span class="hljs-number"><span class="hljs-number">100</span></span> discounted.push(finalPrice) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i) <span class="hljs-comment"><span class="hljs-comment">// 3 console.log(discountedPrice) // 150 console.log(finalPrice) // 150 return discounted }</span></span></code> </pre> <br>  Note that all declared variables have been set to <i>undefined</i> .  That's why if you try to access one of them before it is actually declared, you just get <i>undefined</i> . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discountPrices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prices, discount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(discounted) <span class="hljs-comment"><span class="hljs-comment">// undefined var discounted = [] for (var i = 0; i &lt; prices.length; i++) { var discountedPrice = prices[i] * (1 - discount) var finalPrice = Math.round(discountedPrice * 100) / 100 discounted.push(finalPrice) } console.log(i) // 3 console.log(discountedPrice) // 150 console.log(finalPrice) // 150 return discounted }</span></span></code> </pre> <br>  Now you know everything you need about <i>var</i> , now let's finally talk about the main goal, because of which we are here: what is the difference between <i>var</i> , <i>let</i> and <i>const</i> ? <br><br><h3>  var, let or const </h3><br>  First, let's compare <i>var</i> and <i>let</i> .  The key difference between <i>var</i> and <i>let</i> is that <i>let,</i> in addition to the global scope and function scope, allows variables in the scope of a block to be defined.  This means that a variable created using the <i>let</i> keyword is available inside the “block” where it was created, also inside nested blocks.  When I said “block”, I meant something surrounded by curly braces {}, for example a for loop or an <i>if statement</i> . <br><br>  And so, let's go back to our <i>discountPrices</i> function for the last time. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discountPrices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prices, discount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> discounted = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; prices.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> discountedPrice = prices[i] * (<span class="hljs-number"><span class="hljs-number">1</span></span> - discount) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> finalPrice = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(discountedPrice * <span class="hljs-number"><span class="hljs-number">100</span></span>) / <span class="hljs-number"><span class="hljs-number">100</span></span> discounted.push(finalPrice) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i) <span class="hljs-comment"><span class="hljs-comment">// 3 console.log(discountedPrice) // 150 console.log(finalPrice) // 150 return discounted }</span></span></code> </pre> <br>  Recall that we have the right to output <i>i</i> , <i>discountPrice</i> , and <i>finalPrice</i> outside of the <i>for</i> loop, since they were declared with <i>var</i> , and variables declared with the <i>var</i> keyword are limited to the scope of the function.  But what happens now if we change <i>var</i> to <i>let</i> and try to run our code? <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discountPrices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prices, discount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> discounted = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; prices.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> discountedPrice = prices[i] * (<span class="hljs-number"><span class="hljs-number">1</span></span> - discount) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> finalPrice = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(discountedPrice * <span class="hljs-number"><span class="hljs-number">100</span></span>) / <span class="hljs-number"><span class="hljs-number">100</span></span> discounted.push(finalPrice) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i) <span class="hljs-comment"><span class="hljs-comment">// 3 console.log(discountedPrice) // 150 console.log(finalPrice) // 150 return discounted } discountPrices([100, 200, 300], .5) // NOT OK: ReferenceError: i is not defined</span></span></code> </pre> <br>  We received <i>ReferenceError: i is not defined</i> .  This tells us that a variable declared with <i>let</i> is limited to the scope of the block, not the function.  Try to contact <i>i</i> (or <i>discountedPrice</i> or <i>finalPrice</i> ) outside the “block” where they were declared, and this will give us a conversion error, as we just saw. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> VS <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>: ограничена областью видимости функции <span class="hljs-keyword"><span class="hljs-keyword">let</span></span>: ограничена областью видимости блока</code> </pre> <br>  The following difference is due to “uplift”.  Earlier, we said that the definition of “raising” is: “The JavaScript interpreter assigns <i>undefined</i> to declared variables during a phase called“ Creation. " <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discountPrices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prices, discount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(discounted) <span class="hljs-comment"><span class="hljs-comment">// undefined var discounted = [] for (var i = 0; i &lt; prices.length; i++) { var discountedPrice = prices[i] * (1 - discount) var finalPrice = Math.round(discountedPrice * 100) / 100 discounted.push(finalPrice) } console.log(i) // 3 console.log(discountedPrice) // 150 console.log(finalPrice) // 150 return discounted }</span></span></code> </pre> <br>  I can’t remember a single use case where you actually would like to access a variable before it is declared.  It seems that getting a <i>ReferenceError</i> would be better than getting <i>undefined</i> . <br><br>  In fact, this is what <i>let</i> does.  If you try to access a variable before declaring it with <i>let</i> , instead of getting <i>undefined</i> (as was the case when declaring with <i>var</i> ), you will get a <i>ReferenceError</i> . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discountPrices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prices, discount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(discounted) <span class="hljs-comment"><span class="hljs-comment">// NOT OK: ReferenceError let discounted = [] for (let i = 0; i &lt; prices.length; i++) { let discountedPrice = prices[i] * (1 - discount) let finalPrice = Math.round(discountedPrice * 100) / 100 discounted.push(finalPrice) } console.log(i) // 3 console.log(discountedPrice) // 150 console.log(finalPrice) // 150 return discounted }</span></span></code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> VS <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>: ограничена областью видимости функции её значение будет <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> если вы попытаетесь обратиться к ней до её объявления. let: ограничена областью видимости блока вы получите <span class="hljs-built_in"><span class="hljs-built_in">ReferenceError</span></span> если попытаетесь обратиться к ней до её объявления.</code> </pre> <br><h3>  let or const </h3><br>  Now you understand the difference between var and let, what about const?  It turns out that const is almost the same as let.  However, there is one difference: if you once assigned a value using const, you cannot change it to another. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-string"><span class="hljs-string">'Tyler'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handle = <span class="hljs-string"><span class="hljs-string">'tylermcginnis'</span></span> name = <span class="hljs-string"><span class="hljs-string">'Tyler McGinnis'</span></span> <span class="hljs-comment"><span class="hljs-comment">// OK handle = '@tylermcginnis' // NOT OK: TypeError: Assignment to constant variable.</span></span></code> </pre> <br>  The conclusion from the fact that the above - variables declared with <i>let</i> can be overwritten, and variables declared with <i>const</i> can not. <br><br>  Great, now when you want your variable to be unchanged, you can declare it with <i>const</i> .  Or not at all.  Just because a variable was declared with <i>const</i> does not mean that it is unchanged, all that it means is that it cannot be overwritten.  Below is a good example. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Kim Kardashian'</span></span> } person.name = <span class="hljs-string"><span class="hljs-string">'Kim Kardashian West'</span></span> <span class="hljs-comment"><span class="hljs-comment">// OK person = {} // NOT OK: Assignment to constant variable.</span></span></code> </pre> <br>  Note that changing an object's property is not its rewriting, so even if an object is declared with <i>const</i> , this does not mean that you cannot change any of its properties.  It only means that you cannot overwrite this object. <br><br>  Now, the most important question that has not yet been answered is: what should <i>var</i> , <i>let</i> or <i>const</i> be used for?  The most popular opinion, and the opinion of which I hold, is to always use <i>const</i> , as long as you do not know whether the variable will change.  The reason for this is that using <i>const</i> you make it clear to yourself and future developers who need to read your code that this variable should not be changed.  If you need to change it (for example, in a <i>for</i> loop), just use <i>let</i> . <br><br>  Between variables that change and variables that do not change, there are not too many cases left.  This means that you will never need to use <i>var</i> again. <br><br>  Now an unpopular opinion, although it still has a rationale, is that you should never use <i>const</i> , despite the fact that you are trying to show that this variable is constant, as we saw above, this is not exactly the case.  Developers who hold this view always use <i>let</i> as long as there are no variables that are actually constants, such as _LOCATION_ = .... <br><br>  We will summarize the above, <i>var is</i> limited to the scope of the function, and if you try to access such a variable before its declaration, you will get <i>undefined</i> .  <i>const</i> and <i>let are</i> limited to the block's scope and if you try to access these variables before they are declared, you will get a <i>ReferenceError</i> .  And the difference between <i>const</i> and <i>let</i> is that the value that was assigned to <i>const</i> cannot be overwritten, unlike <i>let</i> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> VS <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> VS <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>: ограничена областью видимости функции её значение будет <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> если вы попытаетесь обратиться к ней до её объявления. let: ограничена областью видимости блока вы получите <span class="hljs-built_in"><span class="hljs-built_in">ReferenceError</span></span> если попытаетесь обратиться к ней до её объявления. const: ограничена областью видимости блока вы получите <span class="hljs-built_in"><span class="hljs-built_in">ReferenceError</span></span> если попытаетесь обратиться к ней до её объявления. не может быть перезаписана</code> </pre> <br>  This article was originally published on <a href="https://tylermcginnis.com/var-let-const/">tylermcginnis.com</a> as part of the <a href="https://tylermcginnis.com/courses/modern-javascript/">Modern JavaScript</a> course. <br><br>  <i>Thank you for reading this translation, I hope you met something new and useful for yourself.</i>  <i>I would be happy to see feedback!</i> </cut></div>