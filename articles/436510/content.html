<div class="post__text post__text-html js-mediator-article">  Recently, I started working on a large project using Core Data.  The usual thing is that people on projects change, experience is lost, and the nuances are forgotten.  It is impossible to deepen everyone into studying a specific framework - everyone has their own working problems.  Therefore, I prepared a small presentation, from those points that I consider important or insufficiently covered in the tutorials.  I share with everyone and I hope that this will help write effective code and not make mistakes.  It is assumed that you are already a bit in the subject. <br><br>  I'll start with the banal. <br><br>  Core Data is a framework that manages and stores data in an application.  You can think of Core Data as a shell over a physical relational repository that represents data as objects, while Core Data itself is not a database. <br><br><h2>  Core Data Objects </h2><br><img src="https://habrastorage.org/webt/aq/ka/bk/aqkabk_js9w9knvyat6xp_u4u5a.png" alt="image"><br><a name="habracut"></a><br>  To create a repository, the application uses the <b>NSPersistentStoreCoordinator</b> or <b>NSPersistentContainer classes</b> .  NSPersistentStoreCoordinator creates a storage of the specified type based on the model, you can specify the location and additional options.  NSPersistentContainer can be used with IOS10, allows you to create with a minimum amount of code. <br><br>  It works as follows: if there is a database along the specified path, the coordinator checks its version and, if necessary, makes a migration.  If the base does not exist, then it is created based on the NSManagedObjectModel model.  To make it all work correctly, before making changes to the model, create a new version in Xcode through the menu Editor -&gt; Add Model Version.  If you bring the path, you can find and open the base in the emulator. <br><br><div class="spoiler">  <b class="spoiler_title">Example with NSPersistentStoreCoordinator</b> <div class="spoiler_text"><pre><code class="objectivec hljs">var persistentCoordinator: <span class="hljs-built_in"><span class="hljs-built_in">NSPersistentStoreCoordinator</span></span> = { let modelURL = Bundle.main.url(forResource: <span class="hljs-string"><span class="hljs-string">"Test"</span></span>, withExtension: <span class="hljs-string"><span class="hljs-string">"momd"</span></span>) let managedObjectModel = <span class="hljs-built_in"><span class="hljs-built_in">NSManagedObjectModel</span></span>(contentsOf: modelURL!) let persistentCoordinator = <span class="hljs-built_in"><span class="hljs-built_in">NSPersistentStoreCoordinator</span></span>(managedObjectModel: managedObjectModel!) let documentsPath = <span class="hljs-built_in"><span class="hljs-built_in">NSSearchPathForDirectoriesInDomains</span></span>(.documentDirectory, .userDomainMask, <span class="hljs-literal"><span class="hljs-literal">true</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>] let storeURL = URL(fileURLWithPath: documentsPath.appending(<span class="hljs-string"><span class="hljs-string">"/Test.sqlite"</span></span>)) print(<span class="hljs-string"><span class="hljs-string">"storeUrl = \(storeURL)"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { try persistentCoordinator.addPersistentStore(ofType: <span class="hljs-built_in"><span class="hljs-built_in">NSSQLiteStoreType</span></span>, configurationName: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, at: storeURL, options: [<span class="hljs-built_in"><span class="hljs-built_in">NSSQLitePragmasOption</span></span>: [<span class="hljs-string"><span class="hljs-string">"journal_mode"</span></span>:<span class="hljs-string"><span class="hljs-string">"MEMORY"</span></span>]]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> persistentCoordinator } catch { abort() } } ()</code> </pre> <br></div></div><div class="spoiler">  <b class="spoiler_title">Example with NSPersistentContainer</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">var persistentContainer: <span class="hljs-built_in"><span class="hljs-built_in">NSPersistentContainer</span></span> = { let container = <span class="hljs-built_in"><span class="hljs-built_in">NSPersistentContainer</span></span>(name: <span class="hljs-string"><span class="hljs-string">"CoreDataTest"</span></span>) container.loadPersistentStores(completionHandler: { (storeDescription, error) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> print(<span class="hljs-string"><span class="hljs-string">"storeDescription = \(storeDescription)"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let error = error as <span class="hljs-built_in"><span class="hljs-built_in">NSError</span></span>? { fatalError(<span class="hljs-string"><span class="hljs-string">"Unresolved error \(error), \(error.userInfo)"</span></span>) } }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> container } ()</code> </pre><br></div></div><br>  Core Data uses 4 types of storage: <br><br>  - SQLite <br>  - Binary <br>  - In-Memory <br>  - XML ​​(Mac OS only) <br><br>  If, for example, for security reasons you do not want to store data in a file form, but you also want to use caching during the session and data in the form of objects, an “In-Memory” storage is quite suitable.  Actually, it is not forbidden to have several repositories of different types in one application. <br><br>  I would like to say a few words about the <b>NSManagedObjectContext</b> object.  In general, Apple provides a rather vague wording for NSManagedObjectContext - an environment for working with Core Data objects.  All this comes from the desire to dissociate from associations with relational databases, and to present Core Data as an easy-to-use tool that does not require an understanding of keys, transactions, and other database attributes.  But in the language of relational databases NSManagedObjectContext can, in a sense, be called a transaction manager.  You probably noticed that it has save and rollback methods, although most likely you use only the first one. <br><br>  A misunderstanding of this simple fact leads to the use of a single-context model, even in situations where it is not enough.  For example, you are editing a large document, and at the same time you needed to load a couple of reference books.  At what point do you call save?  If we were working with a relational database, then there would be no questions, since each operation would be performed in its own transaction.  In Core Data, there is also a quite convenient way to solve this problem - this is a branch of the child context.  But unfortunately, it is for some reason rarely used.  Here is a good <a href="https://habr.com/ru/post/238901/">article</a> on this topic. <br><br><h2>  Inheritance </h2><br>  For some reason I do not understand, there are a very large number of manuals and examples where inheritance for Entity / NSManagedObject (tables) is not used at all.  Meanwhile, it is a very convenient tool.  If you do not use inheritance, then you can assign values ​​to attributes (fields) only through the KVC mechanism, which does not check the names and types of attributes, and this can easily lead to runtime errors. <br><br>  Class overrides for NSManagedObject are done in Core Data Designer: <br><br><img src="https://habrastorage.org/webt/ce/52/_p/ce52_pz39mzguhyiotm5rvhh00k.png" alt="image"><br><br><h2>  Inheritance and Code Generation </h2><br>  After specifying the class name for Entity, you can use code generation and get a class with ready-made code: <br><br><img src="https://habrastorage.org/webt/al/dn/7a/aldn7aozwsnv-l7sjv8vau4iwmi.png" alt="image"><br><br><img src="https://habrastorage.org/webt/kj/ra/kh/kjrakhjgijvth5obsls22g6vtjk.png" alt="image"><br><br>  If you want to see the auto-generated code, but at the same time, do not want to add files to the project, you can use another way: set the Entity option "Codegen".  In this case, the code must be searched in ../DerivedData/ ... <br><br><img src="https://habrastorage.org/webt/zg/vw/9e/zgvw9e3sulaf6g7qici-uitdsei.png" alt="image"><br><br>  Use code generation to create classes, typos in variable names can lead to runtime errors. <br><br>  Something like this will be generated: <br><br><pre> <code class="objectivec hljs">@objc public <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Company: <span class="hljs-built_in"><span class="hljs-built_in">NSManagedObject</span></span> {    @<span class="hljs-built_in"><span class="hljs-built_in">NSManaged</span></span> public var inn: String?  @<span class="hljs-built_in"><span class="hljs-built_in">NSManaged</span></span> public var name: String?  @<span class="hljs-built_in"><span class="hljs-built_in">NSManaged</span></span> public var uid: String?  @<span class="hljs-built_in"><span class="hljs-built_in">NSManaged</span></span> public var employee: <span class="hljs-built_in"><span class="hljs-built_in">NSSet</span></span>? }</code> </pre><br>  In swift, @NSManaged has the same meaning as <a href="https://habr.com/ru/users/dynamic/" class="user_link">dynamic</a> in Objective C. <br>  Core Data itself takes care of obtaining data (has internal accessors) for the attributes of its classes.  If you have transit fields, then you need to add functions to calculate them. <br><br>  Classes inherited from NSManagedObject (tables) did not have an “ordinary” constructor before IOS10, unlike other classes.  To create an object of type Company, it was necessary to write a rather cumbersome construct using the NSEntityDescription.  Now there is a more convenient method of initialization through context (NSManagedObjectContext).  Code below.  Pay attention to the advantage of inheritance when assigning attributes to the KVC mechanism: <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 - создание записи через NSEntityDescription, присвоение значений через KVO let company1 = NSEntityDescription.insertNewObject(forEntityName: "Company", into: moc) company1.setValue("077456789111", forKey: "inn") company1.setValue("Натура кура", forKey: "name") // 2 - создание записи через NSEntityDescription, присвоение значений через свойства let company2 = NSEntityDescription.insertNewObject(forEntityName: "Company", into: moc) as! Company company2.inn = "077456789222" company2.name = "Крошка макарошка" // 3 - создание записи через инициализатор (IOS10+), присвоение значений через свойства let company3 = Company(context: moc) company3.inn = "077456789222" company3.name = "Крошка макарошка"</span></span></code> </pre><br><h2>  Namespace for NSManagedObject </h2><br>  Another thing worth mentioning is the namespace. <br><br><img src="https://habrastorage.org/webt/fk/a7/wl/fka7wlfqlf4cvi1ezcqst4kiiyi.png" alt="image"><br><br>  You will have no difficulty if you are working on ObjectiveC or Swift.  Usually, this field is filled in correctly by default.  But in mixed projects, it may be a surprise for you that for classes in swift and ObjectiveC you need to set different options.  In Swift, the "Module" must be filled.  If this field is not filled in, a prefix with the name of the project will be added to the class name, which will cause an execution error.  In Objetive C “Module” leave empty, otherwise NSManagedObject will not be found when accessing it through the class name. <br><br><h2>  Connections between objects </h2><br>  In principle, the topic of relationships is well covered, but I want to focus on how to add child entities to the parent.  Therefore, first quickly recall the mechanism for creating relationships.  Consider the traditional example, the company - employees, one-to-many communication: <br><br><ul><li>  Create a link on each side (table) </li><li>  After this, the Inverse field becomes available, it must be filled in each table. </li></ul><br><img src="https://habrastorage.org/webt/_m/fx/si/_mfxsi_lcnxt8t3zlhh0vbrbsus.png" alt="image"><br><br><img src="https://habrastorage.org/webt/kb/uo/my/kbuomy1etksutabvijrvxlztiyy.png" alt="image"><br><br>  Apple very much insists on specifying inverse relationships.  At the same time, inversion does not enhance connectivity, but helps Core Data to track changes on both sides of the connection; this is important for caching and updating information. <br><br>  It is also important to correctly specify the removal rule.  The delete rule is an action that will be executed on this object when the parent object is deleted. <br><br><ul><li>  Cascade - deleting all child objects when deleting the parent. </li><li>  Deny - prohibition of deleting a parent if there is a child </li><li>  Nullify - reset parent reference </li><li>  No action - the action is not specified, will issue a warning when compiling </li></ul><br>  In this example, if you delete a company, all employees will be deleted (cascade).  When you delete an employee, the link to him in the company will be reset (pre screen) <br><br><h2>  Ways to add child entities to parent </h2><br>  <b>1)</b> The first way is to add via NSSet.  For example, add 2 employees to the company: <br><br><pre> <code class="objectivec hljs">let set = <span class="hljs-built_in"><span class="hljs-built_in">NSMutableSet</span></span>();    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let employee1 = <span class="hljs-built_in"><span class="hljs-built_in">NSEntityDescription</span></span>.insertNewObject(forEntityName: <span class="hljs-string"><span class="hljs-string">"Employee"</span></span>, into: moc) as? Employee { employee1.firstName = <span class="hljs-string"><span class="hljs-string">"Дима"</span></span> employee1.secondName = <span class="hljs-string"><span class="hljs-string">"Васильев"</span></span> set.add(employee1) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let emploee2 = <span class="hljs-built_in"><span class="hljs-built_in">NSEntityDescription</span></span>.insertNewObject(forEntityName: <span class="hljs-string"><span class="hljs-string">"Employee"</span></span>, into: moc) as? Employee { employee2.firstName = <span class="hljs-string"><span class="hljs-string">"Наташа"</span></span> employee2.secondName = <span class="hljs-string"><span class="hljs-string">"Ростова"</span></span> set.add(employee2) }    company.employee = set</code> </pre><br>  This method is convenient for the initial initialization of an object or when filling a database.  There is a small nuance.  If the company already had employees, and you assigned a new set, then the former employees will reset the link to the company, but they will not be deleted.  As an option, you can get a list of employees and work with this set already. <br><br><pre> <code class="objectivec hljs">let set = company.mutableSetValue(forKey: <span class="hljs-string"><span class="hljs-string">"employee"</span></span>)</code> </pre> <br>  <b>2)</b> Adding child objects through parent ID <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let employee = <span class="hljs-built_in"><span class="hljs-built_in">NSEntityDescription</span></span>.insertNewObject(forEntityName: <span class="hljs-string"><span class="hljs-string">"Employee"</span></span>, into: moc) as? Employee { employee.firstName = <span class="hljs-string"><span class="hljs-string">"Маша"</span></span> employee.secondName = <span class="hljs-string"><span class="hljs-string">"Богданова"</span></span> employee.company = company }</code> </pre><br>  The second method is convenient when adding or editing a child object in <br>  separate form. <br><br>  <b>3)</b> Adding child objects through auto-generated methods <br><br><pre> <code class="objectivec hljs">extension Company {    @objc(addEmployeeObject:)  @<span class="hljs-built_in"><span class="hljs-built_in">NSManaged</span></span> public func addEmployee(_ value: Employee)    @objc(removeEmployeeObject:)  @<span class="hljs-built_in"><span class="hljs-built_in">NSManaged</span></span> public func removeFromEmployee(_ value: Employee)    @objc(addEmployee:)  @<span class="hljs-built_in"><span class="hljs-built_in">NSManaged</span></span> public func addEmployee(_ values: <span class="hljs-built_in"><span class="hljs-built_in">NSSet</span></span>)    @objc(removeEmployee:)  @<span class="hljs-built_in"><span class="hljs-built_in">NSManaged</span></span> public func removeFromEmployee(_ values: <span class="hljs-built_in"><span class="hljs-built_in">NSSet</span></span>) }</code> </pre><br>  For the sake of completeness, it is useful to know about this method, but somehow it was not useful to me, and I delete the extra code in order not to overload the project. <br><br><h2>  Requests with a condition on a child element </h2><br>  In Core Data, you cannot make an arbitrary query between any data, as we can do in SQL.  But between dependent objects it is easy to follow using the standard predicate.  Below is an example of a query that selects all companies in which there is an employee with the specified name: <br><br><pre> <code class="objectivec hljs">public <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> func getCompanyWithEmployee(name: String) -&gt; [Company] { let request = <span class="hljs-built_in"><span class="hljs-built_in">NSFetchRequest</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">NSFetchRequestResult</span></span>&gt;(entityName: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.className()) request.predicate = <span class="hljs-built_in"><span class="hljs-built_in">NSPredicate</span></span>(format: <span class="hljs-string"><span class="hljs-string">"ANY employee.firstName = %@"</span></span>, name) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let result = try moc.fetch(request) as? [Company] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result } } catch { } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [Company]() }</code> </pre><br>  The method call in the code will look like this: <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// выбрать комании, где работает Миша let companies = Company.getCompanyWithEmployee(name: "Миша")</span></span></code> </pre><br>  Do not use transit fields in requests, their values ​​are not defined at the time of the request.  Errors will not happen, but the result will be wrong. <br><br><h2>  Setting Attributes (Fields) </h2><br>  You may have noticed that the attributes of the Entity have several options. <br>  C optional everything is clear from the title. <br><br>  The option “use scalar type” appeared in swif.  In Objective-C, scalar types are not used for attributes, since they cannot be nil.  Attempting to assign a scalar value to an attribute via KVC will cause an execution error.  From here it becomes clear why attribute types in Core Data do not have a strict correspondence with language types.  In swift and mixed projects, scalar-type attributes can be used. <br><br>  Transit attributes are calculated fields that are <b>not</b> stored in the database.  They can be used for encryption.  These attributes get values ​​through the redefined accessor, or by assigning primitives as needed (for example, overriding willSave and awakeFromFetch). <br><br><h2>  Attribute accessors: </h2><br>  If you do not need to use calculated fields, for example, do encryption or something else, then you can not even think about what are accessories accessories.  Meanwhile, the operations of obtaining and assigning values ​​to attributes are not “atomic”.  To understand what I mean, see the code below: <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// чтение let name = company.name // чтение company.willAccessValue(forKey: "name") let name = company.primitiveValue(forKey: "name") company.didAccessValue(forKey: "name") // присвоение company.name = "Азбука укуса" // присвоение company.willChangeValue(forKey: "name") company.setPrimitiveValue("Азбука укуса", forKey: "name") company.didChangeValue(forKey: "name")</span></span></code> </pre><br>  Use primitives in the NSManagedObject event, instead of the usual assignment, to avoid looping.  Example: <br><br><pre> <code class="objectivec hljs">override func willSave() {   let nameP = encrypt(field: primitiveValue(forKey: <span class="hljs-string"><span class="hljs-string">"name"</span></span>), password: password)   setPrimitiveValue(nameP, forKey: <span class="hljs-string"><span class="hljs-string">"nameC"</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.willSave() }  override func awakeFromFetch() {   let nameP = decrypt(field: primitiveValue(forKey: <span class="hljs-string"><span class="hljs-string">"nameC"</span></span>), password: password)   setPrimitiveValue(nameP, forKey: <span class="hljs-string"><span class="hljs-string">"name"</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.awakeFromFetch() }</code> </pre><br>  If suddenly you have to screw the awakeFromFetch function into a project, you will be surprised that it works very strangely, but in fact it is not called when you execute the request.  This is due to the fact that Core Data has a very intelligent caching mechanism, and if the sample is already in memory (for example, due to the fact that you just filled this table), then the method will not be called.  Nevertheless, my experiments have shown that in terms of calculated values, you can safely rely on the use of awakeFromFetch, the same Apple documentation says.  If for testing and development you need to forcefully call awakeFromFetch, add managedObjectContext.refreshAllObjects () before the request. <br><br>  That's all. <br><br>  Thanks to everyone who read to the end. </div>