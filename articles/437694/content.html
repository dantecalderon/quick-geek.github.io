<div class="post__text post__text-html js-mediator-article">  Not finding anywhere sensible description in Russian, that for the beast <b>Files.walkFileTree ()</b> , and with a creak having mastered it, as it turned out later, simple functionality, I decided to share in the framework of fixing material with examples, which I missed so much. <br><br>  The walkFileTree () method allows you to bypass the tree of files and subdirectories passed to it as a parameter of the Path element ... <br><a name="habracut"></a><br>  <b>Two method signatures</b> <br><br><pre><code class="java hljs">Files.walkFileTree(Path start, FileVisitor&lt;? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> Path&gt; visitor); Files.walkFileTree(Path start, Set&lt;FileVisitOption&gt; options, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxDepth, FileVisitor&lt;? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> Path&gt; visitor);</code> </pre> <br>  Where <br>  Path start - directory, the contents of which will be bypassed, <br>  FileVisitor visitor is an instance of the class that implements the FileVisitor interface, or inherits from SimpleFileVisitor ().  The latter, in my opinion, is more convenient to use when you do not need to override all FileVisitor () methods, which will be discussed below (but everything depends on the situation), <br>  Set &lt;\ FileVisitOption&gt; options - a set of options that determine the behavior when traversing, <br>  maxDepth - the depth of the subdirectories. <br><br>  <b>First, about the parameters that sooner or later come in handy.</b> <br><br>  <i>maxDepth</i> - traversal depth.  At = 0, the directory will not be entered, at = MAX_VALUE the directory will be studied to the maximum depth, respectively, at maxDepth = 3, the passage will be carried out on 3 subdirectories "down". <br><br>  <i>FileVisitOption</i> - enum set, which determines whether the program should follow symbolic links when crawling (in this case, the value FileVisitOption.FOLLOW_LINKS is specified). <br><br>  <b>FileVisitor</b> is an interface that has 4 methods: <br><br>  <b>1)</b> <i>FileVisitResult preVisitDirectory (T dir, BasicFileAttributes attrs) throws IOException;</i> <br>  includes a set of methods that should be performed before visiting the current subdirectory.  For example, through attrs you can get from such data as: <br>  lastModifiedTime () <br>  lastAccessTime (), <br>  creationTime (), <br>  isRegularFile () - true if we have a file, <br>  isDirectory () - true if we have a directory <br>  isSymbolicLink () - true if the object is a link, <br>  isOther () is true if the object in question is neither a file, nor a directory, nor a link, <br>  size () - returns the size of the object and <br>  fileKey () - returns the file key or null; <br><br>  If during the crawling process it is planned to count the number of directories, we should not forget that the start directory will also be taken into account in the total amount. <br><br>  <b>2)</b> <i>FileVisitResult visitFile (T file, BasicFileAttributes attrs) throws IOException;</i> <br>  a set of methods that should be performed during a visit to the current file (you can, for example, rummage through its contents and search for occurrences of the search string, or again find out the date of the last visit, change the file or fold the size of all files to crawl the directory size) <br><br>  <b>Example</b> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyFileVisitor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleFileVisitor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Path</span></span></span><span class="hljs-class">&gt; </span></span>{ String partOfName; String partOfContent; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> FileVisitResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visitFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Path file, BasicFileAttributes attrs)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> containsName = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(partOfName!=<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; !file.getFileName().toString().contains(partOfName)) containsName = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; String content = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(Files.readAllBytes(file)); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> containsContent = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(partOfContent!=<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; !content.contains(partOfContent)) containsContent = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(containsName &amp;&amp; containsContent) foundFiles.add(file); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FileVisitResult.CONTINUE; }</code> </pre> <br>  In this example, when traversing the file tree, each file is checked for the simultaneous execution of 2 events - whether the file name contains the desired entry and whether the body of the file contains the occurrence of the required string.  When both conditions are met, the file is added to the result sheet, after which the crawl continues; <br><br>  Or another <b>example of</b> overloading the visitFile method. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> FileVisitResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visitFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Path path, BasicFileAttributes attrs)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(path.toString().endsWith(<span class="hljs-string"><span class="hljs-string">".rar"</span></span>) || path.toString().endsWith(<span class="hljs-string"><span class="hljs-string">".zip"</span></span>)) archived.add(path.toString()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FileVisitResult.CONTINUE; }</code> </pre> <br>  The program during a tree traversal when visiting a file, in case it is a zip or rar archive, adds its address (path) as a string to the list of archive files; <br><br>  <b>3)</b> <i>FileVisitResult visitFileFailed (T file, IOException exc) throws IOException;</i> <br>  This method can be useful in case of file access error + it “can” throw Exception.  The rest can be taught through the Override annotation.  For example, count the number of files that could not be accessed; <br><br>  <b>Example</b> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> FileVisitResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visitFileFailed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Path path, IOException exc)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ failed.add(path.toString()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FileVisitResult.SKIP_SUBTREE; }</code> </pre> <br>  In the case of an unsuccessful attempt to access the path, the given path as a string is added to the failed sheet for it like it, and the program continues bypassing without visiting its subdirectory; <br><br>  <b>4)</b> <i>FileVisitResult postVisitDirectory (T dir, IOException exc) throws IOException;</i> <br>  Everything that needs to be done after visiting the directory should be listed as part of the overload of this method.  For example, having gone through the directory and destroying all the files in it, this method can also destroy it itself (we remember that Files.delete (Path dir) only deletes the directory if it is empty and does not contain any files). <br><br>  <b>Example</b> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> FileVisitResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postVisitDirectory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Path path, IOException exc)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ Files.delete(path); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FileVisitResult.CONTINUE; }</code> </pre> <br>  All the above methods finish working, returning the “visit results” (FileVisitResult) of an object that belong to the enum set and can take the following values: <br><br><ol><li>  <code>CONTINUE</code> - continues to traverse the tree; </li><li>  <code>TERMINATE</code> - finishes tree traversal; </li><li>  <code>SKIP_SUBTREE</code> - continues traversing, without entering this directory; </li><li>  <code>SKIP_SIBLINGS</code> - excludes from bypassing the "relatives" of the file or directory; </li></ol></div>