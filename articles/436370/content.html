<div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/tk/9x/m3/tk9xm3b0z6etzpbcvbk2qypdgmo.png" align="left"><blockquote>  The <a href="https://habr.com/ru/post/417735/">“H” time is</a> inexorably approaching: “the use of the signature scheme GOST R 34.10-2001 for the formation of a signature after December 31, 2018 is not allowed!”. </blockquote><a name="habracut"></a>  However, then something went wrong, someone was not ready, and the use of GOST R 34.10-2001 was extended to 2019.  But suddenly everyone rushed to transfer the TC to GOST R 34.10-2012, and to transfer ordinary citizens to new certificates.  There were several certificates in the hands of people.  When checking certificates or an electronic signature, questions began to arise, and where to get the root certificates to install in the trusted root certificate stores. <br><br>  This applies to both the certificate store in Windows and the certificate store in Firefox and Google Chrome, <a href="https://habr.com/ru/post/417735/">GnuPG</a> , <a href="https://habr.com/ru/post/428429/">LibreOffice</a> , <a href="https://habr.com/ru/post/316736/">mail clients</a> and even <a href="https://habr.com/ru/post/415423/">OpenSSL</a> .  Of course, it was necessary to attend to this when obtaining a certificate in the CA and record the chain of certificates on a USB flash drive.  On the other hand, we also have a digital society and at any time should be able to get this chain from the network.  How to do this on the pages of Habr <a href="https://habr.com/ru/post/304458/">showed</a> <a href="https://habr.com/ru/users/simpleadmin/" class="user_link">simpleadmin</a> .  However, for an ordinary citizen it is still difficult (especially if we bear in mind that the absolute majority of them are on Windows): you need to have “some” openssl, the fetch utility, which I didn’t have on the computer, and not everyone knows that you can use wget instead.  And how many actions you need to perform.  There is a way out, of course, write a script, but not just a script on top of openssl and others like it, but packaged in a self-sufficient executable module for various platforms. <br><br>  On what to write there were no doubts - on <a href="https://habr.com/ru/post/335842/">Tcl and Python</a> .  And we start with Tcl and <a href="https://www.linux.org.ru/forum/development/12833014/page1">this is why</a> : <br><blockquote>  * Awesome <a href="http://wiki.tcl.tk/">wiki</a> , where there are <a href="http://wiki.tcl.tk/20801">even toys</a> (there you can peek at interesting :) <br>  * <a href="http://pleac.sourceforge.net/pleac_tcl/index.html">cheat sheets</a> <br>  * normal <a href="https://code.google.com/archive/p/tclkit/downloads">tclkit builds</a> (1.5 - 2 MB as payment for real cross-platform) <br>  * and my favorite <a href="http://wiki.tcl.tk/15260">eTcl</a> build <a href="http://wiki.tcl.tk/15260">from Evolane</a> (carefully saved from the deceased site :( <br>  keep a high Tcl / Tk rating on my personal tool list <br>  and yes, <a href="http://wiki.tcl.tk/16867">wiki.tcl.tk/16867</a> (a small web server from cgi to Tcl, periodically used with an enviable constancy under tclkit) <br>  and more - it's just <a href="https://habrahabr.ru/post/89919/">beautiful</a> and <a href="https://habrahabr.ru/post/89822/">beautiful</a> :) </blockquote>  To this, I would add the presence of the <a href="http://freewrap.sourceforge.net/">freewrap</a> utility, which will help us build standalone utilities for Linux and MS Windows.  As a result, we will have the chainfromcert utility: <br><br><pre><code class="bash hljs">bash-4.3$ ./chainfromcert_linux64 Copyright(C)2019 Usage: chainfromcert &lt;file with certificate&gt; &lt;directory <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> chain certificate&gt; Bad usage! bash-4.3$</code> </pre> <br>  As parameters, the utility is given a file with a user certificate (both in PEM and DER format) and a directory in which CA certificates that are included in the chain will be saved: <br><br><pre> <code class="bash hljs">bash-4.3$ ./chainfromcert_linux64 ./cert_test.der /tmp Loading file: cert_test.der Directory <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> chain: . cert 1 from http://ca.ekey.ru/cdp/ekeyUC2012.cer cert 2 from http://reestr-pki.ru/cdp/guc_gost12.crt Goodby! Length chain=2 Copyright(C) 2019 bash-4.3$</code> </pre> <br>  Now consider how the utility works. <br>  Information about the certification center that issued the certificate to the user is stored in the extension with oid-ohm 1.3.6.1.5.5.7.1.1.  This extension can store both the CA certificate location (oid 1.3.6.1.5.5.7.48.2) and the CA OCSP service information (oid 1.3.6.1.5.5.7.48.1): <br><br><img src="https://habrastorage.org/webt/v2/rg/n5/v2rgn5yw6sjb3pygp-vziqcvrys.png"><br><br>  And information, for example, about the period of use of a key of an electronic signature is stored in the extension with oid-ohm 2.5.29.16. <br><br>  To parse the certificate and access the certificate extensions, we will use the pki package: <br><br><pre> <code class="plaintext hljs">#!/usr/bin/tclsh -f package require pki</code> </pre> <br>  We will also need the base64 package: <br><br><pre> <code class="plaintext hljs">package require base64</code> </pre> <br>  The pki package, as well as the asn package that it loads, and the base64 package will help us convert certificates from PEM to DER encoding, parse ASN structures, and actually access information about the location of CA certificates. <br><br>  The utility starts with checking the parameters and downloading the file with the certificate: <br><br><pre> <code class="plaintext hljs">proc usage {use } { puts "Copyright(C) LISSI-Soft Ltd (http://soft.lissi.ru) 2011-2019" if {$use == 1} { puts "Usage:\nchainfromcert &lt;file with certificate&gt; &lt;directory for chain certificate&gt;\n" } } if {[llength $argv] != 2 } { usage 1 puts "Bad usage!" exit } set file [lindex $argv 0] if {![file exists $file]} { puts "File $file not exist" usage 1 exit } puts "Loading file: $file" set dir [lindex $argv 1] if {![file exists $dir]} { puts "Dir $dir not exist" usage 1 exit } puts "Directory for chain: $dir" set fd [open $file] chan configure $fd -translation binary set data [read $fd] close $fd if {$data == "" } { puts "Bad file with certificate=$file" usage 1 exit }</code> </pre> <br>  Here everything is clear and we only note one thing - the file with the certificate is treated as a binary file: <br><br><pre> <code class="plaintext hljs">chan configure $fd -translation binary</code> </pre> <br>  This is due to the fact that the certificate can be stored both in DER format (binary code) and in PEM format (base64 - encoding). <br><br>  After the file is loaded, the chainfromcert procedure is called: <br><br><pre> <code class="plaintext hljs">set depth [chainfromcert $data $dir]</code> </pre>  which actually loads root certificates: <br><br><pre> <code class="plaintext hljs">proc chainfromcert {cert dir} { if {$cert == "" } { exit } set asndata [cert_to_der $cert] if {$asndata == "" } { #Файл содержит все что угодно, только не сертификат return -1 } array set cert_parse [::pki::x509::parse_cert $asndata] array set extcert $cert_parse(extensions) if {![info exists extcert(1.3.6.1.5.5.7.1.1)]} { #В сертификате нет расширений return 0 } set a [lindex $extcert(1.3.6.1.5.5.7.1.1) 0] # if {$a == "false"} { # puts $a # } #Читаем ASN1-последовательность расширения в Hex-кодировке set b [lindex $extcert(1.3.6.1.5.5.7.1.1) 1] #Переводим в двоичную кодировку set c [binary format H* $b] #Sequence 1.3.6.1.5.5.7.1.1 ::asn::asnGetSequence c c_par_first #Цикл перебора значений в засширении 1.3.6.1.5.5.7.1.1 while {[string length $c_par_first] &gt; 0 } { #Выбираем очередную последовательность (sequence) ::asn::asnGetSequence c_par_first c_par #Выбираем oid из последовательности ::asn::asnGetObjectIdentifier c_par c_type set tas1 [::pki::_oid_number_to_name $c_type] #Выбираем установленное значение ::asn::asnGetContext c_par c_par_two #Ищем oid с адресом корневого сертификата if {$tas1 == "1.3.6.1.5.5.7.48.2" } { #Читаем очередной корневой сертификат set certca [readca $c_par $dir] if {$certca == ""} { #Прочитать сертификат не удалось. Ищем следующую точку с сертификатом continue } else { global count #Сохраняем корневой сертификат в указанном каталоге set f [file join $dir [file tail $c_par]] set fd [open $fw] chan configure $fd -translation binary puts -nonewline $fd $certca close $fd incr count puts "cert $count from $c_par" #ПОДЫМАЕМСЯ по ЦЕПОЧКЕ СЕРТИФИКАТОВ ВВЕРХ chainfromcert $certca $dir continue } } elseif {$tas1 == "1.3.6.1.5.5.7.48.1" } { # puts "OCSP server (oid=$tas1)=$c_par" } } # Цепочка закончилась return $count }</code> </pre> <br>  There is nothing to add to the comments, but the readca procedure remains unresolved: <br><pre> <code class="plaintext hljs">proc readca {url dir} { set cer "" #Читаем сертификат в бинарном виде if {[catch {set token [http::geturl $url -binary 1] #получаем статус выполнения функции set ere [http::status $token] if {$ere == "ok"} { #Получаем код возврата с которым был прочитан сертификат set code [http::ncode $token] if {$code == 200} { #Сертификат успешно прочитан и будет созвращен set cer [http::data $token] } elseif {$code == 301 || $code == 302} { #Сертификат перемещен в другое место, получаем его set newURL [dict get [http::meta $token] Location] #Читаем сертификат с другого сервера set cer [readca $newURL $dir] } else { #Сертификат не удалось прочитать set cer "" } } } error]} { #Сертификат не удалось прочитать, нет узла в сети set cer "" } return $cer }</code> </pre> <br>  This procedure is based on using the http package: <br><br><pre> <code class="plaintext hljs">package require http</code> </pre> <br>  To read the certificate, we use the following function: <br><br><pre> <code class="plaintext hljs">set token [http::geturl $url -binary 1]</code> </pre> <br>  The purpose of the remaining functions used is clear from the comments.  We give only the decoding of return codes for the function http :: ncodel: <br><blockquote>  200 Request successfully completed <br>  206 The request was successful, but only a part of the file could be downloaded. <br>  301 File moved to another location. <br>  302 File is temporarily moved to another location. <br>  401 Server authentication required <br>  403 Access to this resource is denied. <br>  404 The specified resource could not be found. <br>  500 Internal error </blockquote>  There is one procedure not considered, namely cert_to_der: <br><br><pre> <code class="plaintext hljs">proc cert_to_der {data} { set lines [split $data \n] set hlines 0 set total 0 set first 0 #Ищем PEM-сертификат в файле foreach line $lines { incr total if {[regexp {^-----BEGIN CERTIFICATE-----$} $line]} { if {$first} { incr total -1 break } else { set first 1 incr hlines } } if {[regexp {^(.*):(.*)$} $line ]} { incr hlines } } if { $first == 0 &amp;&amp; [string range $data 0 0 ] == "0" } { #Очень похоже на DER-кодировку "0" == 0x30 return $data } if {$first == 0} {return ""} set block [join [lrange $lines $hlines [expr {$total-1}]]] #from PEM to DER set asnblock [base64::decode $block] return $asnblock }</code> </pre> <br>  The procedure is very simple.  If this is a PEM file with a certificate ("----- BEGIN CERTIFICATE -----"), then the body of this file is selected and converted to bin code: <br><br><pre> <code class="plaintext hljs">set asnblock [base64::decode $block]</code> </pre> <br>  If it is not a PEM file, then this “similarity” to the asn encoding is checked (the zero bit must be 0x30). <br><br>  That's all, it remains to add the final lines: <br><br><pre> <code class="plaintext hljs">if {$depth == -1} { puts "Bad file with certificate=$file" usage 1 exit } puts "Goodby!\nLength chain=$depth" usage 0 exit</code> </pre><br>  Now we collect everything in a single file with the name <br><br><div class="spoiler">  <b class="spoiler_title">chainfromcert.tcl</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#!/usr/bin/tclsh encoding system utf-8 package require pki package require base64 #package require asn package require http global count set count 0 proc chainfromcert {cert dir} { if {$cert == "" } { exit } set asndata [cert_to_der $cert] if {$asndata == "" } { #Файл содержит все что угодно, только не сертификат return -1 } array set cert_parse [::pki::x509::parse_cert $asndata] array set extcert $cert_parse(extensions) if {![info exists extcert(1.3.6.1.5.5.7.1.1)]} { #В сертификате нет расширений return 0 } set a [lindex $extcert(1.3.6.1.5.5.7.1.1) 0] # if {$a == "false"} { # puts $a # } #Читаем ASN1-последовательность расширения в Hex-кодировке set b [lindex $extcert(1.3.6.1.5.5.7.1.1) 1] #Переводим в двоичную кодировку set c [binary format H* $b] #Sequence 1.3.6.1.5.5.7.1.1 ::asn::asnGetSequence c c_par_first #Цикл перебора значений в засширении 1.3.6.1.5.5.7.1.1 while {[string length $c_par_first] &gt; 0 } { #Выбираем очередную последовательность (sequence) ::asn::asnGetSequence c_par_first c_par #Выбираем oid из последовательности ::asn::asnGetObjectIdentifier c_par c_type set tas1 [::pki::_oid_number_to_name $c_type] #Выбираем установленное значение ::asn::asnGetContext c_par c_par_two #Ищем oid с адресом корневого сертификата if {$tas1 == "1.3.6.1.5.5.7.48.2" } { #Читаем очередной корневой сертификат set certca [readca $c_par $dir] if {$certca == ""} { #Прочитать сертификат не удалось. Ищем следующую точку с сертификатом continue } else { global count #Сохраняем корневой сертификат в указанном каталоге set f [file join $dir [file tail $c_par]] set fd [open $fw] chan configure $fd -translation binary puts -nonewline $fd $certca close $fd incr count puts "cert $count from $c_par" #ПОДЫМАЕМСЯ по ЦЕПОЧКЕ СЕРТИФИКАТОВ ВВЕРХ chainfromcert $certca $dir continue } } elseif {$tas1 == "1.3.6.1.5.5.7.48.1" } { # puts "OCSP server (oid=$tas1)=$c_par" } } # Цепочка закончилась return $count } proc readca {url dir} { set cer "" #Читаем сертификат в бинарном виде if {[catch {set token [http::geturl $url -binary 1] #получаем статус выполнения функции set ere [http::status $token] if {$ere == "ok"} { #Получаем код возврата с которым был прочитан сертификат set code [http::ncode $token] if {$code == 200} { #Сертификат успешно прочитан и будет созвращен set cer [http::data $token] } elseif {$code == 301 || $code == 302} { #Сертификат перемещен в другое место, получаем его set newURL [dict get [http::meta $token] Location] #Читаем сертификат с другого сервера set cer [readca $newURL $dir] } else { #Сертификат не удалось прочитать set cer "" } } } error]} { #Сертификат не удалось прочитать, нет узла в сети set cer "" } return $cer } proc cert_to_der {data} { set lines [split $data \n] set hlines 0 set total 0 set first 0 #Ищем PEM-сертификат в файле foreach line $lines { incr total # if {[regexp {^-----(.*?)-----$} $line]} {} if {[regexp {^-----BEGIN CERTIFICATE-----$} $line]} { if {$first} { incr total -1 break } else { set first 1 incr hlines } } if {[regexp {^(.*):(.*)$} $line ]} { incr hlines } } if { $first == 0 &amp;&amp; [string range $data 0 0 ] == "0" } { #Очень похоже на DER-кодировку "0" == 0x30 return $data } if {$first == 0} {return ""} set block [join [lrange $lines $hlines [expr {$total-1}]]] #from PEM to DER set asnblock [base64::decode $block] return $asnblock } proc usage {use } { puts "Copyright(C) LISSI-Soft Ltd (http://soft.lissi.ru) 2011-2019" if {$use == 1} { puts "Usage:\nchainfromcert &lt;file with certificate&gt; &lt;directory for chain certificate&gt;\n" } } if {[llength $argv] != 2 } { usage 1 puts "Bad usage!" exit } set file [lindex $argv 0] if {![file exists $file]} { puts "File $file not exist" usage 1 exit } puts "Loading file: $file" set dir [lindex $argv 1] if {![file exists $dir]} { puts "Dir $dir not exist" usage 1 exit } puts "Directory for chain: $dir" set fd [open $file] chan configure $fd -translation binary set data [read $fd] close $fd if {$data == "" } { puts "Bad file with certificate=$file" usage 1 exit } set depth [chainfromcert $data $dir] if {$depth == -1} { puts "Bad file with certificate=$file" usage 1 exit } puts "Goodby!\nLength chain=$depth" usage 0 exit</code> </pre><br></div></div><br>  You can check the operation of this file using the tclsh interpreter: <br><br><pre> <code class="plaintext hljs">$ tclsh ./chainfromcert.tcl cert_orlov.der /tmp Loading file: cert_test.der Directory for chain: /tmp cert 1 from http://ca.ekey.ru/cdp/ekeyUC2012.cer cert 2 from http://reestr-pki.ru/cdp/guc_gost12.crt Goodby! Length chain=2 Copyright(C) 2019 $</code> </pre> <br>  As a result, we got a chain of two certificates in the / tmp directory. <br><br>  But we wanted to get executable modules for the Linux and Windows platforms, and so that users would not think about any interpreters. <br><br>  For this purpose, we will use the <a href="https://sourceforge.net/projects/freewrap/files/freewrap/freeWrap%25206.64/">freewrapTCLSH</a> utility.  With the help of this utility we will make the executable modules of our utility for Linux and Windows platforms, both 32-bit and 64-bit.  Utility assembly can be carried out for all platforms on any of the platforms.  Sorry for the tautology.  I will collect on linux_x86_64 (Mageia). <br><br>  For the assembly will require: <br><blockquote>  1. The freewrapTCLSH utility for the linux_x86_64 platform; <br>  2. File freewrapTCLSH with this utility for each platform: <br>  - freewrapTCLSH_linux32 <br>  - freewrapTCLSH_linux64 <br>  - freewrapTCLSH_win32 <br>  - freewrapTCLSH_win64 <br>  3. The source file of our utility: chainfromcert.tcl </blockquote>  So, the executable chainfromcerty_linuxx86 executable for the Linux x86 platform: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$freewrapTCLSH</span></span> chainfromcert.tcl –w freewrapTCLSH_linux32 –o chainfromcerty_linuxx86 $</code> </pre> <br>  Building a utility for the Windows 64-bit platform looks like this: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$freewrapTCLSH</span></span> chainfromcert.tcl –w freewrapTCLSH_win64 –o chainfromcerty_win64.exe $</code> </pre> <br>  Etc.  Utilities are ready to use.  Everything necessary for their work they have absorbed. <br>  The code is written in the same way in Python. <br><br>  In the coming days, I think to supplement the <a href="https://habr.com/ru/post/421107/">fsb795</a> package (and it is written in Python) with the function of obtaining the root certificate chain. </div>