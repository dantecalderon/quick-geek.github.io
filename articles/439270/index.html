<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>An example of parsing C ++ code using libclang in Python</title>
  <meta name="description" content="On one personal project in C ++, I needed to get information about the types of objects during the execution of the application. C ++ has a built-in R...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>An example of parsing C ++ code using libclang in Python</h1><div class="post__text post__text-html js-mediator-article"><p>  On one personal project in C ++, I needed to get information about the types of objects during the execution of the application.  C ++ has a built-in Run-Time Type Information (RTTI) mechanism, and of course the first thought was to use it, but I decided to write my own implementation, because I didn‚Äôt want to pull the entire built-in mechanism, because I needed only a small part of its functionality.  I also wanted to try to practice new features of C ++ 17, with which I was not particularly familiar. </p><br><p>  In this post I will provide an example of working with the libclang parser in the Python language. </p><a name="habracut"></a><br><p>  I will omit the details of releasing my RTTI.  The following points are important for us in this case: </p><br><ul><li> Each class or structure that can provide information about its type must inherit the <code>IRttiTypeIdProvider</code> interface; </li><li>  In each such class (if it is not abstract), you must add the macro <code>RTTI_HAS_TYPE_ID</code> , which adds a static field of the type pointer to the <code>RttiTypeId</code> object.  Thus, to obtain a type identifier, you can write <code>MyClass::__typeId</code> or call the <code>getTypeId</code> method <code>getTypeId</code> a specific instance of the class at runtime. </li></ul><br><p>  Example: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include "RTTI.h" struct BaseNode : public IRttiTypeIdProvider { virtual ~BaseNode() = default; bool bypass = false; }; struct SourceNode : public BaseNode { RTTI_HAS_TYPE_ID std::string inputFilePath; }; struct DestinationNode : public BaseNode { RTTI_HAS_TYPE_ID bool includeDebugInfo = false; std::string outputFilePath; }; struct MultiplierNode : public BaseNode { RTTI_HAS_TYPE_ID double multiplier; }; struct InverterNode : public BaseNode { RTTI_HAS_TYPE_ID };</span></span></span></span></code> </pre> <br><p>  It was already possible to work with this, but after a while I needed to get information about the fields of these classes: the name of the field, the offset and the size.  To implement all this, you will have to manually form a structure with a description of each field of the class of interest somewhere in the .cpp file.  Having written several macros, the description of the type and its fields began to look like this: </p><br><pre> <code class="cpp hljs">RTTI_PROVIDER_BEGIN_TYPE(SourceNode) ( RTTI_DEFINE_FIELD(SourceNode, bypass) RTTI_DEFINE_FIELD(SourceNode, inputFilePath) ) RTTI_PROVIDER_END_TYPE() RTTI_PROVIDER_BEGIN_TYPE(DestinationNode) ( RTTI_DEFINE_FIELD(DestinationNode, bypass) RTTI_DEFINE_FIELD(DestinationNode, includeDebugInfo) RTTI_DEFINE_FIELD(DestinationNode, outputFilePath) ) RTTI_PROVIDER_END_TYPE() RTTI_PROVIDER_BEGIN_TYPE(MultiplierNode) ( RTTI_DEFINE_FIELD(MultiplierNode, bypass) RTTI_DEFINE_FIELD(MultiplierNode, multiplier) ) RTTI_PROVIDER_END_TYPE() RTTI_PROVIDER_BEGIN_TYPE(InverterNode) ( RTTI_DEFINE_FIELD(InverterNode, bypass) )</code> </pre> <br><p>  And this is only for 4 classes.  What problems can be identified? </p><br><ol><li>  When copying blocks of code manually, you can overlook the name of the class when defining the field (accumulated a block from SourceNode for DestinationNode, but in one of the fields they forgot to change SourceNode to DestinationNode).  The compiler will skip everything, the application may not even fall, but the field information will be incorrect.  And if you record or read data based on information from such a field, everything will explode (as they say, but I don‚Äôt want to check it myself). </li><li>  If you add a field to the base class, then you need to update ALL entries. </li><li>  If you change the name or the order of the fields in the class, then you need to remember to update the name and order in this bag of code. </li></ol><br><p>  But the main thing - all this needs to be written manually.  When it comes to such a monotonous code, I get very lazy and look for a way to generate it automatically, even if it takes more time and effort than manual writing. </p><br><p>  Python helps me with this, I write scripts on it to solve such problems.  But we are dealing not just with template text, but with text built on the basis of C ++ source code.  We need a tool to get information about C ++ code, and libclang will help us with this. </p><br><blockquote>  <a href="https://clang.llvm.org/docs/Tooling.html">libclang</a> is a high-level C-interface for Clang.  Provides APIs for tools to parse source code in an abstract syntax tree (AST), load already analyzed ASTs, bypass ASTs, match locations of a physical source with elements within ASTs, and other tools from the Clang set. </blockquote><p>  As follows from the description, libclang provides a C-interface, and to work with it through Python you need a binding library (binding).  At the time of this writing, there is no official such library for Python, but from the unofficial there is this <a href="https://github.com/ethanhs/clang">https://github.com/ethanhs/clang</a> . </p><br><p>  Install it through the package manager: </p><br><pre> <code class="plaintext hljs">pip install clang</code> </pre> <br><p>  The library is provided with comments in the result code.  But to understand the libclang device, you need to read the <a href="https://clang.llvm.org/doxygen/group__CINDEX.html">libclang documentation</a> .  There are not many examples of using the library, and there are no comments explaining why everything works like this and not otherwise.  Those who already had experience with libclang will have fewer questions, but personally I didn‚Äôt have that experience, so I had to notably dig in the code and poke around in the debugger. </p><br><p>  Let's start with a simple example: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> clang.cindex index = clang.cindex.Index.create() translation_unit = index.parse(<span class="hljs-string"><span class="hljs-string">'my_source.cpp'</span></span>, args=[<span class="hljs-string"><span class="hljs-string">'-std=c++17'</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> translation_unit.get_tokens(extent=translation_unit.cursor.extent): <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (i.kind)</code> </pre> <br><p>  This creates an object of type <code>Index</code> , which can parse a file with C ++ code.  The <code>parse</code> method returns an object of type <code>TranslationUnit</code> ; this is a unit of code translation.  <code>TranslationUnit</code> is an AST node (node), and each AST node stores information about its position in the source code (extent).  We cycle through all the tokens in the <code>TranslationUnit</code> and display the type of these tokens (the property of kind). </p><br><p>  For example, take the following C ++ code: </p><br><pre> <code class="plaintext hljs">class X {}; class Y {}; class Z : public X {};</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Script Execution Result</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">TokenKind.KEYWORD TokenKind.IDENTIFIER TokenKind.PUNCTUATION TokenKind.PUNCTUATION TokenKind.PUNCTUATION TokenKind.KEYWORD TokenKind.IDENTIFIER TokenKind.PUNCTUATION TokenKind.PUNCTUATION TokenKind.PUNCTUATION TokenKind.KEYWORD TokenKind.IDENTIFIER TokenKind.PUNCTUATION TokenKind.KEYWORD TokenKind.IDENTIFIER TokenKind.PUNCTUATION TokenKind.PUNCTUATION TokenKind.PUNCTUATION</code> </pre> </div></div><br><p>  Now let's handle AST.  Before writing Python code, let's see what we generally expect from the clang parser.  Run the clang in dump mode AST: </p><br><pre> <code class="plaintext hljs">clang++ -cc1 -ast-dump my_source.cpp</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">The result of the command</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">TranslationUnitDecl 0xaaaa9b9fa8 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; |-TypedefDecl 0xaaaa9ba880 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __int128_t '__int128' | `-BuiltinType 0xaaaa9ba540 '__int128' |-TypedefDecl 0xaaaa9ba8e8 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __uint128_t 'unsigned __int128' | `-BuiltinType 0xaaaa9ba560 'unsigned __int128' |-TypedefDecl 0xaaaa9bac48 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __NSConstantString '__NSConstantString_tag' | `-RecordType 0xaaaa9ba9d0 '__NSConstantString_tag' | `-CXXRecord 0xaaaa9ba938 '__NSConstantString_tag' |-TypedefDecl 0xaaaa9e6570 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __builtin_ms_va_list 'char *' | `-PointerType 0xaaaa9e6530 'char *' | `-BuiltinType 0xaaaa9ba040 'char' |-TypedefDecl 0xaaaa9e65d8 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __builtin_va_list 'char *' | `-PointerType 0xaaaa9e6530 'char *' | `-BuiltinType 0xaaaa9ba040 'char' |-CXXRecordDecl 0xaaaa9e6628 &lt;my_source.cpp:1:1, col:10&gt; col:7 referenced class X definition | |-DefinitionData pass_in_registers empty aggregate standard_layout trivially_copyable pod trivial literal has_constexpr_non_copy_move_ctor can_const_default_init | | |-DefaultConstructor exists trivial constexpr needs_implicit defaulted_is_constexpr | | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param | | |-MoveConstructor exists simple trivial needs_implicit | | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param | | |-MoveAssignment exists simple trivial needs_implicit | | `-Destructor simple irrelevant trivial needs_implicit | `-CXXRecordDecl 0xaaaa9e6748 &lt;col:1, col:7&gt; col:7 implicit class X |-CXXRecordDecl 0xaaaa9e6800 &lt;line:3:1, col:10&gt; col:7 class Y definition | |-DefinitionData pass_in_registers empty aggregate standard_layout trivially_copyable pod trivial literal has_constexpr_non_copy_move_ctor can_const_default_init | | |-DefaultConstructor exists trivial constexpr needs_implicit defaulted_is_constexpr | | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param | | |-MoveConstructor exists simple trivial needs_implicit | | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param | | |-MoveAssignment exists simple trivial needs_implicit | | `-Destructor simple irrelevant trivial needs_implicit | `-CXXRecordDecl 0xaaaa9e6928 &lt;col:1, col:7&gt; col:7 implicit class Y `-CXXRecordDecl 0xaaaa9e69e0 &lt;line:5:1, col:21&gt; col:7 class Z definition |-DefinitionData pass_in_registers empty standard_layout trivially_copyable trivial literal has_constexpr_non_copy_move_ctor can_const_default_init | |-DefaultConstructor exists trivial constexpr needs_implicit defaulted_is_constexpr | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param | |-MoveConstructor exists simple trivial needs_implicit | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param | |-MoveAssignment exists simple trivial needs_implicit | `-Destructor simple irrelevant trivial needs_implicit |-public 'X' `-CXXRecordDecl 0xaaaa9e6b48 &lt;col:1, col:7&gt; col:7 implicit class Z</code> </pre> </div></div><br><p>  Here <code>CXXRecordDecl</code> is the type of the node representing the class declaration.  You may notice that there are more such nodes here than the classes in the source file.  This is because reference nodes are represented by the same type, i.e.  nodes that are links to other nodes.  In our case, the indication of the base class is the reference.  When disassembling this tree, the reference node can be determined using a special flag. </p><br><p>  Now we will write a script that lists the classes in the source file: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> clang.cindex <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> typing index = clang.cindex.Index.create() translation_unit = index.parse(<span class="hljs-string"><span class="hljs-string">'my_source.cpp'</span></span>, args=[<span class="hljs-string"><span class="hljs-string">'-std=c++17'</span></span>]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter_node_list_by_node_kind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( nodes: typing.Iterable[clang.cindex.Cursor], kinds: list )</span></span></span><span class="hljs-function"> -&gt; typing.Iterable[clang.cindex.Cursor]:</span></span> result = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> nodes: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i.kind <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> kinds: result.append(i) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result all_classes = filter_node_list_by_node_kind(translation_unit.cursor.get_children(), [clang.cindex.CursorKind.CLASS_DECL, clang.cindex.CursorKind.STRUCT_DECL]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> all_classes: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (i.spelling)</code> </pre><br><p>  The class name is stored in the <code>spelling</code> property.  For different types of nodes, the <code>spelling</code> value may contain some type modifiers, but for a class or structure declaration it contains the name without modifiers. </p><br><p>  Result of performance: </p><br><pre> <code class="plaintext hljs">X Y Z</code> </pre> <br><p>  When parsing AST, clang also parses files connected via <code>#include</code> .  Try adding <code>#include &lt;string&gt;</code> to the source, and in the dump you will get 84 thousand lines, which is obviously a bit much to solve our problem. </p><br><p>  To view the AST dump of such files via the command line, it is better to delete all <code>#include</code> .  Bring them back when you study AST and get an idea of ‚Äã‚Äãthe hierarchy and types in the file of interest. </p><br><p>  In the script, in order to filter only the AST belonging to the source file, and not connected via <code>#include</code> , you can add the following filtering function by file: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter_node_list_by_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( nodes: typing.Iterable[clang.cindex.Cursor], file_name: str )</span></span></span><span class="hljs-function"> -&gt; typing.Iterable[clang.cindex.Cursor]:</span></span> result = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> nodes: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i.location.file.name == file_name: result.append(i) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result ... filtered_ast = filter_by_file(translation_unit.cursor, translation_unit.spelling)</code> </pre> <br><p>  Now you can do field extraction.  Below is the full code that generates a list of fields <em>, taking into account inheritance</em> and generates text from the template.  There is nothing clang specific, so no comments. </p><br><div class="spoiler">  <b class="spoiler_title">Full script code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> clang.cindex <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> typing index = clang.cindex.Index.create() translation_unit = index.parse(<span class="hljs-string"><span class="hljs-string">'Input.h'</span></span>, args=[<span class="hljs-string"><span class="hljs-string">'-std=c++17'</span></span>]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter_node_list_by_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( nodes: typing.Iterable[clang.cindex.Cursor], file_name: str )</span></span></span><span class="hljs-function"> -&gt; typing.Iterable[clang.cindex.Cursor]:</span></span> result = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> nodes: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i.location.file.name == file_name: result.append(i) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter_node_list_by_node_kind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( nodes: typing.Iterable[clang.cindex.Cursor], kinds: list )</span></span></span><span class="hljs-function"> -&gt; typing.Iterable[clang.cindex.Cursor]:</span></span> result = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> nodes: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i.kind <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> kinds: result.append(i) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_exposed_field</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(node)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node.access_specifier == clang.cindex.AccessSpecifier.PUBLIC <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_all_exposed_fields</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( cursor: clang.cindex.Cursor )</span></span></span><span class="hljs-function">:</span></span> result = [] field_declarations = filter_node_list_by_node_kind(cursor.get_children(), [clang.cindex.CursorKind.FIELD_DECL]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> field_declarations: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> is_exposed_field(i): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> result.append(i.displayname) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result source_nodes = filter_node_list_by_file(translation_unit.cursor.get_children(), translation_unit.spelling) all_classes = filter_node_list_by_node_kind(source_nodes, [clang.cindex.CursorKind.CLASS_DECL, clang.cindex.CursorKind.STRUCT_DECL]) class_inheritance_map = {} class_field_map = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> all_classes: bases = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> i.get_children(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node.kind == clang.cindex.CursorKind.CXX_BASE_SPECIFIER: referenceNode = node.referenced bases.append(node.referenced) class_inheritance_map[i.spelling] = bases <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> all_classes: fields = find_all_exposed_fields(i) class_field_map[i.spelling] = fields <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">populate_field_list_recursively</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(class_name: str)</span></span></span><span class="hljs-function">:</span></span> field_list = class_field_map.get(class_name) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> field_list <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [] baseClasses = class_inheritance_map[class_name] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> baseClasses: field_list = populate_field_list_recursively(i.spelling) + field_list <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> field_list rtti_map = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> class_name, class_list <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> class_inheritance_map.items(): rtti_map[class_name] = populate_field_list_recursively(class_name) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> class_name, field_list <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rtti_map.items(): wrapper_template = <span class="hljs-string"><span class="hljs-string">"""\ RTTI_PROVIDER_BEGIN_TYPE(%s) ( %s ) RTTI_PROVIDER_END_TYPE() """</span></span> rendered_fields = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> field_list: rendered_fields.append(<span class="hljs-string"><span class="hljs-string">" RTTI_DEFINE_FIELD(%s, %s)"</span></span> % (class_name, f)) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (wrapper_template % (class_name, <span class="hljs-string"><span class="hljs-string">",\n"</span></span>.join(rendered_fields)))</code> </pre></div></div><br><p>  This script does not take into account whether the class has RTTI.  Therefore, after obtaining the result, you will have to manually remove the blocks describing classes without RTTI.  But it is a trifle. </p><br><p>  I hope someone will be useful and save time.  <a href="https://github.com/tekord/Python-Clang-RTTI-Generator-Example">All code is posted on GitHub</a> . </p></div><p>Source: <a href="https://habr.com/ru/post/439270/">https://habr.com/ru/post/439270/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>