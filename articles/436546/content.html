<div class="post__text post__text-html js-mediator-article"><p>  Today, multi-scale tests of the data request team from the database took place, the development process of which was described <a href="https://habr.com/ru/post/436228/">here</a> and <a href="https://habr.com/ru/post/436348/">here</a> in detail and <strong>very verbally</strong> . </p><br><p>  What did the tests show?  The team works, but ... in the usage scenario in which it has to be activated, it is inconvenient to configure. <a name="habracut"></a></p><br><p>  As I mentioned in the first publication, as much as possible for each data exchange with a KYC service provider, relatively many entries should be selected from the database.  More than a dozen.  The behavior of the algorithm for extracting a record from the database is identical within each request; only the settings change.  If I had first written an integration test that demonstrates the combat usage scenario, I would understand which key details should not be overlooked.  An integration test might look like this: </p><br><pre><code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'configure and run database requests'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> context = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../src/storage/requestContext'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> requestHandler = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../src/storage/requestHandler'</span></span>); it(<span class="hljs-string"><span class="hljs-string">'should get full recordset from db'</span></span>, (done) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> context.rules.keys()) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> handle = requestHandler.bind(context, [key]); context.store.subscribe(handle); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> assert = checkDataIsReady.bind(context, [done]); context.store.subscribe(assert); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> note = { <span class="hljs-attr"><span class="hljs-attr">Id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">UserId</span></span>: <span class="hljs-number"><span class="hljs-number">38</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'NOTE'</span></span>, note }; context.store.dispatch(start); }); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkDataIsReady</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">args</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(notAllDataIsHereYet()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; checkUserRecord(); <span class="hljs-comment"><span class="hljs-comment">// // Здесь добавляем нужный код, проверяющий // что все записи из базы данных загружены // const checkIsCompleted = args[0]; checkIsCompleted(); } function notAllDataIsHereYet(){ // // Здесь код, который проверяет // все ли данные получены из базы // return false; } function checkUserRecord(){ const user = context.store.getState().user; expect(user.Id).toEqual(38); expect(user.Name).toEqual('Jack'); } });</span></span></code> </pre> <br><p>  The cardinality of the difference is that we prepare in advance the rules for configuring requests and store them in the <code>context.rules</code> dictionary.  And this dictionary and other objects necessary for executing queries and storing the results are contained in a context that we collect from the preconfigured database store <code>context.db</code> , the preconfigured repository of the <code>context.store</code> state container, and the above dictionary. </p><br><p>  At the same time, query configuration rules can contain both ordinary string data, for example, the name of the table from which data should be requested, as well as factory methods that form queries to the database and dispatch methods that send actions to the state container.  In this scenario, setting the necessary commands looks completely different than it already implies the existing code. </p><br><p>  This architectural solution allows us, among other things, to define various levels of KYC checks, simply in the form of rowsets ( <code>Set</code> ), which are used as keys when storing query configuration rules.  For example, if we want to send for verification only personal data and an address, we simply place the corresponding keys in the rowset: <code>user</code> , <code>person</code> and <code>address</code> . </p><br><p>  In the above test, the maximum configuration option is shown, with a crawl of the entire rules dictionary and setting up a generalized request code, to specific tables.  Well, as can be seen in the code below, the actual launch of requests will occur as a reaction to the events of a change in the state container: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> handle = requestHandler.bind(context, [key]); context.store.subscribe(handle);</code> </pre> <br><p>  Descriptions of the implementation process in all chilling details of the blood today will not, because it has not yet taken place ... </p></div>