<div class="post__text post__text-html js-mediator-article"><h3 id="srazu-k-delu">  Immediately to the point </h3><br><p>  There is a proprietary product that successfully helps me in debugging and called it <a href="https://github.com/ALexeyP0708/PhpDump">PhpDump</a> . </p><br><p>  At one time, CMS MODX prompted me to write my debugger.  Of course there are var_dump, phpConsole, xDebug in PHP.  But here I am with my <em>PhpDump</em> . </p><br><p>  I will say that the solution is not perfect, but very practical. </p><br><p>  How much you like, you decide. </p><a name="habracut"></a><br><p>  Here are some screenshots of what it looks like. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/ou/_x/zb/ou_xzb4g9y9wtcmzm9izpoezxbq.png"></a> <br> <a href=""><img src="https://habrastorage.org/webt/ms/nw/yi/msnwyihg5ijouv_x3bxqjp6xkoe.png"></a> </p><br><p>  The article will tell how to install and use it in CMS MODX Revo </p><br><h2 id="trebovaniya">  Requirements </h2><br><p>  Apache + PHP 7, CMS MODX Revo 2.7 <br>  Git + composer </p><br><h2 id="zagruzka-i--ustanovka">  Download and install </h2><br><ul><li>  Composer </li></ul><br><p>  Create a directory for PhpDump separately from your projects.  Since you may want to use it on a local server in different projects.  To do this, it is not necessary to install it everywhere. </p><br><p> In the directory, create a file <code>composer.json</code> with the following data: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"require"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"Alpa/PhpDump"</span></span>:<span class="hljs-string"><span class="hljs-string">"1.*"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"repositories"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"git"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://github.com/ALexeyP0708/PhpDump.git"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"git"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://github.com/ALexeyP0708/EntityDetails"</span></span> } ] }</code> </pre><br><p>  In the terminal, enter <code>$ composer install</code> </p><br><p>  When installing via composer, the project will be located in the <code>[directory install]/vendor/PhpDump</code> </p><br><ul><li>  Installation via GIT <br>  Terminal command <br> <code>$ git clone https://github.com/ALexeyP0708/PhpDump.git</code> </li> </ul><br><p>  Or unzip the archive. </p><br><p>  you can download it here <a href="https://github.com/ALexeyP0708/PhpDump">GitHub</a> </p><br><h2 id="ustanovka--phpdumpconsole">  Install PhpDumpConsole </h2><br><p>  In Google Chrome, go to the <em>Extensions</em> section, turn on the developer mode (in the upper right corner), then <code>Загрузить распакованное расширение</code> . </p><br><p>  Specify the directory <code>[directory PhpDump]/ChromeExtension/PhpDumpConsole_v1.1</code> . </p><br><p>  A red icon will appear in the panel in the form of a gear wheel in a circle.  If by pressing the gear does not turn blue, then either the server does not support PhpDump or the client has not passed authorization. </p><br><h2 id="proverka-rabotosposobnosti">  Health check </h2><br><p>  read the file <code>[dirictory Php Dump]/tests/test_debugManager.php</code> </p><br><p>  If installed via a composer, then you need to specify the correct route to the autoloader file. </p><br><p>  To do this, replace the line </p><br><pre> <code class="php hljs"> <span class="hljs-keyword"><span class="hljs-keyword">include_once</span></span> <span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span>.<span class="hljs-string"><span class="hljs-string">'/../vendor/autoload.php'</span></span>;</code> </pre> <br><p>  on </p><br><pre> <code class="php hljs"> <span class="hljs-comment"><span class="hljs-comment">//include_once __DIR__.'/../vendor/autoload.php'; include_once __DIR__.'/../../../autoload.php';</span></span></code> </pre> <br><p>  The directory where PhpDump is installed should have web access and free routing to scripts. </p><br><p>  Suppose you installed PhpDump in <code>/sites/www/mysite/TestPhpDump</code> and web access to the site <code>http://mysite/</code> then to run the test script <br> <code>http://mysite/TestPhpDump/tests/test_debugManager.php</code> </p> <br><p>  The page with the generated errors will be launched.  Launch the Google Chrome console and click the gear in the application bar.  The page will reload, the gear will turn blue.  All information is now displayed in the console. </p><br><h2 id="kak-zapustit-na-svoem-proekte">  How to run on your project </h2><br><p>  At the beginning of the page that runs the script for your project, you must specify: </p><br><pre> <code class="php hljs"> <span class="hljs-keyword"><span class="hljs-keyword">include_once</span></span> <span class="hljs-string"><span class="hljs-string">'[directory phpdump]/vendor/autoload.php'</span></span>;<span class="hljs-comment"><span class="hljs-comment">//ваш путь до phpdump абсолютный или относительный. new PhpDump\InitDump();</span></span></code> </pre> <br><p>  You need to understand that PhpDump runs in the script where the given lines are declared. <br>  You also need to take into account the fact that PHPdumpConsole displays a dump not only for the main page, but also for ajax requests and for front-end scripts generated by the server dynamically. </p><br><p>  If your project accesses erratically to different scenarios (for example, the page was loaded via Index.php, and the ajax request was made via other.php or the browser loads the dynamic js script from script.js.php), then unexpected situations may occur. </p><br><p>  In such a case, it is necessary that all routing go through one script startup file.  For example, via /index.php.  Or apply additional solutions, as was done with MODX (Described below). </p><br><h2 id="zapusk-na-testovom-sayte-s-cms-modx">  Run on a test site with CMS MODX </h2><br><p>  To run PhpDump on CMS MODX there are several solutions. </p><br><p>  The first Solution - according to the instructions above, write the code in the file index.php of your site: </p><br><pre> <code class="php hljs"> <span class="hljs-keyword"><span class="hljs-keyword">include_once</span></span> <span class="hljs-string"><span class="hljs-string">'[directory phpdump]/vendor/autoload.php'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PhpDump\InitDump();</code> </pre> <br><p>  In this case, PhpDump will work in debugging and error trapping mode. </p><br><p>  But all that will appear in the MODX logs, as well as errors that are suppressed by the system, <br>  will not be displayed in phpdumpconsole </p><br><p>  The second option: Official - without making customization.  This is an extension of the ErrorHandler class and setting the corresponding variables in the MODX parameters. </p><br><p>  This solution has a flaw.  If you make incorrect data in the settings, the site crashes.  And the situation can be corrected only through the Database. </p><br><p>  Therefore, the description of this option is omitted. </p><br><p>  In this version, you can see all generated PHP errors.  But you will not see the generated logs, which contain a significant part of the errors MODX. </p><br><p>  The third option, which I personally stopped at, is to install the full routing of calls to scripts via the 'dev_route.php' file; <br>  With .htaccess, all non-static downloads are directed to the dev_route.php file. </p><br><p>  <strong>ATTENTION:</strong> Behavior is not investigated until the end.  Perhaps some applications may offer different logic of requests to the site, the routing of which is not described in dev_route.php. </p><br><p>  <strong>ATTENTION:</strong> .htaccess is not written to the end.  Not all static resources are defined in it.  Therefore, will be processed in dev_route.php <br>  Make backup <code>.htaccess</code> file old. <br>  Create a new <code>.htaccess</code> in the root directory of the site and enter the code: </p><br><pre> <code class="plaintext hljs"># file .htaccess #---------------------------------------- # Деактивируем запросы к не существующим файлам каталогов статического ресурса. - Иначе сайт их будет обрабатывать как полноценный запрос. RewriteCond %{REQUEST_URI} /manager/min/assets/.* RewriteCond %{REQUEST_FILENAME} !-f [OR] RewriteCond %{REQUEST_URI} /manager/assets/.* RewriteCond %{REQUEST_FILENAME} !-f [OR] RewriteCond %{REQUEST_URI} /assets/.* RewriteCond %{REQUEST_FILENAME} !-f RewriteRule ^(.*)$ - [R=404,L] #--------------------------------------- #--------------------------------------- # здесь перечисляем каталоги статических ресурсов RewriteCond %{REQUEST_URI} /manager/min/assets/.* RewriteCond %{REQUEST_FILENAME} -f [OR] RewriteCond %{REQUEST_URI} /manager/assets/.* RewriteCond %{REQUEST_FILENAME} -f [OR] RewriteCond %{REQUEST_URI} /assets/.* RewriteCond %{REQUEST_FILENAME} -f [OR] RewriteRule ^(.*)$ $1 [L] #--------------------------------------- #--------------------------------------- # здесь перечисляем расширение статических ресурсов c правом свободного доступа. RewriteCond %{REQUEST_FILENAME} .*\.js$ [OR] RewriteCond %{REQUEST_FILENAME} .*\.html$ [OR] RewriteCond %{REQUEST_FILENAME} .*\.css$ [OR] RewriteCond %{REQUEST_FILENAME} .*\.gif$ [OR] RewriteCond %{REQUEST_FILENAME} .*\.jpg$ [OR] RewriteCond %{REQUEST_FILENAME} .*\.jpeg$ [OR] RewriteCond %{REQUEST_FILENAME} .*\.png$ [OR] RewriteCond %{REQUEST_FILENAME} .*\.svg$ [OR] RewriteCond %{REQUEST_FILENAME} .*\.woff$ RewriteRule ^(.*)$ $1 [L] #--------------------------------------- #--------------------------------------- # Перенаправляем запросы бекенда. RewriteCond %{REQUEST_URI} /manager(?:|/.*) RewriteRule ^(.*)$ dev_route.php [L] RewriteCond %{REQUEST_URI} /connectors(?:|/.*) RewriteRule ^(.*)$ dev_route.php [L] #--------------------------------------- #--------------------------------------- # Перенаправляем все остальные запросы. RewriteCond %{REQUEST_URI} .* RewriteRule ^(.*)$ dev_route.php?q=$1 [L,QSA] #---------------------------------------</code> </pre> <br><p>  Create the <code>dev_route.php</code> file in the root of the site directory and <code>dev_route.php</code> code into it: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">include_once</span></span> <span class="hljs-string"><span class="hljs-string">'[yor path php dump]/vendor/autoload.php'</span></span>;<span class="hljs-comment"><span class="hljs-comment">// Обязательно указываем путь к файлу автозагрузки классов new \Alpa\PhpDump\InitDump(); $redirect_url=$_SERVER['REDIRECT_URL']; $manager_path='manager'; $manager_dir='manager'; $connectors_path='connectors'; $connectors_dir='connectors'; if(preg_match("~^/{$manager_path}(|/[\s\S]*)$~",$redirect_url,$match)){ if(trim($match[1])=='' || trim($match[1])=='/' || !is_file(__DIR__.'/'.$manager_dir.$match[1])){ $match[1]='/index.php'; } include_once __DIR__.'/'.$manager_dir.$match[1]; } else if(preg_match("~^/{$connectors_path}(|/[\s\S]*)$~",$redirect_url,$match)){ if(trim($match[1])=='' || trim($match[1])=='/' || !is_file(__DIR__.'/'.$connectors_dir.$match[1])){ $match[1]='/index.php'; } include_once __DIR__.'/'.$connectors_dir.$match[1]; } else if(empty($redirect_url) || $redirect_url=='/' || $redirect_url=='/index.php'){ include_once __DIR__.'/index.php'; } else { //header( 'Location: /index.php' ); exit; include_once __DIR__.'/index.php'; } //include_once __DIR__.$redirect_url;</span></span></code> </pre><br><p>  Then in the <code>core\xpdo\xpdo.class.php</code> (for MODX revo 2.7) arrange the log method as follows: </p><br><pre> <code class="php hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($level, $msg, $target= </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span><span class="hljs-function"><span class="hljs-params">, $def= </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span><span class="hljs-function"><span class="hljs-params">, $file= </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span><span class="hljs-function"><span class="hljs-params">, $line= </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ \deb::print($msg.<span class="hljs-string"><span class="hljs-string">"=&gt;[$target][$def][$file][$line]"</span></span>,<span class="hljs-string"><span class="hljs-string">'LOG'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_log($level, $msg, $target, $def, $file, $line); }</code> </pre> <br><p>  And that's all.  You have to earn everything properly. <br>  We test in admin panel.  if the admin is loading well, then everything is done as it should. </p><br><p>  How to use: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// выведет переменную любого типа. Рекурсивно предоставит все свойства объекта и массива \deb::print($var,'point1'); // Предоставит рекурсивно детальную информацию по объекту. \deb::dump($object,'point2'); // результат var_dump \deb::vdump($object,'point3'); //результат var_export \deb::vexport($object,'point4'); // информация о классе \deb::infoClass($name_class, 'point5'); // вывод ошибок Предназначен как правило для внутренних целей. при генерации ошибки системой. \deb::error($errno = false, $errstr, $errfile = false, $errline = false, $errcontext = false); //В лучшем случае вызывать ошибку стоит через trigger_error();</span></span></code> </pre> <br><h3 id="nastroyki-bezopasnosti">  Security Settings </h3><br><p>  PhpDump is currently not designed for professional work, so security conditions are minimal. </p><br><p>  If you decided to attach PhpDump to the current site on the Internet, then in the [directory phpdump] /src/include_file_in_index.php file, change the following settings for authorization: </p><br><pre> <code class="php hljs">$settings=[ <span class="hljs-string"><span class="hljs-string">'hashkeys'</span></span>=&gt;[ <span class="hljs-string"><span class="hljs-string">'HashKey'</span></span>=&gt;[ <span class="hljs-comment"><span class="hljs-comment">// любой ключ в виде строки (латиница).Будет являться публичным ключём 'key'=&gt;'HashKey', // дублируем строку ключа 'greeting_server'=&gt;'greeting_server', // ключ в виде строки для авторизации на стороне сервера 'greeting_client'=&gt;'greeting_client' // ключ для авторизации на стороне клиента. ] ] ];</span></span></code> </pre> <br><p>  On the client side, in the 'Java Scripts Context' drop-down list, select PhpDumpConsole and enter the code in the console. </p><br><pre> <code class="plaintext hljs">dm.setHashKey({ hashkey:'HashKey', greeting_server:'greeting_server', greeting_client:'greeting_client' }); //где параметры hashkey , greeting_server, greeting_client устанавливаете такие же как и на сервере. dm.bindHashKeyDomain({hashkey:'HashKey',domain:'global'}); // или domain:'your_domain' //если domain='global' будет применяться по умолчанию для всех сайтов к которым не установлена авторизация по другому ключу.</code> </pre><br><h2 id="drugie-plyushki">  Other buns </h2><br><p>  Through the console, you can control the on / off bektrays, filter output. <br>  All this can be found in the instructions on the <a href="https://github.com/ALexeyP0708/PhpDump">GitHub</a> page. <br>  PhpDump can be used not only for MODX, but also in other projects.  The main thing is to know how to fasten. </p><br><p>  PS: If you are fans of MODX, then in the near future a new bun is waiting for you: The method of forming snipet "Divide and Conquer".  Snippets of logic and snippets of templates will be able to self-organize and group with each other, with the help of a combination of 2-3 snippets you can expand the behavior. </p><br><p>  There is flexibility in writing snippets.  Programmers will not need to describe the full cycle of writing a snippet, but only a separate part, describing its API for further interaction with other snippets. </p><br><p>  Thanks to all. </p></div>