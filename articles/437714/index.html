<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Draw a cartoon explosion for 180 lines of naked C ++</title>
  <meta name="description" content="A week ago, I published another chapter from my lecture course on computer graphics ; today we are back to ray tracing, but this time we‚Äôll go a littl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Draw a cartoon explosion for 180 lines of naked C ++</h1><div class="post__text post__text-html js-mediator-article">  A week ago, I <a href="https://habr.com/ru/post/436790/">published another chapter</a> from my <a href="https://github.com/ssloy/tinyrenderer/wiki">lecture course on computer graphics</a> ;  today we are back to ray tracing, but this time we‚Äôll go a little further on drawing the trivial spheres.  I do not need photorealism, for cartoon purposes <a href="https://github.com/ssloy/tinykaboom">such an explosion</a> , it seems to me, will come down. <br><br>  As always, we have only the bare compiler at our disposal, no third-party libraries can be used.  I don't want to bother with window managers, mouse / keyboard handling, and the like.  The result of our program will be a simple image saved to disk.  I absolutely do not chase for speed / optimization, my goal is to show the basic principles. <br><br>  Total, how in such conditions to draw just such a picture for 180 lines of code? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/052/265/365/052265365c5c2a1da16850f7e0cb6eb1.jpg"><br><a name="habracut"></a><br>  Let me even put in an animated gif (six meters): <br><br><img src="https://github.com/ssloy/tinykaboom/raw/master/kaboom.gif"><br><br>  And now we divide the whole task into several stages: <br><br><h1>  Stage one: read the previous article </h1><br>  Yes exactly.  The very first thing you need to read the <a href="https://habr.com/ru/post/436790/">previous chapter</a> , which tells about the basics of ray tracing.  It is quite short, in principle, you can not read any reflections, refractions, but at least I should recommend to finish reading diffused lighting.  The code is quite simple, the people run it even on microcontrollers: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc7/080/0d1/cc70800d1c9d4263579068543833351d.gif"><br><br><h1>  Stage two: we draw one sphere </h1><br>  Let's draw one sphere without bothering with materials or lighting.  For simplicity, this sphere will live in the center of coordinates.  About this picture I want to get: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/384/491/07f/38449107fec46a30b60ea125a61180e7.jpg"><br><br>  Look at the code <a href="https://github.com/ssloy/tinykaboom/tree/c45987e9c4ad8594282e2af40775910b2b1c51ec">here</a> , but let me give you the main one right in the text of the article: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _USE_MATH_DEFINES #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cmath&gt; #include &lt;algorithm&gt; #include &lt;limits&gt; #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;vector&gt; #include "geometry.h" const float sphere_radius = 1.5; float signed_distance(const Vec3f &amp;p) { return p.norm() - sphere_radius; } bool sphere_trace(const Vec3f &amp;orig, const Vec3f &amp;dir, Vec3f &amp;pos) { pos = orig; for (size_t i=0; i&lt;128; i++) { float d = signed_distance(pos); if (d &lt; 0) return true; pos = pos + dir*std::max(d*0.1f, .01f); } return false; } int main() { const int width = 640; const int height = 480; const float fov = M_PI/3.; std::vector&lt;Vec3f&gt; framebuffer(width*height); #pragma omp parallel for for (size_t j = 0; j&lt;height; j++) { // actual rendering loop for (size_t i = 0; i&lt;width; i++) { float dir_x = (i + 0.5) - width/2.; float dir_y = -(j + 0.5) + height/2.; // this flips the image at the same time float dir_z = -height/(2.*tan(fov/2.)); Vec3f hit; if (sphere_trace(Vec3f(0, 0, 3), Vec3f(dir_x, dir_y, dir_z).normalize(), hit)) { // the camera is placed to (0,0,3) and it looks along the -z axis framebuffer[i+j*width] = Vec3f(1, 1, 1); } else { framebuffer[i+j*width] = Vec3f(0.2, 0.7, 0.8); // background color } } } std::ofstream ofs("./out.ppm", std::ios::binary); // save the framebuffer to file ofs &lt;&lt; "P6\n" &lt;&lt; width &lt;&lt; " " &lt;&lt; height &lt;&lt; "\n255\n"; for (size_t i = 0; i &lt; height*width; ++i) { for (size_t j = 0; j&lt;3; j++) { ofs &lt;&lt; (char)(std::max(0, std::min(255, static_cast&lt;int&gt;(255*framebuffer[i][j])))); } } ofs.close(); return 0; }</span></span></span></span></code> </pre> <br>  The class of vectors lives in the geometry.h file, I will not describe it here: first, everything is trivial, simple manipulation of two and three-dimensional vectors (addition, subtraction, assignment, scalar multiplication, scalar production), and second, <a href="https://habr.com/ru/users/gbg/" class="user_link">gbg</a> has already <a href="https://habr.com/ru/post/248909/">described</a> it in <a href="https://habr.com/ru/post/248909/">detail</a> as part of a course on computer graphics. <br><br>  I save the picture in <a href="https://en.wikipedia.org/wiki/Netpbm_format">ppm format</a> ;  This is the easiest way to save images, although it is not always the most convenient for further viewing. <br><br>  So, in the function main (), I have two cycles: the second cycle simply saves the image to the disk, and the first cycle passes through all the pixels of the image, emits a beam from the camera through this pixel, and looks to see if this beam intersects with our sphere. <br><br>  <b>Attention, the main idea of ‚Äã‚Äãthe article:</b> if in the last article we analytically considered the intersection of the ray and the sphere, now I consider it numerically.  The idea is simple: a sphere has an equation of the form x ^ 2 + y ^ 2 + z ^ 2 - r ^ 2 = 0;  but in general the function f (x, y, z) = x ^ 2 + y ^ 2 + z ^ 2 - r ^ 2 is defined in the whole space.  Inside the sphere, the function f (x, y, z) will have negative values, and outside the sphere will be positive.  That is, the function f (x, y, z) for the point (x, y, z) sets the distance (with a sign!) To our sphere.  Therefore, we will simply slide along the ray until either we are bored or the function f (x, y, z) becomes negative.  The function sphere_trace () does just that. <br><br><h1>  Stage Three: Primitive Lighting </h1><br>  Let's code the simplest diffuse lighting, that's what I want to get at the output: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7b5/a6b/9e6/7b5a6b9e6d05c103b630ffeb6f10018e.jpg"><br><br>  As in the previous article, for ease of reading, I made one stage = one commit.  Changes can be <a href="https://github.com/ssloy/tinykaboom/commit/ef22c62142f293cc84a15cc4a6a64882ac1b2f6e">viewed here</a> . <br><br>  For diffuse illumination it is not enough for us to calculate the point of intersection of the beam with the surface, we need to know the vector of the normal to the surface at this point.  I obtained this normal vector by simple <a href="https://en.wikipedia.org/wiki/Finite_difference">finite differences</a> in our function of the distance to the surface: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">distance_field_normal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;pos)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> eps = <span class="hljs-number"><span class="hljs-number">0.1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d = signed_distance(pos); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> nx = signed_distance(pos + Vec3f(eps, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)) - d; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> ny = signed_distance(pos + Vec3f(<span class="hljs-number"><span class="hljs-number">0</span></span>, eps, <span class="hljs-number"><span class="hljs-number">0</span></span>)) - d; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> nz = signed_distance(pos + Vec3f(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, eps)) - d; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vec3f(nx, ny, nz).normalize(); }</code> </pre><br>  In principle, of course, since we draw a sphere, the normal can be obtained much easier, but I did so with the groundwork for the future. <br><br><h1>  Stage four: let's draw a pattern on our sphere </h1><br>  And let's look at some pattern on our field, for example, like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/061/6cd/67a/0616cd67af48498b5ef3876f9b3e9754.jpg"><br><br>  To do this, in the previous code, I changed <a href="https://github.com/ssloy/tinykaboom/commit/45ea36a1568ca8e1b2f44a1ea55a792709983ef9">only two lines!</a> <br><br>  How did I do it?  Of course, I have no textures.  I just took the function g (x, y, z) = sin (x) * sin (y) * sin (z);  it is again defined in all space.  When my ray intersects the sphere at some point, the value of the function g (x, y, z) at this point sets the color of the pixel to me. <br><br>  By the way, pay attention to the concentric circles on the sphere - these are artifacts of my numerical calculation of the intersection. <br><br><h1>  Stage Five: displacement mapping </h1><br>  Why did I want to draw this pattern?  And he will help me to draw such a hedgehog: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fae/28b/583/fae28b583626fc4b44706a465dc3f328.jpg"><br><br>  Where my pattern gave black color, I want to push a hole in our sphere, and where it was white, on the contrary, draw a hump. <br><br>  To do this, it is enough <a href="https://github.com/ssloy/tinykaboom/commit/2c9e70fcee4f09fb563e5272f349763654b1eaad">to change three lines</a> in our code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">signed_distance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;p)</span></span></span><span class="hljs-function"> </span></span>{ Vec3f s = Vec3f(p).normalize(sphere_radius); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> displacement = <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-number"><span class="hljs-number">16</span></span>*sx)*<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-number"><span class="hljs-number">16</span></span>*sy)*<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-number"><span class="hljs-number">16</span></span>*sz)*noise_amplitude; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p.norm() - (sphere_radius + displacement); }</code> </pre><br>  That is, I changed the calculation of the distance to our surface, defining it as x ^ 2 + y ^ 2 + z ^ 2 - r ^ 2 - sin (x) * sin (y) * sin (z).  In fact, we have defined an <a href="https://en.wikipedia.org/wiki/Implicit_surface">implicit function</a> . <br><br><h1>  Stage Six: Another Implicit Function </h1><br>  And why do I value the product of sines only for points lying on the surface of our sphere?  Let's redefine our implicit function like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">signed_distance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> displacement = <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-number"><span class="hljs-number">16</span></span>*px)*<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-number"><span class="hljs-number">16</span></span>*py)*<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-number"><span class="hljs-number">16</span></span>*pz)*noise_amplitude; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p.norm() - (sphere_radius + displacement); }</code> </pre><br>  The difference with the previous code is quite small, it is better to <a href="https://github.com/ssloy/tinykaboom/commit/ec1ed71b23bf398af1aade84e1a7a45afcbe57b5">look diff</a> .  Here is the result: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f72/da1/e29/f72da1e29ba32fb8cbd7df9acfdd4058.jpg"><br><br>  In this way, we can define disconnected components in our object! <br><br><h1>  Stage Seven: pseudo-random noise </h1><br>  The previous picture is already beginning to vaguely resemble an explosion, but the product of the sines has a too regular pattern.  We would have some more ‚Äúragged‚Äù, more ‚Äúrandom‚Äù function ... <a href="https://en.wikipedia.org/wiki/Perlin_noise">Perlin's noise</a> will come to our aid.  Here is something that would suit us much better than the product of sines: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0f8/b7a/677/0f8b7a677e99281f724edb3cb94bf9d0.png"><br><br>  How to generate such noise is a bit offtopic, but here‚Äôs the basic idea: you need to generate random images with different resolutions, smooth them to get something like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/24b/577/f9e/24b577f9e194d834d2e243f4dc6d2e3a.png"><br><br>  And then just sum up them: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bd0/e8d/172/bd0e8d172b8179a5f9cd30abdcfa3ae7.jpg"><br><br>  Read more <a href="https://medium.com/100-days-of-algorithms/day-88-perlin-noise-96d23158a44c">here</a> and <a href="https://library.creativecow.net/articles/zwar_chris/fractal_noise.php">here</a> . <br><br>  Let's <a href="https://github.com/ssloy/tinykaboom/commit/6ac4658d75cadaf095af7994572d79ceb395af9a">add some code</a> that generates this noise, and we get this picture: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/175/da8/80a/175da880a5e746fd8582906bd6c2829e.jpg"><br><br>  Please note that in the rendering code I didn‚Äôt change anything at all, only the function that ‚Äúhesitates‚Äù our sphere has changed. <br><br><h1>  Stage eight, final: add color </h1><br>  The only thing I <a href="https://github.com/ssloy/tinykaboom/commit/585c779712baa7bdae89e6eeccdb90da12bcbf06">changed in this commit</a> was that, instead of a uniform white color, I imposed a color that depends linearly on the amount of noise applied: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">palette_fire</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> d)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">yellow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.7</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.3</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// note that the color is "hot", ie has components &gt;1 const Vec3f orange(1.0, 0.6, 0.0); const Vec3f red(1.0, 0.0, 0.0); const Vec3f darkgray(0.2, 0.2, 0.2); const Vec3f gray(0.4, 0.4, 0.4); float x = std::max(0.f, std::min(1.f, d)); if (x&lt;.25f) return lerp(gray, darkgray, x*4.f); else if (x&lt;.5f) return lerp(darkgray, red, x*4.f-1.f); else if (x&lt;.75f) return lerp(red, orange, x*4.f-2.f); return lerp(orange, yellow, x*4.f-3.f); }</span></span></code> </pre><br>  This is a simple linear gradient between five key colors.  Well, here's the picture! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/052/265/365/052265365c5c2a1da16850f7e0cb6eb1.jpg"><br><br><h1>  Conclusion </h1><br>  This ray tracing technique is called ray marching.  Homework is simple: to cross the previous raytracer with blackjack and reflections with our explosion, so much so that the explosion also illuminates everything around!  By the way, this explosion is strongly lacking in translucency. </div><p>Source: <a href="https://habr.com/ru/post/437714/">https://habr.com/ru/post/437714/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>