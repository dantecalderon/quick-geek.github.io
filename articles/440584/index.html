<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What is wrong with the Raspberry Pi</title>
  <meta name="description" content="The Raspberry Pi is an incredibly popular device, known for its availability, versatility, capabilities and active community. It is easy to find fan s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>What is wrong with the Raspberry Pi</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/a37/a11/5ba/a37a115ba84ab61241ed37541fa8c52f.png"><br><br>  The Raspberry Pi is an incredibly popular device, known for its availability, versatility, capabilities and active community.  It is easy to find fan sites and articles, but most people are not aware of its weak points until they themselves suffer from them and search for information on the forums. <br><br>  I will try to talk about some of the issues that I faced personally, as well as some typical problems that most often appear in people who are unaware of this.  And finally, why I do not recommend Pi for some applications, in particular, NAS services, such as NextCloudPi and Open Media Vault.  I hope this will save me time, so as not to repeat all this on the forums. <br><a name="habracut"></a><br>  I have had a lot of Raspberry Pi, and I have been using them for years.  When the first model appeared in 2012, it became an important milestone in the single-player market.  Although there were already some good motherboards such as the Beagleboard and Odroid, they were quite expensive, and only hardcore lovers could buy and test them. <br><br>  Pi is not as powerful compared to them, but because of the amazing cheapness it literally blew up the market.  Blogs, expansion cards, lots of personal projects, tons of libraries ... Raspberry Pi was the first to achieve all of this, and to this day a thriving community is Pi's biggest advantage over other boards. <br><br>  But now it's 2019 and it's time to look around again.  In my opinion, there are more open alternatives of better quality at the same price.  I will try to explain. <br><br><h1>  Performance </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/7e2/b93/d81/7e2b93d812239e878bd9c654875cc5ed.jpg"><br><br>  Raspberry Pi reduced the price by cutting corners.  As a result, the board is not productive enough for some tasks, compared to competitors.  In particular, it is poorly suited for network tasks and USB functionality. <br><br>  Here stands the <a href="https://www.raspberrypi.org/magpi/raspberry-pi-3-specs-benchmarks/">SMSC LAN9514 chip</a> , which connects to the SoC with one USB channel, acting as a USB-to-Ethernet adapter and a USB hub at the same time.  Thus, Ethernet and USB sit on the same channel and compete with each other, which is contrary to the typical use of the NAS, when something is downloaded over the network and stored on a USB drive, not to mention adding RAID here. <br><br>  For the same reason, even when last year they finally released a model with Gigabit Ethernet support, the actual network performance never even came close to gigabit, and is <a href="https://libre.computer/2018/03/21/raspberry-pi-3-model-b-review-and-comparison/">40 MB / s maximum in net speed and 20 MB / s maximum if Transferring to USB device</a> .  At that time, there were already cheap motherboards with true Gigabit Ethernet and USB3. <br><br>  In fact, Wi-Fi <a href="https://www.raspberrypi.org/forums/viewtopic.php%3Fp%3D915455">does not come via SMSC</a> , but connects to the BCM4343 chip via <a href="https://en.wikipedia.org/wiki/Secure_Digital">SDIO</a> , so this bottleneck can somehow be avoided using Wi-Fi.  However, the Wi-Fi chip is not omnipotent, it will have to deal with the surrounding interference, so this is not an ideal alternative. <br><br>  For these reasons, I would not recommend using Pi as a NAS, whether it is Open Media Vault or Nextcloud. <br><br><h1>  Real Pi brain - closed source </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bca/bc7/cec/bcabc7cec7c9fc04dc7f1c4b99c242f8.png"></div><br><br>  If you participated in the software freedom debate, the main problem in our Linux systems is the binary source code blobs.  I will not go into details, but the problem is that these parts of the system cannot be verified, and they have access to everything that happens in the device.  This has generated large open source projects, such as <a href="https://www.replicant.us/">Android Replicant</a> , designed to free our systems from any binary blobs: a painful, tedious and slow process. <br><br>  A similar problem with the Raspberry Pi, where the CPU and GPU are embedded in the same chip <a href="">BCM2837B0</a> .  The central processor is a 64-bit quad-core ARM A53 at 1,400 MHz (in Pi 3B), and the graphic processor is a dual-core 32-bit VideoCore IV with a frequency of 400 MHz.  The integration of CPU and GPU is popular in the mobile world, because it reduces the price and power consumption.  The NXP iMX and Allwinner competitors use a similar approach. <br><br>  Thus, in the last Pi there are six cores, but only four of them are ARM.  The processor runs Linux, but you may be surprised that Linux on this device is a second-class citizen.  The GPU cores are running the ThreadX real-time operating system.  This closed source operating system manages the system without the knowledge of the Linux kernel. <br><br>  At the start of the Raspberry Pi boot, the processor is completely disabled (technically in the <i>reset</i> state) and it is the GPU that starts the system.  You can take a look at the <code>/boot</code> folder - and find the binary blobs with which the GPU starts the processor and its own ThreadX OS ( <i>bootcode.bin</i> and <i>start.elf</i> ).  Read more about the download process <a href="https://elinux.org/RPi_Software">here</a> . <br><br>  It is the GPU that mounts the SD card, loads these blobs, and reads the configuration from the <a href="">text file config.txt</a> , which we are editing to adjust the video settings or overclock the GPU.  Linux is not involved here. <br><br>  When the GPU allows the CPU to load the Linux kernel, it does not just leave the stage, working only as a <i>graphics processor</i> .  No, the GPU is still in charge.  Have you ever thought who displays these logos when Pi connects to HDMI?  Or are these <a href="">symbols of lightning or temperature</a> warning signs?  That's right, this makes the system ThreadX on the GPU, and Linux doesn‚Äôt know what is going on at all. <br><br>  We can not know all the functionality of the GPU, but we know something for which he is responsible.  For this article, it is important that ThreadX monitors voltage reduction ‚Äî a widespread problem, as we will see later, and reduces the frequency of the processor in order to prevent processor crashes and freezes.  Therefore, in humans, the devices operate at a frequency of 600 MHz instead of 1400 MHz, at best.  This throttling starts at 4.65 V and can also be triggered by temperature.  At the same time, Linux still thinks that the system is operating normally at full frequency. <br><br>  This is just what we see.  Since the main OS is proprietary, we have no way of knowing what else it does or can do, so there is always the issue of privacy. <br><br>  There is at least one patent included in the closed source blob that prohibits opening the code <a href="https://www.raspberrypi.org/forums/viewtopic.php%3Ft%3D201449">until at least 2025</a> , but we don‚Äôt know if it will be done even then.  There have been attempts to <a href="https://github.com/hermanhermitage/videocoreiv">reverse-engineer VideoCore IV</a> and create open source firmware for it.  Unfortunately, the <a href="https://github.com/christinaa/rpi-open-firmware/issues/37">project died</a> before it gave something useful.  As with Android blobs, this is an incredibly difficult job. <br><br><h1>  Power problems </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/d31/66a/a51/d3166aa5114934a62cd3ff0f5ac1212d.jpg"><br>  This is not a technical error of the Raspberry Pi, but rather a typical user error. <br><br>  The first model hardly used 80 mA, but each new generation became more and more powerful, and for this reason more energy-consuming.  In addition, many users connect USB devices that also consume power if they are not supplied with their own power sources. <br><br>  The microUSB connector was originally designed only for 1.8 A, and although this is an old standard, you can find chargers that give out more, so many people try to use old 1 A phone chargers or buy cheap adapters on the Internet to power their "Raspberry".  But Pi is a computer, and it requires a high-quality, stabilized power supply that provides stable 5 V at the input with a current of up to 2.5 A. Not only a decent transformer is needed, but also a good connection (or a voltage drop will occur), but more importantly that you need a good <i>cable</i> , otherwise the voltage drops across it.  Bad cables are more common than unstable voltage sources, so be sure to use a good cable: perhaps <a href="https://www.bluejeanscable.com/articles/what-does-wire-gage-mean.htm">20AWG</a> or similar, or just buy an official power supply.  The conclusion is that not any USB charger will work properly, even if it is 2.5A 5V. <br><br>  Add this to what we discussed in the last section, and begin to understand the big picture.  Most users work on their devices at a reduced frequency, and the GPU hides it from them, so they actually work at a reduced frequency of 600 MHz: almost the same as ARMv6 on the very first Pi. <br><br>  In many cases, the GPU is not enough effort, and the system randomly crashes or just freezes, possibly damaging data or damaging the SD card.  This usually happens <i>under load</i> , that is, when transistors need maximum power.  Then the user comes to the forums and complains: <i>my power supply is in order, I ran this and that, and nothing failed</i> .  Of course, this is not true, but often they do not believe it. <br><br>  In my opinion, here is what the Japanese can call <a href="https://en.wikipedia.org/wiki/Poka_yoke">Poka Yoke</a> , that is, we must design such systems that, <i>by their design,</i> will not allow the user to shoot himself in the leg.  Again, the official power source is of very good quality for its price, and I highly recommend it. <br><br>  I do not like the fact that the hidden proprietary system lowers the frequency beyond our control.  It would be better if the system hung up: then you can immediately see what is happening, and a person can replace the power supply.  In my opinion, this is better than deceiving users and forcing them to complain <a href="https://github.com/bamarni/pi64/issues/66">all over the internet</a> .  It is hard to imagine the reason why Pi developers would do this if they did not hide the problem of Poka Yoke. <br><br><h1>  Check for power problems </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/926/327/e38/926327e38041460535cd7c0e219553c3.png"></div><br><br>  It took too much time, but we <a href="https://github.com/raspberrypi/linux/issues/2367">still</a> managed to log the problem at the kernel level.  If <a href="https://github.com/raspberrypi/linux/issues/2512">you see</a> such a message in the system logs: <br><br><pre>  kern: crit: [1701.464833 2.116656] Under-voltage detected!  (0x00050005)
 kern: info: [1707.668180 6.203347] Voltage normalized (0x00000000 </pre><br>  then you have a decrease in voltage.  It's good that now Linux captures at least such information, but if we want to learn more, we need direct access to the GPU. <br><br>  <a href="https://elinux.org/RPI_vcgencmd_usage">The vcgencmd command</a> can get system information from the ThreadX firmware. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># vcgencmd get_config int arm_freq=1000 core_freq=500 sdram_freq=600 over_voltage=6 disable_overscan=1 force_pwm_open=1</span></span></code> </pre> <br>  You can use the <code>vcgencmd measure_clock arm</code> and <code>vcgencmd measure_volts</code> to check the actual frequency and voltage.  Here is an example of the output from the tkaiser <a href="https://github.com/bamarni/pi64/issues/4">monitoring script</a> . <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># With a crappy PSU and/or Micro USB cable output looks like this # on a RPi 3: # # 44.0'C 600 MHz 1010000000000000000 1.2V # 44.5'C 600 MHz 1010000000000000000 1.2V # 44.0'C 600 MHz 1010000000000000101 1.2V # 44.0'C 600 MHz 1010000000000000101 1.2V # 44.0'C 600 MHz 1010000000000000101 1.2V # 44.5'C 600 MHz 1010000000000000000 1.2V # 45.1'C 600 MHz 1010000000000000101 1.2V # # With an ok-ish cable it looks like this (when running cpuburn-a53): # # 48.3'C 1200 MHz 0000000000000000000 1.3312V # 48.3'C 1200 MHz 0000000000000000000 1.3312V # 48.3'C 1200 MHz 0000000000000000000 1.3312V # 48.3'C 1200 MHz 0000000000000000000 1.3312V # 50.5'C 1200 MHz 0000000000000000000 1.3312V # 56.4'C 600 MHz 0000000000000000000 1.2V # 54.8'C 600 MHz 1010000000000000101 1.2V # 55.3'C 600 MHz 1010000000000000101 1.2V # 55.8'C 600 MHz 1010000000000000101 1.3312V # 53.7'C 600 MHz 1010000000000000101 1.2V # 51.5'C 600 MHz 1010000000000000101 1.2V # 51.0'C 600 MHz 1010000000000000101 1.2V # # And only by bypassing the crappy connector you can enjoy RPi 3 # performing as it should (please note, there's a heatsink on my RPi # -- without throttling would start and then reported clockspeed # numbers start to get funny): # # 75.2'C 1200 MHz 1010000000000000000 1.3250V # 75.8'C 1200 MHz 1010000000000000000 1.3250V # 75.8'C 1200 MHz 1010000000000000000 1.3250V # 76.3'C 1200 MHz 1010000000000000000 1.3250V # 76.3'C 1200 MHz 1010000000000000000 1.3250V # 73.6'C 1200 MHz 1010000000000000000 1.3250V # 72.0'C 1200 MHz 1010000000000000000 1.3250V # 70.4'C 1200 MHz 1010000000000000000 1.3250V # # Now with a pillow on top for some throttling: # # 82.2'C 1200/ 947 MHz 1110000000000000010 1.3250V # 82.7'C 1200/ 933 MHz 1110000000000000010 1.3250V # 82.7'C 1200/ 931 MHz 1110000000000000010 1.3250V # 82.7'C 1200/ 918 MHz 1110000000000000010 1.3250V # 82.2'C 1200/ 935 MHz 1110000000000000010 1.3250V # 79.9'C 1200/1163 MHz 1110000000000000000 1.3250V # 75.8'C 1200 MHz 1110000000000000000 1.3250V # # And here on RPi 2 with crappy USB cable and some load # # 50.8'C 900 MHz 1010000000000000000 1.3125V # 49.8'C 900 MHz 1010000000000000000 1.3125V # 49.8'C 900/ 600 MHz 1010000000000000101 1.2V # 49.8'C 900/ 600 MHz 1010000000000000101 1.2V # 48.7'C 900/ 600 MHz 1010000000000000101 1.2V # 49.2'C 900/ 600 MHz 1010000000000000101 1.2V # 48.7'C 900 MHz 1010000000000000000 1.3125V # 46.5'C 900 MHz 1010000000000000000 1.3125V # # The funny thing is that while the kernel thinks it's running # with 900 MHz (performance governor) in reality the 'firmware' # throttles down to 600 MHz but no one knows :)</span></span></code> </pre> <br><br><h1>  Conclusion </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/106/493/231/1064932310fa170fa18ac7cea097f515.jpg"></div><br>  I really think that Raspberry Pi has become a very important event in the history of single-board computers, but today it is lagging behind in terms of quality, performance and openness.  There are alternatives available where the developers paid more attention to these issues. <br><br>  Despite this, I still use Raspberry Pi, <a href="https://github.com/nachoparker">helping users</a> install their own cloud hosting.  Given the popularity of this board, for me it makes sense to support it as long as it is useful to people. </div><p>Source: <a href="https://habr.com/ru/post/440584/">https://habr.com/ru/post/440584/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>