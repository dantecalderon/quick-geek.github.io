<div class="post__text post__text-html js-mediator-article"><p>  <em>From the translator: in spite of the fact that a year has already passed, the questions about what new gave us the 2nd Boot do not end there.</em>  <em>To write such content from scratch is not the smartest idea.</em>  <em>Therefore, we decided to translate the article, which seems to us the most concise and at the same time quite complete.</em> </p><br><p>  The release of Spring Boot 2 took place in early 2018, and everyone can’t wait to see it in action.  This release was the culmination of 17 months of work and over 6800 commits from 215 different people.  There are a lot of cool features that are worth discussing, so let's talk about what's new in Spring Boot 2. </p><br><p>  In this article we will look at: </p><br><ul><li>  Spring Boot Story </li><li>  What's new in Spring Boot </li><li>  Spring Boot 2 Migration Guide </li></ul><a name="habracut"></a><br><h2 id="istoriya-spring-boot">  Spring Boot History </h2><br><p>  Before delving into innovations, I would like to take this opportunity to tell a little about the history of Spring Boot.  In a post published in August 2013, on his blog, <a href="https://spring.io/blog/2013/08/06/spring-boot-simplifying-spring-for-everyone/">Phil Webb announced the first landmark release of the project called Spring Boot</a> . </p><br><p>  <em>Spring Boot is designed to make the creation of ready-to-work applications and services for Spring simple, without undue effort.</em>  <em>Spring Boot is a subjective view of the Spring platform, which allows both novice and experienced Spring users to find everything they need.</em>  <em>With the help of Boot, you can create stand-alone applications launched as 'java -jar' or distributed by a more traditional WAR format.</em> </p><br><p>  After about 9 months, in April 2014, Spring Boot 1.0 was released.  Since then, there have been many minor releases and new useful features. </p><br><p>  <a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-1.1-Release-Notes">Spring Boot 1.1 (June 2014)</a> </p><br><ul><li>  spring-boot-starter-test </li><li>  Metrics &amp; Health Endpoints </li><li>  Elastic Search, Apache Solr, Spring Social and Spring Integration auto configuration </li><li>  Support for standardization tools (Freemaker, Groovy, and Velocity) </li></ul><br><p>  <a href="https://github.com/spring-projects/spring-boot/wiki/spring-boot-1.2-release-notes">Spring Boot 1.2 (March 2015)</a> </p><br><ul><li>  Servlet 3.1, Tomcat 8 &amp; Jetty 9 </li><li>  Spring 4.1 </li><li>  Annotation @SpringBootApplication </li><li>  Email support </li></ul><br><p>  <a href="https://github.com/spring-projects/spring-boot/wiki/spring-boot-1.3-release-notes">Spring Boot 1.3 (December 2016)</a> </p><br><ul><li>  Update Spring Framework to version 4.2 </li><li>  Upgrading Spring Security to version 4.0 </li><li>  Developer Tools </li><li>  Caching auto configuration </li><li>  Fully executable JARs and support services </li></ul><br><p>  <a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-1.4-Release-Notes">Spring Boot 1.4 (January 2017)</a> </p><br><ul><li>  Spring 4.3 </li><li>  Hibernate 5 </li><li>  Improvements in testing mechanisms </li><li>  Integration starter </li><li>  Couchbase and Neo4J support </li></ul><br><p>  <a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-1.5-Release-Notes">Spring Boot 1.5 (February 2017)</a> </p><br><ul><li>  Loggers endpoint </li><li>  Apache Kafka support </li><li>  Advanced mechanisms for Cloud Foundry </li><li>  LDAP support </li><li>  Testing updates </li></ul><br><h2 id="chto-novogo-v-spring">  What's new in Spring </h2><br><p>  So what's new in Spring Boot 2?  If we talk about the biggest innovation, then this update of the Spring Framework to the 5th version.  Since the Spring Framework 5 came out in September 2017, most developers (like me) have been waiting for the release of Spring Boot 2. Spring Framework 5 has a considerable list of new features, but I would like to talk about only a few of the most important ones. </p><br><h3 id="chto-novogo-v-spring-framework-5">  What's new in Spring Framework 5 </h3><br><h4 id="podderzhka-versiy-java-8">  Java 8+ version support </h4><br><p>  If you continue to want to create applications on the Spring Framework, you need to work with the Java 8+ version.  You probably thought that this is a very important change for all of us, but for the Spring team it is even more important.  This made it possible to update the source code base to Java 8 with all its new features like lambda expressions or streams.  This not only makes the code more readable, but also improves the performance of the platform’s core. </p><br><h4 id="podderzhka-java-9">  Java 9 support </h4><br><p>  If you want to use Java 9, you need to upgrade to Spring Framework 5 and also to Spring Boot 2. I know that many are not yet using the latest versions of Java in production, and this is a great opportunity to experiment with new cool “toys”.  Everything should work without problems when using the standard classpath, but I read about some difficulties when switching to Java 9 modules. </p><br><h4 id="spring-mvc">  Spring MVC </h4><br><p>  Although Spring MVC is not at the center of the story in this article, it is worth saying that there have been several nice upgrades.  I will not dwell on them, details can be found in the <a href="">documentation for the Spring Framework 5</a> . </p><br><h4 id="spring-webflux">  Spring webflux </h4><br><p>  Asynchronous data flows are central to the story of the Spring Framework 5. This is a completely different type of thinking, but fortunately for us there is no need to re-learn how to write applications in a completely new way.  Spring WebFlux is a completely asynchronous and non-blocking framework built from scratch that allows you to cope with a large number of parallel connections.  Although this is a paradigm revolution, it will not be so difficult to start. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/77f/704/951/77f704951fdd78f0cf3d4e6a4836ed17.png" alt="Webflux"></p><br><h4 id="podderzhka-kotlin">  Kotlin support </h4><br><p>  Kotlin support has been added back to <a href="http://start.spring.io/">http://start.spring.io</a> , but Spring Framework 5 has specialized support for this language, which has brought useful features, you can read about them <a href="">here</a> . </p><br><h4 id="uluchsheniya-v-mehanizmah-testirovaniya">  Improvements in testing mechanisms </h4><br><p>  The biggest change in the testing system is full support for <a href="http://junit.org/junit5/">JUnit</a> 5 Jupiter.  I’ll talk about this in more detail below, but when you launch a new application on Spring Boot 2, you still use JUnit 4 by default, but switching to JUnit 5 is a trivial task. </p><br><h3 id="chto-novogo-v-spring-boot-2">  What's new in Spring Boot 2 </h3><br><h4 id="obnovleniya-storonnih-bibliotek">  Third Party Updates </h4><br><p>  With each new release of Spring Boot, the Spring team is able to update various dependencies. </p><br><ul><li>  Thymeleaf 3 * </li><li>  Jetty 9.4 </li><li>  Tomcat 8.5 </li><li>  Hibernate 5.2 </li><li>  Flyway 5 </li><li>  Gradle 4 </li></ul><br><p>  * <em>Thymeleaf starter now has a built-in thymeleaf-extras-java8time.</em> </p><br><h4 id="bezopasnost-i-reactive-spring-data">  Security and Reactive Spring Data </h4><br><p>  With the transition to Spring WebFlux, Spring Data has added support for applications with asynchronous data streams.  Currently, Cassandra, MongoDB, Couchbase and Redis have support for the asynchronous API.  In Spring Boot there are POM starters for all of them, thanks to which it is very easy to start working with them. </p><br><p>  It also became possible to use Spring Security 5.0 in our reactive applications. </p><br><h4 id="actuator">  Actuator </h4><br><p>  Spring Boot Actuator is nothing new, but it was rewritten from scratch.  If you are not familiar with Actuator, this is what it does: it automatically displays endpoints to get information about the status of the application.  Actuator in Spring Boot 1.x was written on top of servlets, and with the new reactive approaches, the Spring team needed a solution that supports both the old and reactive approaches.  In addition, the following changes were made to Actuator: </p><br><ul><li>  Redesign to support servlets and reactivities </li><li>  Status and detailed health-check became divided. </li><li>  Simplified Security Model </li><li>  Switch to Micrometer (this is like SLF4J, only for metrics) </li><li>  Improved JSON data structure </li><li>  Simplified process of creating custom endpoints. </li><li>  <a href="https://habr.com/en/users/endpoint/" class="user_link">Endpoint</a> </li><li>  @WebEndpoint </li><li>  @JmxEndpoint </li></ul><br><p> Probably, there may be difficulties in the upgrade due to changes in the security model, which we will discuss later.  By default, all web-endpoint's are accessible via the <code>/actuator</code> path with a URL in the form <code>/actuator/{id}</code> .  The path / <code>actuator</code> can be changed in the settings <code>management.endpoints.web.base-path</code> . </p><br><p>  There is a detailed separate <a href="https://docs.spring.io/spring-boot/docs/2.0.x/actuator-api/html/">documentation block for the Spring Boot Actuator Web API Endpoints</a> , you should start with it to familiarize yourself with this tool. </p><br><h4 id="plagin-gradle">  Gradle plugin </h4><br><p>  I always really liked Gradle, and I absolutely loved that the team decided to rewrite the plugin for Gradle. <br>  The Spring Boot Gradle plugin allows you to implement Spring Boot support in Gradle and allows you to package executable jar or war archives, run applications on the Spring Boot and manage dependencies through spring-boot-dependencies.  Gradle plugin in Spring Boot requires Gradle 4.0 or later. </p><br><p>  <strong>Beginning of work</strong> </p><br><p>  To start working with the plugin, you need to load it to the project. </p><br><pre> <code class="plaintext hljs">buildscript { repositories { maven { url 'https://repo.spring.io/libs-milestone' } } dependencies { classpath 'org.springframework.boot:spring-boot-gradle-plugin:2.0.0.RC1' } } apply plugin: 'org.springframework.boot'</code> </pre> <br><p>  <strong>Creating executable jar and war archives</strong> </p><br><p>  The bootRepackage task has been replaced by bootJar and bootWar to create jar and war files respectively.  Both tasks have more functionality than the standard similar command Gradle, providing access to all settings and logic. </p><br><p>  <strong>Dependency management</strong> </p><br><p>  The Gradle plugin in Spring Boot no longer pulls the plugin to manage dependencies automatically.  Instead, the Gradle Spring Boot plugin sees that the dependency management plugin is connected and imports the correct version of BOM.  This allows you to better control where and how dependency management is configured.  For most applications, it will be enough to add a plugin for managing dependencies: </p><br><pre> <code class="plaintext hljs">apply plugin: 'io.spring.dependency-management'</code> </pre> <br><p>  The <a href="https://docs.spring.io/spring-boot/docs/2.0.x/gradle-plugin/reference/html/">Gradle plugin has its own documentation</a> , which contains very useful information.  I recommend that anyone who wants to start working with Gradle follow this link. </p><br><h4 id="uproschennaya-sistema-bezopasnosti">  Simplified Security System </h4><br><p>  One of the main goals in Spring Boot 2.x was to simplify the security configuration and make it so that you can easily add custom security settings.  By default, all data is protected, including static resources and enduints of Actuators.  If Spring Security is in the classpath, Spring Boot will add the <code>@EnableWebSecurity</code> annotation, and what specific authentication mechanism will be used will determine the content-negotiation mechanism from Spring Security. </p><br><p>  When a user configures his security rules, the standard configuration of the Spring Boot security system will no longer be valid.  At this stage, the user will need to accurately write down all the safety rules.  This means that all security settings are collected in one place and there are no problems with the order of processing commands with the existing <code>WebSecurityConfigurerAdapters</code> . </p><br><p>  An example of individual security settings: </p><br><pre> <code class="plaintext hljs">http .authorizeRequests() // 1 .requestMatchers(EndpointRequest.to("status", "info")) .permitAll() // 2 .requestMatchers(EndpointRequest.toAnyEndpoint()) .hasRole("ACTUATOR") // 3 .requestMatchers(StaticResourceRequest.toCommonLocations()) .permitAll() // 4 .antMatchers("/**") .hasRole("USER") .and() ... // additional configuration</code> </pre> <br><ol><li>  <code>/status</code> and <code>/info</code> do not require authorization. </li><li>  All other actuators are protected by the role <code>ACTUATOR</code> . </li><li>  Location of shared static resources available to all. </li><li>  All other endpoint applications are protected by the <code>USER</code> role. </li></ol><br><h4 id="actuator-security">  Actuator security </h4><br><p>  Given that actuator's endpoints are fixed, it is necessary to include or exclude endpoints, depending on which ones you need.  Here are the settings that control this, since release 1.x they have changed. </p><br><pre> <code class="plaintext hljs"># ENDPOINTS WEB CONFIGURATION (WebEndpointProperties) management.endpoints.web.exposure.include=info,health # Endpoint IDs that should be included or '*' for all. management.endpoints.web.exposure.exclude= # Endpoint IDs that should be excluded. management.endpoints.web.base-path=/actuator # Base path for Web endpoints. Relative to server.servlet.context path or management.server.servlet.context-path if management.server.port is configured. management.endpoints.web.path-mapping= # Mapping between endpoint IDs and the path that should expose them.</code> </pre> <br><p>  If you are not sure how to configure these settings, bookmark the <a href="https://docs.spring.io/spring-boot/docs/2.0.x/reference/html/common-application-properties.html">documentation for the general settings of the application</a> . </p><br><h4 id="podderzhka-http2">  HTTP / 2 support </h4><br><p>  Incredibly, the release of the HTTP 1.1 specification was already in 1996.  I suppose it’s not necessary to remind you that the modern network is different in all respects.  If you want to implement HTTP / 2 support in a Spring MVC or WebFlux application, use the following parameter. </p><br><pre> <code class="plaintext hljs">server.http2.enabled=true</code> </pre> <br><p>  HTTP / 2 support depends on the selected web server and application environment, since this protocol is not supported in JDK8 out of the box.  Read more about this <a href="&amp;xid=25657,15700023,15700186,15700190,15700248&amp;usg=ALkJrhhhvAbCB7eT-s8VQypImdbiNUSDdA#howto-configure-">in the documentation</a> . </p><br><h4 id="konfiguracionnye-parametry">  Configuration parameters </h4><br><p>  In Spring Boot 1.x, the so-called relaxed binding was supported, in other words, you could define the name of the parameter in many ways (camel-case, underscore, hyphen), and eventually the value was assigned to the same property. </p><br><p>  Relaxed binding works the same way, and the way you read variables in your code has changed: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c96/e1b/0bc/c96e1b0bc18fb75d2192f855682d766a.png" alt="Data read"></p><br><p>  <a href="https://docs.spring.io/spring-boot/docs/2.0.x/reference/html/boot-features-external-config.html">24. Externalized Configuration</a> </p><br><p>  It can be up to the same docs.spring.io </p><br><h4 id="metrika">  Metrics </h4><br><p>  Spring Boot's own metric has been replaced by Micrometer.  It is developed by the Pivotal team and quickly adapts to Pivotal projects. </p><br><p>  Spring Boot Actuator provides autoconfiguration for <a href="https://micrometer.io/">Micrometer</a> , an application metrics interface that supports many types of monitoring, including: </p><br><ul><li>  <a href="https://docs.spring.io/spring-boot/docs/2.0.x/reference/html/production-ready-metrics.html">Atlas</a> </li><li>  <a href="https://docs.spring.io/spring-boot/docs/2.0.x/reference/html/production-ready-metrics.html">Datadog</a> </li><li>  <a href="https://docs.spring.io/spring-boot/docs/2.0.x/reference/html/production-ready-metrics.html">Ganglia</a> </li><li>  <a href="https://docs.spring.io/spring-boot/docs/2.0.x/reference/html/production-ready-metrics.html">Graphite</a> </li><li>  <a href="https://docs.spring.io/spring-boot/docs/2.0.x/reference/html/production-ready-metrics.html">Influx</a> </li><li>  <a href="https://docs.spring.io/spring-boot/docs/2.0.x/reference/html/production-ready-metrics.html">Jmx</a> </li><li>  <a href="https://docs.spring.io/spring-boot/docs/2.0.x/reference/html/production-ready-metrics.html">New relic</a> </li><li>  <a href="https://docs.spring.io/spring-boot/docs/2.0.x/reference/html/production-ready-metrics.html">Prometheus</a> </li><li>  <a href="https://docs.spring.io/spring-boot/docs/2.0.x/reference/html/production-ready-metrics.html">Signalfx</a> </li><li>  <a href="https://docs.spring.io/spring-boot/docs/2.0.x/reference/html/production-ready-metrics.html">Simple (in-memory)</a> </li><li>  <a href="https://docs.spring.io/spring-boot/docs/2.0.x/reference/html/production-ready-metrics.html">StatsD</a> </li><li>  <a href="https://docs.spring.io/spring-boot/docs/2.0.x/reference/html/production-ready-metrics.html">Wavefront</a> </li></ul><br><p><img src="https://habrastorage.org/getpro/habr/post_images/80f/d29/c55/80fd29c553f5e2747119d4345a660111.png" alt="Micrometer"></p><br><p>  More information about Micrometer at <a href="https://micrometer.io/">https://micrometer.io/</a> . </p><br><p>  An upgrade because of this can be painful for those who log tons of custom metrics. </p><br><h4 id="quartz-scheduler">  Quartz Scheduler </h4><br><p>  In Spring Boot 2, there is support for the Quartz schedule execution library, which is easy to add with the spring-boot-starter-quartz starter.  Supports work on RAM and on JDBC. </p><br><pre> <code class="plaintext hljs">&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt; &lt;/dependency&gt;</code> </pre> <br><h4 id="hikaricp-connection-pool">  HikariCP Connection Pool </h4><br><p>  Standard connection pool changed from Tomcat to HikariCP.  If you used spring.datasource.type to get Hikari to work in the Tomcat application, you can remove it.  Similarly, if you want to continue using the Tomcat pool, simply add the following to your configuration: </p><br><pre> <code class="plaintext hljs">spring.datasource.type=org.apache.tomcat.jdbc.pool.DataSource</code> </pre> <br><h4 id="instrumenty-razrabotchika">  Developer Tools </h4><br><p>  By default, every time the application is restarted, a report on the differences in configurations is recorded.  In other words, the report shows the changes in the auto-configuration of the application that occur as you make changes such as deleting / adding beans and setting configuration parameters. </p><br><p>  To disable the recording of this report, configure the following parameter: </p><br><pre> <code class="plaintext hljs">spring.devtools.restart.log-condition-evaluation-delta=false</code> </pre> <br><h4 id="podderzhka-kotlin-1">  Kotlin support </h4><br><p>  Earlier in this article it was mentioned about the official support of Kotlin.  There is also a <a href="https://docs.spring.io/spring-boot/docs/2.0.x/reference/html/boot-features-kotlin.html">specialized Kotlin documentation block</a> . </p><br><h4 id="junit-5">  JUnit 5 </h4><br><p>  As mentioned above, Spring Boot applications still use JUnit 4 by default. If you want to upgrade to JUnit 5, you need to exclude JUnit 4 from spring-boot-starter-test and add the necessary dependencies.  You will also need plugins from the list below. </p><br><pre> <code class="plaintext hljs">&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.platform&lt;/groupId&gt; &lt;artifactId&gt;junit-platform-surefire-provider&lt;/artifactId&gt; &lt;version&gt;${junit-platform.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;</code> </pre> <br><h4 id="rukovodstvo-po-perehodu-na-spring-boot-2">  Spring Boot 2 Migration Guide </h4><br><p>  I think it is possible not to talk about such an obvious fact that with such a large release just changing the version number in production is not the best way to upgrade.  First of all, I would advise you to read the <a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Migration-Guide">Spring Boot 2.0 Migration Guide</a> .  Personally, I found the solution to most of my problems in a simplified security model and parameter changes.  This guide has great tips for transferring parameter files. </p><br><p>  <em>In Spring Boot 2.0, many configuration options have been renamed / deleted, and developers need to update <code>application.properties</code> / <code>application.yml</code> to reflect these changes.</em>  <em>To facilitate this task, Spring Boot implemented the delivery of a new <code>spring-boot-properties-migrator</code> module.</em>  <em>Being added to your project as a dependency, it will not only analyze the application environment and display diagnostic results on startup, but also temporarily migrate settings in runtime.</em>  <em>This is a necessary action when migrating an application:</em> </p><br><pre> <code class="plaintext hljs">&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-properties-migrator&lt;/artifactId&gt; &lt;/dependency&gt;</code> </pre> <br><p>  I don’t know what you think about it, but I’ll definitely start messing around with Spring Boot 2 and working on migrating the code to this version, but usually with any major release I’m waiting for the release of the next minor version.  This applies not only to Spring, but also to other brands from Apple to Pivotal and even Angry Birds! </p></div>