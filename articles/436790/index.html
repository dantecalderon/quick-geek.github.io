<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>256 lines of bare C ++: we write a ray tracer from scratch in a few hours</title>
  <meta name="description" content="I am publishing another chapter from my lecture course on computer graphics ( here you can read the original in Russian, although the English version ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>256 lines of bare C ++: we write a ray tracer from scratch in a few hours</h1><div class="post__text post__text-html js-mediator-article">  I am publishing another chapter from my <a href="https://github.com/ssloy/tinyrenderer/wiki">lecture course on computer graphics</a> ( <a href="https://habr.com/ru/post/249139/">here you can read the</a> original in Russian, although the English version is newer).  This time the topic of conversation - <a href="https://github.com/ssloy/tinyraytracer">drawing scenes using ray tracing</a> .  As usual, I try to avoid third-party libraries, as this forces students to look under the hood. <br><br>  Similar projects on the Internet are already the sea, but almost all of them show complete programs, which are extremely difficult to understand.  For example, a very well-known <a href="https://www.taylorpetrick.com/blog/post/business-rt">rendering program that fits on a business card</a> .  Very impressive result, but to understand this code is very difficult.  My goal is not to show how I can, but to tell in detail how to reproduce such a thing.  Moreover, it seems to me that specifically this lecture is useful even not so much as educational material on computer graphics, but rather as a programming manual.  I will consistently show how to arrive at the final result, starting from scratch: how to decompose a complex task into elementary solvable steps. <br><br>  <i>Warning: just to consider my code, as well as just reading this article with a cup of tea in hand, does not make sense.</i>  <i>This article is designed for you to take up the keyboard and write your own engine.</i>  <i>He will certainly be better than mine.</i>  <i>Well, or just change the programming language!</i> <br><br>  So, today I will show how to draw such pictures: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/064/50f/65d/06450f65da7c0503838bc008dcaba6a3.jpg"><br><a name="habracut"></a><br><h1>  Stage one: save the image to disk </h1><br>  I don't want to bother with window managers, mouse / keyboard handling, and the like.  The result of our program will be a simple image saved to disk.  So, the first thing we need to be able to do is save the image to disk.  <a href="https://github.com/ssloy/tinyraytracer/tree/bd36c9857305b3cbd06f5b768bb48a92df9ae68b">Here</a> is the code that allows you to do this.  Let me give him the main file: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;limits&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;vector&gt; #include "geometry.h" void render() { const int width = 1024; const int height = 768; std::vector&lt;Vec3f&gt; framebuffer(width*height); for (size_t j = 0; j&lt;height; j++) { for (size_t i = 0; i&lt;width; i++) { framebuffer[i+j*width] = Vec3f(j/float(height),i/float(width), 0); } } std::ofstream ofs; // save the framebuffer to file ofs.open("./out.ppm"); ofs &lt;&lt; "P6\n" &lt;&lt; width &lt;&lt; " " &lt;&lt; height &lt;&lt; "\n255\n"; for (size_t i = 0; i &lt; height*width; ++i) { for (size_t j = 0; j&lt;3; j++) { ofs &lt;&lt; (char)(255 * std::max(0.f, std::min(1.f, framebuffer[i][j]))); } } ofs.close(); } int main() { render(); return 0; }</span></span></span></span></code> </pre> <br>  In the main function, only the render () function is called, nothing else.  What is inside the render () function?  First of all, I define a picture as a one-dimensional array of framebuffer values ‚Äã‚Äãof type Vec3f, these are simple three-dimensional vectors that give us the color (r, g, b) for each pixel. <br><br>  The class of vectors lives in the geometry.h file, I will not describe it here: first, everything is trivial, simple manipulation of two and three-dimensional vectors (addition, subtraction, assignment, scalar multiplication, scalar production), and second, <a href="https://habr.com/ru/users/gbg/" class="user_link">gbg</a> has already <a href="https://habr.com/ru/post/248909/">described</a> it in <a href="https://habr.com/ru/post/248909/">detail</a> as part of a course on computer graphics. <br><br>  I save the picture in <a href="https://en.wikipedia.org/wiki/Netpbm_format">ppm format</a> ;  This is the easiest way to save images, although it is not always the most convenient for further viewing.  If you want to save in other formats, I recommend to connect a third-party library, for example, <a href="https://github.com/nothings/stb">stb</a> .  This is an excellent library: it is enough to include one stb_image_write.h header file in the project, and this will allow you to save at least in png, at least in jpg. <br><br>  So, the goal of this stage is to make sure that we can a) create a picture in memory and record different color values ‚Äã‚Äãthere b) save the result to disk so that it can be viewed in a third-party program.  Here is the result: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec1/8d8/1f8/ec18d81f825957255d786b50c05c8c4b.jpg"><br><br><h1>  Stage two, the most difficult: direct ray tracing </h1><br>  This is the most important and difficult stage of the whole chain.  I want to define one sphere in my code and show it on the screen without bothering with materials or lighting.  This is how our result should look like: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b02/143/d02/b02143d02d333d683313d209ec14eb25.jpg"><br><br>  For convenience, in my repository there is one commit per stage;  Github makes it very convenient to view your changes.  <a href="https://github.com/ssloy/tinyraytracer/commit/5806eb45e93dab225ab335824cbc3f537d511b28">Here, for example</a> , what has changed in the second commit compared with the first. <br><br>  To begin with: what do we need in order to represent the sphere in the computer's memory?  Four numbers are enough for us: a three-dimensional vector with the center of a sphere and a scalar that describes the radius: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sphere</span></span></span><span class="hljs-class"> {</span></span> Vec3f center; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> radius; Sphere(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3f &amp;c, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> &amp;r) : center(c), radius(r) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ray_intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;t0)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ Vec3f L = center - orig; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> tca = L*dir; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d2 = L*L - tca*tca; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d2 &gt; radius*radius) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> thc = sqrtf(radius*radius - d2); t0 = tca - thc; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t1 = tca + thc; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t0 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) t0 = t1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t0 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } };</code> </pre><br>  The only non-trivial thing in this code is a function that allows you to check whether a given beam (originating from orig in the direction of dir) intersects with our sphere.  A detailed description of the algorithm for checking the intersection of the ray and sphere can be <a href="http://www.lighthouse3d.com/tutorials/maths/ray-sphere-intersection/">found here</a> , I highly recommend doing this and checking my code. <br><br>  How does ray tracing work?  Very simple.  At the first stage, we just swept the picture with a gradient: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;height; j++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;width; i++) { framebuffer[i+j*width] = Vec3f(j/<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(height),i/<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(width), <span class="hljs-number"><span class="hljs-number">0</span></span>); } }</code> </pre><br>  Now for each pixel we will form a ray going from the center of coordinates and passing through our pixel, and check if this ray crosses our sphere. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/66d/a0e/be3/66da0ebe356e82253f0492e6335f114e.svg"><br><br>  If there is no intersection with the sphere, then we put color1, otherwise color2: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast_ray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Sphere &amp;sphere)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sphere_dist = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;::max(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!sphere.ray_intersect(orig, dir, sphere_dist)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vec3f(<span class="hljs-number"><span class="hljs-number">0.2</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, <span class="hljs-number"><span class="hljs-number">0.8</span></span>); <span class="hljs-comment"><span class="hljs-comment">// background color } return Vec3f(0.4, 0.4, 0.3); } void render(const Sphere &amp;sphere) { Ôøº [...] for (size_t j = 0; j&lt;height; j++) { for (size_t i = 0; i&lt;width; i++) { float x = (2*(i + 0.5)/(float)width - 1)*tan(fov/2.)*width/(float)height; float y = -(2*(j + 0.5)/(float)height - 1)*tan(fov/2.); Vec3f dir = Vec3f(x, y, -1).normalize(); framebuffer[i+j*width] = cast_ray(Vec3f(0,0,0), dir, sphere); } } Ôøº [...] }</span></span></code> </pre><br>  At this point, I recommend taking a pencil and checking all calculations on paper, both the intersection of the ray with the sphere and the sweeping of the picture by the rays.  Just in case, our camera is determined by the following things: <br><br><ul><li>  picture width </li><li>  picture height </li><li>  viewing angle, fov </li><li>  camera location, Vec3f (0,0,0) </li><li>  gaze direction, along the z axis, in the direction of minus infinity </li></ul><br><h1>  Stage three: add more spheres </h1><br>  All the hardest is over, now our path is clear.  If we can draw one sphere.  then obviously add some more work will not be.  <a href="https://github.com/ssloy/tinyraytracer/commit/c19c430151cb659372b4988876173b022164e371">Look at the</a> changes in the code, and here is the result: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc0/f37/6c9/fc0f376c9cb8971781f2a24065b47fa5.jpg"><br><br><h1>  Stage Four: Lighting </h1><br>  Everyone is good at our picture, but that's just not enough lighting.  Throughout the rest of the article, we will only talk about it.  Add a few point sources of lighting: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Light</span></span></span><span class="hljs-class"> {</span></span> Light(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3f &amp;p, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> &amp;i) : position(p), intensity(i) {} Vec3f position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> intensity; };</code> </pre><br>  Considering real lighting is a very, very difficult task, so, like everyone else, we will fool the eye by drawing completely non-physical, but as far as possible believable results.  First note: why is it cold in winter and hot in summer?  Because the heating of the earth's surface depends on the angle of sunlight.  The higher the sun above the horizon, the brighter the surface is illuminated.  Conversely, the lower over the horizon, the weaker.  Well, after the sun sets below the horizon, photons do not even reach us.  With reference to our spheres: here is our beam, emitted from the camera (no relation to photons, pay attention!) Crossed with the sphere.  How do we understand how the intersection point is lit?  You can simply look at the angle between the normal vector at this point and the vector that describes the direction of the light.  The smaller the angle, the better the surface is lit.  To make it more convenient, you can simply take a scalar product between the normal vector and the light vector.  I recall that the production between two vectors a and b is equal to the product of the norms of the vectors by the cosine of the angle between the vectors: a * b = | a |  | b |  cos (alpha (a, b)).  If we take vectors of unit length, then the simplest scalar product will give us the intensity of illumination of the surface. <br><br>  Thus, in the cast_ray function, instead of the constant color, we will return the color taking into account the sources of illumination: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast_ray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Sphere &amp;sphere)</span></span></span><span class="hljs-function"> </span></span>{ [...] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> diffuse_light_intensity = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;lights.size(); i++) { Vec3f light_dir = (lights[i].position - point).normalize(); diffuse_light_intensity += lights[i].intensity * <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(<span class="hljs-number"><span class="hljs-number">0.f</span></span>, light_dir*N); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> material.diffuse_color * diffuse_light_intensity; }</code> </pre><br>  <a href="https://github.com/ssloy/tinyraytracer/commit/9a728fff2bbebb1eedd86e1ac89f657d43191609">See the</a> changes <a href="https://github.com/ssloy/tinyraytracer/commit/9a728fff2bbebb1eedd86e1ac89f657d43191609">here</a> , but the result of the program: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/207/766/76d/20776676d3aff568b466807ef548ea5a.jpg"><br><br><h1>  Stage Five: shiny surfaces </h1><br>  The trick with the scalar product between the normal vector and the vector of light approximates well the illumination of matte surfaces, in the literature it is called diffuse illumination.  What to do if we want smooth and shiny?  I want to get this picture: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2d6/b39/c52/2d6b39c52aaa6a8c8667fd2df19f2e93.jpg"><br><br>  See <a href="https://github.com/ssloy/tinyraytracer/commit/f5ec45c2541feb86b6a30cc3bb04917d60d13e9b">how little</a> change was needed.  In short, the brightening on brilliant surfaces is brighter, the smaller the angle between the direction of the look and the direction of the <i>reflected</i> light.  Well, the angles, of course, we will consider through the scalar product, exactly as before. <br><br>  This gymnastics with matte and shiny surface lighting is known as <a href="https://en.wikipedia.org/wiki/Phong_reflection_model">the Phong model</a> .  The wiki has a fairly detailed description of this lighting model, it is well read when compared in parallel with my code.  Here is the key picture to understand: <br><img src="https://habrastorage.org/getpro/habr/post_images/881/d77/0ca/881d770ca8779cc876808a22c0fd8cce.png"><br><br><h1>  Stage Six: Shadows </h1><br>  And why do we have the light, but no shadows?  Disorder!  I want this picture: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e8f/fdd/04c/e8ffdd04c72dfc92f0845bb7b079faf7.jpg"><br><br>  <a href="https://github.com/ssloy/tinyraytracer/commit/ef70d1356169dacb3183ad4fcb4c23f1d7003e1b">Only six lines of code</a> allow us to achieve this: when drawing each point, we just make sure that the ray-source of light does not intersect the objects of our scene, and if it crosses, then skip the current source of light.  There is only a small subtlety: I just shift the point in the direction of the normal: <br><br><pre> <code class="cpp hljs">Vec3f shadow_orig = light_dir*N &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? point - N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span> : point + N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span>;</code> </pre><br>  Why?  Yes, simply our point lies on the surface of the object, and (excluding the question of numerical errors), any beam from this point will cross our scene. <br><br><h1>  Stage Seven: Reflections </h1><br>  This is unbelievable, but to add reflections to our scene, we only need to add three lines of code: <br><br><pre> <code class="cpp hljs"> Vec3f reflect_dir = reflect(dir, N).normalize(); Vec3f reflect_orig = reflect_dir*N &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? point - N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span> : point + N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span>; <span class="hljs-comment"><span class="hljs-comment">// offset the original point to avoid occlusion by the object itself Vec3f reflect_color = cast_ray(reflect_orig, reflect_dir, spheres, lights, depth + 1);</span></span></code> </pre><br>  <a href="https://github.com/ssloy/tinyraytracer/commit/c80479d1d22fe98f41b584972affeb43422a23a6">See for yourself:</a> when intersecting with an object, we simply consider the reflected beam (the function of calculating the debris was useful!) And recursively call the cast_ray function in the direction of the reflected beam.  Be sure to play with the <a href="">depth of recursion</a> , I set it equal to four, start from scratch, what will change in the picture?  Here is my result with a working reflection and a depth of four: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a9d/1c2/e6d/a9d1c2e6d428aaba07953cae3fa007ea.jpg"><br><br><h1>  Stage Eight: Refraction </h1><br>  Having learned to count reflections, <a href="https://github.com/ssloy/tinyraytracer/commit/b69793bf6e8be54973cad1b18185a67dbf11bad1">refractions are considered exactly the same</a> .  One function allows us to calculate the direction of the refracted ray ( <a href="https://en.wikipedia.org/wiki/Snell%2527s_law">according to Snell's law</a> ), and three lines of code in our recursive cast_ray function.  Here is the result, in which the nearest ball became ‚Äúglass‚Äù, it refracts and reflects a little: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8c8/14a/56a/8c814a56aafc88609ebeb8c5a6f9a494.jpg"><br><br><h1>  Stage nine: add more objects </h1><br>  And why are we all without milk, but without milk.  Up to this point, we have rendered only spheres, since this is one of the simplest non-trivial mathematical objects.  And let's add a piece of the plane.  The classic of the genre is a chessboard.  For this we need a <a href="https://github.com/ssloy/tinyraytracer/commit/5e0da1f09fdbc585caa16df4c7b2f527d61536ef">dozen lines</a> in a function that considers the intersection of the beam with the stage. <br><br>  Well, here's the result: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d88/871/a50/d88871a5021eb69cc64c7b9a5915e855.jpg"><br><br>  As I promised, exactly 256 lines of code, <a href="https://github.com/ssloy/tinyraytracer">count for yourself</a> ! <br><br><h1>  Stage ten: homework </h1><br>  We have come a long way: we learned how to add objects to the scene, count the rather complex lighting.  Let me leave two tasks as homework.  Absolutely all the preparatory work has already been done in the <a href="https://github.com/ssloy/tinyraytracer/tree/homework_assignment">homework_assignment</a> branch.  Each task will require a maximum of ten lines of code. <br><br><h3>  Task one: Environment map </h3><br>  At the moment, if the beam does not intersect the scene, then we just give it a constant color.  And why, in fact, permanent?  Let's take a spherical photo (file <a href="">envmap.jpg</a> ) and use it as a background!  To make life easier, I linked our project with the stb library for the convenience of working with zhpegami.  It should be such a render: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3e0/531/fa9/3e0531fa9ee361de7580029e818bc5f5.jpg"><br><br><h3>  Second task: quack! </h3><br>  We are able to render both spheres and planes (see chessboard).  So let's add a drawing of triangulated models!  I wrote code that allows you to read a grid of triangles, and added a ray-triangle intersection function there.  Now add a duckling to our scene should be quite trivial! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/064/50f/65d/06450f65da7c0503838bc008dcaba6a3.jpg"><br><br><h1>  Conclusion </h1><br>  My main task is to show projects that are interesting (and easy!) To program, I really hope that I can do it.  This is very important, as I am convinced that the programmer should write a lot and with taste.  I don‚Äôt know about you, but personally, accounting and sapper, with quite comparable code complexity, do not appeal at all. <br><br>  Two hundred and fifty lines of raytracing can actually be written in a few hours.  <a href="https://github.com/ssloy/tinyrenderer/wiki">Five hundred lines of the</a> software rasterizer can be mastered in a few days.  Next time we will sort out <a href="https://ru.wikipedia.org/wiki/Ray_casting">rajkasting</a> , and at the same time I will show the simplest games that my first-year students write as part of C ++ programming training.  Stay tuned! </div><p>Source: <a href="https://habr.com/ru/post/436790/">https://habr.com/ru/post/436790/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>