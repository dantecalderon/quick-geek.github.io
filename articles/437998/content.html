<div class="post__text post__text-html js-mediator-article"><p>  Some time ago, a link to the article <a href="http://lucteo.ro/2018/12/28/modern-dining-philosophers/">"Modern dining philosophers"</a> spread over resources like Reddit and HackerNews.  The article is interesting, it shows several solutions to this well-known problem, implemented in modern C ++ using the task-based approach.  If someone has not read this article, then it makes sense to spend time and read it. </p><br><p>  However, I cannot say that the solutions presented in the article seemed simple and clear to me.  This is probably due to the use of Tasks.  Too many of them are created and dispatched by various dispatchers / serializers.  So it is not always clear where, when and what tasks are performed. </p><br><p>  At the same time, the task-based approach is not the only one possible to solve such problems.  Why not see how the task of the "dining philosophers" is solved through the models of actors and CSP? </p><br><p>  Therefore, I tried to look at and implemented several solutions to this problem both with the use of Actors and with the use of CSP.  The code for these solutions can be found <a href="https://bitbucket.org/sobjectizerteam/so5_dining_philosophers">in the BitBucket repository</a> .  And under the cut explanations and explanations, so who cares, you are welcome under the cat. </p><a name="habracut"></a><br><h1 id="neskolko-obschih-slov">  A few common words </h1><br><p>  I didn’t have the goal of exactly repeating the solutions shown in the very article <a href="http://lucteo.ro/2018/12/28/modern-dining-philosophers/">"Modern dining philosophers"</a> , especially since I fundamentally dislike one important thing: in fact, the "philosopher" does not do anything in those decisions.  He only says “I want to eat,” and then either someone magically provides forks to him, or he says “now it won't work out”. </p><br><p>  It is clear why the author resorted to this behavior: it allows you to use the same implementation of the "philosopher" in conjunction with different implementations of the "protocols".  However, it seems to me personally that it is more interesting when exactly the “philosopher” tries to take one fork first, then the other.  And when the "philosopher" is forced to handle unsuccessful attempts to seize the plug. </p><br><p>  It is such an implementation of the task of the "dining philosophers" that I tried to do.  In this case, some solutions used the same approaches as in the above-mentioned article (for example, implemented by the ForkLevelPhilosopherProtocol and WaiterFair protocols). </p><br><p>  I built my decisions on the basis of <a href="https://habr.com/post/304386/">SObjectizer</a> , which would hardly surprise those who read my articles before.  If someone has not yet heard about SObjectizer, then in a nutshell: this is one of the few living and developing OpenSource "action frameworks" for C ++ (among others, <a href="http://actor-framework.org/">CAF</a> and <a href="https://state-machine.com/qpcpp/">QP / C ++</a> can also be mentioned).  I hope that the examples given with my comments will be clear enough even for those unfamiliar with SObjectizer.  If not, I will be happy to answer questions in the comments. </p><br><h1 id="resheniya-na-baze-aktorov">  Actor based solutions </h1><br><p>  The discussion of implemented solutions will begin with those made on the basis of the Actors.  First, consider the implementation of the Edsger Dijkstra solution, then move on to several other solutions and see how the behavior of each of the solutions differs. </p><br><h2 id="reshenie-deykstry">  Dijkstra's decision </h2><br><p>  Edsger Dijkstra, not only did he formulate the task of “dining filophos” (formulated using forks and spaghetti voiced by Tony Hoar), he also suggested a very simple and beautiful solution.  Namely: philosophers should seize the forks only in the order of increasing numbers of the forks, and if the philosopher managed to take the first fork, then he would not let go of it until he received the second fork. </p><br><p>  For example, if a philosopher needs to use plugs with numbers 5 and 6, the philosopher must first take plug number 5. Only after that he can take plug number 6. Thus, if forks with smaller numbers lie to the left of philosophers, then the philosopher must first take the left fork and only then can it take the right fork. </p><br><p>  The last philosopher on the list, who has to deal with forks for numbers (N-1) and 0, does the opposite: he first takes the right fork with the number 0, and then the left fork with the number (N-1). </p><br><p>  To implement this approach, two types of actors are required: one for forks, the second for philosophers.  If the philosopher wants to eat, he sends a message to the corresponding actor-fork to seize the fork, and the actor-fork responds with a response message. </p><br><p>  The implementation code for this approach can be seen <a href="">here</a> . </p><br><h3 id="soobscheniya">  Messages </h3><br><p>  Before talking about the actors, you need to look at the messages that the actors will exchange: </p><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">take_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> m_who; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> m_philosopher_index; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">taken_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">put_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {};</code> </pre> <br><p>  When a philosopher actor wants to take a fork, he sends the <code>take_t</code> message to the fork <code>take_t</code> , and the actor-fork responds with the message <code>taken_t</code> .  When the philosopher actor finishes eating and wants to put the forks back on the table, he sends the messages put_t to the forks <code>put_t</code> . </p><br><p>  In the <code>take_t</code> message, the <code>take_t</code> field indicates the mailbox (aka mbox) of the actor-philosopher.  A reply message <code>taken_t</code> should be sent to this <code>taken_t</code> .  The second field from <code>take_t</code> is not used in this example, we will need it when we get to the waiter_with_queue and waiter_with_timestamps implementations. </p><br><h3 id="aktor-vilka">  Actor Fork </h3><br><p>  Now we can look at what the actor-plug is.  Here is his code: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fork_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx ) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx) } {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Начальным должно быть состояние 'free'. this &gt;&gt;= st_free; // В состоянии 'free' обрабатывается только одно сообщение. st_free .event( [this]( mhood_t&lt;take_t&gt; cmd ) { this &gt;&gt;= st_taken; so_5::send&lt; taken_t &gt;( cmd-&gt;m_who ); } ); // В состоянии 'taken' обрабатываются два сообщения. st_taken .event( [this]( mhood_t&lt;take_t&gt; cmd ) { // Философу придется подождать в очереди. m_queue.push( cmd-&gt;m_who ); } ) .event( [this]( mhood_t&lt;put_t&gt; ) { if( m_queue.empty() ) // Вилка сейчас никому не нужна. this &gt;&gt;= st_free; else { // Вилка должна достаться первому из очереди. const auto who = m_queue.front(); m_queue.pop(); so_5::send&lt; taken_t &gt;( who ); } } ); } private : // Определение состояний для актора. const state_t st_free{ this, "free" }; const state_t st_taken{ this, "taken" }; // Очередь ждущих философов. std::queue&lt; so_5::mbox_t &gt; m_queue; };</span></span></code> </pre> <br><p>  Each actor in SObjectizer should be derived from the base class <code>agent_t</code> .  What we see here is for the <code>fork_t</code> type. </p><br><p>  In the <code>fork_t</code> class, the <code>so_define_agent()</code> method is <code>so_define_agent()</code> .  This is a special method, it is automatically called by SObjectizer when registering a new agent.  In the <code>so_define_agent()</code> method, the <code>so_define_agent()</code> is "configured" to work in SObjectizer: the starting state changes, the necessary messages are subscribed to. </p><br><p>  Each actor in a SObjectizer is a state machine with states (even if the actor uses only one default state).  Here the <code>fork_t</code> actor has two states: <em>free</em> and <em>taken</em> .  When the actor is <em>free</em> , the plug can be "captured" by the philosopher.  And after the fork is <code>fork_t</code> actor should go into the state of <em>taken</em> .  Inside the <code>fork_t</code> class <code>fork_t</code> states are represented by instances of <code>st_free</code> and <code>st_taken</code> special type <code>state_t</code> . </p><br><p>  States allow you to process incoming messages in different ways.  For example, in the <em>free</em> state, the agent responds only to <code>take_t</code> and this reaction is very simple: the state of the actor changes and the response <code>taken_t</code> : </p><br><pre> <code class="cpp hljs">st_free .event( [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]( <span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span>&gt; cmd ) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_taken; so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span> &gt;( cmd-&gt;m_who ); } );</code> </pre> <br><p>  While all other messages, including <code>put_t</code> in the <em>free</em> state, are simply ignored. </p><br><p>  In the state <em>taken, the</em> actor handles two messages, and even the <code>take_t</code> message it processes differently: </p><br><pre> <code class="cpp hljs">st_taken .event( [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]( <span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span>&gt; cmd ) { m_queue.push( cmd-&gt;m_who ); } ) .event( [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]( <span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">put_t</span></span>&gt; ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_queue.empty() ) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_free; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> who = m_queue.front(); m_queue.pop(); so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span> &gt;( who ); } } );</code> </pre> <br><p>  Here the handler for <code>put_t</code> most interesting: if the queue of waiting philosophers is empty, then we can return to <em>free</em> , but if not empty, then the first one should be sent <code>taken_t</code> . </p><br><h3 id="aktor-filosof">  Actor-philosopher </h3><br><p>  <a href="">The code of the actor-philosopher is</a> much more extensive, so I will not give it here in full.  We will discuss only the most significant fragments. </p><br><p>  The actor-philosopher has several more states: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_thinking{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"thinking.normal"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_wait_left{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"wait_left"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_wait_right{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"wait_right"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_eating{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"eating"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_done{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"done"</span></span> };</code> </pre> <br><p>  The actor starts his work in the state of <em>thinking</em> , then switches to <em>wait_left</em> , then to <em>wait_right</em> , then to <em>eating</em> .  From <em>eating the</em> actor can return to <em>thinking</em> or can go to <em>done</em> if the philosopher ate everything he should have. </p><br><p>  The state diagram for the actor-philosopher can be represented as follows: </p><br><p><img src="https://habrastorage.org/webt/ir/j0/sm/irj0smrzaedcsud20y71aynfqb4.png" alt="image"></p><br><p>  The logic of the behavior of the actor is described in the implementation of its <code>so_define_agent()</code> method: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// В состоянии thinking реагируем только на сигнал stop_thinking. st_thinking .event( [=]( mhood_t&lt;stop_thinking_t&gt; ) { // Пытаемся взять левую вилку. this &gt;&gt;= st_wait_left; so_5::send&lt; take_t &gt;( m_left_fork, so_direct_mbox(), m_index ); } ); // Когда ждем левую вилку реагируем только на taken. st_wait_left .event( [=]( mhood_t&lt;taken_t&gt; ) { // У нас есть левая вилка. Пробуем взять правую. this &gt;&gt;= st_wait_right; so_5::send&lt; take_t &gt;( m_right_fork, so_direct_mbox(), m_index ); } ); // Пока ждем правую вилку, реагируем только на taken. st_wait_right .event( [=]( mhood_t&lt;taken_t&gt; ) { // У нас обе вилки, можно поесть. this &gt;&gt;= st_eating; } ); // Пока едим реагируем только на stop_eating. st_eating // 'stop_eating' должен быть отослан как только входим в 'eating'. .on_enter( [=] { so_5::send_delayed&lt; stop_eating_t &gt;( *this, eat_pause() ); } ) .event( [=]( mhood_t&lt;stop_eating_t&gt; ) { // Обе вилки нужно вернуть на стол. so_5::send&lt; put_t &gt;( m_right_fork ); so_5::send&lt; put_t &gt;( m_left_fork ); // На шаг ближе к финалу. ++m_meals_eaten; if( m_meals_count == m_meals_eaten ) this &gt;&gt;= st_done; // Съели все, что могли, пора завершаться. else think(); } ); st_done .on_enter( [=] { // Сообщаем о том, что мы закончили. completion_watcher_t::done( so_environment(), m_index ); } ); }</span></span></code> </pre> <br><p>  Perhaps the only point on which it should stop especially is the approach to imitating the processes of "thinking" and "food."  There is no <code>this_thread::sleep_for</code> or any other way of blocking the current working thread in the actor code.  Instead, deferred messages are used.  For example, when the actor enters the <em>eating</em> state, it sends to itself a pending message <code>stop_eating_t</code> .  This message is given to the SObjectizer timer, and the timer delivers the message to the actor when the time comes. </p><br><p>  The use of deferred messages allows you to run all the actors in the context of a single working thread.  Roughly speaking, one thread reads from some message queue and pulls the handler of the next message from the corresponding receiving actor.  More on working contexts for actors will be discussed below. </p><br><h3 id="rezultaty">  results </h3><br><p>  The results of this implementation may look like this (small fragment): </p><br><pre> <code class="plaintext hljs"> Socrates: tttttttttttLRRRRRRRRRRRRRREEEEEEEttttttttLRRRRRRRRRRRRRREEEEEEEEEEEEE Plato: ttttttttttEEEEEEEEEEEEEEEEttttttttttRRRRRREEEEEEEEEEEEEEttttttttttLLL Aristotle: ttttEEEEEtttttttttttLLLLLLRRRREEEEEEEEEEEEttttttttttttLLEEEEEEEEEEEEE Descartes: tttttLLLLRRRRRRRREEEEEEEEEEEEEtttLLLLLLLLLRRRRREEEEEEttttttttttLLLLLL Spinoza: ttttEEEEEEEEEEEEEttttttttttLLLRRRREEEEEEEEEEEEEttttttttttRRRREEEEEEtt Kant: ttttttttttLLLLLLLRREEEEEEEEEEEEEEEttttttttttLLLEEEEEEEEEEEEEEtttttttt Schopenhauer: ttttttEEEEEEEEEEEEEttttttLLLLLLLLLEEEEEEEEEttttttttLLLLLLLLLLRRRRRRRR Nietzsche: tttttttttLLLLLLLLLLEEEEEEEEEEEEEttttttttLLLEEEEEEEEEttttttttRRRRRRRRE Wittgenstein: ttttEEEEEEEEEEtttttLLLLLLLLLLLLLEEEEEEEEEttttttttttttRRRREEEEEEEEEEEt Heidegger: tttttttttttLLLEEEEEEEEEEEEEEtttttttLLLLLLREEEEEEEEEEEEEEEtttLLLLLLLLR Sartre: tttEEEEEEEEEttttLLLLLLLLLLLLRRRRREEEEEEEEEtttttttLLLLLLLLRRRRRRRRRRRR</code> </pre> <br><p>  Read this as follows: </p><br><ul><li>  <code>t</code> means that the philosopher "reflects"; </li><li>  <code>L</code> means that the philosopher is waiting for the capture of the left fork (is in the <em>wait_left</em> state); </li><li>  <code>R</code> means that the philosopher is waiting for the capture of the right fork (is in the <em>wait_right</em> state); </li><li>  <code>E</code> means that the philosopher is "eating." </li></ul><br><p>  We can see that Socrates can take the plug on the left only after Sartre gives it away.  Then Socrates will wait for Plato to release the right fork.  Only then can Socrates eat. </p><br><h2 id="prostoe-reshenie-bez-arbitra-oficianta">  A simple decision without an arbitrator (waiter) </h2><br><p>  If we analyze the result of the work of Dijkstra’s solution, we will see that philosophers spend a lot of time waiting for the forks to be captured.  What is not good, because  This time can also be spent on meditation.  Not for nothing is the opinion that if you think on an empty stomach, you can get much more interesting and unexpected results;) </p><br><p>  Let's look at the simplest solution, in which the philosopher returns the first fork seized if he cannot capture the second one (in the Modern Dining philosophers article mentioned above, this solution is implemented by ForkLevelPhilosopherProtocol). </p><br><p>  The source code of this implementation can be seen <a href="">here</a> , and the code of the corresponding actor-philosopher is <a href="">here</a> . </p><br><h3 id="soobscheniya-1">  Messages </h3><br><p>  This solution uses almost the same set of messages: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">take_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> m_who; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> m_philosopher_index; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">busy_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">taken_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">put_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {};</code> </pre> <br><p>  The only difference is the presence of the <code>busy_t</code> signal.  This signal actor-fork sends in response to the actor-philosopher if the plug is already captured by another philosopher. </p><br><h3 id="aktor-vilka-1">  Actor Fork </h3><br><p>  Actor-fork in this solution is even easier than in the decision Dijkstra: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fork_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx ) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>( ctx ) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_free; st_free.event( [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]( <span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span>&gt; cmd ) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_taken; so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span> &gt;( cmd-&gt;m_who ); } ); st_taken.event( []( <span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span>&gt; cmd ) { so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">busy_t</span></span> &gt;( cmd-&gt;m_who ); } ) .just_switch_to&lt; <span class="hljs-keyword"><span class="hljs-keyword">put_t</span></span> &gt;( st_free ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_free{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_taken{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }; };</code> </pre> <br><p>  We do not even need to keep the waiting line of philosophers here. </p><br><h3 id="aktor-filosof-1">  Actor-philosopher </h3><br><p>  The actor-philosopher in this implementation is similar to that of Dijkstra’s decision, but here the actor-philosopher also has to process <code>busy_t</code> , so the state diagram looks like this: </p><br><p><img src="https://habrastorage.org/webt/xa/ek/c8/xaekc8xbxewoj1e7myao4le6jn0.png" alt="image"></p><br><p>  Similarly, the entire logic of the actor-philosopher is defined in <code>so_define_agent()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ st_thinking .event&lt; <span class="hljs-keyword"><span class="hljs-keyword">stop_thinking_t</span></span> &gt;( [=] { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_wait_left; so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span> &gt;( m_left_fork, so_direct_mbox(), m_index ); } ); st_wait_left .event&lt; <span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span> &gt;( [=] { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_wait_right; so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span> &gt;( m_right_fork, so_direct_mbox(), m_index ); } ) .event&lt; <span class="hljs-keyword"><span class="hljs-keyword">busy_t</span></span> &gt;( [=] { think( st_hungry_thinking ); } ); st_wait_right .event&lt; <span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span> &gt;( [=] { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_eating; } ) .event&lt; <span class="hljs-keyword"><span class="hljs-keyword">busy_t</span></span> &gt;( [=] { so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">put_t</span></span> &gt;( m_left_fork ); think( st_hungry_thinking ); } ); st_eating .on_enter( [=] { so_5::send_delayed&lt; <span class="hljs-keyword"><span class="hljs-keyword">stop_eating_t</span></span> &gt;( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, eat_pause() ); } ) .event&lt; <span class="hljs-keyword"><span class="hljs-keyword">stop_eating_t</span></span> &gt;( [=] { so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">put_t</span></span> &gt;( m_right_fork ); so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">put_t</span></span> &gt;( m_left_fork ); ++m_meals_eaten; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_meals_count == m_meals_eaten ) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_done; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> think( st_normal_thinking ); } ); st_done .on_enter( [=] { <span class="hljs-keyword"><span class="hljs-keyword">completion_watcher_t</span></span>::done( so_environment(), m_index ); } ); }</code> </pre> <br><p>  In general, this is practically the same code as in Dijkstra’s solution, except that a couple of handlers for <code>busy_t</code> . </p><br><h3 id="rezultaty-1">  results </h3><br><p>  The results of the work look different: </p><br><pre> <code class="plaintext hljs"> Socrates: tttttttttL..R.....EEEEEEEEEEEEttttttttttR...LL..EEEEEEEttEEEEEE Plato: ttttEEEEEEEEEEEttttttL.....L..EEEEEEEEEEEEEEEttttttttttL....L.... Aristotle: ttttttttttttL..LR.EEEEEEtttttttttttL..L....L....R.....EEEEEEEEE Descartes: ttttttttttEEEEEEEEttttttttttttEEEEEEEEttttEEEEEEEEEEEttttttL..L.. Spinoza: ttttttttttL.....L...EEEEEEtttttttttL.L......L....L..L...R...R...E Kant: tttttttEEEEEEEttttttttL.L.....EEEEEEEEttttttttR...R..R..EEEEEtttt Schopenhauer: tttR..R..L.....EEEEEEEttttttR.....L...EEEEEEEEEEEEEEEEttttttttttt Nietzsche: tttEEEEEEEEEEtttttttttEEEEEEEEEEEEEEEttttL....L...L..L....EEEEEEE Wittgenstein: tttttL.L..L.....RR....L.....L....L...EEEEEEEEEEEEEEEtttttttttL. Heidegger: ttttR..R......EEEEEEEEEEEEEttttttttttR..L...L...L..L...EEEEtttttt Sartre: tttEEEEEEEtttttttL..L...L....R.EEEEEEEtttttEEEEtttttttR.....R..R.</code> </pre> <br><p>  Here we see a new symbol, which means that the actor-philosopher is in "hungry thoughts". </p><br><p>  Even on this short fragment, one can see that there are long moments of time during which the philosopher cannot eat.  This is because this solution is protected from the problem of deadlocks, but does not have protection against fasting. </p><br><h2 id="reshenie-s-oficiantom-i-ocheredyu">  Solution with a waiter and a queue </h2><br><p>  The simplest solution shown above without an arbitrator does not protect against fasting.  The above-mentioned article "Modern dining philosophers" contains a solution to the problem of fasting in the form of the WaiterFair protocol.  The bottom line is that an arbitrator (waiter) appears to whom philosophers turn to when they want to eat.  And the waiter has a queue of applications from philosophers.  And the philosopher gets the forks only if both of the forks are now free, and there is still no one in the queue of the neighbors of the philosopher who turned to the waiter. </p><br><p>  Let's look at how the same solution might look like on actors. </p><br><p>  The source code for this implementation can be found <a href="">here</a> . </p><br><h3 id="tryuk">  Trick </h3><br><p>  The easiest thing would be to introduce a new set of messages through which philosophers could communicate with the waiter.  But I wanted to save not only the already existing set of messages (i.e. <code>take_t</code> , <code>taken_t</code> , <code>busy_t</code> , <code>put_t</code> ).  I also wanted the same actor-philosopher to be used as in the previous decision.  Therefore, I needed to solve a clever puzzle: how to make the actor-philosopher communicate with the only actor-waiter, but at the same time thought that he interacts directly with the actors-forks (which are no longer in fact). </p><br><p>  This problem was solved with the help of a simple trick: the actor-waiter creates a set of mboxes, links to which are given to actors-philosophers as references to the mboxes of the forks.  At the same time, the actor-waiter subscribes to messages from all these mboxes (which is easily implemented in SObjectizer, since SObjectizer is not only / much of the Actor model, but also Pub / Sub is supported out of the box) . </p><br><p>  In code, it looks like this: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">waiter_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">waiter_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> forks_count ) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx) } , m_fork_states( forks_count, <span class="hljs-keyword"><span class="hljs-keyword">fork_state_t</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">free</span></span> ) { <span class="hljs-comment"><span class="hljs-comment">// Нужны mbox-ы для каждой "вилки" m_fork_mboxes.reserve( forks_count ); for( std::size_t i{}; i != forks_count; ++i ) m_fork_mboxes.push_back( so_environment().create_mbox() ); } ... void so_define_agent() override { // Требуется создать подписки для каждой "вилки". for( std::size_t i{}; i != m_fork_mboxes.size(); ++i ) { // Нам нужно знать индекс вилки. Поэтому используются лямбды. // Лямбда захватывает индекс и затем отдает этот индекс в // актуальный обработчик входящего сообщения. so_subscribe( fork_mbox( i ) ) .event( [i, this]( mhood_t&lt;take_t&gt; cmd ) { on_take_fork( std::move(cmd), i ); } ) .event( [i, this]( mhood_t&lt;put_t&gt; cmd ) { on_put_fork( std::move(cmd), i ); } ); } } private : ... // Почтовые ящики для несуществующих "вилок". std::vector&lt; so_5::mbox_t &gt; m_fork_mboxes;</span></span></code> </pre> <br><p>  Those.  First, create a vector mboxes for non-existent "forks", then subscribe to each of them.  Yes, so we subscribe to know which plug the request belongs to. </p><br><p>  The real handler for the <code>on_take_fork()</code> incoming request is the <code>on_take_fork()</code> method: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_take_fork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mhood_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">take_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; cmd, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fork_index )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Используем тот факт, что у левой вилки индекс совпадает // с индексом самого философа. if( fork_index == cmd-&gt;m_philosopher_index ) handle_take_left_fork( std::move(cmd), fork_index ); else handle_take_right_fork( std::move(cmd), fork_index ); }</span></span></code> </pre> <br><p>  By the way, it was here that we needed the second field from the <code>take_t</code> message. </p><br><p>  So, in <code>on_take_fork()</code> we have the original query and the index of the fork to which the query belongs.  Therefore, we can determine whether the philosopher is asking for the left or right fork.  And, accordingly, we can process them in different ways (and we have to process them in different ways). </p><br><p>  Since the philosopher always asks for the left plug first, we need to do all the necessary checks at this very moment.  And we may end up in one of the following situations: </p><br><ol><li>  Both forks are free and can be given to the philosopher who sent the request.  In this case, we <code>taken_t</code> philosopher, and mark the right fork as reserved so that no one else can take it. </li><li>  Plugs cannot be given to the philosopher.  No matter why.  Maybe some of them are busy right now.  Or in the queue there is someone from the neighbors of the philosopher. Как бы то ни было, мы помещаем философа, приславшего запрос, в очередь, после чего отсылаем ему <code>busy_t</code> . </li></ol><br><p> Благодаря такой логике работы философ, получивший <code>taken_t</code> для левой вилки, может спокойно послать запрос <code>take_t</code> для правой вилки. Этот запрос будет сразу же удовлетворен, т.к. вилка уже зарезервирована для данного философа. </p><br><h3 id="rezultaty-2">  results </h3><br><p> Если запустить получившееся решение, то можно увидеть что-то вроде: </p><br><pre> <code class="plaintext hljs"> Socrates: tttttttttttL....EEEEEEEEEEEEEEttttttttttL...L...EEEEEEEEEEEEEtttttL. Plato: tttttttttttL....L..L..L...L...EEEEEEEEEEEEEtttttL.....L....L.....EEE Aristotle: tttttttttL.....EEEEEEEEEttttttttttL.....L.....EEEEEEEEEEEtttL....LL Descartes: ttEEEEEEEEEEtttttttL.L..EEEEEEEEEEEEtttL..L....L....L.....EEEEEEEEEE Spinoza: tttttttttL.....EEEEEEEEEttttttttttL.....L.....EEEEEEEEEEEtttL....LL Kant: ttEEEEEEEEEEEEEtttttttL...L.....L.....EEEEEttttL....L...L..L...EEEEE Schopenhauer: ttttL...L.....L.EEEEEEEEEEEEEEEEEtttttttttttL..L...L..EEEEEEEttttttt Nietzsche: tttttttttttL....L..L..L...L...L.....L....EEEEEEEEEEEEttL.....L...L.. Wittgenstein: tttttttttL....L...L....L....L...EEEEEEEttttL......L.....L.....EEEEEE Heidegger: ttttttL..L...L.....EEEEEEEEEEEEtttttL...L..L.....EEEEEEEEEEEttttttL. Sartre: ttEEEEEEEEEEEEEttttttttL.....L...EEEEEEEEEEEEttttttttttttL.....EEEEE</code> </pre> <br><p> Можно обратить внимание на отсутствие символов <code>R</code> . Это потому, что не может возникнуть неудачи или ожидания на запросе правой вилки. </p><br><h2 id="esche-odno-reshenie-s-ispolzovaniem-arbitra-oficianta"> Еще одно решение с использованием арбитра (официанта) </h2><br><p> В некоторых случаях предыдущее решение waiter_with_queue может показывать результаты, похожие вот на этот: </p><br><pre> <code class="plaintext hljs"> Socrates: tttttEEEEEEEEEEEEEEtttL.....LL...L....EEEEEEEEEttttttttttL....L.....EE Plato: tttttL..L..L....LL...EEEEEEEEEEEEEEEttttttttttttL.....EEEEEEEEEttttttt Aristotle: tttttttttttL..L...L.....L.....L....L.....EEEEEEEEEEEEtttttttttttL....L.. Descartes: ttttttttttEEEEEEEEEEttttttL.....L....L..L.....L.....L..L...L..EEEEEEEEtt Spinoza: tttttttttttL..L...L.....L.....L....L.....L..L..L....EEEEEEEEEEtttttttttt Kant: tttttttttL....L....L...L...L....L..L...EEEEEEEEEEEttttttttttL...L......E Schopenhauer: ttttttL....L..L...L...LL...L...EEEEEtttttL....L...L.....EEEEEEEEEttttt Nietzsche: tttttL..L..L....EEEEEEEEEEEEEttttttttttttEEEEEEEEEEEEEEEttttttttttttL... Wittgenstein: tttEEEEEEEEEEEEtttL....L....L..EEEEEEEEEtttttL..L..L....EEEEEEEEEEEEEEEE Heidegger: tttttttttL...L..EEEEEEEEttttL..L.....L...EEEEEEEEEtttL.L..L...L....L...L Sartre: ttttttttttL..L....L...L.EEEEEEEEEEEtttttL...L..L....EEEEEEEEEEtttttttttt</code> </pre> <br><p> Можно увидеть наличие достаточно длинных периодов времени, когда философы не могут поесть даже не смотря на наличие свободных вилок. Например, левая и правая вилки для Канта свободны на протяжении длительного времени, но Кант не может их взять, т.к. в очереди ожидания уже стоят его соседи. Которые ждут своих соседей. Которые ждут своих соседей и т.д. </p><br><p> Поэтому рассмотренная выше реализация waiter_with_queue защищает от голодания в том смысле, что рано или поздно философ поест. Это ему гарантировано. Но периоды голодания могут быть довольно долгими. И утилизация ресурсов может быть не оптимальной временами. </p><br><p> Дабы решить эту проблему я реализовал еще одно решение, waiter_with_timestamp (его код можно найти <a href="">здесь</a> ). Вместо очереди там используется приоритизация запросов от философов с учетом времени их голодания. Чем дольше философ голодает, тем приоритетнее его запрос. </p><br><p> Рассматривать код этого решения мы не будем, т.к. по большому счету главное в нем — это тот же самый трюк с набором mbox-ов для несуществующих "вилок", который мы уже обсудили в разговоре про реализацию waiter_with_queue. </p><br><h2 id="neskolko-detaley-realizacii-na-kotorye-hotelos-by-obratit-vnimanie"> Несколько деталей реализации, на которые хотелось бы обратить внимание </h2><br><p> Есть несколько деталей в реализациях на базе Акторов, на которые хотелось бы обратить внимание, т.к. эти детали демонстрируют интересные особенности SObjectizer-а. </p><br><h3 id="rabochiy-kontekst-dlya-aktorov"> Рабочий контекст для акторов </h3><br><p> В рассмотренных реализациях все основные акторы ( <code>fork_t</code> , <code>philosopher_t</code> , <code>waiter_t</code> ) работали на контексте одной общей рабочей нити. Что вовсе не означает, что в SObjectizer-е все акторы работают только на одной единственной нити. В SObjectizer-е можно привязывать акторов к разным контекстам, что можно увидеть, например, в коде функции <code>run_simulation()</code> в решении no_waiter_simple. </p><br><div class="spoiler"> <b class="spoiler_title">Код run_simulation из no_waiter_simple</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run_simulation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">environment_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; env, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">names_holder_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; names )</span></span></span><span class="hljs-function"> </span></span>{ env.introduce_coop( [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop ) { coop.make_agent_with_binder&lt; <span class="hljs-keyword"><span class="hljs-keyword">trace_maker_t</span></span> &gt;( so_5::disp::one_thread::create_private_disp( env )-&gt;binder(), names, <span class="hljs-keyword"><span class="hljs-keyword">random_pause_generator_t</span></span>::trace_step() ); coop.make_agent_with_binder&lt; <span class="hljs-keyword"><span class="hljs-keyword">completion_watcher_t</span></span> &gt;( so_5::disp::one_thread::create_private_disp( env )-&gt;binder(), names ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> count = names.size(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * &gt; forks( count, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != count; ++i ) forks[ i ] = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span> &gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != count; ++i ) coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span> &gt;( i, forks[ i ]-&gt;so_direct_mbox(), forks[ (i + <span class="hljs-number"><span class="hljs-number">1</span></span>) % count ]-&gt;so_direct_mbox(), default_meals_count ); }); }</code> </pre> </div></div><br><p> В этой функции создаются дополнительные акторы типов <code>trace_maker_t</code> и <code>completion_watcher_t</code> . Они будут работать на отдельных рабочих контекстах. Для этого создается два экземпляра диспетчера типа <code>one_thread</code> и акторы привязываются к этим экземплярам диспетчеров. Что означает, что данные акторы будут работать как <em>активные объекты</em> : каждый будет владеть собственной рабочей нитью. </p><br><p> SObjectizer предоставляет набор из нескольких разных диспетчеров, которые могут использоваться прямо "из коробки". При этом разработчик может создать в своем приложении столько экземпляров диспетчеров, сколько разработчику нужно. </p><br><p> Но самое важное то, что в самом акторе ничего не нужно менять, чтобы заставить его работать на другом диспетчере. Скажем, мы легко можем запустить акторов <code>fork_t</code> на одном пуле рабочих нитей, а акторов <code>philosopher_t</code> на другом пуле. </p><br><div class="spoiler"> <b class="spoiler_title">Код run_simulation из no_waiter_simple_tp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run_simulation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">environment_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; env, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">names_holder_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; names )</span></span></span><span class="hljs-function"> </span></span>{ env.introduce_coop( [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop ) { coop.make_agent_with_binder&lt; <span class="hljs-keyword"><span class="hljs-keyword">trace_maker_t</span></span> &gt;( so_5::disp::one_thread::create_private_disp( env )-&gt;binder(), names, <span class="hljs-keyword"><span class="hljs-keyword">random_pause_generator_t</span></span>::trace_step() ); coop.make_agent_with_binder&lt; <span class="hljs-keyword"><span class="hljs-keyword">completion_watcher_t</span></span> &gt;( so_5::disp::one_thread::create_private_disp( env )-&gt;binder(), names ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> count = names.size(); <span class="hljs-comment"><span class="hljs-comment">// Параметры для настройки поведения thread_pool-диспетчера. so_5::disp::thread_pool::bind_params_t bind_params; bind_params.fifo( so_5::disp::thread_pool::fifo_t::individual ); std::vector&lt; so_5::agent_t * &gt; forks( count, nullptr ); // Создаем пул нитей для акторов-вилок. auto fork_disp = so_5::disp::thread_pool::create_private_disp( env, 3u // Размер пула. ); for( std::size_t i{}; i != count; ++i ) // Каждая вилка будет привязана к пулу. forks[ i ] = coop.make_agent_with_binder&lt; fork_t &gt;( fork_disp-&gt;binder( bind_params ) ); // Создаем пул нитей для акторов-философов. auto philosopher_disp = so_5::disp::thread_pool::create_private_disp( env, 6u // Размер пула. ); for( std::size_t i{}; i != count; ++i ) coop.make_agent_with_binder&lt; philosopher_t &gt;( philosopher_disp-&gt;binder( bind_params ), i, forks[ i ]-&gt;so_direct_mbox(), forks[ (i + 1) % count ]-&gt;so_direct_mbox(), default_meals_count ); }); }</span></span></code> </pre> </div></div><br><p> И при этом нам не потребовалось поменять ни строчки в классах <code>fork_t</code> и <code>philosopher_t</code> . </p><br><h3 id="trassirovka-smeny-sostoyaniy-aktorov"> Трассировка смены состояний акторов </h3><br><p> Если посмотреть в реализацию философов в упомянутой выше статье <a href="http://lucteo.ro/2018/12/28/modern-dining-philosophers/">Modern dining philosophers</a> можно легко увидеть код, относящийся к трассировке действий философа, например: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doEat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ eventLog_.startActivity(ActivityType::eat); wait(randBetween(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>)); eventLog_.endActivity(ActivityType::eat);</code> </pre> <br><p> В тоже время в показанных выше реализациях на базе SObjectizer подобного кода нет. Но трассировка, тем не менее, выполняется. За счет чего? </p><br><p> Дело в том, что в SObjectizer-е есть специальная штука: слушатель состояний агента. Такой слушатель реализуется как наследник класса <code>agent_state_listener_t</code> . Когда слушатель связывается с агентом, то SObjectizer автоматически уведомляет слушателя о каждом изменении состояния агента. </p><br><p> Установку слушателя можно увидеть в конструкторе агентов <code>greedy_philosopher_t</code> и <code>philosopher_t</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>(...) ... { so_add_destroyable_listener( <span class="hljs-keyword"><span class="hljs-keyword">state_watcher_t</span></span>::make( so_environment(), index ) ); }</code> </pre> <br><p> Здесь <code>state_watcher_t</code> — это и есть нужная мне реализация слушателя. </p><br><div class="spoiler"> <b class="spoiler_title">Определение state_watcher_t</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">state_watcher_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_state_listener_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> m_mbox; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> m_index; <span class="hljs-keyword"><span class="hljs-keyword">state_watcher_t</span></span>( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> mbox, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> index ); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">environment_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; env, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_state_listener_unique_ptr_t</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">state_watcher_t</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">trace_maker_t</span></span>::make_mbox(env), index } }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">changed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">agent_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">state_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; state )</span></span></span><span class="hljs-function"> override</span></span>; };</code> </pre> </div></div><br><p> Когда экземпляр <code>state_watcher_t</code> связан с агентом SObjectizer вызывает метод <code>changed()</code> при смене состояния агента. И уже внутри <code>state_watcher_t::changed</code> инициируются действия для трассировки действий актора-философа. </p><br><div class="spoiler"> <b class="spoiler_title">Фрагмент реализации state_watcher_t::changed</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">state_watcher_t</span></span>::changed( so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> &amp;, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> &amp; state ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> detect_label = []( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp; name ) {...}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> state_label = detect_label( state.query_name() ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-string"><span class="hljs-string">'?'</span></span> == state_label ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; so_5::send&lt; trace::<span class="hljs-keyword"><span class="hljs-keyword">state_changed_t</span></span> &gt;( m_mbox, m_index, state_label ); }</code> </pre> </div></div><br><h1 id="resheniya-na-baze-csp"> Решения на базе CSP </h1><br><p> Теперь мы поговорим о реализациях, которые не используют акторов вообще. Посмотрим на те же самые решения (no_waiter_dijkstra, no_waiter_simple, waiter_with_timestamps) при реализации которых применяются <code>std::thread</code> и SObjectizer-овские mchain-ы (которые, по сути, есть CSP-шные каналы). Причем, подчеркну особо, в CSP-шных решениях используется тот же самый набор сообщений (все те же <code>take_t</code> , <code>taken_t</code> , <code>busy_t</code> , <code>put_t</code> ). </p><br><p> В CSP-подходе вместо "процессов" используются нити ОС. Поэтому каждая вилка, каждый философ и каждый официант реализуется отдельным объектом <code>std::thread</code> . </p><br><h2 id="reshenie-deykstry-1"> Решение Дейкстры </h2><br><p> Исходный код этого решения можно увидеть <a href="">здесь</a> . </p><br><h3 id="nit-dlya-vilki"> Нить для вилки </h3><br><p> Нить для вилки в решении Дейкстры работает очень просто: цикл чтения сообщений из входного канала + обработка сообщений типа <code>take_t</code> и <code>put_t</code> . Что реализуется функцией <code>fork_process</code> следующего вида: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fork_process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fork_ch )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Состояние вилки: занята или нет. bool taken = false; // Очередь ждущих философов. std::queue&lt; so_5::mbox_t &gt; wait_queue; // Читаем и обрабатываем сообщения пока канал не закроют. so_5::receive( so_5::from( fork_ch ), [&amp;]( so_5::mhood_t&lt;take_t&gt; cmd ) { if( taken ) // Вилка занята, философ должен ждать в очереди. wait_queue.push( cmd-&gt;m_who ); else { // Философ может взять вилку. taken = true; so_5::send&lt; taken_t &gt;( cmd-&gt;m_who ); } }, [&amp;]( so_5::mhood_t&lt;put_t&gt; ) { if( wait_queue.empty() ) taken = false; // Вилка больше никому не нужна. else { // Вилку нужно отдать первому философу из очереди. const auto who = wait_queue.front(); wait_queue.pop(); so_5::send&lt; taken_t &gt;( who ); } } ); }</span></span></code> </pre> <br><p> У функции <code>fork_process</code> всего один аргумент: входной канал, который создается где-то в другом месте. </p><br><p> Самое интересное в <code>fork_process</code> — это "цикл" выборки сообщений из канала до тех пор, пока канал не будет закрыт. Этот цикл реализуется всего одним вызовом функции <code>receive()</code> : </p><br><pre> <code class="cpp hljs">so_5::receive( so_5::from( fork_ch ), [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span>&gt; cmd ) {...}, [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">put_t</span></span>&gt; ) {...} );</code> </pre> <br><p> В SObjectizer-е есть несколько версий функции <code>receive()</code> и здесь мы видим одну из них. Эта версия читает сообщения из канала пока канал не будет закрыт. Для каждого прочитанного сообщения ищется обработчик. Если обработчик найден, то он вызывается и сообщение обрабатывается. Если не найден, то сообщение просто выбрасывается. </p><br><p> Обработчики сообщений задаются в виде лямбда-функций. Эти лямбды выглядят как близнецы братья соответствующих обработчиков в акторе <code>fork_t</code> из решения на базе Акторов. Что, в принципе, не удивительно. </p><br><h3 id="nit-dlya-filosofa"> Нить для философа </h3><br><p> Логика работы философа реализована в функции <code>philosopher_process</code> . У этой функции достаточно объемный код, поэтому мы будем разбираться с ним по частям. </p><br><div class="spoiler"> <b class="spoiler_title">Полный код philosopher_process</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">oid </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">philosopher_process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">trace_maker_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; tracer, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> control_ch, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> philosopher_index, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left_fork, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right_fork, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> meals_count )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> meals_eaten{ <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">random_pause_generator_t</span></span> pause_generator; <span class="hljs-comment"><span class="hljs-comment">// Этот канал будет использован для получения ответов от вилок. auto self_ch = so_5::create_mchain( control_ch-&gt;environment() ); while( meals_eaten &lt; meals_count ) { tracer.thinking_started( philosopher_index, thinking_type_t::normal ); // Имитируем размышления приостанавливая нить. std::this_thread::sleep_for( pause_generator.think_pause( thinking_type_t::normal ) ); // Пытаемся взять левую вилку. tracer.take_left_attempt( philosopher_index ); so_5::send&lt; take_t &gt;( left_fork, self_ch-&gt;as_mbox(), philosopher_index ); // Запрос отправлен, ждем ответа. so_5::receive( so_5::from( self_ch ).handle_n( 1u ), [&amp;]( so_5::mhood_t&lt;taken_t&gt; ) { // Взяли левую вилку, пытаемся взять правую. tracer.take_right_attempt( philosopher_index ); so_5::send&lt; take_t &gt;( right_fork, self_ch-&gt;as_mbox(), philosopher_index ); // Запрос отправлен, ждем ответа. so_5::receive( so_5::from( self_ch ).handle_n( 1u ), [&amp;]( so_5::mhood_t&lt;taken_t&gt; ) { // У нас обе вилки. Можно поесть. tracer.eating_started( philosopher_index ); // Имитируем поглощение пищи приостанавливая нить. std::this_thread::sleep_for( pause_generator.eat_pause() ); // На шаг ближе к финалу. ++meals_eaten; // После еды возвращаем правую вилку. so_5::send&lt; put_t &gt;( right_fork ); } ); // А следом возвращаем и левую. so_5::send&lt; put_t &gt;( left_fork ); } ); } // Сообщаем о том, что мы закончили. tracer.philosopher_done( philosopher_index ); so_5::send&lt; philosopher_done_t &gt;( control_ch, philosopher_index ); }</span></span></code> </pre> </div></div><br><p> Давайте начнем с прототипа функции: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">philosopher_process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">trace_maker_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; tracer, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> control_ch, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> philosopher_index, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left_fork, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right_fork, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> meals_count )</span></span></span></span></code> </pre> <br><p> Смысл и назначение некоторых из этих параметров придется пояснить. </p><br><p> Поскольку мы не используем SObjectizer-овских агентов, то у нас нет возможности снимать след работы философа через слушателя состояний агента, как это делалось в варианте на Actor-ах. Поэтому в коде философа приходится делать вот такие вставки: </p><br><pre> <code class="cpp hljs">tracer.thinking_started( philosopher_index, <span class="hljs-keyword"><span class="hljs-keyword">thinking_type_t</span></span>::normal );</code> </pre> <br><p> И аргумент <code>tracer</code> как раз является ссылкой на объект, который занимается трассировкой работы философов. </p><br><p> Аргумент <code>control_ch</code> задает канал, в который должно быть записано сообщение <code>philosopher_done_t</code> после того, как философ съест все, что ему положено. Этот канал затем будет использоваться для определения момента завершения работы всех философов. </p><br><p> Аргументы <code>left_fork</code> и <code>right_fork</code> задают каналы для взаимодействия с вилками. Именно в эти каналы будут отсылаться сообщения <code>take_t</code> и <code>put_t</code> . Но если это каналы, то почему используется тип <code>mbox_t</code> вместо <code>mchain_t</code> ? </p><br><p> Это хороший вопрос! Но ответ на него мы увидим ниже, при обсуждении другого решения. Пока же можно сказать, что mchain — это что-то вроде разновидности mbox-а, поэтому ссылки на mchain-ы можно передавать через объекты <code>mbox_t</code> . </p><br><p> Далее определяется ряд переменных, которые формируют состояние философа: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> meals_eaten{ <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">random_pause_generator_t</span></span> pause_generator; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> self_ch = so_5::create_mchain( control_ch-&gt;environment() );</code> </pre> <br><p> Наверное наиболее важная переменная — это <code>self_ch</code> . Это персональный канал философа, через который философ будет получать ответные сообщения от вилок. </p><br><p> Ну а теперь мы можем перейти к основной логике работы философа.  Those. к циклу повторения таких операций как размышления, захват вилок и поглощение пищи. </p><br><p> Можно отметить, что в отличии от решения на базе Акторов, для имитации длительных операций здесь используется <code>this_thread::sleep_for</code> вместо отложенных сообщений. </p><br><p> Попытка взять вилку выглядит практически так же, как и в случае с Акторами: </p><br><pre> <code class="cpp hljs">so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span> &gt;( left_fork, self_ch-&gt;as_mbox(), philosopher_index );</code> </pre> <br><p> Здесь используется все тот же тип <code>take_t</code> . Но в нем есть поле типа <code>mbox_t</code> , тогда как <code>self_ch</code> имеет тип <code>mchain_t</code> . Поэтому приходится преобразовывать ссылку на канал в ссылку на почтовый ящик через вызов <code>as_mbox()</code> . </p><br><p> Далее можно увидеть вызов <code>receive()</code> : </p><br><pre> <code class="cpp hljs">so_5::receive( so_5::from( self_ch ).handle_n( <span class="hljs-number"><span class="hljs-number">1u</span></span> ), [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span>&gt; ) {...} );</code> </pre> <br><p> Этот вызов возвращает управление только когда один экземпляр <code>taken_t</code> будет извлечен и обработан. Ну или если канал будет закрыт. В общем, мы здесь ждем поступление нужного нам ответа от вилки. </p><br><p> В общем-то это практически все, что можно было бы рассказать про <code>philosopher_process</code> . Хотя стоит заострить внимание на вложенном вызове <code>receive()</code> для одного и того же канала: </p><br><pre> <code class="cpp hljs">so_5::receive( so_5::from( self_ch ).handle_n( <span class="hljs-number"><span class="hljs-number">1u</span></span> ), [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span>&gt; ) { ... so_5::receive( so_5::from( self_ch ).handle_n( <span class="hljs-number"><span class="hljs-number">1u</span></span> ), [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span>&gt; ) {...} ); ... } );</code> </pre> <br><p> Эта вложенность позволяет записать логику работы философа в простом и более-менее компактном виде. </p><br><h3 id="funkciya-zapuska-simulyacii"> Функция запуска симуляции </h3><br><p> При обсуждении решений на базе Акторов мы не останавливались на разборе функций <code>run_simulation()</code> , поскольку там ничего особо интересного или важного не было. Но вот в случае с CSP-подходом на <code>run_simulation()</code> имеет смысл остановиться. В том числе для того, чтобы в очередной раз убедиться в том, насколько непросто писать корректный многопоточный код (кстати говоря вне зависимости от языка программирования). </p><br><div class="spoiler"> <b class="spoiler_title">Полный код функции run_simulation</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run_simulation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">environment_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; env, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">names_holder_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; names )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> table_size = names.size(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> join_all = []( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread&gt; &amp; threads ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; t : threads ) t.join(); }; <span class="hljs-keyword"><span class="hljs-keyword">trace_maker_t</span></span> tracer{ env, names, <span class="hljs-keyword"><span class="hljs-keyword">random_pause_generator_t</span></span>::trace_step() }; <span class="hljs-comment"><span class="hljs-comment">// Создаем вилки. std::vector&lt; so_5::mchain_t &gt; fork_chains; std::vector&lt; std::thread &gt; fork_threads( table_size ); for( std::size_t i{}; i != table_size; ++i ) { // Персональный канал для очередной вилки. fork_chains.emplace_back( so_5::create_mchain(env) ); // Рабочая нить для очередной вилки. fork_threads[ i ] = std::thread{ fork_process, fork_chains.back() }; } // Канал для получения уведомлений от философов. auto control_ch = so_5::create_mchain( env ); // Создаем философов. const auto philosopher_maker = [&amp;](auto index, auto left_fork_idx, auto right_fork_idx) { return std::thread{ philosopher_process, std::ref(tracer), control_ch, index, fork_chains[ left_fork_idx ]-&gt;as_mbox(), fork_chains[ right_fork_idx ]-&gt;as_mbox(), default_meals_count }; }; std::vector&lt; std::thread &gt; philosopher_threads( table_size ); for( std::size_t i{}; i != table_size - 1u; ++i ) { // Запускаем очередного философа на отдельной нити. philosopher_threads[ i ] = philosopher_maker( i, i, i+1u ); } // Последний философ должен захватывать вилки в обратном порядке. philosopher_threads[ table_size - 1u ] = philosopher_maker( table_size - 1u, table_size - 1u, 0u ); // Ждем пока все философы закончат. so_5::receive( so_5::from( control_ch ).handle_n( table_size ), [&amp;names]( so_5::mhood_t&lt;philosopher_done_t&gt; cmd ) { fmt::print( "{}: done\n", names[ cmd-&gt;m_philosopher_index ] ); } ); // Дожидаемся завершения рабочих нитей философов. join_all( philosopher_threads ); // Принудительно закрываем каналы для вилок. for( auto &amp; ch : fork_chains ) so_5::close_drop_content( ch ); // После чего дожидаемся завершения рабочих нитей вилок. join_all( fork_threads ); // Показываем результат. tracer.done(); // И останавливаем SObjectizer. env.stop(); }</span></span></code> </pre> </div></div><br><p> В принципе, в основном код <code>run_simulation()</code> должен быть более-менее понятен. Поэтому я разберу только некоторые моменты. </p><br><p> Нам требуются рабочие нити для вилок. Этот фрагмент как раз отвечает за их создание: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; so_5::<span class="hljs-keyword"><span class="hljs-keyword">mchain_t</span></span> &gt; fork_chains; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread &gt; fork_threads( table_size ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != table_size; ++i ) { fork_chains.emplace_back( so_5::create_mchain(env) ); fork_threads[ i ] = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread{ fork_process, fork_chains.back() }; }</code> </pre> <br><p> При этом нам нужно сохранять и каналы, созданные для вилок, и сами рабочие нити. Каналы потребуются ниже для передачи ссылок на них философам. А рабочие нити потребуются для того, чтобы затем вызвать <code>join</code> для них. </p><br><p> После чего мы создаем рабочие нити для философов и так же собираем рабочие нити в контейнер, т.к. нам нужно будет затем вызывать <code>join</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread &gt; philosopher_threads( table_size ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != table_size - <span class="hljs-number"><span class="hljs-number">1u</span></span>; ++i ) { philosopher_threads[ i ] = philosopher_maker( i, i, i+<span class="hljs-number"><span class="hljs-number">1u</span></span> ); } philosopher_threads[ table_size - <span class="hljs-number"><span class="hljs-number">1u</span></span> ] = philosopher_maker( table_size - <span class="hljs-number"><span class="hljs-number">1u</span></span>, table_size - <span class="hljs-number"><span class="hljs-number">1u</span></span>, <span class="hljs-number"><span class="hljs-number">0u</span></span> );</code> </pre> <br><p> Далее мы должны дать философам некоторое время для выполнения симуляции. Дожидаемся момента завершения симуляции с помощью этого фрагмента: </p><br><pre> <code class="cpp hljs">so_5::receive( so_5::from( control_ch ).handle_n( table_size ), [&amp;names]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_done_t</span></span>&gt; cmd ) { fmt::print( <span class="hljs-string"><span class="hljs-string">"{}: done\n"</span></span>, names[ cmd-&gt;m_philosopher_index ] ); } );</code> </pre> <br><p> Этот вариант <code>receive()</code> возвращает управление только после получения <code>table_size</code> сообщений типа <code>philosopher_done_t</code> . </p><br><p> Ну а после получения всех <code>philosopher_done_t</code> остается выполнить очистку ресурсов. </p><br><p> Делаем <code>join</code> для всех рабочих нитей философов: </p><br><pre> <code class="cpp hljs">join_all( philosopher_threads );</code> </pre> <br><p> После чего нужно сделать <code>join</code> для всех нитей вилок. Но просто вызывать <code>join</code> нельзя, т.к. тогда мы тупо зависнем. Ведь рабочие нити вилок спят внутри вызовов <code>receive()</code> и никто их не разбудит. Поэтому нам нужно сперва закрыть все каналы для вилок и лишь затем вызывать <code>join</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; ch : fork_chains ) so_5::close_drop_content( ch ); join_all( fork_threads );</code> </pre> <br><p> Вот теперь главные операции по очистке ресурсов можно считать законченными. </p><br><h4 id="neskolko-slov-o-noexcept"> Несколько слов о noexcept </h4><br><p> Надеюсь, что код <code>run_simulation</code> сейчас полностью понятен и я могу попробовать объяснить, почему эта функция помечена как <em>noexcept</em> . Дело в том, что в ней exception-safety не обеспечивается от слова совсем. Поэтому самая лучшая реакция на возникновение исключения в такой тривиальной реализации — это принудительное завершение всего приложения. </p><br><p> Но почему <code>run_simulation</code> не обеспечивает безопасность по отношению к исключениям? </p><br><p> Давайте представим, что мы создаем рабочие нити для вилок и при создании очередной нити у нас выскакивает исключение. Дабы обеспечить хоть какую-нибудь exception-safety нам нужно принудительно завершить те нити, которые уже были запущены. И кто-то может подумать, что для этого достаточно переписать код запуска нитей для вилок следующим образом: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != table_size; ++i ) { fork_chains.emplace_back( so_5::create_mchain(env) ); fork_threads[ i ] = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread{ fork_process, fork_chains.back() }; } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>( ... ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != fork_chains.size(); ++i ) { so_5::close_drop_content( fork_chains[ i ] ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( fork_threads[ i ].joinable() ) fork_threads[ i ].join(); } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; }</code> </pre> <br><p> К сожалению, это очевидное и неправильное решение.  Since оно окажется бесполезным если исключение возникнет уже после того, как мы создадим все нити для вилок. Поэтому лучше использовать что-то вроде вот такого: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fork_threads_stuff_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; so_5::<span class="hljs-keyword"><span class="hljs-keyword">mchain_t</span></span> &gt; m_fork_chains; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread &gt; m_fork_threads; <span class="hljs-keyword"><span class="hljs-keyword">fork_threads_stuff_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> table_size ) : m_fork_threads( table_size ) {} ~<span class="hljs-keyword"><span class="hljs-keyword">fork_threads_stuff_t</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != m_fork_chains.size(); ++i ) { so_5::close_drop_content( m_fork_chains[ i ] ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_fork_threads[ i ].joinable() ) m_fork_threads[ i ].join(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != m_fork_threads.size(); ++i ) { m_fork_chains.emplace_back( so_5::create_mchain(env) ); m_fork_threads[ i ] = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread{ fork_process, m_fork_chains.back() }; } } } fork_threads_stuff{ table_size }; <span class="hljs-comment"><span class="hljs-comment">// Преаллоцируем нужные ресурсы. fork_threads_stuff.run(); // Создаем каналы и запускаем нити. // Вся нужная очистка произойдет в деструкторе fork_threads_stuff.</span></span></code> </pre> <br><p> Ну или можно воспользоваться трюками, которые позволяют выполнять нужный нам код при выходе из скоупа (например, Boost-овским ScopeExit-ом, GSL-овским finally() и им подобным). </p><br><p> Аналогичная проблема существует и с запуском нитей для философов. И решать ее нужно будет подобным образом. </p><br><p> Однако, если поместить весь необходимый код по обеспечению exception-safety в <code>run_simulation()</code> , то код <code>run_simulation()</code> окажется и объемнее, и сложнее в восприятии. Что не есть хорошо для функции, написанной исключительно в демонстрационных целях и не претендующей на продакшен-качество. Поэтому я решил забить на обеспечение exception-safety внутри <code>run_simulation()</code> и пометил функцию как <em>noexcept</em> , что приведет к вызову <code>std::terminate</code> в случае возникновения исключения. ИМХО, для такого рода демонстрационных примеров это вполне себе разумный вариант. </p><br><p> Тем не менее, проблема в том, что нужно иметь соответствующий опыт чтобы понять, какой код по очистке ресурсов будет работать, а какой нет. Неопытный программист может посчитать, что достаточно только вызвать <code>join</code> , хотя на самом деле нужно еще предварительно закрыть каналы перед вызовом <code>join</code> . И такую проблему в коде будет очень непросто выловить. </p><br><h2 id="prostoe-reshenie-bez-ispolzovaniya-arbitra-oficianta"> Простое решение без использования арбитра (официанта) </h2><br><p> Теперь мы можем рассмотреть, как в CSP-подходе будет выглядеть простое решение с возвратом вилок при неудачном захвате, но без арбитра. </p><br><p> Исходный код этого решения можно найти <a href="">здесь</a> . </p><br><h3 id="nit-dlya-vilki-1"> Нить для вилки </h3><br><p> Нить для вилки реализуется функцией <code>fork_process</code> , которая выглядит следующим образом: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fork_process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fork_ch )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Состояние вилки: захвачена или свободна. bool taken = false; // Обрабатываем сообщения пока канал не закроют. so_5::receive( so_5::from( fork_ch ), [&amp;]( so_5::mhood_t&lt;take_t&gt; cmd ) { if( taken ) so_5::send&lt; busy_t &gt;( cmd-&gt;m_who ); else { taken = true; so_5::send&lt; taken_t &gt;( cmd-&gt;m_who ); } }, [&amp;]( so_5::mhood_t&lt;put_t&gt; ) { if( taken ) taken = false; } ); }</span></span></code> </pre> <br><p> Можно увидеть, что эта <code>fork_process</code> проще, чем аналогичная в решении Дейкстры (ту же самую картину мы могли наблюдать, когда рассматривали решения на базе Акторов). </p><br><h3 id="nit-dlya-filosofa-1"> Нить для философа </h3><br><p> Нить для философа реализуется функцией <code>philosopher_process</code> , которая оказывается несколько сложнее, чем ее аналог в решении Дейкстры. </p><br><div class="spoiler"> <b class="spoiler_title">Полный код philosopher_process</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">philosopher_process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">trace_maker_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; tracer, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> control_ch, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> philosopher_index, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left_fork, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right_fork, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> meals_count )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> meals_eaten{ <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// Этот флаг потребуется для трассировки действий философа. thinking_type_t thinking_type{ thinking_type_t::normal }; random_pause_generator_t pause_generator; // Канал для получения ответов от вилок. auto self_ch = so_5::create_mchain( control_ch-&gt;environment() ); while( meals_eaten &lt; meals_count ) { tracer.thinking_started( philosopher_index, thinking_type ); // Имитируем размышления приостанавливая нить. std::this_thread::sleep_for( pause_generator.think_pause( thinking_type ) ); // На случай, если захватить вилки не получится. thinking_type = thinking_type_t::hungry; // Пытаемся взять левую вилку. tracer.take_left_attempt( philosopher_index ); so_5::send&lt; take_t &gt;( left_fork, self_ch-&gt;as_mbox(), philosopher_index ); // Запрос отправлен, ждем ответа. so_5::receive( so_5::from( self_ch ).handle_n( 1u ), []( so_5::mhood_t&lt;busy_t&gt; ) { /* ничего не нужно делать */ }, [&amp;]( so_5::mhood_t&lt;taken_t&gt; ) { // Левая вилка взята, попробуем взять правую. tracer.take_right_attempt( philosopher_index ); so_5::send&lt; take_t &gt;( right_fork, self_ch-&gt;as_mbox(), philosopher_index ); // Запрос отправлен, ждем ответа. so_5::receive( so_5::from( self_ch ).handle_n( 1u ), []( so_5::mhood_t&lt;busy_t&gt; ) { /* ничего не нужно делать */ }, [&amp;]( so_5::mhood_t&lt;taken_t&gt; ) { // У нас обе вилки, можно поесть. tracer.eating_started( philosopher_index ); // Имитируем поглощение пищи приостанавливая нить. std::this_thread::sleep_for( pause_generator.eat_pause() ); // На шаг ближе к финалу. ++meals_eaten; // После еды нужно вернуть правую вилку. so_5::send&lt; put_t &gt;( right_fork ); // Следующий период размышлений должен быть помечен как "normal". thinking_type = thinking_type_t::normal; } ); // Левую вилку нужно вернуть в любом случае. so_5::send&lt; put_t &gt;( left_fork ); } ); } // Уведомляем о завершении работы. tracer.philosopher_done( philosopher_index ); so_5::send&lt; philosopher_done_t &gt;( control_ch, philosopher_index ); }</span></span></code> </pre> </div></div><br><p> В общем-то код <code>philosopher_process</code> очень похож на код <code>philosopher_process</code> из решения Дейкстры. Но есть два важных отличия. </p><br><p> Во-первых, это переменная <code>thinking_type</code> . Она нужна для того, чтобы формировать правильный след работы философа, а так же для того, чтобы вычислять паузы при имитации "раздумий" философа. </p><br><p> Во-вторых, это обработчики для сообщений <code>busy_t</code> . Мы их можем увидеть при вызове <code>receive()</code> : </p><br><pre> <code class="cpp hljs">so_5::receive( so_5::from( self_ch ).handle_n( <span class="hljs-number"><span class="hljs-number">1u</span></span> ), []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">busy_t</span></span>&gt; ) { <span class="hljs-comment"><span class="hljs-comment">/* ничего не нужно делать */</span></span> }, [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span>&gt; ) { ... so_5::receive( so_5::from( self_ch ).handle_n( <span class="hljs-number"><span class="hljs-number">1u</span></span> ), []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">busy_t</span></span>&gt; ) { <span class="hljs-comment"><span class="hljs-comment">/* ничего не нужно делать */</span></span> }, [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span>&gt; ) {...} );</code> </pre> <br><p> Да, обработчики для <code>busy_t</code> пусты, но это потому, что все необходимые действия либо уже были сделаны перед вызовом <code>receive()</code> , либо будут сделаны после выхода из <code>receive()</code> . Поэтому при получении <code>busy_t</code> ничего не нужно делать. Но сами обработчики должны быть определены, т.к. их присутствие запрещает <code>receive()</code> выбрасывать экземпляры <code>busy_t</code> без обработки. Благодаря присутствию таких обработчиков <code>receive()</code> возвращает управление когда в канал приходит сообщение <code>busy_t</code> . </p><br><h2 id="reshenie-s-oficiantom-i-vremennymi-otmetkami"> Решение с официантом и временными отметками </h2><br><p> На базе CSP-подхода было сделано еще одно решение, которое я бы хотел здесь кратко осветить. Разбирая решения на базе Акторов речь шла о решениях с арбитром (официантом): мы рассматривали решение waiter_with_queue, в котором официант использует очередь заявок, а так же упоминалось решение waiter_with_timestamps. Оба эти решения использовали один и тот же трюк: официант создавал набор mbox-ов для несуществующих вилок, эти mbox-ы раздавались философам, но сообщения из mbox-ов обрабатывались официантом. </p><br><p> Похожий трюк нужен и в CSP-подходе для того, чтобы я смог переиспользовать уже существующую реализацию <code>philosopher_process</code> из решения no_waiter_simple. Но может ли официант создать набор mchain-ов которые будут использоваться философами и из которых официант будет читать сообщения, адресованные вилкам? </p><br><p> К сожалению, нет. </p><br><p> Создать набор mchain-ов не проблема. Проблема в том, чтобы читать сообщения сразу из нескольких mchain-ов. </p><br><p> В SObjectizer-е есть функция <code>select()</code> , которая позволяет это делать, например, она позволяет написать так: </p><br><pre> <code class="cpp hljs">so_5::select( so_5::from_all(), case_(ch1, one_handler_1, one_handler_2, one_handler_3, ...), case_(ch2, two_handler_1, two_handler_2, two_handler_3, ...), ...);</code> </pre> <br><p> Но для <code>select()</code> нужно, чтобы список каналов и обработчиков сообщений из них был доступен в компайл-тайм. Тогда как в моих решениях задачи "обедающих философов" этот список становится известен только во время исполнения. Поэтому в CSP-подходе нельзя в чистом виде переиспользовать трюк из подхода на базе Акторов. </p><br><p> Но мы можем его переосмыслить. </p><br><p> Итак, суть в том, что в исходных сообщениях <code>take_t</code> и <code>put_t</code> нет поля для хранения индекса вилки. И поэтому нам нужно как-то эти индексы получить. Раз уж мы не можем запихнуть индексы внутрь <code>take_t</code> и <code>put_t</code> , то давайте сделаем расширенные версии этих сообщений: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extended_take_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> m_who; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> m_philosopher_index; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> m_fork_index; <span class="hljs-keyword"><span class="hljs-keyword">extended_take_t</span></span>( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> who, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> philosopher_index, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> fork_index ) : m_who{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(who) } , m_philosopher_index{ philosopher_index } , m_fork_index{ fork_index } {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extended_put_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> m_fork_index; <span class="hljs-keyword"><span class="hljs-keyword">extended_put_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> fork_index ) : m_fork_index{ fork_index } {} };</code> </pre> <br><blockquote> Вообще говоря, нет надобности наследовать типы сообщений от <code>so_5::message_t</code> , хотя я обычно как раз использую такое наследование (у него есть некоторые небольшие бенефиты). В данном же случае наследование используется просто для того, чтобы продемонстрировать такой способ определения SObjectizer-овских сообщений. </blockquote><p> Теперь нужно сделать так, чтобы официант читал именно расширенные версии сообщений вместо оригинальных. Значит нам нужно научиться перехватывать сообщения <code>take_t</code> и <code>put_t</code> , преобразовывать их в <code>extended_take_t</code> и <code>extended_put_t</code> , отсылать новые сообщения официанту. </p><br><p> Для этого нам потребуется собственный mbox. Всего лишь :) </p><br><div class="spoiler"> <b class="spoiler_title">Код собственного mbox-а</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wrapping_mbox_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::extra::mboxes::proxy::<span class="hljs-keyword"><span class="hljs-keyword">simple_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">base_type_t</span></span> = so_5::extra::mboxes::proxy::<span class="hljs-keyword"><span class="hljs-keyword">simple_t</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Куда сообщения должны доставляться. const so_5::mbox_t m_target; // Индекс вилки, который должен использоваться в новых сообщениях. const std::size_t m_fork_index; // Типы сообщений для перехвата. static std::type_index original_take_type; static std::type_index original_put_type; public : wrapping_mbox_t( const so_5::mbox_t &amp; target, std::size_t fork_index ) : base_type_t{ target } , m_target{ target } , m_fork_index{ fork_index } {} // Это основной метод so_5::abstract_message_box_t для доставки сообщений. // Переопределяем его для перехвата и преобразования сообщений. void do_deliver_message( const std::type_index &amp; msg_type, const so_5::message_ref_t &amp; message, unsigned int overlimit_reaction_deep ) const override { if( original_take_type == msg_type ) { // Получаем доступ к исходному сообщению. const auto &amp; original_msg = so_5::message_payload_type&lt;::take_t&gt;:: payload_reference( *message ); // Шлем новое сообщение вместо старого. so_5::send&lt; extended_take_t &gt;( m_target, original_msg.m_who, original_msg.m_philosopher_index, m_fork_index ); } else if( original_put_type == msg_type ) { // Шлем новое сообщение вместо старого. so_5::send&lt; extended_put_t &gt;( m_target, m_fork_index ); } else base_type_t::do_deliver_message( msg_type, message, overlimit_reaction_deep ); } // Фабричный метод чтобы было проще создавать wrapping_mbox_t. static auto make( const so_5::mbox_t &amp; target, std::size_t fork_index ) { return so_5::mbox_t{ new wrapping_mbox_t{ target, fork_index } }; } }; std::type_index wrapping_mbox_t::original_take_type{ typeid(::take_t) }; std::type_index wrapping_mbox_t::original_put_type{ typeid(::put_t) };</span></span></code> </pre> </div></div><br><p> Здесь использовался самый простой способ создания собственного mbox-а: в сопутствующем проекте <a href="https://stiffstream.com/en/products/so_5_extra.html">so_5_extra</a> есть заготовка, которую можно переиспользовать и сохранить себе кучу времени. Без использования этой заготовки мне пришлось бы наследоваться напрямую от <code>so_5::abstract_message_box_t</code> и реализовывать ряд чистых виртуальных методов. </p><br><p> Как бы то ни было, теперь есть класс <code>wrapping_mbox_t</code> . Так что мы теперь можем создать набор экземпляров этого класса, ссылки на которые и будут раздаваться философам. Философы будут отсылать сообщения в wrapping_mbox, а эти сообщения будут преобразовываться и переадресовываться в единственный mchain официанта. Поэтому функция <code>waiter_process</code> , которая является главной функцией нити официанта, будет иметь вот такой простой вид: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waiter_process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> waiter_ch, details::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">waiter_logic_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; logic )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Получаем и обрабатываем сообщения пока канал не закроют. so_5::receive( so_5::from( waiter_ch ), [&amp;]( so_5::mhood_t&lt;details::extended_take_t&gt; cmd ) { logic.on_take_fork( std::move(cmd) ); }, [&amp;]( so_5::mhood_t&lt;details::extended_put_t&gt; cmd ) { logic.on_put_fork( std::move(cmd) ); } ); }</span></span></code> </pre> <br><p> Конечно же, прикладная логика официанта реализована в другом месте и ее код не так прост и короток, но мы не будем туда погружаться. Интересующиеся могут посмотреть код решения waiter_with_timestamps <a href="">здесь</a> . </p><br><p> Вот сейчас мы можем ответить на вопрос: "Почему каналы для вилок передаются в <code>philosopher_process</code> как mbox-ы?" Это потому, что для решения waiter_with_timestamps был реализован собственный mbox, а не mchain. </p><br><p> Конечно же, можно было бы создать и собственный mchain. Но это потребовало бы несколько больше работы, т.к. в so_5_extra пока нет такой же заготовки для собственных mchain-ов (может быть со временем появится). Так что для экономии времени я просто остановился на mbox-ах вместо mchain-ов. </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p> Вот, пожалуй, и все, что хотелось рассказать про реализованные на базе Акторов и CSP решения. Свою задачу я видел не в том, чтобы сделать максимально эффективные решения. А в том, чтобы показать, как именно они могут выглядеть. Надеюсь, что кому-то это было интересно. </p><br><p> Позволю себе отвлечь внимание тех, кто интересуется SObjectizer-ом. Все идет к тому, что в ближайшее время начнется работа над следующей "большой" версией SObjectizer — веткой 5.6, нарушающей совместимость с веткой 5.5. Желающие сказать свое веское слово по этому поводу, могут сделать это <a href="https://github.com/eao197/so-5-5/issues/19">здесь</a> (или <a href="https://sourceforge.net/p/sobjectizer/discussion/550088/thread/4e530cf329/">здесь</a> ). Более-менее актуальный список того, что поменяется в SO-5.6 можно найти <a href="https://sourceforge.net/p/sobjectizer/discussion/550088/thread/40e9b8ac/">здесь</a> (туда же можно добавить и свои пожелания). </p><br><p> На этом у меня все, большое спасибо всем читателям за потраченное на данную статью время! </p><br><p>  Ps. Слово "современные" в заголовке взято в кавычки потому, что в самих решениях нет ничего современного. Разве что за исключением использования кода на C++14. </p></div>