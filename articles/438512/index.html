<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Data compression by Huffman algorithm</title>
  <meta name="description" content="Introduction 
 In this article I will talk about the well-known Huffman algorithm, as well as its application in data compression. 

 As a result, we ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Data compression by Huffman algorithm</h1><div class="post__text post__text-html js-mediator-article"><h2>  Introduction </h2><br>  In this article I will talk about the well-known Huffman algorithm, as well as its application in data compression. <br><br>  As a result, we will write a simple archiver.  This has already been <a href="https://habr.com/ru/post/144200/">an article on Habr√©</a> , but without practical implementation.  The theoretical material of the current post is taken from the computer lessons of computer science and from the book by Robert Laforet "Data Structures and Algorithms in Java".  So, everything is under the cat! <br><a name="habracut"></a><br><h2>  A little thought </h2><br>  In a plain text file, one character is encoded with 8 bits (ASCII encoding) or 16 (Unicode encoding).  Next we will consider the ASCII encoding.  For example, take the string s1 = "SUSIE SAYS IT IS EASY \ n".  There are a total of 22 characters in the line, of course, including spaces and the newline character - '\ n'.  A file containing this string will weigh 22 * ‚Äã‚Äã8 = 176 bits.  Immediately the question arises: is it rational to use all 8 bits to encode 1 character?  We after all use not all characters of coding ASCII.  Even if they used it, it would be more rational to give the shortest possible code, S, the shortest possible code, and for the rarest letter, T (or U, or '\ n'), give the code more authentic.  This is the Huffman algorithm: you need to find the best encoding option, in which the file will be the minimum weight.  It is quite normal that different characters will have different code lengths - this is the basis of the algorithm. <br><br><h3>  Coding </h3><br>  Why don't the 'S' character be given a code, for example, 1 bit long: 0 or 1. Let it be 1. Then the second most common character - '' (space) - will give 0. Imagine you started to decode your message - the encoded string s1 - and you see that the code starts with 1. So, what to do: is it a character S, or is it some other character, for example A?  Therefore, there is an important rule: <br><br>  <b>No code should be prefixed by another.</b> <br><br>  This rule is key to the algorithm.  Therefore, the creation of a code begins with a frequency table, in which the frequency (number of occurrences) of each symbol is indicated: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cu/h6/y6/cuh6y658iqqnvb0whujokfbsaeq.jpeg" width="350"></div>  The characters with the most occurrences must be encoded with the least <u>possible</u> number of bits.  I will give an example of one of the possible code tables: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3j/01/_2/3j01_2tsdi_q790e8yuwa1l41zc.jpeg" width="350"></div>  Thus, the encoded message will look like this: <br><br><pre><code class="plaintext hljs">10 01111 10 110 1111 00 10 010 1110 10 00 110 0110 00 110 10 00 1111 010 10 1110 01110</code> </pre> <br>  I separated the code of each character with a space.  Truly in a compressed file this will not happen! <br>  The question arises: <s>how did this salaga come up with a code</s> how to create a code table?  This will be discussed below. <br><br><h4>  Building a Huffman Tree </h4><br>  Here come binary binary search trees.  Do not worry, here the search, insert and delete methods are not required.  Here is the java tree structure: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> frequence; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> letter; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Node leftChild; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Node rightChild; ... }</code> </pre><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BinaryTree</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Node root; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BinaryTree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Node(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BinaryTree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node root)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.root = root; } ... }</code> </pre><br>  This is not a complete code, the full code will be lower. <br><br>  Here is the tree building algorithm itself: <br><br><ol><li>  Create a Node object for each character in the message (line s1).  In our case there will be 9 nodes (Node objects).  Each node consists of two data fields: symbol and frequency </li><li>  Create a Tree object (BinaryTree) for each node Node.  The node becomes the root of the tree. </li><li>  Paste these trees into the priority queue.  The lower the frequency, the higher the priority.  Thus, when retrieving, the douvo is always selected by the lowest frequency. </li></ol><br>  Next you need to do the following cyclically: <br><br><ol><li>  Extract the two trees from the priority queue and make them the descendants of the new node (the newly created node without a letter).  The frequency of a new node is equal to the sum of the frequencies of two descendant trees. </li><li>  For this node create a tree with a root in this node.  Insert this tree back into the priority queue.  (Since the tree has a new frequency, then it will most likely come to a new place in the queue) </li><li>  Continue to perform steps 1 and 2 until one tree is left in the queue - a Huffman tree </li></ol><br>  Consider this algorithm on line s1: <br><br><img src="https://habrastorage.org/webt/v4/l2/xn/v4l2xnrj2mzomws6y696cm7o3_q.jpeg"><br><br>  Here, the symbol ‚Äúlf‚Äù (linefeed) denotes the transition to a new line, ‚Äúsp‚Äù (space) is a space. <br><br><h4>  What's next? </h4><br>  We got a Huffman tree.  OK.  And what to do with it?  <s>He will not be taken for free.</s> And further, you need to track all possible paths from the root to the leaves of the tree.  We agree to denote the edge 0 if it leads to the left descendant and 1 if it leads to the right.  Strictly speaking, in these designations, the symbol code is the path from the root of the tree to the leaf containing this very symbol. <br><br><img src="https://habrastorage.org/webt/of/pi/k4/ofpik4e7t3afswjddxugb-ddkfa.jpeg"><br><br>  This is how the code table turned out.  Note that if we consider this table, then we can conclude that the ‚Äúweight‚Äù of each character is the length of its code.  Then in the compressed form the source file will weigh: 2 * 3 + 2 * 4 + 3 * 3 + 6 * 2 + 1 * 4 + 1 * 5 + 2 * 4 + 4 * 2 + 1 * 5 = 65 bits.  At first he weighed 176 bits.  Therefore, we have reduced it by 176/65 = 2.7 times!  But this is utopia.  Such a coefficient is unlikely to be obtained.  Why?  This will be discussed later. <br><br><h3>  Decoding </h3><br>  Well, perhaps the simplest thing is decoding.  I think many of you have guessed that it is impossible to simply create a compressed file without any hints of how it was encoded - we will not be able to decode it!  Yes, it was hard for me to realize this, but I would have to create a text file table.txt with a compression table: <br><br><pre> <code class="plaintext hljs">01110 00 A010 E1111 I110 S10 T0110 U01111 Y1110</code> </pre><br>  Write a table in the form of a "character" "character code."  Why 01110 without a character?  In fact, it‚Äôs with a symbol, just the java tools I‚Äôve used when outputting to a file, the newline character is the '\ n' -convert to the newline transition (no matter how silly it sounds).  Therefore, the blank line at the top is the symbol for code 01110. For code 00, the character is a space at the beginning of a line.  I must say at once that <s>our</s> method of storing the table can claim to be the most irrational for <s>our khan coefficient</s> .  But it is simple to understand and implement.  I am pleased to hear your recommendations in the comments about optimization. <br><br>  Having this table is very easy to decode.  Recall what rule we followed when creating the encoding: <br><br>  <b>No code should be a prefix of another.</b> <br><br>  This is where it plays a facilitating role.  We read sequentially bit by bit and, as soon as the received string d, consisting of the read bits, coincides with the encoding corresponding to the character character, we immediately know that the character character was coded (and only that!).  Next, write the character to the decoding line (the line containing the decoded message), reset the string d, and read the encoded file further. <br><br><h2>  Implementation </h2><br>  It's time to <s>humiliate my code</s> to write an archiver.  Let's call it Compressor. <br><br>  Start over.  First, write the Node class: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> frequence;<span class="hljs-comment"><span class="hljs-comment">//—á–∞—Å—Ç–æ—Ç–∞ private char letter;//–±—É–∫–≤–∞ private Node leftChild;//–ª–µ–≤—ã–π –ø–æ—Ç–æ–º–æ–∫ private Node rightChild;//–ø—Ä–∞–≤—ã–π –ø–æ—Ç–æ–º–æ–∫ public Node(char letter, int frequence) { //—Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ, –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä this.letter = letter; this.frequence = frequence; } public Node() {}//–ø–µ—Ä–µ–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Å—Ç—Ä—É—Ç–æ—Ä–∞ –¥–ª—è –±–µ–∑—ã–º—è–Ω–Ω—ã—Ö —É–∑–ª–æ–≤(—Å–º. –≤—ã—à–µ –≤ —Ä–∞–∑–¥–µ–ª–µ –æ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–∏ –¥–µ—Ä–µ–≤–∞ –•–∞—Ñ—Ñ–º–∞–Ω–∞) public void addChild(Node newNode) {//–¥–æ–±–∞–≤–∏—Ç—å –ø–æ—Ç–æ–º–∫–∞ if (leftChild == null)//–µ—Å–ª–∏ –ª–µ–≤—ã–π –ø—É—Å—Ç–æ–π=&gt; –ø—Ä–∞–≤—ã–π —Ç–æ–∂–µ=&gt; –¥–æ–±–∞–≤–ª—è–µ–º –≤ –ª–µ–≤—ã–π leftChild = newNode; else { if (leftChild.getFrequence() &lt;= newNode.getFrequence()) //–≤ –æ–±—â–µ–º, –ª–µ–≤—ã–º –ø–æ—Ç–æ–º–∫–æ–º rightChild = newNode;//—Å—Ç–∞–Ω–µ—Ç —Ç–æ—Ç, —É –∫–æ–≥–æ –º–µ–Ω—å—à–µ —á–∞—Å—Ç–æ—Ç–∞ else { rightChild = leftChild; leftChild = newNode; } } frequence += newNode.getFrequence();//–∏—Ç–æ–≥–æ–≤–∞—è —á–∞—Å—Ç–æ—Ç–∞ } public Node getLeftChild() { return leftChild; } public Node getRightChild() { return rightChild; } public int getFrequence() { return frequence; } public char getLetter() { return letter; } public boolean isLeaf() {//–ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ª–∏—Å—Ç return leftChild == null &amp;&amp; rightChild == null; } }</span></span></code> </pre><br>  Now the tree: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BinaryTree</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Node root; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BinaryTree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Node(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BinaryTree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node root)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.root = root; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFrequence</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> root.getFrequence(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Node </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRoot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> root; } }</code> </pre><br>  Priority queue: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.ArrayList;<span class="hljs-comment"><span class="hljs-comment">//–¥–∞-–¥–∞, –æ—á–µ—Ä–µ–¥—å –±—É–¥–µ—Ç –Ω–∞ –±–∞–∑–µ —Å–ø–∏—Å–∫–∞ class PriorityQueue { private ArrayList&lt;BinaryTree&gt; data;//—Å–ø–∏—Å–æ–∫ –æ—á–µ—Ä–µ–¥–∏ private int nElems;//–∫–æ–ª-–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ –æ—á–µ—Ä–µ–¥–∏ public PriorityQueue() { data = new ArrayList&lt;BinaryTree&gt;(); nElems = 0; } public void insert(BinaryTree newTree) {//–≤—Å—Ç–∞–≤–∫–∞ if (nElems == 0) data.add(newTree); else { for (int i = 0; i &lt; nElems; i++) { if (data.get(i).getFrequence() &gt; newTree.getFrequence()) {//–µ—Å–ª–∏ —á–∞—Å—Ç–æ—Ç–∞ –≤—Å—Ç–∞–≤–ª—è–µ–º–æ–≥–æ –¥–µ—Ä–µ–≤–∞ –º–µ–Ω—å—à–µ data.add(i, newTree);//—á–µ–º —á–∞—Å—Ç. —Ç–µ–∫—É—â–µ–≥–æ, —Ç–æ c–¥–≤–∏–≥–∞–µ–º –≤—Å–µ –¥–µ—Ä–µ–≤—å—è –Ω–∞ –ø–æ–∑–∏—Ü–∏—è—Ö —Å–ø—Ä–∞–≤–∞ –Ω–∞ 1 —è—á–µ–π–∫—É break;//–∑–∞—Ç–µ–º —Å—Ç–∞–≤–∏–º –Ω–æ–≤–æ–µ –¥–µ—Ä–µ–≤–æ –Ω–∞ –ø–æ–∑–∏—Ü–∏—é —Ç–µ–∫—É—â–µ–≥–æ } if (i == nElems - 1) data.add(newTree); } } nElems++;//—É–≤–µ–ª–∏—á–∏–≤–∞–µ–º –∫–æ–ª-–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –Ω–∞ 1 } public BinaryTree remove() {//—É–¥–∞–ª–µ–Ω–∏–µ –∏–∑ –æ—á–µ—Ä–µ–¥–∏ BinaryTree tmp = data.get(0);//–∫–æ–ø–∏—Ä—É–µ–º —É–¥–∞–ª—è–µ–º—ã–π —ç–ª–µ–º–µ–Ω—Ç data.remove(0);//—Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ, —É–¥–∞–ª—è–µ–º nElems--;//—É–º–µ–Ω—å—à–∞–µ–º –∫–æ–ª-–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –Ω–∞ 1 return tmp;//–≤–æ–∑–≤—Ä–∞—â–∞–µ–º —É–¥–∞–ª–µ–Ω–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç(—ç–ª–µ–º–µ–Ω—Ç —Å –Ω–∞–∏–º–µ–Ω—å—à–µ–π —á–∞—Å—Ç–æ—Ç–æ–π) } }</span></span></code> </pre><br>  The class that creates the Huffman tree: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HuffmanTree</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ENCODING_TABLE_SIZE = <span class="hljs-number"><span class="hljs-number">127</span></span>;<span class="hljs-comment"><span class="hljs-comment">//–¥–ª–∏–Ω–∞ –∫–æ–¥–∏—Ä–æ–≤–æ—á–Ω–æ–π —Ç–∞–±–ª–∏—Ü—ã private String myString;//—Å–æ–æ–±—â–µ–Ω–∏–µ private BinaryTree huffmanTree;//–¥–µ—Ä–µ–≤–æ –•–∞—Ñ—Ñ–º–∞–Ω–∞ private int[] freqArray;//—á–∞—Å—Ç–æ—Ç–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞ private String[] encodingArray;//–∫–æ–¥–∏—Ä–æ–≤–æ—á–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞ //----------------constructor---------------------- public HuffmanTree(String newString) { myString = newString; freqArray = new int[ENCODING_TABLE_SIZE]; fillFrequenceArray(); huffmanTree = getHuffmanTree(); encodingArray = new String[ENCODING_TABLE_SIZE]; fillEncodingArray(huffmanTree.getRoot(), "", ""); } //--------------------frequence array------------------------ private void fillFrequenceArray() { for (int i = 0; i &lt; myString.length(); i++) { freqArray[(int)myString.charAt(i)]++; } } public int[] getFrequenceArray() { return freqArray; } //------------------------huffman tree creation------------------ private BinaryTree getHuffmanTree() { PriorityQueue pq = new PriorityQueue(); //–∞–ª–≥–æ—Ä–∏—Ç–º –æ–ø–∏—Å–∞–Ω –≤—ã—à–µ for (int i = 0; i &lt; ENCODING_TABLE_SIZE; i++) { if (freqArray[i] != 0) {//–µ—Å–ª–∏ —Å–∏–º–≤–æ–ª —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –≤ —Å—Ç—Ä–æ–∫–µ Node newNode = new Node((char) i, freqArray[i]);//—Ç–æ —Å–æ–∑–¥–∞—Ç—å –¥–ª—è –Ω–µ–≥–æ Node BinaryTree newTree = new BinaryTree(newNode);//–∞ –¥–ª—è Node —Å–æ–∑–¥–∞—Ç—å BinaryTree pq.insert(newTree);//–≤—Å—Ç–∞–≤–∏—Ç—å –≤ –æ—á–µ—Ä–µ–¥—å } } while (true) { BinaryTree tree1 = pq.remove();//–∏–∑–≤–ª–µ—á—å –∏–∑ –æ—á–µ—Ä–µ–¥–∏ –ø–µ—Ä–≤–æ–µ –¥–µ—Ä–µ–≤–æ. try { BinaryTree tree2 = pq.remove();//–∏–∑–≤–ª–µ—á—å –∏–∑ –æ—á–µ—Ä–µ–¥–∏ –≤—Ç–æ—Ä–æ–µ –¥–µ—Ä–µ–≤–æ Node newNode = new Node();//—Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π Node newNode.addChild(tree1.getRoot());//—Å–¥–µ–ª–∞—Ç—å –µ–≥–æ –ø–æ—Ç–æ–º–∫–∞–º–∏ –¥–≤–∞ –∏–∑–≤–ª–µ—á–µ–Ω–Ω—ã—Ö –¥–µ—Ä–µ–≤–∞ newNode.addChild(tree2.getRoot()); pq.insert(new BinaryTree(newNode); } catch (IndexOutOfBoundsException e) {//–æ—Å—Ç–∞–ª–æ—Å—å –æ–¥–Ω–æ –¥–µ—Ä–µ–≤–æ –≤ –æ—á–µ—Ä–µ–¥–∏ return tree1; } } } public BinaryTree getTree() { return huffmanTree; } //-------------------encoding array------------------ void fillEncodingArray(Node node, String codeBefore, String direction) {//–∑–∞–ø–æ–ª–Ω–∏—Ç—å –∫–æ–¥–∏—Ä–æ–≤–æ—á–Ω—É—é —Ç–∞–±–ª–∏—Ü—É if (node.isLeaf()) { encodingArray[(int)node.getLetter()] = codeBefore + direction; } else { fillEncodingArray(node.getLeftChild(), codeBefore + direction, "0"); fillEncodingArray(node.getRightChild(), codeBefore + direction, "1"); } } String[] getEncodingArray() { return encodingArray; } public void displayEncodingArray() {//–¥–ª—è –æ—Ç–ª–∞–¥–∫–∏ fillEncodingArray(huffmanTree.getRoot(), "", ""); System.out.println("======================Encoding table===================="); for (int i = 0; i &lt; ENCODING_TABLE_SIZE; i++) { if (freqArray[i] != 0) { System.out.print((char)i + " "); System.out.println(encodingArray[i]); } } System.out.println("========================================================"); } //----------------------------------------------------- String getOriginalString() { return myString; } }</span></span></code> </pre><br>  A class containing which encodes / decodes: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HuffmanOperator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ENCODING_TABLE_SIZE = <span class="hljs-number"><span class="hljs-number">127</span></span>;<span class="hljs-comment"><span class="hljs-comment">//–¥–ª–∏–Ω–∞ —Ç–∞–±–ª–∏—Ü—ã private HuffmanTree mainHuffmanTree;//–¥–µ—Ä–µ–≤–æ –•–∞—Ñ—Ñ–º–∞–Ω–∞ (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –¥–ª—è —Å–∂–∞—Ç–∏—è) private String myString;//–∏—Å—Ö–æ–¥–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ private int[] freqArray;//—á–∞—Å—Ç–æ—Ç–∞–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞ private String[] encodingArray;//–∫–æ–¥–∏—Ä–æ–≤–æ—á–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞ private double ratio;//–∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç —Å–∂–∞—Ç–∏—è public HuffmanOperator(HuffmanTree MainHuffmanTree) {//for compress this.mainHuffmanTree = MainHuffmanTree; myString = mainHuffmanTree.getOriginalString(); encodingArray = mainHuffmanTree.getEncodingArray(); freqArray = mainHuffmanTree.getFrequenceArray(); } public HuffmanOperator() {}//for extract; //---------------------------------------compression----------------------------------------------------------- private String getCompressedString() { String compressed = ""; String intermidiate = "";//–ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω–∞—è —Å—Ç—Ä–æ–∫–∞(–±–µ–∑ –¥–æ–±–∞–≤–æ—á–Ω—ã—Ö –Ω—É–ª–µ–π) //System.out.println("=============================Compression======================="); //displayEncodingArray(); for (int i = 0; i &lt; myString.length(); i++) { intermidiate += encodingArray[myString.charAt(i)]; } //–ú—ã –Ω–µ –º–æ–∂–µ–º –ø–∏—Å–∞—Ç—å –±–∏—Ç –≤ —Ñ–∞–π–ª. –ü–æ—ç—Ç–æ–º—É –Ω—É–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å –¥–ª–∏–Ω—É —Å–æ–æ–±—â–µ–Ω–∏—è –∫—Ä–∞—Ç–Ω–æ–π 8=&gt; //–Ω—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –Ω—É–ª–∏ –≤ –∫–æ–Ω–µ—Ü(–º–æ–∂–Ω–æ 1, –Ω–µ—Ç —Ä–∞–∑–Ω–∏—Ü—ã) byte counter = 0;//–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã—Ö –≤ –∫–æ–Ω–µ—Ü –Ω—É–ª–µ–π (–±–∞–π—Ç–∞ –≤ –ø–æ–ª–Ω–µ —Ö–≤–∞—Ç–∏—Ç: 0&lt;=counter&lt;8&lt;127) for (int length = intermidiate.length(), delta = 8 - length % 8; counter &lt; delta ; counter++) {//delta - –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã—Ö –Ω—É–ª–µ–π intermidiate += "0"; } //—Å–∫–ª–µ–∏—Ç—å –∫–æ–ª-–≤–æ –¥–æ–±–∞–≤–æ—á–Ω—ã—Ö –Ω—É–ª–µ–π –≤ –±–∏–Ω–∞—Ä–Ω–æ–º –ø—Ä–µ–¥–∞—Å—Ç–≤–ª–µ–Ω–∏–∏ –∏ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—É—é —Å—Ç—Ä–æ–∫—É compressed = String.format("%8s", Integer.toBinaryString(counter &amp; 0xff)).replace(" ", "0") + intermidiate; //–∏–¥–µ–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç setCompressionRatio(); //System.out.println("==============================================================="); return compressed; } private void setCompressionRatio() {//–ø–æ—Å—á–∏—Ç–∞—Ç—å –∏–¥–µ–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç double sumA = 0, sumB = 0;//A-the original sum for (int i = 0; i &lt; ENCODING_TABLE_SIZE; i++) { if (freqArray[i] != 0) { sumA += 8 * freqArray[i]; sumB += encodingArray[i].length() * freqArray[i]; } } ratio = sumA / sumB; } public byte[] getBytedMsg() {//final compression StringBuilder compressedString = new StringBuilder(getCompressedString()); byte[] compressedBytes = new byte[compressedString.length() / 8]; for (int i = 0; i &lt; compressedBytes.length; i++) { compressedBytes[i] = (byte) Integer.parseInt(compressedString.substring(i * 8, (i + 1) * 8), 2); } return compressedBytes; } //---------------------------------------end of compression---------------------------------------------------------------- //------------------------------------------------------------extract----------------------------------------------------- public String extract(String compressed, String[] newEncodingArray) { String decompressed = ""; String current = ""; String delta = ""; encodingArray = newEncodingArray; //displayEncodingArray(); //–ø–æ–ª—É—á–∏—Ç—å –∫–æ–ª-–≤–æ –≤—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã—Ö –Ω—É–ª–µ–π for (int i = 0; i &lt; 8; i++) delta += compressed.charAt(i); int ADDED_ZEROES = Integer.parseInt(delta, 2); for (int i = 8, l = compressed.length() - ADDED_ZEROES; i &lt; l; i++) { //i = 8, —Ç.–∫. –ø–µ—Ä–≤—ã–º –±–∞–π—Ç–æ–º —É –Ω–∞—Å –∏–¥–µ—Ç –∫–æ–ª-–≤–æ –≤—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã—Ö –Ω—É–ª–µ–π current += compressed.charAt(i); for (int j = 0; j &lt; ENCODING_TABLE_SIZE; j++) { if (current.equals(encodingArray[j])) {//–µ—Å–ª–∏ —Å–æ–≤–ø–∞–ª–æ decompressed += (char)j;//—Ç–æ –¥–æ–±–∞–≤–ª—è–µ–º —ç–ª–µ–º–µ–Ω—Ç current = "";//–∏ –æ–±–Ω—É–ª—è–µ–º —Ç–µ–∫—É—â—É—é —Å—Ç—Ä–æ–∫—É } } } return decompressed; } public String getEncodingTable() { String enc = ""; for (int i = 0; i &lt; encodingArray.length; i++) { if (freqArray[i] != 0) enc += (char)i + encodingArray[i] + '\n'; } return enc; } public double getCompressionRatio() { return ratio; } public void displayEncodingArray() {//–¥–ª—è –æ—Ç–ª–∞–¥–∫–∏ System.out.println("======================Encoding table===================="); for (int i = 0; i &lt; ENCODING_TABLE_SIZE; i++) { //if (freqArray[i] != 0) { System.out.print((char)i + " "); System.out.println(encodingArray[i]); //} } System.out.println("========================================================"); } }</span></span></code> </pre><br>  A class that facilitates writing to a file: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.File; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.PrintWriter; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.FileNotFoundException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.FileOutputStream; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.Closeable; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileOutputHelper</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Closeable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> File outputFile; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FileOutputStream fileOutputStream; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FileOutputHelper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File file)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> FileNotFoundException </span></span>{ outputFile = file; fileOutputStream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileOutputStream(outputFile); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeByte</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> msg)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ fileOutputStream.write(msg); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeBytes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] msg)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ fileOutputStream.write(msg); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String msg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (PrintWriter pw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PrintWriter(outputFile)) { pw.write(msg); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (FileNotFoundException e) { System.out.println(<span class="hljs-string"><span class="hljs-string">"–ù–µ–≤–µ—Ä–Ω—ã–π –ø—É—Ç—å, –∏–ª–∏ —Ç–∞–∫–æ–≥–æ —Ñ–∞–π–ª–∞ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç!"</span></span>); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ fileOutputStream.close(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">finalize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ close(); } }</code> </pre><br>  A class that facilitates reading from a file: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.FileInputStream; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.EOFException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.BufferedReader; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.InputStreamReader; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.Closeable; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.File; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileInputHelper</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Closeable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FileInputStream fileInputStream; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BufferedReader fileBufferedReader; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FileInputHelper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File file)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ fileInputStream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(file); fileBufferedReader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BufferedReader(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InputStreamReader(fileInputStream)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readByte</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cur = fileInputStream.read(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cur == -<span class="hljs-number"><span class="hljs-number">1</span></span>)<span class="hljs-comment"><span class="hljs-comment">//–µ—Å–ª–∏ –∑–∞–∫–æ–Ω—á–∏–ª—Å—è —Ñ–∞–π–ª throw new EOFException(); return (byte)cur; } public String readLine() throws IOException { return fileBufferedReader.readLine(); } @Override public void close() throws IOException{ fileInputStream.close(); } }</span></span></code> </pre><br>  Well, the main class: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.File; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.charset.MalformedInputException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.FileNotFoundException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.file.Files; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.file.NoSuchFileException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.file.Paths; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.List; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.EOFException; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ENCODING_TABLE_SIZE = <span class="hljs-number"><span class="hljs-number">127</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {<span class="hljs-comment"><span class="hljs-comment">//—É–∫–∞–∑—ã–≤–∞–µ–º –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é —Å –ø–æ–º–æ—â—å—é –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏ if (args[0].equals("--compress") || args[0].equals("-c")) compress(args[1]); else if ((args[0].equals("--extract") || args[0].equals("-x")) &amp;&amp; (args[2].equals("--table") || args[2].equals("-t"))) { extract(args[1], args[3]); } else throw new IllegalArgumentException(); } catch (ArrayIndexOutOfBoundsException | IllegalArgumentException e) { System.out.println("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –≤–≤–æ–¥–∞ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ "); System.out.println("–ß–∏—Ç–∞–π—Ç–µ Readme.txt"); e.printStackTrace(); } } public static void compress(String stringPath) throws IOException { List&lt;String&gt; stringList; File inputFile = new File(stringPath); String s = ""; File compressedFile, table; try { stringList = Files.readAllLines(Paths.get(inputFile.getAbsolutePath())); } catch (NoSuchFileException e) { System.out.println("–ù–µ–≤–µ—Ä–Ω—ã–π –ø—É—Ç—å, –∏–ª–∏ —Ç–∞–∫–æ–≥–æ —Ñ–∞–π–ª–∞ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç!"); return; } catch (MalformedInputException e) { System.out.println("–¢–µ–∫—É—â–∞—è –∫–æ–¥–∏—Ä–æ–≤–∫–∞ —Ñ–∞–π–ª–∞ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è"); return; } for (String item : stringList) { s += item; s += '\n'; } HuffmanOperator operator = new HuffmanOperator(new HuffmanTree(s)); compressedFile = new File(inputFile.getAbsolutePath() + ".cpr"); compressedFile.createNewFile(); try (FileOutputHelper fo = new FileOutputHelper(compressedFile)) { fo.writeBytes(operator.getBytedMsg()); } //create file with encoding table: table = new File(inputFile.getAbsolutePath() + ".table.txt"); table.createNewFile(); try (FileOutputHelper fo = new FileOutputHelper(table)) { fo.writeString(operator.getEncodingTable()); } System.out.println("–ü—É—Ç—å –∫ —Å–∂–∞—Ç–æ–º—É —Ñ–∞–π–ª—É: " + compressedFile.getAbsolutePath()); System.out.println("–ü—É—Ç—å –∫ –∫–æ–¥–∏—Ä–æ–≤–æ—á–Ω–æ–π —Ç–∞–±–ª–∏—Ü–µ " + table.getAbsolutePath()); System.out.println("–ë–µ–∑ —Ç–∞–±–ª–∏—Ü—ã —Ñ–∞–π–ª –±—É–¥–µ—Ç –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ –∏–∑–≤–ª–µ—á—å!"); double idealRatio = Math.round(operator.getCompressionRatio() * 100) / (double) 100;//–∏–¥–µ–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç double realRatio = Math.round((double) inputFile.length() / ((double) compressedFile.length() + (double) table.length()) * 100) / (double)100;//–Ω–∞—Å—Ç–æ—è—â–∏–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç System.out.println("–ò–¥–µ–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç —Å–∂–∞—Ç–∏—è —Ä–∞–≤–µ–Ω " + idealRatio); System.out.println("–ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç —Å–∂–∞—Ç–∏—è —Å —É—á–µ—Ç–æ–º –∫–æ–¥–∏—Ä–æ–≤–æ—á–Ω–æ–π —Ç–∞–±–ª–∏—Ü—ã " + realRatio); } public static void extract(String filePath, String tablePath) throws FileNotFoundException, IOException { HuffmanOperator operator = new HuffmanOperator(); File compressedFile = new File(filePath), tableFile = new File(tablePath), extractedFile = new File(filePath + ".xtr"); String compressed = ""; String[] encodingArray = new String[ENCODING_TABLE_SIZE]; //read compressed file //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!check here: try (FileInputHelper fi = new FileInputHelper(compressedFile)) { byte b; while (true) { b = fi.readByte();//method returns EOFException compressed += String.format("%8s", Integer.toBinaryString(b &amp; 0xff)).replace(" ", "0"); } } catch (EOFException e) { } //-------------------- //read encoding table: try (FileInputHelper fi = new FileInputHelper(tableFile)) { fi.readLine();//skip first empty string encodingArray[(byte)'\n'] = fi.readLine();//read code for '\n' while (true) { String s = fi.readLine(); if (s == null) throw new EOFException(); encodingArray[(byte)s.charAt(0)] = s.substring(1, s.length()); } } catch (EOFException ignore) {} extractedFile.createNewFile(); //extract: try (FileOutputHelper fo = new FileOutputHelper(extractedFile)) { fo.writeString(operator.extract(compressed, encodingArray)); } System.out.println("–ü—É—Ç—å –∫ —Ä–∞—Å–ø–∞–∫–æ–≤–∞–Ω–Ω–æ–º—É —Ñ–∞–π–ª—É " + extractedFile.getAbsolutePath()); } }</span></span></code> </pre><br>  File with instructions readme.txt you have to write yourself :-) <br><br><h2>  Conclusion </h2><br>  Perhaps this is all I wanted to say.  If you have something to say about <s>my incompetence of</s> improvements in the code, algorithm, in general, any optimization, feel free to write.  If I haven't done anything, write too.  I will be glad to hear you in the comments! <br><br><h3>  PS </h3><br>  Yes, yes, I'm still here, because I have not forgotten about the coefficient.  For the string s1, the coding table weighs 48 bytes - much larger than the source file, and we did not forget about the additional zeros (the number of added zeros is 7) =&gt; the compression ratio will be less than one: 176 / (65 + 48 * 8 + 7) = 0.38.  If you also noticed this, then <s>you are not a</s> good fellow <s>in the face</s> .  Yes, this implementation will be extremely inefficient for small files.  But what happens with large files?  File sizes far exceed the size of the coding table.  This is where the algorithm works as it should!  For example, for the <a href="http://www.monologuearchive.com/g/goethe_001.html">monologue of Faust, the</a> archiver produces a real (not idealized) coefficient of 1.46 - almost one and a half times!  And yes, it was assumed that the file will be in English. </div><p>Source: <a href="https://habr.com/ru/post/438512/">https://habr.com/ru/post/438512/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>