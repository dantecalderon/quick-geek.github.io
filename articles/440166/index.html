<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Java pointer compression</title>
  <meta name="description" content="This article will discuss the implementation of pointer compression in the Java Virtual Machine 64-bit , which is controlled by the UseCompressedOops ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Java pointer compression</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/co/jr/rf/cojrrf-lekmifni81uch0imua1m.png"><br><p>  This article will discuss the implementation of pointer compression in the <strong>Java Virtual Machine 64-bit</strong> , which is controlled by the <strong>UseCompressedOops</strong> option and enabled by default for 64-bit systems starting with Java SE 6u23. </p><a name="habracut"></a><br><h1>  Description of the problem </h1><br><p>  In 64-bit JVM pointers occupy 2 times more (surprise-surprise) memory space than in 32-bit.  This can increase the size of the data by 1.5 times compared with the same code for the 32-bit architecture.  At the same time, in the 32-bit architecture, only 2 ^ 32 bytes (4 GB) can be addressed, which is quite small in the modern world. </p><br><p>  Let's write a small program and look at how many bytes Integer objects occupy: </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.stream.IntStream; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.stream.Stream; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HeapTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String ... args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Integer[] x = IntStream.range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1_000_000</span></span>).boxed().toArray(Integer[]::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); Thread.sleep(<span class="hljs-number"><span class="hljs-number">6000000</span></span>); Stream.of(x).forEach(System.out::println); } }</code> </pre> <br><p>  Here we allocate a million objects of class Integer and fall asleep for a long time.  The last line is needed so that the compiler suddenly does not ignore the creation of an array (although on my machine without this line, objects are created normally). </p><br><p>  Compile and run the program with pointer compression disabled: </p><br><pre> <code class="plaintext hljs">&gt; javac HeapTest.java &gt; java -XX:-UseCompressedOops HeapTest</code> </pre> <br><p>  Using the <strong>jcmd</strong> utility, <strong>we</strong> look at the memory allocation: </p><br><pre> <code class="plaintext hljs">&gt; jps 45236 HeapTest ... &gt; jcmd 45236 GC.class_histogram</code> </pre> <br><img src="https://habrastorage.org/webt/he/yd/y7/heydy7fyiamklkvz2ff9umu7fak.png"><br><p><br>  The picture shows that the total number of objects is <strong>1000128</strong> , and the size of the memory that these objects <strong>occupy is 24003072 bytes</strong> .  Those.  <strong>24</strong> bytes per object (why exactly 24 will be written below). </p><br><p>  But the memory of the same program, but with the flag <strong>UseCompressedOops enabled</strong> : </p><br><img src="https://habrastorage.org/webt/su/dj/5g/sudj5gdfm0i-apwneqfbskmgqc8.png"><br><p><br>  Now each object is <strong>16 bytes</strong> . <br>  The advantages of compression are obvious =) </p><br><h1>  Decision </h1><br><p>  How does the JVM compress the pointers?  This technique is called <strong>Compressed Oops</strong> .  Oop stands for <em>ordinary object pointer</em> or a <em>normal pointer to an object</em> . </p><br><p>  The trick is that in a 64-bit system, the data in memory is aligned with the machine word, i.e.  8 bytes each.  And the address always has three zero bits at the end. </p><br><p>  If, while saving the pointer, the address is shifted 3 bits to the right (the operation is called <strong>encode</strong> ), and before use it is shifted by 3 bits to the left ( <strong>decode</strong> ), then you can fit <strong>35 bits</strong> in <strong>32 bits</strong> , i.e.  address up to <strong>32 GB</strong> (2 ^ 35 bytes). </p><br><p>  If the heap size for your program is more than 32GB, then the compression stops working and all pointers become 8 bytes in size. </p><br><p>  When the <strong>UseCompressedOops</strong> option <strong>is</strong> enabled, the following pointer types are compressed: </p><br><ul><li>  Class field for each object </li><li>  Class field objects </li><li>  Elements of an array of objects. </li></ul><br><p>  Objects of the JVM itself are never compressed.  In this case, compression occurs at the level of the virtual machine, and not bytecode. </p><br><h1>  Learn more about placing objects in memory. </h1><br><p>  And now let's use the <a href="http://openjdk.java.net/projects/code-tools/jol/">jol (Java Object Layout)</a> utility to <a href="http://openjdk.java.net/projects/code-tools/jol/">take a</a> closer look at how much memory our Integer occupies in different JVMs: </p><br><pre> <code class="plaintext hljs">&gt; java -jar jol-cli-0.9-full.jar estimates java.lang.Integer ***** 32-bit VM: ********************************************************** java.lang.Integer object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 8 (object header) N/A 8 4 int Integer.value N/A 12 4 (loss due to the next object alignment) Instance size: 16 bytes Space losses: 0 bytes internal + 4 bytes external = 4 bytes total ***** 64-bit VM: ********************************************************** java.lang.Integer object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 16 (object header) N/A 16 4 int Integer.value N/A 20 4 (loss due to the next object alignment) Instance size: 24 bytes Space losses: 0 bytes internal + 4 bytes external = 4 bytes total ***** 64-bit VM, compressed references enabled: *************************** java.lang.Integer object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 12 (object header) N/A 12 4 int Integer.value N/A Instance size: 16 bytes Space losses: 0 bytes internal + 0 bytes external = 0 bytes total ***** 64-bit VM, compressed references enabled, 16-byte align: ************ java.lang.Integer object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 12 (object header) N/A 12 4 int Integer.value N/A Instance size: 16 bytes Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</code> </pre><br><p>  The difference between "64-bit VM" and "64-bit VM, compressed references enabled" is to reduce the <strong>object header</strong> by 4 bytes.  Plus, in the case of no compression, it becomes necessary to add another 4 bytes to <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D1%258B%25D1%2580%25D0%25B0%25D0%25B2%25D0%25BD%25D0%25B8%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585">align the data</a> in memory. </p><br><p>  What is this object header?  Why did it decrease by 4 bytes? </p><br><img src="https://habrastorage.org/web/e2d/a4b/301/e2da4b30184a495c8e02dd1912539409.png"><br><p>  The image shows an object header equal to 12 bytes, i.e.  with the UseCompressedOops option enabled.  The header consists of some internal flags of the JVM, as well as a pointer to the class of this object.  It can be seen that the pointer to the class takes 32 bits.  Without compression, it would occupy 64 bits and the size of the object header would be 16 bytes. </p><br><p>  By the way, you can see that there is another option for 16-byte alignment.  In this case, you can increase the memory to 64 GB. </p><br><h1>  Pointer compression </h1><br><p>  Compression of pointers, of course, has an obvious disadvantage - the cost of operations <strong>encode</strong> and <strong>decode</strong> with each reference to the pointer.  The exact numbers will depend on the specific application. </p><br><p>  For example, here is the garbage collector pause schedule for compressed and uncompressed pointers taken from here. <a href="http://blog.ragozin.info/2013/07/java-gc-in-numbers-compressed-oops.html">Java GC in Numbers - Compressed OOPs</a> </p><br><img src="https://habrastorage.org/webt/gp/ki/2k/gpki2k7rbztm2xpycy_26nzt-1e.png"><br><p>  It is seen that when compression is on, GC pauses last longer.  More details about this can be found in the article itself (the article is rather old - in 2013). </p><br><p>  References: </p><br><p>  <a href="https://wiki.openjdk.java.net/display/HotSpot/CompressedOops">Compressed oops in the Hotspot JVM</a> <br>  <a href="https://umumble.com/blogs/java/how-does-jvm-allocate-objects%253F/">How does the JVM allocate objects</a> <br>  <a href="https://www.javacodegeeks.com/2016/05/compressedoops-introduction-compressed-references-java.html">CompressedOops: Introduction to compressed references in Java</a> <br>  <a href="https://stackoverflow.com/questions/25120546/trick-behind-jvms-compressed-oops">Trick behind JVM's compressed oops</a> <br>  <a href="https://docs.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html">Java HotSpot Virtual Machine Performance Enhancements</a> </p></div><p>Source: <a href="https://habr.com/ru/post/440166/">https://habr.com/ru/post/440166/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>