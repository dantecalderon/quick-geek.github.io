<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>On the issue of shifts, signs and speed MK</title>
  <meta name="description" content="‚ÄúFind a reason for everything and you will understand a lot‚Äù 
 Perhaps my regular readers (well, it can not be that they were not) remember that I som...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>On the issue of shifts, signs and speed MK</h1><div class="post__text post__text-html js-mediator-article"><h3>  ‚ÄúFind a reason for everything and you will understand a lot‚Äù </h3><br>  Perhaps my regular readers (well, it can not be that they were not) remember that I somehow in my post was perplexed about the fact that when describing the registers of external devices use the unsigned attribute.  It was suggested in the comments that this was done in order to avoid unspecific behavior during shifts and I agreed.  As I recently discovered, there is another reason for this use of an attribute, and it can be applied not only to registers, but also to ordinary variables. <br><br>  So we begin. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">To start a small introduction to iron</b> <div class="spoiler_text">  As a target platform, we will consider an 8-bit MK without a battery (this is such a pathetic attempt to hide the compromised name of the AVR), which has the following hardware-implemented commands: <br><br>  <b>lsl / lsr</b> logical left / right shift, low / high bit cleared; <br>  <b>rol / ror</b> cyclic shift left / right through the transfer (shift 9 bits); <br>  <b>asr</b> arithmetic shift to the right, the most significant (sign) bit is preserved (note that it is generally impossible to perform this type of shift to the left in general). <br><br>  All these commands are executed on the byte operand and are the basis for the implementation of all other possible shifts.  For example, a word shift (2 bytes rh, rl) with a sign right by 1 bit is implemented by the following sequence: <br><br>  <b>asr rh;</b>  <b>ror rl;</b> <br></div></div><br>  Consider a simple code example and the corresponding assembly code for the MC with the AVR command system, as always, received on godbolt.org.  (it is assumed that optimization is enabled and the variable is located in the r24 register) <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> byte; byte = byte &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><pre> <code class="cpp hljs">clr r25 sbrc r24,<span class="hljs-number"><span class="hljs-number">7</span></span> com r25 lsl r24 rol r25</code> </pre> <br>  and see that the operation takes five teams? <br><br>  Note: If someone in the comments tells how to arrange this fragment (and subsequent) in 2 columns, I would be grateful. <br><br>  From the assembler code, it is clear that the byte variable expands to an integer (16-bit) type in the first three commands, and in the next two, the two-byte number itself is shifted ‚Äî somehow strange, to say the least. <br><br>  Right shift is no better <br><br><pre> <code class="cpp hljs">byte = byte &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; clr r25 sbrc r24,<span class="hljs-number"><span class="hljs-number">7</span></span> com r25 asr r25 ror r24</code> </pre> <br>  - the same five teams.  Meanwhile, it is obvious that in fact, to perform the last operation, you need one single command. <br><br><pre> <code class="cpp hljs">–∞sr r24</code> </pre> <br>  and for the first operation no more.  I have repeatedly stated that at present the compiler creates assembly code no worse than a programmer (although it was about the ARM command system), especially if it was a little help, and suddenly such a bummer.  But let's try to help the compiler to create the correct code, it may be the case of mixing the types in the shift operation and try <br><br><pre> <code class="cpp hljs">byte = byte &gt;&gt; (<span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  - did not help, from the word "absolutely", but option <br><br><pre> <code class="cpp hljs"> byte=(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>) byte &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  gives a slightly better result <br><br><pre> <code class="cpp hljs">ldi r25,lo8(<span class="hljs-number"><span class="hljs-number">0</span></span>) asr r25 ror r24</code> </pre> <br>  - three teams, since the expansion to the whole now takes one team - is already better, although not perfect, the same picture for <br><br><pre> <code class="cpp hljs">byte=(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>) byte &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  - three teams.  Okay, so as not to write unnecessary casts, we make the variable itself unsigned <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> byteu;</code> </pre> <br>  and BINGO - assembly code is fully consistent with our expectations <br><br><pre> <code class="cpp hljs">byteu = byteu &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>; lsr r24</code> </pre> <br>  It is strange how it would seem, what a difference, to specify the right type of variable immediately, or bring it directly into the operation - but it turns out there is a difference. <br><br>  Further studies have shown that the assembler code takes into account the type of the variable that is assigned the result, because <br><br><pre> <code class="cpp hljs">byteu = byte &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  works fine and produces minimal code, and the option <br><br><pre> <code class="cpp hljs">byte = byteu &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  can not do without three teams. <br><br>  Surely this behavior is described in the standard of the language, I ask those who know in the commentary, but once again I will proudly declare that the ‚ÄúChukchi is not a reader‚Äù and will continue the narration. <br><br>  So, this method did not help the right shift - as before, there were 3 teams (well, which is not 5, as for the sign option) and I could not improve the result by any means. <br>  But in any case, we see that shift operations with an unsigned number are carried out faster than with his opponent.  Therefore, if we are not going to treat the most significant bit of a number as a sign (and in the case of registers, this is the case, as a rule), then we should certainly add the unsigned attribute, which we will do in the future. <br><br>  It turns out that in general everything is extremely interesting with shifts, we will begin to increase the number of positions when shifting to the left and look at the results: &lt;&lt; 1 takes 1 tick, &lt;&lt; 2 - 2, &lt;&lt; 3 - 3, 4 - 2 unexpectedly, the compiler has applied a clever optimization <br><br><pre> <code class="cpp hljs">swap r24 andi r24,lo8(<span class="hljs-number"><span class="hljs-number">-16</span></span>)</code> </pre> <br>  where the s <b>wap</b> command swaps two nibbles per byte.  Further, on the basis of the last optimization &lt;&lt; 5 - 3, &lt;&lt; 6 - 4, &lt;&lt; 7 - 3 again unexpectedly, there is another optimization <br><br><pre> <code class="cpp hljs">ror r24 clr r24 ror r24</code> </pre> <br>  the carry bit is used, &lt;&lt; 8 - 0 clock cycles, since it just turns out to be 0, it makes no sense to look further. <br><br>  By the way, here you have an interesting task - in what minimum time can you perform an operation? <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> byteu; byteu = byteu &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre> <br>  which translates 0x1234 to 0x2340.  The obvious solution is to run a couple of commands 4 times. <br><br><pre> <code class="cpp hljs">lsl rl rol rh</code> </pre> <br>  leads to 4 * 2 = 8 clocks, I quickly came up with an option <br><br><pre> <code class="cpp hljs">swap rl ; <span class="hljs-number"><span class="hljs-number">1243</span></span> swap rh ; <span class="hljs-number"><span class="hljs-number">2143</span></span> andi rh,<span class="hljs-number"><span class="hljs-number">0xf0</span></span> ; <span class="hljs-number"><span class="hljs-number">2043</span></span> mov tmp,rl andi tmp,<span class="hljs-number"><span class="hljs-number">0x0f</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rh,tmp ; <span class="hljs-number"><span class="hljs-number">2343</span></span> andi rl,<span class="hljs-number"><span class="hljs-number">0xf0</span></span> ; <span class="hljs-number"><span class="hljs-number">2340</span></span></code> </pre> <br>  which requires 7 clock cycles and an intermediate register.  So, the compiler generates a code of 6 commands and no intermediate registers - cool, yes. <br><br><div class="spoiler">  <b class="spoiler_title">I hide this code under the spoiler - try to find a solution yourself.</b> <div class="spoiler_text">  Hint: in the MK command set, there is an EXCLUSIVE OR or SUM according to the MODULE TWO <b>eor</b> command <br><br><div class="spoiler">  <b class="spoiler_title">Here it is, this wonderful code</b> <div class="spoiler_text"><pre> <code class="cpp hljs">swap rl ; <span class="hljs-number"><span class="hljs-number">1243</span></span> swap rh ; <span class="hljs-number"><span class="hljs-number">2143</span></span> andi rh,<span class="hljs-number"><span class="hljs-number">0xf0</span></span> ; <span class="hljs-number"><span class="hljs-number">2043</span></span> eor rh,rl ; <span class="hljs-number"><span class="hljs-number">6343</span></span> andi r2l,<span class="hljs-number"><span class="hljs-number">0xf0</span></span> ; <span class="hljs-number"><span class="hljs-number">6340</span></span> eor rh,rl ; <span class="hljs-number"><span class="hljs-number">2340</span></span></code> </pre> <br></div></div><br>  Just get aesthetic pleasure from this piece. <br></div></div><br>  What is characteristic, for 16-bit numbers, the difference between the code for a signed and unsigned number is gone when shifting to the left, strangely like that. <br><br>  Let's go back to our bytes and start moving to the right.  As we remember, for the sign byte we have 5 cycles, for the unsigned byte - 3 and this time cannot be reduced.  Or all the same it is possible - yes, it is possible, but in a very strange way (GCC with included optimizations - ‚Äúthis is a very, very strange place‚Äù), namely <br><br><pre> <code class="cpp hljs">byteu = (byteu &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7F</span></span>;</code> </pre> <br>  which spawns exactly one command for both sign options.  Fits and option <br><br><pre> <code class="cpp hljs"> byteu = (byteu &amp; <span class="hljs-number"><span class="hljs-number">0xFE</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  but only for the unsigned number, with the significant one, everything becomes even more dismal - 7 cycles, so we continue to explore only the first option. <br><br>  I can not say that I understand what is happening, because it is obvious that logical multiplication (&amp;) by such a constant after such a shift does not make any sense (and is not carried out), but the code of the shift itself is affected by the &amp; operation.  "You see a gopher - no - and I do not see, but he is." <br><br>  Shifts by 2 and so on have shown that it is important to pay off the sign bit in the result, but the number is initially signless, in general, some kind of garbage turns out, ‚Äúbut it works the same‚Äù - the only thing that can be said about this. <br><br>  Nevertheless, it is safe to say that the interpretation of the contents of the registers and memory as unsigned numbers allows for a number of operations (for example, shifting or expanding the value) with them to be performed faster and generates a more compact code, so it can be highly recommended when writing programs for MK, if otherwise (interpretation as a number with a sign) is not a prerequisite. </div><p>Source: <a href="https://habr.com/ru/post/436956/">https://habr.com/ru/post/436956/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>