<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We create effect of distribution of color in Unity</title>
  <meta name="description" content="This effect was inspired by the episode of Powerpuff Girls . I wanted to create the effect of color propagation in the black and white world, but to r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>We create effect of distribution of color in Unity</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ia/i5/in/iai5inmdx06iz81yoz8pu_2oyui.gif"></div><br>  This effect was inspired by the <a href="https://www.youtube.com/watch%3Ftime_continue%3D1%26amp%3Bv%3DV-CTM_LVl60">episode of Powerpuff Girls</a> .  I wanted to create the effect of color propagation in the black and white world, but to <strong>realize it in the coordinates of world space</strong> , to see how <strong>color paints objects</strong> , and not just flatly distributed across the screen, as in a cartoon. <br><br>  I created the effect in the new <strong>Lightweight Rendering Pipeline</strong> Unity engine, the built-in example of the Scriptable Rendering Pipeline.  All concepts apply to other pipelines, but some built-in functions or matrices may have different names.  I also used the new post-processing stack, but in the tutorial I‚Äôll omit the detailed description of its settings, because it is fairly well described in other manuals, for example, in <a href="https://www.youtube.com/watch%3Fv%3DTs2F2SxeRSY">this video</a> . <br><a name="habracut"></a><br><hr><br><h1>  The effect of post-processing in grayscale </h1><br>  Just for reference - this is what the scene looks like without post-processing effects. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43b/283/6ad/43b2836ad62ee59df7efdd98494d0140.png"></div><br>  For this effect, I used the new package, Unity 2018 Post-Processing, which can be downloaded from the package manager.  If you do not know how to use it, then I recommend <a href="https://www.youtube.com/watch%3Fv%3DTs2F2SxeRSY">this tutorial</a> . <br><br>  I wrote my own effect by extending the PostProcessingEffectSettings and PostProcessEffectRenderer classes written in C #, the source code of which can be seen <a href="https://github.com/lindenreid/ColorSpread/tree/master/Color/Assets/Scripts">here</a> .  In fact, I didn‚Äôt do anything particularly interesting with these effects on the CPU side (in C # code), except that I added a group of common properties to the Inspector, so I won‚Äôt explain in the tutorial how this is done.  I hope my code speaks for itself. <br><br>  Let's move on to the shader code and start off with a grayscale effect.  In the tutorial, we will not change the shaderlab file, the input structures and the vertex shader, so you can see their source code <a href="">here</a> .  Instead, we will do a fragment shader. <br><br>  To convert a color to grayscale, we <strong>reduce the value of each pixel to the luminance value</strong> , which describes its <strong>brightness</strong> .  This can be done by taking the dot product of <strong>the color value of the camera texture</strong> and the <strong>weighted vector</strong> , which describes the contribution of each color channel to the overall brightness of the color. <br><br>  <strong>Why do we use scalar product?</strong>  Do not forget that scalar products are calculated as follows: <br><br> <code>dot(a, b) = a <sub>x</sub> * b <sub>x</sub> + a <sub>y</sub> * b <sub>y</sub> + a <sub>z</sub> * b <sub>z</sub></code> <br> <br>  In this case, we multiply each <strong>color value</strong> channel by <strong>weight</strong> .  Then we add these pieces to reduce them to a single scalar value.  When the RGB color has the same values ‚Äã‚Äãin the R, G, and B channels, the color becomes gray. <br><br>  This is what the shader code looks like: <br><br><pre> <code class="cpp hljs">float4 fullColor = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.screenPos); float3 weight = float3(<span class="hljs-number"><span class="hljs-number">0.299</span></span>, <span class="hljs-number"><span class="hljs-number">0.587</span></span>, <span class="hljs-number"><span class="hljs-number">0.114</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> luminance = dot(fullColor.rgb, weight); float3 greyscale = luminance.xxx; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float4(greyscale, <span class="hljs-number"><span class="hljs-number">1.0</span></span>);</code> </pre> <br>  If the base shader is configured correctly, then the post-processing effect should color the entire screen in grayscale. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/596/217/fc5/596217fc5e9caed9176480f1f9eb2bb1.png"></div><br><hr><br><h1>  Drawing the effect of color in global space </h1><br>  Since this is a post-processing effect, in the vertex shader <strong>we have no information about the geometry of the</strong> scene.  At the post-processing stage, the only information we have is the <strong>image rendered by the camera</strong> and the <strong>space of the truncated coordinates</strong> for its sampling.  However, we want the coloring effect to spread across objects as if it were happening in the world, and not just on a flat screen. <br><br>  To draw this effect in the scene geometry, we need the <strong>coordinates of the world space of</strong> each pixel.  To go from the <strong>coordinates of the space of truncated coordinates</strong> to the <strong>coordinates of world space</strong> , we need to <strong>convert the space of coordinates</strong> . <br><br>  Usually, to go from one space of coordinates to another, a matrix is ‚Äã‚Äãneeded that defines a transformation from the space of coordinates A to space B. To go from A to B, we multiply a vector in the space of coordinates A by this transformation matrix.  In our case, we will perform the following transition: <strong>space of truncated coordinates (clip space)</strong> -&gt; <strong>view space (view space)</strong> -&gt; <strong>world space (world space)</strong> .  That is, we need the clip-to-view-space matrix and the view-to-world-space matrix that Unity provides. <br><br>  However, in the <strong>coordinates of the truncated coordinates space provided by Unity, there is no z value</strong> that determines the pixel depth or the distance to the camera.  We need this value to go from the space of truncated coordinates to the species space.  Let's start with that! <br><br><h2>  Getting the value of the depth buffer </h2><br>  If the rendering pipeline is turned on, then it draws in the <strong>viewport a</strong> texture that stores <strong>the z values</strong> in a structure called the <strong>depth buffer (depth buffer)</strong> .  We can sample this buffer to get the missing <strong>z value of</strong> our coordinate space of truncated coordinates! <br><br>  First, make sure that the <strong>depth buffer is</strong> actually rendered by clicking on the ‚ÄúAdd Additional Data‚Äù section of the camera in the Inspector and checking that the box ‚ÄúDepth Texture‚Äù is checked.  Also ensure that the ‚ÄúAllow MSAA‚Äù option is enabled for the camera.  I do not know why for the effect to work, you need to check this box, but it is so.  If the depth buffer is drawn, then in the <strong>frame debugger</strong> you should see the <strong>‚ÄúDepth Prepass‚Äù</strong> stage. <br><br>  Create a _CameraDepthTexture sampler in the <strong>hlsl file</strong> <br><br><pre> <code class="cpp hljs">TEXTURE2D_SAMPLER2D(_CameraDepthTexture, sampler_CameraDepthTexture);</code> </pre> <br>  Now let's write the function GetWorldFromViewPosition and for the time being we will use it to check <strong>the depth buffer</strong> .  (We will expand it later to get a position in the world.) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWorldFromViewPosition</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VertexOutput i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> z = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, sampler_CameraDepthTexture, i.screenPos).r; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> z.xxx; }</code> </pre> <br>  In the fragment shader, we will draw the value of the sample texture of the depths. <br><br><pre> <code class="cpp hljs">float3 depth = GetWorldFromViewPosition(i); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float4(depth, <span class="hljs-number"><span class="hljs-number">1.0</span></span>);</code> </pre> <br>  Here is what my results look like when there is only one hilly plain in the scene (I turned off all the trees in order to further simplify the testing of the values ‚Äã‚Äãof world space).  Your result should look like.  Black and white values ‚Äã‚Äãdescribe the distances from the geometry to the camera. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b10/6b6/5cc/b106b65cc3d1441aacd5042ee21b25a6.png"></div><br>  Here are some steps you can take if you have problems: <br><br><ul><li>  Make sure that the camera has a depth texture rendering enabled. </li><li>  Make sure the camera has MSAA turned on. </li><li>  Try changing the near and far plane of the camera. </li><li>  Make sure that the objects you expect to see in the depth buffer use a shader with a depth pass (depth pass).  This ensures that the object is rendering to the depth buffer.  All standard shaders in LWRP do this. </li></ul><br><h2>  Getting value in global space </h2><br>  Now that we have all the necessary information for the <strong>space of truncated coordinates</strong> , let's transform into a <strong>species space</strong> and then into <strong>world space</strong> . <br><br>  Note that the transformation matrices required for these operations are already in the SRP library.  However, they are contained in the Unity C # library, so I inserted them into the shader in the Render function of the <a href="">ColorSpreadRenderer</a> script: <br><br><pre> <code class="cpp hljs">sheet.properties.SetMatrix(<span class="hljs-string"><span class="hljs-string">"unity_ViewToWorldMatrix"</span></span>, context.camera.cameraToWorldMatrix); sheet.properties.SetMatrix(<span class="hljs-string"><span class="hljs-string">"unity_InverseProjectionMatrix"</span></span>, projectionMatrix.inverse);</code> </pre> <br>  Now let's extend our GetWorldFromViewPosition function. <br><br>  First, we need to obtain a position in the view space by performing a <strong>multiplication of the position in the space of truncated coordinates by InverseProjectionMatrix</strong> .  We will also need to perform some more voodoo magic with a screen position that is related to the way Unity stores the position in the space of truncated coordinates. <br><br>  Finally, we can <strong>multiply the position in the view space by ViewToWorldMatrix</strong> to get a position in the <strong>world space</strong> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWorldFromViewPosition</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VertexOutput i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// –ø–æ–ª—É—á–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ –≥–ª—É–±–∏–Ω—ã float z = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, sampler_CameraDepthTexture, i.screenPos).r; // –ø–æ–ª—É—á–∞–µ–º –ø–æ–∑–∏—Ü–∏—é –≤ –≤–∏–¥–æ–≤–æ–º –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ float4 result = mul(unity_InverseProjectionMatrix, float4(2*i.screenPos-1.0, z, 1.0)); float3 viewPos = result.xyz / result.w; // –ø–æ–ª—É—á–∞–µ–º –ø–æ–∑–∏—Ü–∏—é –≤ –º–∏—Ä–æ–≤–æ–º –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ float3 worldPos = mul(unity_ViewToWorldMatrix, float4(viewPos, 1.0)); return worldPos; }</span></span></code> </pre> <br>  Let's perform a check to make sure that the positions in world space are correct.  To do this, I wrote a <a href="https://github.com/lindenreid/ColorSpread/blob/master/Color/Assets/Shaders/TestWorldPos.shader">shader</a> that returns only the position of the object in <strong>world space</strong> ;  This is a fairly simple calculation based on the usual shader, the correctness of which can be trusted.  Disable the post-processing effect and take a screenshot of this test shader of <strong>global space</strong> .  My after applying the shader to the ground in the scene looks like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a91/4f2/b78/a914f2b787501e385ef27746865429bd.png"></div><br>  (Note that the values ‚Äã‚Äãin world space are much larger than 1.0, so do not worry about these colors having any meaning; instead, just make sure that the results are the same for the "correct" and "calculated" answers.) Next, let's return to the test The object is a common material (and not a world space test material), and then re-enable the post-processing effect.  My results look like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9e/deb/7ce/f9edeb7cea30fb33b72705a568264638.png"></div><br>  This is completely similar to the test shader written by me, that is, the calculations of the world space are most likely correct! <br><br><h2>  Drawing a circle in the world space </h2><br>  Now that we have <strong>positions in global space</strong> , we can draw a circle of colors in the scene!  We need to set the <strong>radius</strong> within which the effect will draw the color.  Beyond it, the effect will draw a picture in grayscale.  To set it, you need to adjust the values ‚Äã‚Äãfor the <strong>radius of the</strong> effect ( <strong>_MaxSize</strong> ) and the center of the circle (_Center).  I set these values ‚Äã‚Äãin the C # <a href="">ColorSpread</a> class so that they are visible in the inspector.  Let's extend our fragment shader by making it <strong>check whether the current pixel is inside the radius of the circle</strong> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Frag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VertexOutput i)</span></span></span><span class="hljs-function"> : SV_Target </span></span>{ float3 worldPos = GetWorldFromViewPosition(i); <span class="hljs-comment"><span class="hljs-comment">// –ø—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –º–∞–∫—Å. —Ä–∞–¥–∏—É—Å–∞ // –≤—ã–±–∏—Ä–∞–µ–º –≥—Ä–∞–¥–∞—Ü–∏–∏ —Å–µ—Ä–æ–≥–æ, –µ—Å–ª–∏ –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏, –ø–æ–ª–Ω—ã–π —Ü–≤–µ—Ç, –µ—Å–ª–∏ –≤–Ω—É—Ç—Ä–∏ float dist = distance(_Center, worldPos); float blend = dist &lt;= _MaxSize? 0 : 1; // –æ–±—ã—á–Ω—ã–π —Ü–≤–µ—Ç float4 fullColor = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.screenPos); // –≥—Ä–∞–¥–∞—Ü–∏–∏ —Å–µ—Ä–æ–≥–æ float luminance = dot(fullColor.rgb, float3(0.2126729, 0.7151522, 0.0721750)); float3 greyscale = luminance.xxx; // —Ä–µ—à–∞–µ—Ç, –≤—ã–±—Ä–∞—Ç—å –ª–∏ —Ü–≤–µ—Ç –∏–ª–∏ –≥—Ä–∞–¥–∞—Ü–∏–∏ —Å–µ—Ä–æ–≥–æ float3 color = (1-blend)*fullColor + blend*greyscale; return float4(color, 1.0); }</span></span></code> </pre> <br>  Finally, we will be able to draw the color based on whether it is within a <strong>radius</strong> in <strong>world space</strong> .  This is what the base effect looks like! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/983/6be/fb0/9836befb050f5a354b1eb4e6faee50d5.png"></div><br><hr><br><h1>  Adding special effects </h1><br>  I will consider a couple of techniques used to spread the color on the ground.  There is much more in the full effect, but the tutorial has already become too large, so we limit ourselves to the most important. <br><br><h2>  Circle zoom animation </h2><br>  We want the effect to spread throughout the world, that is, as it were grow.  For this you need to change the <strong>radius</strong> depending on the time. <br><br>  _StartTime indicates the time at which the circle should start to grow.  In my project, I used an additional script that allows you to click anywhere on the screen to start the growth of the circle;  in this case, the start time is equal to the mouse click time. <br><br>  _GrowthSpeed ‚Äã‚Äãsets the speed for increasing the circle. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// –≤—ã—á–∏—Å–ª—è–µ–º —Ä–∞–¥–∏—É—Å –Ω–∞ –æ—Å–Ω–æ–≤–∞–Ω–∏–∏ –≤—Ä–µ–º–µ–Ω–∏ –Ω–∞—á–∞–ª–∞ –∞–Ω–∏–º–∞—Ü–∏–∏ –∏ —Ç–µ–∫—É—â–µ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ float timeElapsed = _Time.y - _StartTime; float effectRadius = min(timeElapsed * _GrowthSpeed, _MaxSize); // –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–¥–∏—É—Å, —á—Ç–æ–±—ã –Ω–µ –ø–æ–ª—É—á–∏—Ç—å —Å—Ç—Ä–∞–Ω–Ω—ã—Ö –∞—Ä—Ç–µ—Ñ–∞–∫—Ç–æ–≤ effectRadius = clamp(effectRadius, 0, _MaxSize);</span></span></code> </pre> <br>  We also need to update the distance check to compare the current distance with the increasing <strong>radius of the effect</strong> , not _MaxSize. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// –ø—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö —Ç–µ–∫—É—â–µ–≥–æ —Ä–∞–¥–∏—É—Å–∞ —ç—Ñ—Ñ–µ–∫—Ç–∞ // –≤—ã–±–∏—Ä–∞–µ–º –≥—Ä–∞–¥–∞—Ü–∏–∏ —Å–µ—Ä–æ–≥–æ, –µ—Å–ª–∏ –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏, –ø–æ–ª–Ω—ã–π —Ü–≤–µ—Ç, –µ—Å–ª–∏ –≤–Ω—É—Ç—Ä–∏ float dist = distance(_Center, worldPos); float blend = dist &lt;= effectRadius? 0 : 1; // –≤—Å—è –æ—Å—Ç–∞–ª—å–Ω–∞—è —Ä–∞–±–æ—Ç–∞ —Å —Ü–≤–µ—Ç–æ–º...</span></span></code> </pre> <br>  Here‚Äôs what the result should look like: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecb/3bc/761/ecb3bc76112c56270745db56f2272e7c.gif"></div><br><h2>  Adding Noise to Radius </h2><br>  I wanted the effect to be more like a blur of paint, and not just a growing circle.  To do this, let's <strong>add noise to the radius of the effect</strong> so that the propagation is uneven. <br><br>  First we need to sample the texture in the <strong>global space</strong> .  The UV coordinates of i.screenPos are in <strong>screen space</strong> , and if we perform sampling based on them, the shape of the effect will move with the camera;  so let's use the coordinates in <strong>world space</strong> .  I added the <strong>_NoiseTexScale</strong> parameter to control the <strong>scale of the noise texture sample</strong> , because the coordinates in world space are quite large. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// –ø–æ–ª—É—á–∞–µ–º –¥–ª—è —Ç–µ–∫—Å—Ç—É—Ä—ã —à—É–º–∞ –ø–æ–∑–∏—Ü–∏—é —Å—ç–º–ø–ª–∏—Ä–æ–≤–∞–Ω–∏—è –≤ –º–∏—Ä–æ–≤–æ–º –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ float2 worldUV = worldPos.xz; worldUV *= _NoiseTexScale;</span></span></code> </pre> <br>  Now let's sample the noise texture and add this value to the radius of the effect.  I used the _NoiseSize scale for more control over the size of the noise. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// –ø—Ä–∏–±–∞–≤–ª—è–µ–º —à—É–º –∫ —Ä–∞–¥–∏—É—Å—É float noise = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, worldUV).r; effectRadius -= noise * _NoiseSize;</span></span></code> </pre> <br>  Here are the results after some tweaking: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51f/b77/f57/51fb77f570eb4ba77fa4e8eaa8cadb20.gif"></div><br><hr><br><h1>  In conclusion </h1><br>  You can follow tutorials for updates on my <a href="https://twitter.com/so_good_lin">Twitter account</a> , and on <a href="https://www.twitch.tv/linden_reid">Twitch</a> I spend on streaming coding!  (I also stream games from time to time, so don‚Äôt be surprised if you see me in my pajamas and play Kingdom Hearts 3.) <br><br>  Thanks: <br><br><ul><li>  All project models are taken in this <a href="https://assetstore.unity.com/packages/3d/environments/landscapes/lowpoly-environment-pack-99479">LowPoly Environment Pack</a> from the Unity store. </li><li>  <a href="">The effect of ScreenSpaceReflections from the Unity engine</a> helped me a lot to figure out how to get a three-dimensional position in the view space from the two-dimensional UV-coordinates of the screen space. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/436456/">https://habr.com/ru/post/436456/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>