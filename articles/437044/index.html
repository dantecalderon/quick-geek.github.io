<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to defeat the dragon: rewrite your program on Golang</title>
  <meta name="description" content="It so happened that your program was written in a scripting language - for example, in Ruby - and there was a need to rewrite it in Golang. 


 A reas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>How to defeat the dragon: rewrite your program on Golang</h1><div class="post__text post__text-html js-mediator-article"><p>  It so happened that your program was written in a scripting language - for example, in Ruby - and there was a need to rewrite it in Golang. </p><br><p>  A reasonable question: <strong>why</strong> in general may need to rewrite the program, which is already written and works fine? </p><br><p><img src="https://habrastorage.org/webt/b7/a0/ho/b7a0hogmqu_sytkfqkhaqbmwbz0.jpeg"><a name="habracut"></a></p><br><p>  First, let's say a program <strong>is associated with a specific ecosystem</strong> - in our case, it is Docker and Kubernetes.  The entire infrastructure of these projects is written in Golang.  This allows access to libraries that use Docker, Kubernetes and others.  From the point of view of maintenance, development and improvement of your program, it is more profitable to use the same infrastructure that the main products use.  In this case, all new features will be available immediately and you will not have to re-implement them in another language.  Only this condition <strong>in our particular situation</strong> was enough to make a decision about the need to change the language in principle, and that it should be for the language.  There are, however, other pluses ... </p><br><p>  Secondly, the <strong>ease of installing</strong> applications on Golang.  You do not need to install Rvm, Ruby, a set of gems, etc. in the system. You need to download one static binary file and use it. </p><br><p> Thirdly, the <strong>speed of the</strong> programs at Golang is higher.  This is not a significant systemic increase in speed, which is obtained by using the correct architecture and algorithms in any language.  But this is a growth that is felt when you start your program from the console.  For example, <code>--help</code> on Ruby can work in 0.8 seconds, and on Golang - 0.02 seconds.  This simply improves the user experience of using the program. </p><br><p>  <em><strong>NB</strong> : As regular readers of our blog could guess, the article is based on the experience of rewriting our <strong>dapp</strong> product, which is now - not even officially (!) - known as <a href="https://github.com/flant/werf">werf</a> .</em>  <em>Small details about him, see the end of the material.</em> </p><br><p>  Well: you can just go and sit down to write a new code, completely isolated from the old script code.  But immediately some <strong>complications and limitations</strong> on resources and time allocated for development emerge: </p><br><ul><li>  The current version of the program in Ruby is constantly in need of improvements and corrections: <br><ul><li>  Bugs arise as they are used and must be corrected promptly; </li><li>  It is impossible to freeze the addition of new features for six months, since  These features are often required by clients / users. </li></ul></li><li>  Maintaining 2 code bases at the same time is difficult and expensive: <br><ul><li>  Teams of 2-3 people are few, considering the presence of other projects besides this program in Ruby. </li></ul></li><li>  The introduction of the new version: <br><ul><li>  There should be no significant degradation in function; </li><li>  Ideally, this should be seamless and seamless. </li></ul></li></ul><br><p>  It is necessary to organize a continuous porting process.  But how to do this if the version on Golang is developed as a separate program? </p><br><h2 id="pishem-srazu-na-dvuh-yazykah">  We write in two languages ‚Äã‚Äãat once </h2><br><p>  And what if to transfer components to the Golang from the bottom up?  We start with low-level things, then go up through the abstractions. </p><br><p>  Imagine that your program consists of the following components: </p><br><pre> <code class="plaintext hljs">lib/ config.rb build/ image.rb git_repo/ base.rb local.rb remote.rb docker_registry.rb builder/ base.rb shell.rb ansible.rb stage/ base.rb from.rb before_install.rb git.rb install.rb before_setup.rb setup.rb deploy/ kubernetes/ client.rb manager/ base.rb job.rb deployment.rb pod.rb</code> </pre> <br><h3 id="portirovat-komponent-s-funkciyami">  Port component with functions </h3><br><p>  A simple case.  We take an existing component that is rather isolated from the rest - for example, <code>config</code> ( <code>lib/config.rb</code> ).  In this component, only the <code>Config::parse</code> function is defined, which takes the path to the config, reads it and returns the completed structure.  A separate binaries for the Golang <code>config</code> and the corresponding package <code>config</code> will be responsible for its implementation: </p><br><pre> <code class="plaintext hljs">cmd/ config/ main.go pkg/ config/ config.go</code> </pre> <br><p>  The binary on Golang gets the arguments from the JSON file and outputs the result to the JSON file. </p><br><pre> <code class="plaintext hljs">config -args-from-file args.json -res-to-file res.json</code> </pre> <br><p>  It is <code>config</code> that the <code>config</code> can output messages to stdout / stderr (in our Ruby program, the output <em>always</em> goes to stdout / stderr, so this feature is not parameterized). </p><br><p>  Calling the <code>config</code> binary is equivalent to calling some function of the <code>config</code> component.  The arguments through the file <code>args.json</code> indicate the name of the function and its parameters.  At the output through the <code>res.json</code> file <code>res.json</code> get the result of the function.  If the function must return an object of some class, then the data of the <em>object of</em> this class is returned in the form serialized in JSON. </p><br><p>  For example, to call the function <code>Config::parse</code> we specify the following <code>args.json</code> : </p><br><pre> <code class="plaintext hljs">{ "command": "Parse", "configPath": "path-to-config.yaml" }</code> </pre> <br><p>  We <code>res.json</code> result in <code>res.json</code> : </p><br><pre> <code class="plaintext hljs">{ "config": { "Images": [{"Name": "nginx"}, {"Name": "rails"}], "From": "ubuntu:16.04" }, }</code> </pre> <br><p>  In the <code>config</code> field, we get the state of the <code>Config::Config</code> object serialized in JSON.  From this state on the caller in Ruby, you need to construct a <code>Config::Config</code> object. </p><br><p>  In the event of an error, the binary can return the following JSON: </p><br><pre> <code class="plaintext hljs">{ "error": "no such file path-to-config.yaml" }</code> </pre> <br><p>  The <code>error</code> field must be processed by the caller. </p><br><h4 id="vyzyvaem-golang-iz-ruby">  Calling Golang from Ruby </h4><br><p>  From the Ruby side, we turn the <code>Config::parse(config_path)</code> into a wrapper that calls our <code>config</code> , gets the result, handles all possible errors.  Here‚Äôs an example of ruby ‚Äã‚Äãpseudocode with simplifications: </p><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parse</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">config_path</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">call_id</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get_random_number</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args_file</span></span></span><span class="hljs-class"> = "</span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#{get_tmp_dir}/args.#{call_id}.json" res_file = "#{get_tmp_dir}/res.#{call_id}.json" args_file.write(JSON.dump( "command" =&gt; "Parse", "configPath" =&gt; config_path, )) system("config -args-from-file #{args_file} -res-to-file #{res_file}") raise "config failed with unknown error" if $?.exitstatus != 0 res = JSON.load_file(res_file) raise ParseError, res["error"] if res["error"] return Config.new_from_state(res["config"]) end end</span></span></span></span></code> </pre> <br><p>  A binary could crash with a non-zero unintended code - this is an exceptional situation.  Or with the provided codes - in this case, we look at the <code>res.json</code> file for the presence of the <code>error</code> and <code>config</code> fields and eventually return the <code>Config::Config</code> object from the serialized <code>config</code> field. </p><br><p>  From the user's point of view, the <code>Config::Parse</code> function has not changed anything. </p><br><h3 id="portirovat-komponent-klass">  Port component class </h3><br><p>  For example, take the class hierarchy <code>lib/git_repo</code> .  There are 2 classes: <code>GitRepo::Local</code> and <code>GitRepo::Remote</code> .  It makes sense to combine their implementation in a single binary <code>git_repo</code> and, accordingly, package <code>git_repo</code> in Golang. </p><br><pre> <code class="plaintext hljs">cmd/ git_repo/ main.go pkg/ git_repo/ base.go local.go remote.go</code> </pre> <br><p>  Calling the <code>git_repo</code> binary corresponds to calling any method of the <code>GitRepo::Local</code> or <code>GitRepo::Remote</code> object.  An object has a state and it can change after calling a method.  Therefore, in the arguments we pass the current state, serialized to JSON.  And at the output we always get the new state of the object - also in JSON. </p><br><p>  For example, to call the <code>local_repo.commit_exists?(commit)</code> method, we specify <code>args.json</code> : </p><br><pre> <code class="plaintext hljs">{ "localGitRepo": { "name": "my_local_git_repo", "path": "path/to/git" }, "method": "IsCommitExists", "commit": "e43b1336d37478282693419e2c3f2d03a482c578" }</code> </pre> <br><p>  At the output we get <code>res.json</code> : </p><br><pre> <code class="plaintext hljs">{ "localGitRepo": { "name": "my_local_git_repo", "path": "path/to/git" }, "result": true, }</code> </pre> <br><p>  In the <code>localGitRepo</code> field, a new state of the object has been received (which may not change).  We should put this state in the current Ruby-object <code>local_git_repo</code> in any case. </p><br><h4 id="vyzyvaem-golang-iz-ruby-1">  Calling Golang from Ruby </h4><br><p>  From the Ruby side, we transform each class method <code>GitRepo::Base</code> , <code>GitRepo::Local</code> , <code>GitRepo::Remote</code> into wrappers that call our <code>git_repo</code> , get the result, set the new state of the object of the <code>GitRepo::Local</code> or <code>GitRepo::Remote</code> class. </p><br><p>  Otherwise, everything is the same as calling a simple function. </p><br><h4 id="kak-byt-s-polimorfizmom-i-bazovymi-klassami">  How to deal with polymorphism and base classes </h4><br><p>  The easiest thing to do is not to support polymorphism by Golang.  Those.  make the calls to the <code>git_repo</code> binary always explicitly address the specific implementation (if <code>localGitRepo</code> specified in the arguments, the call came from an object of the <code>GitRepo::Local</code> class; if <code>remoteGitRepo</code> specified, then from the <code>GitRepo::Remote</code> ) and get by copying a small amount of boilerplate- code in cmd.  After all, all the same, <strong>this code will be thrown out as soon</strong> as the move to Golang is completed. </p><br><h4 id="kak-menyat-sostoyanie-drugogo-obekta">  How to change the state of another object </h4><br><p>  There are situations when an object receives another object as a parameter and calls it a method that implicitly changes the state of this second object. </p><br><p>  In this case it is necessary: </p><br><ol><li>  When a binary is called, in addition to the serialized state of the object called by the method, the serialized state of all the parameter objects is transmitted. </li><li>  After the call, reinstall the state of the object to which the method was called, and also reinstall the state of all the objects that were passed as parameters. </li></ol><br><p>  Otherwise, everything is the same. </p><br><h3 id="chto-poluchaetsya">  What is the result? </h3><br><p>  We take a component, we port to Golang, we release a new version. </p><br><p>  In the case when the underlying components are already ported and the higher-level component that uses them is transferred, this <strong>component can ‚Äútake in itself‚Äù of these underlying ones</strong> .  In this case, the corresponding extra binaries may already be deleted as unnecessary. </p><br><p>  And so it goes until we get to the very top layer, which sticks together <strong>all the underlying abstractions</strong> .  This will complete the first stage of porting.  The top layer is CLI.  He can still live in Ruby for a while before fully switching to Golang. </p><br><h2 id="kak-rasprostranyat-etogo-monstra">  How to distribute this monster? </h2><br><p>  Good: now we have an approach to gradually port all components.  Question: how to distribute such a program in 2 languages? </p><br><p>  In the case of Ruby, the program is still installed as a Gem.  As soon as it comes to calling the binary, it can download this dependency to a specific URL (it's hardcoded) and cache it locally on the system (somewhere in the service files). </p><br><p>  When we make a new release of our program in 2 languages, we must: </p><br><ol><li>  Collect and download all binary dependencies on a hosting. </li><li>  Create Ruby Gem new version. </li></ol><br><p>  The binaries for each subsequent version are collected separately, even if some component has not changed.  It would be possible to make a separate versioning of all dependent binaries.  Then it would not be necessary to collect new binaries for each new version of the program.  But in our case, we proceeded from the fact that we do not have time to do something super-complex and optimize the temporary code, so for simplicity we collected separate binaries for each version of the program at the expense of saving time and space for downloading. </p><br><h2 id="nedostatki-podhoda">  Disadvantages approach </h2><br><p>  Obviously, overhead costs for a constant call of external programs through <code>system</code> / <code>exec</code> . </p><br><p>  It is difficult to make <strong>caching of any global data at the Golang level</strong> - after all, all the data in Golang (for example, package variables) is created when you call a method and die after completion.  This must always be borne in mind.  However, caching is still possible <strong>at the level of class instances</strong> or <strong>when explicitly passing parameters</strong> to an external component. </p><br><p>  We must not forget to transfer the <strong>state of objects in Golang</strong> and correctly restore it after the call. </p><br><p>  Binary dependencies on Golang <strong>take up a lot of space</strong> .  It's one thing when there is a single 30 MB binary ‚Äî a program on Golang.  Another thing is when you have ported ~ 10 components, each of which weighs 30 MB - we get 300 MB of files <strong>for each version</strong> .  Because of this, the place on the binary hosting and on the host machine, where your program is running and constantly updated, quickly goes away.  However, the problem is not significant if periodically deleting old versions. </p><br><p>  Also note that with each update of the program it will take some time to download binary dependencies. </p><br><h2 id="preimuschestva-podhoda">  Benefits of the approach </h2><br><p>  Despite all of these drawbacks, this approach allows you to organize a <strong>continuous process of porting to another language</strong> and get <strong>along with</strong> one development team. </p><br><p>  The most important advantage is the ability to get <strong>quick feedback</strong> on the new code, test and stabilize it. </p><br><p>  In this case, you can, in between times, add new features to your program, fix bugs in the current version. </p><br><h2 id="kak-sdelat-okonchatelnyy-perevorot-na-golang">  How to make a final coup on Golang </h2><br><p>  At the moment when all the main components are addressed to Golang and already tested in production, all that remains is to rewrite the top interface of your program (CLI) to Golang and throw out all the old Ruby code. </p><br><p>  At this stage, it remains only to solve the compatibility problems of your new CLI with the old one. </p><br><p>  Cheers, comrades!  The revolution has come true. </p><br><h2 id="kak-my-perepisali-dapp-na-golang">  How we rewrote dapp on Golang </h2><br><p>  Dapp is a utility developed by Flant for organizing the CI / CD process.  It was written in Ruby for historical reasons: </p><br><ul><li>  Extensive experience in developing programs for Ruby. </li><li>  Used Chef (recipes for it are written in Ruby). </li><li>  Inertness, resistance to the use of a new language for us for something serious. </li></ul><br><p>  The approach described in the article was used to rewrite dapp to Golang.  On the above chart you can see the chronology of the struggle between good (Golang, blue) and evil (Ruby, red): </p><br><img src="https://habrastorage.org/webt/xc/qg/gy/xcqggyavhbvkewruasv-pgcxbfa.png"><br><p>  <em>The amount of code in the dapp / werf project in Ruby vs.</em>  <em>Golang over releases</em> </p><br><p>  At this point, you can <a href="https://github.com/flant/werf">download the alpha version 1.0</a> , which does not contain Ruby.  We also renamed dapp to werf, but this is another story ... <strong>Wait for the full release of werf 1.0 soon!</strong> </p><br><p>  As additional advantages of this migration and illustration of integration with the notorious Kubernetes ecosystem, we note that rewriting dapp on Golang gave us the opportunity to create another project - <strong><a href="https://github.com/flant/kubedog">kubedog</a></strong> .  So we were able to isolate the code for tracking K8s resources into a separate project, which can be useful <strong>not only</strong> in werf, but also in other projects.  For the same task, there are other solutions <em>(for more details, see our <a href="https://habr.com/ru/company/flant/blog/434160/">recent announcement</a> )</em> , but it would hardly be possible to ‚Äúcompete‚Äù with them (in the sense of popularity) without having a Go base. </p><br><h2 id="ps">  PS </h2><br><p>  Read also in our blog: </p><br><ul><li>  ‚Äú <a href="https://habr.com/ru/company/flant/blog/434160/">Introducing the kubedog library for tracking Kubernetes resources.</a> ‚Äù </li><li>  " <a href="https://habr.com/ru/company/flant/blog/333682/">Officially present dapp - a DevOps utility to maintain the CI / CD</a> ." </li><li>  ‚Äú <a href="https://habr.com/ru/company/flant/blog/351838/">They waited: YAML support and Ansible (without cows) in dapp</a> ‚Äù. </li><li>  " <a href="https://habr.com/ru/company/flant/blog/345580/">Build and heat applications in Kubernetes using dapp and GitLab CI</a> ". </li></ul></div><p>Source: <a href="https://habr.com/ru/post/437044/">https://habr.com/ru/post/437044/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>