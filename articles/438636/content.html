<div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/lm/rt/rk/lmrtrkww5knurdsaznutrksterk.jpeg"></p><br><p>  Is the performance below equivalent in performance? </p><br><pre><code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// (A). Вызов HasPrefix будет встроен. return strings.HasPrefix(s, "#") // (B). Ручное встраивание тела HasPrefix. return len(s) &gt;= len("#") &amp;&amp; s[:len("#")] == "#"</span></span></code> </pre> <br><p>  The answer is <strong>no</strong> . </p><br><p>  For details and explanations I ask under cat. </p><a name="habracut"></a><br><hr><br><p>  Good day, before you open the topic, I would like to introduce myself. <br>  My name is Iskander and I send commits to the <a href="https://github.com/golang/go">golang / go</a> repository from time to time. </p><br><img src="https://habrastorage.org/webt/ls/jy/t3/lsjyt3z-jg1l5dx2nlecj17lbks.png" alt="image" align="left"><br><p>  I used to do it on behalf of the <a href="https://github.com/intel-go">Intel Go</a> team, but our paths diverged and now I am an independent contributor.  Recently I work in <a href="https://github.com/VKCOM">vk</a> in the infrastructure team. </p><br><p>  In my free time I make different tools for Go, such as <a href="https://github.com/go-critic/go-critic">go-critic</a> and <a href="https://habr.com/ru/post/429354/">go-consistent</a> .  I also <a href="https://github.com/Quasilyte/gopher-arts">draw gophers</a> . </p><br><p><br></p><br><h1 id="measure-it">  Measure it! </h1><br><p>  Immediately proceed to the comparison and outline the benchmark: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> benchmark <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"strings"</span></span> <span class="hljs-string"><span class="hljs-string">"testing"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = <span class="hljs-string"><span class="hljs-string">"#string"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkHasPrefixCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { _ = strings.HasPrefix(s, <span class="hljs-string"><span class="hljs-string">"#"</span></span>) _ = strings.HasPrefix(s, <span class="hljs-string"><span class="hljs-string">"x"</span></span>) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkHasPrefixInlined</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { _ = <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(s) &gt;= <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(<span class="hljs-string"><span class="hljs-string">"#"</span></span>) &amp;&amp; s[:<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(<span class="hljs-string"><span class="hljs-string">"#"</span></span>)] == <span class="hljs-string"><span class="hljs-string">"#"</span></span> _ = <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(s) &gt;= <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(<span class="hljs-string"><span class="hljs-string">"x"</span></span>) &amp;&amp; s[:<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(<span class="hljs-string"><span class="hljs-string">"x"</span></span>)] == <span class="hljs-string"><span class="hljs-string">"x"</span></span> } }</code> </pre> <br><p>  Instead of recommending <a href="https://godoc.org/golang.org/x/perf/cmd/benchstat">benchstat</a> to you, I will show you <a href="https://github.com/Quasilyte/go-benchrun">benchrun</a> . </p><br><p>  With the help of one command, we can run both benchmarks and get a comparison: </p><br><pre> <code class="bash hljs">go-benchrun HasPrefixCall HasPrefixInlined -v -count=10 . Benchstat results: name old time/op new time/op delta HasPrefixCall-8 9.15ns ± 1% 0.36ns ± 3% -96.09% (p=0.000 n=10+9)</code> </pre> <br><p>  The version with manual embedding is much faster than the code that was obtained by embedding the function body with the compiler.  Let's try to figure out why this is happening. </p><br><h1 id="stringshasprefix">  strings.HasPrefix </h1><br><p>  Recall the <code>strings.HasPrefix</code> implementation: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// HasPrefix tests whether the string s begins with prefix. func HasPrefix(s, prefix string) bool { return len(s) &gt;= len(prefix) &amp;&amp; s[0:len(prefix)] == prefix }</span></span></code> </pre> <br><p>  The <code>HasPrefix</code> function <code>HasPrefix</code> built in by the compiler. <br>  You can check this as follows: </p><br><pre> <code class="bash hljs">go build -gcflags=<span class="hljs-string"><span class="hljs-string">'-m=2'</span></span> strings 2&gt;&amp;1 | grep <span class="hljs-string"><span class="hljs-string">'can inline HasPrefix'</span></span></code> </pre> <br><p>  To call <code>strings.HasPrefix</code> from option <code>(A)</code> we get the following machine code: </p><br><pre> <code class="plaintext hljs"> MOVQ (TLS), CX CMPQ SP, 16(CX) JLS more_stack fn_body: SUBQ $40, SP MOVQ BP, 32(SP) LEAQ 32(SP), BP XCHGL AX, AX MOVQ s+56(SP), AX CMPQ AX, $1 JGE compare_strings XORL AX, AX MOVB AL, ~ret1+64(SP) MOVQ 32(SP), BP ADDQ $40, SP return: RET compare_strings: MOVQ s+48(SP), AX MOVQ AX, (SP) LEAQ go.string."#"(SB), AX MOVQ AX, 8(SP) MOVQ $1, 16(SP) CALL runtime.memequal(SB) MOVBLZX 24(SP), AX JMP return more_stack: CALL runtime.morestack_noctxt(SB) JMP fn_body</code> </pre> <br><p>  Do not pay attention to what the code looks like noodles. </p><br><p>  What you should pay attention to: </p><br><ul><li>  <code>strings.HasPrefix</code> really inserted, no call. </li><li>  <code>runtime.memequal</code> is called to compare strings. </li></ul><br><p>  But what then is generated for the manually built-in variant, the code from the example <code>(B)</code> ? </p><br><pre> <code class="plaintext hljs"> MOVQ s+16(SP), AX CMPQ AX, $1 JLT different_length MOVQ s+8(SP), AX CMPB (AX), $35 // 35 - код символа "#" SETEQ AL return: MOVB AL, "".~ret1+24(SP) RET different_length: XORL AX, AX JMP 22</code> </pre> <br><p>  And here the compiler does not generate a <code>runtime.memequal</code> call and compares a single character directly.  Ideally, he should have done the same for the first option. </p><br><p>  We observe the weak side of the Go optimizer, and we will analyze it. </p><br><h1 id="optimizacii-konstantnyh-vyrazheniy">  Optimize constant expressions </h1><br><p>  The reason why the call to <code>strings.HasPrefix(s, "#")</code> can be optimized is because the prefix argument is constant.  We know its length and content.  It makes no sense to call <code>runtime.memequal</code> for short lines, it is faster to make a comparison of characters "in place", avoiding an extra call. </p><br><p>  As you know, compilers usually have at least two parts: the <a href="https://github.com/golang/go/tree/master/src/cmd/compile/internal/gc">compiler frontend</a> and the <a href="https://github.com/golang/go/tree/master/src/cmd/compile/internal/ssa">compiler backend</a> .  The first works with a higher-level view, the second is closer to the machine and the intermediate view will look like a stream of instructions.  Already several versions in Go use the <a href="https://en.wikipedia.org/wiki/Static_single_assignment_form">SSA</a> representation for optimizations in the backend part of the compiler. </p><br><p>  The folding of constants, such as <code>{10*2 =&gt; 20}</code> , is implemented in the backend.  In general, most of the operations associated with lowering the computational cost of expressions are in this part of the compiler.  But there are exceptions. </p><br><p>  One exception is the optimization of constant string comparisons.  When the compiler sees a string comparison (or substrings) in which one or both operands are constants, a more efficient code is generated than a <code>runtime.memequal</code> call. </p><br><p>  You can view the source code for this in <a href="">cmd / compile / internal / gc / walk.go: 3362</a> . </p><br><p>  Embedding of functions occurs before running these optimizations, but also in the frontend part of the compiler. </p><br><p>  It would seem that all the same does not allow this optimization to work in our case? </p><br><h1 id="kak-go-vstraivaet-vyzovy-funkciy">  How Go builds function calls </h1><br><p>  This is how embedding will occur: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Вот как выглядел вызов: return strings.HasPrefix(s, "#") // Вот сигнатура: func HasPrefix(s, prefix string) bool // А вот результат встраивания: _s, _prefix := s, "#" return len(s) &gt;= len(prefix) &amp;&amp; s[:len(prefix)] == prefix</span></span></code> </pre> <br><p>  When embedding functions, the compiler assigns arguments to temporary variables, which breaks the optimization, since the algorithm in <a href="">walk.go</a> does not see the constants, but the arguments with variables.  This is the problem. </p><br><p>  By the way, optimizations from backend, which are available to SSA, do not interfere.  But there are other problems there, for example, the inability to restore high-level language constructs for their effective comparison (work to eliminate this shortcoming has been “planned” for several years). </p><br><h1 id="eschyo-odin-primer-escape-analysis">  Another example: escape analysis </h1><br><p>  Imagine a function that is important to allocate a temporary buffer on the stack: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">businessLogic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { buf := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>) <span class="hljs-comment"><span class="hljs-comment">// buf используется только локально // для временного хранения результатов. return nil }</span></span></code> </pre> <br><p>  Since <code>buf</code> does not "run away", the compiler will be able to allocate these 16 bytes on the stack, without allocation on the heap.  Again, all thanks to the constant value when invoking <code>make</code> .  To allocate memory on the stack, it is important for us to know the required size, which will be part of the frame allocated for the function call. </p><br><p>  Suppose in the future we wanted to allocate temporary buffers of different sizes and encapsulate some logic in the methods.  We introduced a new abstraction and decided to use the new <code>tmpBuf</code> type <code>tmpBuf</code> .  The design function is extremely simple: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newTmpBuf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sizeHint </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmpBuf</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmpBuf{buf: <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, sizeHint)} }</code> </pre> <br><p>  Adapt the original example: </p><br><pre> <code class="diff hljs">func businessLogic() error { - buf := make([]byte, 0, 16) + buf := newTmpBuf(16) // buf используется только локально // для временного хранения результатов. return nil }</code> </pre> <br><p>  The constructor will be embedded, but the allocation will now always be on the heap, for the same reason passing arguments through temporary variables.  Escape analysis will see <code>make([]byte, 0, _sizeHint)</code> that does not fall under its recognition pattern of optimized <code>make</code> calls. </p><br><p>  If we had "everything just like people", there would be no problem, after embedding the constructor <code>newTmpBuf</code> it would be clear that the size is still known at the compilation stage. </p><br><p>  This saddens almost more than the situation with string comparison. </p><br><h1 id="gorizonty-go-113">  Horizons Go 1.13 </h1><br><p>  The situation can be corrected quite easily and I have already sent the <a href="https://go-review.googlesource.com/c/go/%2B/152478/">first part of the solution</a> . </p><br><img src="https://habrastorage.org/webt/uv/gv/16/uvgv16e70jy6qdip9wju_vqzvog.png" alt="image" align="left"><br><p>  If you think that the problem described in the article really needs a solution, please put a thumbs up in the <a href="https://github.com/golang/go/issues/29095">appropriate issue</a> . </p><br><p></p><hr><br><br><p>  My position is that embedding the code with your hands just because it runs faster in the current version of Go is wrong.  It is necessary to correct this flaw in the optimizer, at least to the level that the examples described above work without unexpected performance regressions. </p><br><p>  If everything goes according to plan, this optimization will go into the release of Go 1.13. </p><br><p>  Thanks for attention. </p><br><h1 id="dopolnenie-predlozhennoe-reshenie">  Addition: proposed solution </h1><br><p>  This section is for the bravest, those who are not yet tired of reading. </p><br><p>  So, we have several places that work worse when using variables instead of their values ​​directly.  The proposed solution is to introduce a new function in the frontend part of the compiler, which allows you to get the last bound value by name.  After that, in each optimization that expects a constant value, do not give up when a variable is detected, but receive this previously saved state. </p><br><p>  The signature of our new feature might look like this: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getConstValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n *Node)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node</span></span></span></span></code> </pre> <br><p>  The <code>Node</code> definition can be viewed in the <a href="">syntax.go</a> file. </p><br><p>  Each variable definition corresponds to a <code>Node</code> with an <code>ONAME</code> tag.  Inside <code>Node.Name.Defn</code> for most of these variables there is an initialization value. </p><br><p>  If the <code>Node</code> already a literal, nothing needs to be done, and we simply return <code>n</code> .  If this is <code>ONAME</code> (variable), then you can try to extract from the <code>n.Name.Defn</code> the same initialization value. </p><br><p>  But what about the modifications between declaring and reading the variable for which we call <code>getConstValue</code> ?  If we confine ourselves to read-only variables, then there is no problem.  In the frontend go, there are already special node flags that mark similar names.  If the variable has been modified, <code>getConstValue</code> will not return an initial value. </p><br><p>  Programmers usually do not modify the input arguments of numeric and string types, and this makes it possible to cover a fairly large number of cases with this primitive algorithm. </p><br><p>  Now we are ready to consider the implementation of: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getConstValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n *Node)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// Мы раскрываем только ONAME у которых доступен definition. if n.Op != ONAME || n.Name.Defn == nil { return n } // Проверка на то, что инициализирующее значение не изменялось. // Заметим, что это очень консервативно, но нашу задачу по // исправлению проблемы встраивания функций и escape analysis'а решает. maybeModified := n.Assigned() || n.Name.Defn.Assigned() || n.Addrtaken() if maybeModified { return n } // OAS - Node типа присваивания. // n.Name.Defn.Left - это LHS. // n.Name.Defn.Right - это RHS. // consttype(v) возвращает константный тип инициализирующего выражения. // Если это CTxxx, то переданное выражение не является константным. if n.Name.Defn.Op == OAS { v := n.Name.Defn.Right if v != nil &amp;&amp; consttype(v) != CTxxx { return v } } return n }</span></span></code> </pre> <br><p>  Something like this changes the code, which depends on the constants: </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- i := indexconst(r) + i := indexconst(getConstValue(r))</span></span></code> </pre> <br><p>  Great, and it even works: </p><br><pre> <code class="go hljs">n := <span class="hljs-number"><span class="hljs-number">10</span></span> xs := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, n) <span class="hljs-comment"><span class="hljs-comment">// Теперь не убегает в кучу!</span></span></code> </pre> <br><p>  Before this change, escape analysis could not get a value of <code>10</code> through <code>n</code> , which made it an assumption that it was necessary to place <code>xs</code> on the heap. </p><br><p>  The code above is syntactically similar to the situation observed when embedding.  <code>n</code> may be a temporary variable that is added when the argument is passed. </p><br><p>  Unfortunately, there are nuances. </p><br><p>  We solved the problem for local variables entered through <a href="">OAS</a> , but Go initializes the variables for the built-in functions through <a href="">OAS2</a> .  Because of this, we will need a second change that extends the <code>getConstValue</code> function and slightly modifies the code of the inliner itself, because, among other things, <code>OAS2</code> does not have a suitable <code>Defn</code> field. </p><br><p>  That was bad news.  Good news: <a href="http://slack.golang-ru.com/">#gocontributing</a> channel appeared in the <a href="http://slack.golang-ru.com/">Russian-language slak</a> , where you can share your ideas and plans, ask questions, and discuss everything related to participation in the development of Go. </p></div>