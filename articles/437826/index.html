<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How we migrated the database from Redis and Riak KV to PostgreSQL. Part 1: the process</title>
  <meta name="description" content="This is the first part of the article, in which I will talk about how we built the process of working on a large database migration project: about saf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>How we migrated the database from Redis and Riak KV to PostgreSQL. Part 1: the process</h1><div class="post__text post__text-html js-mediator-article">  This is the first part of the article, in which I will talk about how we built the process of working on a large database migration project: about safe experiments, team planning and cross-team interaction.  In the following articles I will talk in more detail about the technical problems that we solved: scaling and fault tolerance of PostgreSQL and load testing. <br><br><img src="https://habrastorage.org/webt/h3/cq/xn/h3cqxnvyiw1x3frzzx_tzfwlxzw.png"><br><br>  For a long time, the main database in RealtimeBoard was Redis.  We stored in it all the basic information: data about users, accounts, boards, etc.  Everything worked quickly, but we faced a number of problems. <br><br>  <b>Problems with redis</b> <br><br><ol><li>  Dependence on network latency.  Now in our cloud it is about 20 Moscow time, but as it increases, the application will start working very slowly. </li><li>  The lack of indexes that we need at the level of business logic.  Their independent implementation can complicate business logic and lead to inconsistency of data. </li><li>  The complexity of the code also complicates the maintenance of data consistency. </li><li>  Resource intensity queries with samples. </li></ol><br>  These problems, along with the increasing amount of data on the servers, caused the database to be migrated. <br><a name="habracut"></a><br><h2>  Formulation of the problem </h2><br>  The decision on migration is made.  The next step is to understand which of the databases is suitable for our data model. <br><br>  We conducted a study to select the optimal database for us, and stopped at PostgreSQL.  Our data model fits well with a relational database: PostgreSQL has built-in tools for data consistency, JSONB type, and the ability to index certain fields in JSONB.  It suits us. <br><br>  Simplified, the architecture of our application looked like this: there are Application Servers, which turn to Redis and RiakKV through the data processing layer. <br><br>  Our Application Server is a monolithic Java application.  Business logic is written on a framework that is adapted for NoSQL.  The application has its own transactional system that allows you to ensure the work of many users on any of our boards. <br><br>  RiakKV we used to store data archive boards, which did not open within 7 days. <br><br>  Add PostgreSQL to this schema.  We make it so that Application servers work with a new database.  Copy data from Redis and RiakKV to PostgreSQL.  Problem solved! <br><br>  <b>Nothing complicated, but there are nuances:</b> <br><br><ul><li>  We have 2.2 million registered users.  Every day 50,000 users work in RealtimeBoard, the peak load is up to 14,000 at a time.  Users should not encounter errors due to our work, they should not notice at all the moment of moving to a new base. </li><li>  1 TB of data in the database or 410 million objects. </li><li>  Continuous release of new features by other teams, whose work we should not interfere. </li></ul><br><h2>  Solutions to the problem </h2><br>  We had a choice of two data migration options: <br><br><ol><li>  Stop the development of the service ‚Üí rewrite the code on the server ‚Üí test the functionality ‚Üí launch a new version. </li><li>  Conduct a smooth migration: gradually transfer parts of the product to a new database, while simultaneously supporting PostgreSQL and Redis without interrupting the development of new features. </li></ol><br>  Stopping the development of the service is a waste of time that we could use for growth, which means the loss of users and market share.  For us, this is critical, so we chose the option with a smooth migration.  Despite the fact that, in terms of complexity, this process can be compared with the replacement of wheels on a car while driving. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Rrjgk1PksgU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  In evaluating the work, we broke our product into basic blocks: users, accounts, boards, and so on.  Separately carried out work on the creation of infrastructure PostgreSQL.  And they put the risks in the assessment in case something goes wrong (this is how it happened). <br><br><h2>  Sprints and goals </h2><br>  The next step is to build the work of a team of five people so that everyone moves at the right speed towards a common goal. <br><br>  We have two points: the beginning of work on the task and the final goal.  Ideally, when we move to the goal in a direct way.  But it often happens that we want to go straight, but it turns out like this: <br><br><img src="https://habrastorage.org/webt/td/ab/5p/tdab5prpw4exyylbudctzzzcp8s.png"><br><br>  For example, due to difficulties and problems that could not have been foreseen. <br><br>  A situation is possible in which we generally do not come to the goal.  For example, if we go into deep refactoring or rewriting the entire application. <br><br><img src="https://habrastorage.org/webt/9v/ef/66/9vef66oubzjo89rj7rtedo2a89u.png"><br><br>  We split the task into weekly sprints to minimize the difficulties described above.  If suddenly the team leaves aside, it can quickly return back with minimal losses for the project, since short iterations do not allow to go too far "not there". <br><br>  Each iteration has its own goal, which moves the team to the final big result. <br><br><img src="https://habrastorage.org/webt/ci/lv/z6/cilvz6zsakszbtskmwkc9ipt-w8.png"><br><br>  If during the sprint there is a new task, we estimate whether it brings us closer to the goal of its implementation.  Yes - we take the next sprint or change priorities in the current, if not - we don‚Äôt take it.  If errors appear, we set them high priority and quickly fix them. <br><br>  It happens that developers within a sprint must perform tasks in a strictly defined sequence.  Or, for example, the developer sends the finished task to the QA-engineer for urgent testing.  At the planning stage, we try to build similar dependencies between tasks for each team member.  This allows the entire team to see who will do what and when, without forgetting dependence on others. <br><br>  The team has daily and weekly synchronous.  Every morning in the morning we discuss who will do what and in what priority today.  After each sprint we synchronize with each other to make sure that everyone is moving in the right direction.  Be sure to make plans for large or complex releases.  We assign duty developers who, if necessary, are present during the release and monitor that everything is in order. <br><br>  Planning and synchronization within the team allows you to involve all participants in all phases of the project.  Plans and estimates do not come to us from above, we make them ourselves.  This increases the responsibility and interest of the team in performing tasks. <br><br>  This is one of our sprints.  We conduct everything on the RealtimeBoard board: <br><br><img src="https://habrastorage.org/webt/fq/uz/l2/fquzl2taefgfyi0ge6w4q8x52qm.png"><br><br><h2>  Modes and safe experiments </h2><br>  During the migration, we had to guarantee the stable operation of the service in combat conditions.  To do this, you need to be sure that everything has been tested and there are no errors anywhere.  To achieve this goal, we decided to make our smooth migration even smoother. <br><br>  The idea was to gradually switch the blocks of the product to the new database.  To do this, we came up with a sequence of modes. <br><br>  <b>In the first ‚ÄúRedis Read / Write‚Äù mode,</b> only the old Redis database is running. <br><br><img src="https://habrastorage.org/webt/aq/zs/rc/aqzsrc1smjopt9khha7zrkxfg_c.png"><br><br>  <b>In the second mode ‚ÄúPostgreSQL Passive Write‚Äù</b> we can make sure that writing to the new database is correct and the databases are consistent. <br><br><img src="https://habrastorage.org/webt/rl/gj/2v/rlgj2vmdvm2efjihl-dfccsmitq.png"><br><br>  <b>The third mode ‚ÄúPostgreSQL Read / Write, Redis Passive Write‚Äù</b> allows you to ensure the correctness of reading data from PostgreSQL and see how the new database behaves in combat conditions.  Redis remains the main base, which enabled us to find specific cases of working with boards that could lead to errors. <br><br><img src="https://habrastorage.org/webt/0n/77/23/0n7723633vpttzrti6pp6kajjui.png"><br><br>  <b>In the latter mode, ‚ÄúPostgreSQL Read / Write‚Äù</b> , only the new database works. <br><br><img src="https://habrastorage.org/webt/p4/c7/go/p4c7gokfrrvxrn-c-ltg7fhtvts.png"><br><br>  The migration work could affect the main functions of the product, so we had to be 100% sure that we would not break anything and the new database is at least as slow as the old one.  Therefore, we began to conduct safe experiments with switching modes. <br><br>  Switching modes began on our corporate account, which we use daily in work.  After we were convinced that there were no errors in it, we began to switch modes on a small sample of external users. <br><br>  Timeline run experiments with modes turned out like this: <br><br><ul><li>  January-February: Redis read / write </li><li>  March-April: PostgreSQL passive write </li><li>  May-June: PostgreSQL read / write, the main base is Redis </li><li>  July-August: PostgreSQL read / write </li><li>  September-December: full migration. </li></ul><br>  When errors occurred, we had the opportunity to quickly correct them, because we ourselves could make releases to the servers where the users participating in the experiment worked.  We did not depend on the main release in any way, so we corrected errors quickly and at any time. <br><br><h2>  Cross-team interaction </h2><br>  During migration, we often overlapped with the teams that released new features.  We have a single code base, and as part of their work, the teams could change existing structures in the new database or create new ones.  In this case, there could be intersections of teams for the development and withdrawal of new features.  For example, one of the product teams promised the marketing team to release a new feature by a specific date;  marketing team has planned an advertising campaign for this period;  the sales team is waiting for the feature and campaign to start communicating with new customers.  It turns out that everyone is dependent on each other, and delaying the deadlines by one team disrupts the plans of another. <br><br>  To avoid such situations, we, together with other teams, compiled a single grocery roadmap, according to which we synchronized several times a quarter, and with some teams weekly. <br><br><h2>  findings </h2><br>  What we have learned during this project: <br><br><ol><li>  Do not be afraid to take on complex projects.  After decomposition, evaluation and development of approaches to work, complex projects cease to seem overwhelming. </li>
<li>  Do not spare the time and effort on the preliminary estimates, decomposition and planning.  This helps to better understand the task before you start working on it, and to understand the volume and complexity of the work. </li><li>  Lay risks in heavy technical and organizational projects.  In the process of work, you are sure to encounter a problem that was not taken into account when planning. </li><li>  Do not migrate if it is not necessary. </li></ol><br>  In the following articles I will talk in more detail about the technical problems that we solved during the migration. </div><p>Source: <a href="https://habr.com/ru/post/437826/">https://habr.com/ru/post/437826/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>