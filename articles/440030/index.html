<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Point-by-round PKH locks on an OpenWrt router using WireGuard and DNSCrypt</title>
  <meta name="description" content="What is different from similar materials? 


- Implementing pure OpenWrt 
- Using WireGuard 
- The configuration of the router is organized using Open...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Point-by-round PKH locks on an OpenWrt router using WireGuard and DNSCrypt</h1><div class="post__text post__text-html js-mediator-article"><h2 id="chem-otlichaetsya-ot-podobnyh-materialov">  What is different from similar materials? </h2><br><ul><li>  Implementing pure OpenWrt </li><li>  Using WireGuard </li><li>  The configuration of the router is organized using OpenWrt configs, and not a bunch in one script </li><li>  There are situations when restarting the network and restarting </li><li>  It consumes few resources of the router: blocked subnets are contained in iptables, and not in the routing tables.  That allows you to deploy this business even on weak devices </li><li>  Automating configuration with Ansible (does not require python on the router) </li></ul><a name="habracut"></a><br><h2 id="videoversiya">  Video version </h2><br><iframe width="560" height="315" src="https://www.youtube.com/embed/GMvEF0PXN-w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="pochemu-openwrt-i-wireguard">  Why OpenWrt and WireGuard? </h2><br><p>  OpenWrt is put on so many models of soho routers, configured and expanded as your heart desires.  Now many router firmwares are add-ins over OpenWrt. </p><br><p>  Wireguard is used because of its quick and easy setup, and also because of the high transmission speed through the tunnel. </p><br><h2 id="nemnogo-o-wireguard">  A bit about WireGuard </h2><br><p>  In our case, the server is VPS outside the RKN, the client is the OpenWrt router at home.  When you want to go to <del>  pornolab </del>  telegram, your router will send traffic through the server with WireGuard. <br>  WireGuard raises the site-to-site connection, i.e.  Both the server and the client have a server and a client part of the configuration.  If it is not clear, it will become clear when you see the configuration. </p><br><p>  The server and the client have their own private and public keys. </p><br><h2 id="nastroyka-wireguard-na-servere">  Configuring WireGuard on the server </h2><br><p>  I do everything on Ubuntu 18.04, but the official documentation has <a href="https://www.wireguard.com/install/" title="installation instructions">installation instructions</a> for all known and not very OS. </p><br><h3 id="ustanovka">  Installation </h3><br><pre><code class="bash hljs">sudo add-apt-repository ppa:wireguard/wireguard</code> </pre> <br><blockquote>  When an error occurs <br><pre> <code class="bash hljs">sudo: add-apt-repository: <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> not found</code> </pre> <br><br>  Install software-properties-common - the package provides the ability to add and remove PPA <br><pre> <code class="bash hljs">sudo apt install software-properties-common</code> </pre> <br></blockquote><br><pre> <code class="bash hljs">sudo apt update sudo apt install wireguard-dkms wireguard-tools</code> </pre> <br><p>  We generate keys for the server.  Keys will be saved in the WireGuard directory for convenience </p><br><pre> <code class="plaintext hljs">cd /etc/wireguard/ wg genkey | tee privatekey-server | wg pubkey &gt; publickey-server</code> </pre> <br><p>  Accordingly, in the file privatekey-server will be a private key, and in publickey-server - public. <br>  We will also generate the key for the client right away: </p><br><pre> <code class="plaintext hljs">wg genkey | tee privatekey-client | wg pubkey &gt; publickey-client</code> </pre> <br><p><img src="https://habrastorage.org/webt/k4/xo/m5/k4xom503xmvyxdhjsvelqhaslxo.png"></p><br><h3 id="konfiguraciya">  Configuration </h3><br><p>  The config is stored in /etc/wireguard/wg0.conf.  The server part looks like this: </p><br><pre> <code class="bash hljs">[Interface] Address = 192.168.100.1 PrivateKey = privatekey-server ListenPort = 51820 PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o ens3 -j MASQUERADE PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o ens3 -j MASQUERADE</code> </pre> <br><p>  <strong>Address</strong> - address for the wg interface (address inside the tunnel) <br>  <strong>PrivateKey</strong> - Private key (privatekey-server) <br>  <strong>ListenPort</strong> - The port on which the service is waiting for a connection. </p><br><p>  Well, we do masquerading, because we will use this server to access the Internet <br>  Please note that the interface name in your case may differ: </p><br><p>  Client part </p><br><pre> <code class="bash hljs">[Peer] PublicKey = publickey-client AllowedIPs = 192.168.100.3/24</code> </pre> <br><p>  <strong>PublicKey</strong> - public key of our router (publickey-client) <br>  <strong>AllowedIPs</strong> are the subnets that will be accessible through this tunnel.  The server only needs access to the client's address. </p><br><p>  Both parts are stored in the same config. </p><br><p>  Enable autorun on reboot: </p><br><pre> <code class="bash hljs">systemctl <span class="hljs-built_in"><span class="hljs-built_in">enable</span></span> wg-quick@wg0</code> </pre> <br><p>  Making the server a router: </p><br><pre> <code class="bash hljs">sysctl -w net.ipv4.ip_forward=1</code> </pre> <br><p>  Set up a firewall.  Suppose that we only have WireGuard and ssh on the server: </p><br><pre> <code class="bash hljs">sudo iptables -A INPUT -i lo -j ACCEPT sudo iptables -A INPUT -p udp -m udp --dport 51820 -j ACCEPT sudo iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT sudo iptables -A INPUT -p icmp -j ACCEPT sudo iptables -A INPUT -p tcp -m tcp --dport 22 -j ACCEPT sudo iptables -A INPUT -j DROP</code> </pre> <br><p>  Save the iptables configuration: </p><br><pre> <code class="bash hljs">sudo apt-get install iptables-persistent sudo netfilter-persistent save</code> </pre> <br><p>  Raise the wg interface for the first time manually: </p><br><pre> <code class="bash hljs">wg-quick up wg0</code> </pre> <br><p><img src="https://habrastorage.org/webt/1_/me/ai/1_meai1la87gto2qfa7vwmcfmju.png"></p><br><p>  WireGuard server is ready. </p><br><h2 id="nastroyka-routera">  Configure the router </h2><br><p>  I am using OpenWrt version 18.06.1 on Xiaomi mi 3G and Asus RT-N16. </p><br><h3 id="logika-raboty-routera">  The logic of the router </h3><br><p>  We load lists, we place them in iptables, all addresses from these lists iptables marks with a 0x1 marker.  Further, all packets marked 0x1 go to a separate routing table, all packets that fall into this routing table go through the wg interface. </p><br><p><img src="https://habrastorage.org/webt/vy/rc/ji/vyrcjihaaozo-vzf1nkm9nlxpl0.gif"></p><br><h3 id="ustanovka-paketov">  Package installation </h3><br><p>  As for the space occupied by the flush, everything will need approximately 0.9MB.  If you have a very bad place, replace curl with a wget and you can not install dnscrypt-proxy. </p><br><p>  Put the packages.  In OpenWrt, this is simply done through the package manager opkg: </p><br><pre> <code class="bash hljs">opkg update opkg install ipset wireguard curl</code> </pre> <br><h3 id="zagruzka-spiskov">  Download lists </h3><br><p>  Everything that can be done through the standard features of OpenWrt is done through them.  Everything else (except hotplug) I put in a small script: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh dir=/tmp/lst mkdir -p $dir echo "Run download lists" curl -z $dir/subnet.lst https://antifilter.download/list/subnet.lst --output $dir/subnet.lst curl -z $dir/ipsum.lst https://antifilter.download/list/ipsum.lst --output $dir/ipsum.lst echo "Firewall restart" /etc/init.d/firewall restart</span></span></code> </pre> <br><p>  Lists of prohibited subnets and addresses are received by files.  For them we create a directory in / tmp.  In / tmp - because it is RAM, such a feature of OpenWrt is quite convenient.  On ROM of a router it is not worth writing something once again. </p><br><p>  We download lists with antifilter.download with curl, the z flag means that curl will download the file only if the remote file is different from the local one or if it does not exist, as is the case when loading the router. </p><br><p>  <em>subnet.lst</em> - list of blocked subnets, does not change often. <br>  <em>ipsum.lst</em> - list of blocked addresses, which is summed up by mask.  Instead of 150 thousand records we get 15 thousand - conveniently. </p><br><p>  After we have the files - we restart the firewall, this is necessary in order for ipset to work and add lists to iptables, we will have ipset configured in / etc / config / firewall. </p><br><p>  We add this script to /etc/init.d/ and we call it hirkn.  Let's make it executable </p><br><pre> <code class="bash hljs">chmod +x /etc/init.d/hirkn</code> </pre> <br><p>  Now we have not just a script, but a whole service.  In order to run it at boot, we make a symlink in /etc/rc.d.  We need it to start after all other services, so we make the <a href="https://openwrt.org/docs/techref/initscripts" title="prefix S99">prefix S99</a> </p><br><pre> <code class="bash hljs">ln -s /etc/init.d/hirkn /etc/rc.d/S99hirkn</code> </pre> <br><p>  Lists need to be updated from time to time, we add an entry to cron: </p><br><pre> <code class="bash hljs">crontab -e</code> </pre> <br><pre> <code class="bash hljs">0 4 * * * /etc/init.d/hirkn</code> </pre> <br><p>  It seems to me quite sufficient to update them once a day.  Keep in mind that when adding lists to ipset, the network falls off, in my case it is 2 seconds. </p><br><p>  Also enable kroner, by default it is disabled: </p><br><pre> <code class="bash hljs">/etc/init.d/cron <span class="hljs-built_in"><span class="hljs-built_in">enable</span></span> /etc/init.d/cron start</code> </pre> <br><h3 id="konfiguraciya-tablicy-marshrutizacii">  Routing Table Configuration </h3><br><p>  Create a routing table for traffic through the tunnel by simply adding a line: </p><br><pre> <code class="bash hljs">99 vpn</code> </pre> <br><p>  in the / etc / iproute2 / rt_tables file. </p><br><p>  To create the default route for the "vpn" table via the wg interface, use the command: </p><br><pre> <code class="bash hljs">ip route add table vpn default dev wg0</code> </pre> <br><p>  But when restarting the network, the route will disappear, so we create a 30-rknroute file in the /etc/hotplug.d/iface/ directory with simple contents: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh ip route add table vpn default dev wg0</span></span></code> </pre> <br><p>  This means that when you turn on / off interfaces, our route will be added.  And accordingly, this route will always be registered. </p><br><h3 id="konfiguraciya-seti">  Network configuration </h3><br><p>  We need to configure WireGuard and the rule for packets labeled 0x1. </p><br><p>  The WireGuard configuration is located in / etc / config / network </p><br><p>  "Server" part: </p><br><pre> <code class="bash hljs">config interface <span class="hljs-string"><span class="hljs-string">'wg0'</span></span> option private_key <span class="hljs-string"><span class="hljs-string">'privatekey-client'</span></span> list addresses <span class="hljs-string"><span class="hljs-string">'192.168.100.3/24'</span></span> option listen_port <span class="hljs-string"><span class="hljs-string">'51820'</span></span> option proto <span class="hljs-string"><span class="hljs-string">'wireguard'</span></span></code> </pre> <br><p>  <strong>private_key</strong> is the privatekey-client that we generated when setting up the server <br>  <strong>list addresses</strong> - the address of the wg interface <br>  <strong>listen_port</strong> is the port on which WireGuard accepts connections.  But the connection will occur through the port on the server, so here we will not open a port for it on the firewall <br>  <strong>proto</strong> - we specify the protocol that openwrt would understand that this is a WireGuard configuration </p><br><p>  "Client" part: </p><br><pre> <code class="bash hljs">config wireguard_wg0 option public_key <span class="hljs-string"><span class="hljs-string">'publickey-server'</span></span> option allowed_ips <span class="hljs-string"><span class="hljs-string">'0.0.0.0/0'</span></span> option route_allowed_ips <span class="hljs-string"><span class="hljs-string">'0'</span></span> option endpoint_host <span class="hljs-string"><span class="hljs-string">'wg-server-ip'</span></span> option persistent_keepalive <span class="hljs-string"><span class="hljs-string">'25'</span></span> option endpoint_port <span class="hljs-string"><span class="hljs-string">'51820'</span></span></code> </pre> <br><p>  <strong>public_key</strong> - publickey-server key <br>  <strong>allowed_ips</strong> are subnets where traffic can go through the tunnel, in our case no restrictions are required, therefore 0.0.0.0/0 <br>  <strong>route_allowed_ips</strong> is a flag that makes routing through the wg interface for the listed networks from the allowed_ips parameter.  In our case, this is not necessary, this work is done by iptables. <br>  <strong>endpoint_host</strong> - ip / url of our wg server <br>  <strong>persistent_keepalive</strong> - the time interval through which packets are sent to support the connection <br>  <strong>endpoint_port</strong> - server wireguard port </p><br><p>  In the network configuration, add a rule that will send all traffic marked 0x1 to the routing table "vpn": </p><br><pre> <code class="bash hljs">config rule option priority <span class="hljs-string"><span class="hljs-string">'100'</span></span> option lookup <span class="hljs-string"><span class="hljs-string">'vpn'</span></span> option mark <span class="hljs-string"><span class="hljs-string">'0x1'</span></span></code> </pre> <br><h3 id="konfiguraciya-firewall">  Firewall configuration </h3><br><p>  Add two rules for marking packages, they do not fit into the UCI openwrt syntax, so we add them "as is" in /etc/firewall.user. </p><br><pre> <code class="bash hljs">iptables -t mangle -A PREROUTING -i br-lan -m <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> --match-set vpn_subnets dst -j MARK --<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-xmark 0x1 iptables -t mangle -A PREROUTING -i br-lan -m <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> --match-set vpn_ipsum dst -j MARK --<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-xmark 0x1</code> </pre> <br><p>  These rules imply that all packets going to the subnets from the vpn_subnets and vpn_ipsum lists should be marked with a 0x1 marker. </p><br><p>  Go directly to the firewall configuration in / etc / config / firewall. </p><br><p>  Add a zone for wireguard.  In openwrt, zones are custom chains in iptables.  Thus, a zone with one / several interfaces is created and the rules are already being hung on it.  The wg zone looks like this for example: </p><br><pre> <code class="bash hljs">config zone option name <span class="hljs-string"><span class="hljs-string">'wg'</span></span> option family <span class="hljs-string"><span class="hljs-string">'ipv4'</span></span> option masq <span class="hljs-string"><span class="hljs-string">'1'</span></span> option output <span class="hljs-string"><span class="hljs-string">'ACCEPT'</span></span> option forward <span class="hljs-string"><span class="hljs-string">'REJECT'</span></span> option input <span class="hljs-string"><span class="hljs-string">'REJECT'</span></span> option mtu_fix <span class="hljs-string"><span class="hljs-string">'1'</span></span> option network <span class="hljs-string"><span class="hljs-string">'wg0'</span></span></code> </pre> <br><p>  We allow only the output of traffic from the interface and enable masquerading. </p><br><p>  Now you need to allow forwarding from the lan zone to the wg zone: </p><br><pre> <code class="bash hljs">config forwarding option src <span class="hljs-string"><span class="hljs-string">'lan'</span></span> option dest <span class="hljs-string"><span class="hljs-string">'wg'</span></span></code> </pre> <br><p>  And finally - the formation of lists in iptables using ipset: </p><br><pre> <code class="bash hljs">config ipset option name <span class="hljs-string"><span class="hljs-string">'vpn_subnets'</span></span> option storage <span class="hljs-string"><span class="hljs-string">'hash'</span></span> option loadfile <span class="hljs-string"><span class="hljs-string">'/tmp/lst/subnet.lst'</span></span> option match <span class="hljs-string"><span class="hljs-string">'src_net'</span></span> config ipset option name <span class="hljs-string"><span class="hljs-string">'vpn_ipsum'</span></span> option storage <span class="hljs-string"><span class="hljs-string">'hash'</span></span> option loadfile <span class="hljs-string"><span class="hljs-string">'/tmp/lst/ipsum.lst'</span></span> option match <span class="hljs-string"><span class="hljs-string">'src_net'</span></span></code> </pre> <br><p>  <strong>loadfile</strong> - the file from which we take the list <br>  <strong>name</strong> - the name for our list <br>  <strong>storage</strong> , <strong>match</strong> - here we specify how to store and what type of data.  We will keep the type "subnet" </p><br><p>  After this we restart the network: </p><br><pre> <code class="bash hljs">/etc/init.d/network restart</code> </pre> <br><p><img src="https://habrastorage.org/webt/e6/pm/m6/e6pmm6etqcw0dbz-c3ddqmzqemo.png"></p><br><p>  and run the script: </p><br><pre> <code class="bash hljs">/etc/init.d/hirkn</code> </pre> <br><p><img src="https://habrastorage.org/webt/e4/q-/6r/e4q-6rktvq2y8znvhmtpxfdsnwi.gif"></p><br><p>  After working out the script you should earn everything.  Check the route on the router client: </p><br><pre> <code class="bash hljs">mtr/traceroute telegram.org/linkedin.com</code> </pre> <br><p><img src="https://habrastorage.org/webt/wp/6e/jp/wp6ejpwtfwu9xkk-iizc8qj_aeu.gif"></p><br><h2 id="bonusom-nastroim-dnscrypt">  Bonus configure DNSCrypt </h2><br><p>  What for?  Your provider can carefully replace the ip-address of the blocked resource, thus redirecting you to your ip with a stub, well, and our ip walk will not help in this case.  For substitution it is not always even necessary to use the dns server of the provider, your requests can be intercepted and the answers replaced.  Well, by the way, not only the provider can do this. </p><br><pre> <code class="bash hljs">opkg install dnscrpt-proxy</code> </pre> <br><p>  Configuring the config / etc / config / dnscrypt-proxy like this: </p><br><pre> <code class="bash hljs">config dnscrypt-proxy ns1 option address <span class="hljs-string"><span class="hljs-string">'127.0.0.1'</span></span> option port <span class="hljs-string"><span class="hljs-string">'5353'</span></span> option resolver <span class="hljs-string"><span class="hljs-string">'cpunks-ru'</span></span></code> </pre> <br><p>  Thus, we have the dnscrypt service on port 5353 available on localhost. </p><br><p>  <strong>Resolver</strong> is dns, a server that supports encryption.  On the router, the file /usr/share/dnscrypt-proxy/dnscrypt-resolvers.csv contains a list of servers available at the time of the release of the installed version of dnscrypt.  And here <a href="https://dnscrypt.info/public-servers/">https://dnscrypt.info/public-servers/,</a> in general, all available dnscrypt servers.  You can choose a different resolver and / or add servers for fault tolerance.  Keep in mind that in order for DNSCrypt to work with the selected resolver, it must be listed in dnscrypt-resolvers.csv. </p><br><p>  We configure dnsmasq to work with dnscrypt.  In / etc / config / dhcp we comment the line: </p><br><pre> <code class="bash hljs">option resolvfile <span class="hljs-string"><span class="hljs-string">'/tmp/resolv.conf.auto'</span></span></code> </pre> <br><p>  so that dns servers of the provider would not be involved. </p><br><p>  And add: </p><br><pre> <code class="bash hljs"> option noresolv <span class="hljs-string"><span class="hljs-string">'1'</span></span> list server <span class="hljs-string"><span class="hljs-string">'/pool.ntp.org/208.67.222.222'</span></span> list server <span class="hljs-string"><span class="hljs-string">'/antifilter.download/208.67.222.222'</span></span> list server <span class="hljs-string"><span class="hljs-string">'127.0.0.1#5353'</span></span></code> </pre> <br><p>  <strong>noresolv '1'</strong> disables the processing of the /etc/resolv.conf file </p><br><p>  The <strong>list server 'domain / ip_dns' entry</strong> indicates which dns server to use for resolving the specified domain.  Thus, we do not use dnscrypt to synchronize ntp - it is important to have the current time to work with the dnscrypt service. </p><br><p>  When loading the router, the hirkn script runs faster than dnscrypt starts, so the antifilter.download domain is not resolved and the lists are not downloaded.  You can make a delay or something else to come up with, but so far I see no point. </p><br><p>  As a result, we get the following insert in the config: </p><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#option resolvfile '/tmp/resolv.conf.auto' option noresolv '1' list server '/pool.ntp.org/208.67.222.222' list server '/antifilter.download/208.67.222.222' list server '127.0.0.1#5353'</span></span></code> </pre> <br><p>  Add to autoload and start dnscrypt: </p><br><pre> <code class="bash hljs">/etc/init.d/dnscrypt-proxy <span class="hljs-built_in"><span class="hljs-built_in">enable</span></span> /etc/init.d/dnscrypt-proxy start</code> </pre> <br><p>  Restart dnsmasq: </p><br><pre> <code class="bash hljs">/etc/init.d/dnsmasq restart</code> </pre> <br><p><img src="https://habrastorage.org/webt/i2/b5/90/i2b590nxr6-lqnk1h2-tq-i6t-4.gif"><br>  <em>Illustration of operation without DNSCrypt and with DNSCrypt</em> </p><br><h2 id="avtomaticheski-razvertyvaem-s-pomoschyu-ansible">  Automatically deploy with Ansible </h2><br><p>  Playbook and templates are on <a href="https://github.com/itdoginfo/ansible-openwrt-hirkn" title="github">github</a> .  The <a href="https://github.com/gekmihesg/ansible-openwrt">module is</a> used, it does not need python on the router and there is support for uci.  I tried to make sure that your OpenWrt configuration is left untouched, but still be vigilant. </p><br><p>  Install the gekmihesg / ansible-openwrt module: </p><br><pre> <code class="bash hljs">ansible-galaxy install gekmihesg.openwrt</code> </pre> <br><p>  Copy the playbook and the templates: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> /etc/ansible git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/itdoginfo/ansible-openwrt-hirkn mv ansible-openwrt-hirkn/* . rm -rf ansible-openwrt-hirkn</code> </pre> <br><p>  Add your router to the hosts: </p><br><pre> <code class="bash hljs">[openwrt] 192.168.1.1</code> </pre> <br><p>  Substitute your variables in hirkn.yml: </p><br><pre> <code class="bash hljs"> vars: ansible_template_dir: /etc/ansible/templates/ wg_server_address: wg_server_ip/url wg_private_key: privatekey-client wg_public_key: publickey-server wg_listen_port: 51820 wg_client_port: 51820 wg_client_address: 192.168.100.3/24</code> </pre> <br><p>  Be sure to set: </p><br><p>  <strong>wg_server_address</strong> - ip / url wireguard server <br>  <strong>wg_private_key</strong> , <strong>wg_public_key</strong> - client's private key and public server <br>  The rest can be not changed or changed, depending on how the WireGuard server is configured </p><br><p>  Run the playbook </p><br><pre> <code class="bash hljs">ansible-playbook playbooks/hirkn.yml</code> </pre> <br><p>  After the playbook is executed, the router will immediately begin to bypass the locks through your wireguard server. </p><br><h2 id="pochemu-ne-bgp">  Why not bgp? </h2><br><p>  Under openwrt there are two utilities implementing BGP - quagga and bird.  I could not get Quagg to get data from an antifilter.  Bird made friends with the service with half a pint, but unfortunately I didn‚Äôt understand how to make the default subnets add the default interface.  (I will be glad to know how this can be implemented). </p><br><p>  In the comments to similar articles, I saw that the routers of people "thought about" for a while, when they pushed the lists into the routing table.  With the implementation through ipset, my Xiaomi mi 3G thinks for 2 seconds (Asus rt-n16 for 5 seconds) when you feed him a list of 15 thousand subnets.  With further work, the load on the processor did not notice. </p><br><p>  <em>All materials are not a call to action and are presented for familiarization with the functionality of Linux OS.</em> </p></div><p>Source: <a href="https://habr.com/ru/post/440030/">https://habr.com/ru/post/440030/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>