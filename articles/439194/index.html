<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Controlling a character with SharedEvents</title>
  <meta name="description" content="Link to the project 

 In this article I want to show how you can use SharedEvents to control a third-person character that offers a standard set of a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Controlling a character with SharedEvents</h1><div class="post__text post__text-html js-mediator-article"><iframe width="560" height="315" src="https://www.youtube.com/embed/v3lTKkwBDyE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <a href="https://github.com/yunkadev/sharedstateexample">Link to the project</a> <br><br>  In this article I want to show how you can use <b>SharedEvents</b> to control a third-person character that offers a standard set of assets.  I wrote about <b>SharedEvents</b> in previous articles ( <a href="https://habr.com/ru/post/438554/">this one</a> and <a href="https://habr.com/ru/post/438628/">this one</a> ). <br><br>  Welcome under the cut! <br><a name="habracut"></a><br>  The first thing you need is to take a project with implemented SharedState / SharedEvents and add a standard set of assets <br><br><img src="https://habrastorage.org/webt/3e/6p/if/3e6pifqmbgtgupypezxrm6lqr08.jpeg"><br><br>  I created a small and very simple scene from prototyping prefabs. <br><br><img src="https://habrastorage.org/webt/i2/gt/zu/i2gtzu4zyhrlbjdg5qahs3wti18.jpeg"><br><br>  And baked the navigation on the surface with standard settings <br><br><img src="https://habrastorage.org/webt/tl/ci/if/tlciif79oujqrvkaln_tsajxjgo.jpeg"><br><br>  After that you need to add the ThirdPersonCharacter <b>prefab</b> to this scene. <br><br><img src="https://habrastorage.org/webt/ut/vj/uo/utvjuofiddf4gcrwnf4rr-cfpvs.jpeg"><br><br>  Then you can run and make sure that everything works out of the box.  Then you can proceed to the settings of using the previously created infrastructure <b>SharedState / SharedEvents</b> .  To do this, remove the <b>ThirdPersonUserController</b> component from the character object. <br><br><img src="https://habrastorage.org/webt/8f/gy/hu/8fgyhuqj2hafnuwss-mqebno_jw.jpeg"><br><br>  since manual control using the keyboard is not needed.  The character will be controlled by agents, indicating the position where he will move. <br><br>  And to make this possible, you need to add and configure the <b>NavMeshAgent</b> component on the character object. <br><br><img src="https://habrastorage.org/webt/sf/yq/qs/sfyqqsgrktyfnqwobzc_nkqtuxw.jpeg"><br><br>  Now you need to create a simple controller that will control the character. <br>  with mouse <b>AgentMouseController</b> <br><br><img src="https://habrastorage.org/webt/p0/xf/nd/p0xfndfiw52su5yd7pu5mnkhlae.jpeg"><br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.AI; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityStandardAssets.Characters.ThirdPerson; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AgentMouseController</span></span></span><span class="hljs-class"> :</span></span> MonoBehaviour { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NavMeshAgent agent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ThirdPersonCharacter character; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Camera cam; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//–í—Ä–∞—â–µ–Ω–∏–µ –ø–µ—Ä—Å–∞ –±—É–¥–µ—Ç –æ—Å—É—â–µ—Å—Ç–≤–ª—è—Ç—å—Å—è —á–µ—Ä–µ–∑ –∞–Ω–∏–º–∞—Ü–∏—é agent.updateRotation = false; } void Update() { //–ü–æ–ª—É—á–∞–µ–º –ø–æ–∑–∏—Ü–∏—é –∫–ª–∏–∫–∞ –Ω–∞ –∫–∞—Ä—Ç–µ if (Input.GetMouseButtonDown(0)) { Ray ray = cam.ScreenPointToRay(Input.mousePosition); RaycastHit hit; if (Physics.Raycast(ray, out hit)) { agent.SetDestination(hit.point); } } //–ï—Å–ª–∏ –∞–≥–µ–Ω—Ç –µ—â–µ –Ω–µ –¥–æ–±–µ–∂–∞–ª, —Ç–æ –æ–±–Ω–æ–≤–ª—è–µ–º –ø–µ—Ä—Å—É –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ if(agent.remainingDistance &gt; agent.stoppingDistance) { character.Move(agent.desiredVelocity, false, false); } else //–ï—Å–ª–∏ –¥–æ–±–µ–∂–∞–ª, —Ç–æ —Å—Ç–æ–ø–∞–µ–º –µ–≥–æ { character.Move(Vector3.zero, false, false); } } }</span></span></code> </pre> <br>  And add it to the object of the character, give him links to the camera, controller of the character and agent.  It's all available from the stage. <br><br><img src="https://habrastorage.org/webt/6i/_a/p3/6i_ap3pgbgxkvkl9h4pl0c4mbzi.jpeg"><br><br>  And that's all.  This is enough to control the character by telling the agent where to go, using the mouse (click the left button). <br><br>  You can run and make sure everything works. <br><br><img src="https://habrastorage.org/webt/3n/n_/g-/3nn_g-peo8ivng5gop0l5-75dta.jpeg"><br><br><h2>  Integration with SharedEvents </h2><br>  Now that the base scene is ready, you can proceed to the integration of character management through <b>SharedEvents</b> .  To do this, you will need to create several components.  The first of these is the component that will be responsible for receiving the signal from the mouse and notifying all the components that track the mouse click position on the scene; they will only be interested in click coordinates. <br><br>  The component will be named, for example, <b>MouseHandlerComponent.</b> <br><br><img src="https://habrastorage.org/webt/ib/yk/v4/ibykv4n3mal6i1lfatsrjyto-ha.jpeg"><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MouseHandlerComponent</span></span></span><span class="hljs-class"> :</span></span> SharedStateComponent { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Camera cam; <span class="hljs-meta"><span class="hljs-meta">#region MonoBehaviour protected override void OnSharedStateChanged(SharedStateChangedEventData newState) { } protected override void OnStart() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (cam == null) throw new MissingReferenceException(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"–û–±—ä–µ–∫—Ç –∫–∞–º–µ—Ä—ã –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω"</span></span></span><span class="hljs-meta">); } protected override void OnUpdate() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–ª–∏–∫ –ª–µ–≤–æ–π –∫–Ω–æ–ø–∫–∏ –º—ã—à–∏ if (Input.GetMouseButtonDown(0)) { //–ë–µ—Ä–µ–º —Ç–æ—á–∫—É –ø–æ –∫–æ—Ç–æ—Ä–æ–π –∏–≥—Ä–æ–∫ –Ω–∞–∂–∞–ª –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤—Å–µ–º –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ var hit = GetMouseHit(); Events.PublishAsync("poittogound", new PointOnGroundEventData { Sender = this, Point = hit.point }); } } #endregion private RaycastHit GetMouseHit() { Ray ray = cam.ScreenPointToRay(Input.mousePosition); RaycastHit hit; Physics.Raycast(ray, out hit); return hit; } }</span></span></span></span></code> </pre><br>  This component needs a class to send data in notifications.  For such classes, which will contain only data for notifications, you can create one file and name it <b>DefinedEventsData</b> <br><br><img src="https://habrastorage.org/webt/5y/bp/ar/5ybparw0g4vguy5tkbyttntdodm.jpeg"><br><br>  And add one class to it to send the mouse click position. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PointOnGroundEventData</span></span></span><span class="hljs-class"> :</span></span> EventData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 Point { get; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } }</code> </pre><br>  The next thing you need to do is add a component, which will be a wrapper or a decorator, whatever you like, for the <b>NavMeshAgent</b> component.  Since I will not change the existing (3th party) components, I will use decorators to integrate with <b>SharedState / SharedEvents</b> . <br><br><img src="https://habrastorage.org/webt/yi/1k/v5/yi1kv5s0ytqgy7folh3tygjmtky.jpeg"><br><br>  This component will receive notifications about mouse clicks at certain points on the scene and tell the agent where to go.  And also monitor the position of the agent's position in each frame and create a notification about its change. <br><br>  This component will depend on the <b>NavMeshAgent</b> component <b>.</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.AI; [RequireComponent(typeof(NavMeshAgent))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AgentWrapperComponent</span></span></span><span class="hljs-class"> :</span></span> SharedStateComponent { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NavMeshAgent agent; <span class="hljs-meta"><span class="hljs-meta">#region Monobehaviour protected override void OnSharedStateChanged(SharedStateChangedEventData newState) { } protected override void OnStart() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//–ü–æ–ª—É—á–∞–µ–º –∞–≥–µ–Ω—Ç–∞ agent = GetComponent&lt;NavMeshAgent&gt;(); //–í—Ä–∞—â–µ–Ω–∏–µ –ø–µ—Ä—Å–∞ –±—É–¥–µ—Ç –æ—Å—É—â–µ—Å—Ç–≤–ª—è—Ç—å—Å—è —á–µ—Ä–µ–∑ –∞–Ω–∏–º–∞—Ü–∏—é agent.updateRotation = false; Events.Subscribe&lt;PointOnGroundEventData&gt;("pointtoground", OnPointToGroundGot); } protected override void OnUpdate() { //–ü–µ—Ä–µ–¥–∞—á–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø–æ –ø–æ–∑–∏—Ü–∏–∏ –∞–≥–µ–Ω—Ç–∞ if (agent.remainingDistance &gt; agent.stoppingDistance) { Events.Publish("agentmoved", new AgentMoveEventData { Sender = this, DesiredVelocity = agent.desiredVelocity }); } else { Events.Publish("agentmoved", new AgentMoveEventData { Sender = this, DesiredVelocity = Vector3.zero }); } } #endregion private void OnPointToGroundGot(PointOnGroundEventData eventData) { //–ù–∞–∑–Ω–∞—á–∞–µ–º –∞–≥–µ–Ω—Ç—É –Ω–æ–≤—É—é –ø–æ–∑–∏—Ü–∏—é agent.SetDestination(eventData.Point); } }</span></span></span></span></code> </pre> <br><br>  This component requires data to be sent to the <b>DefinedEventsData</b> file <b>.</b> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AgentMoveEventData</span></span></span><span class="hljs-class"> :</span></span> EventData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 DesiredVelocity { get; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } }</code> </pre> <br>  This is enough for the character to move.  But he will do it without animation, since we do not use the <b>ThirdPersonCharater</b> yet.  And for it as well as for <b>NavMeshAgent,</b> you need to create a CharacterWrapperComponent decorator <br><br><img src="https://habrastorage.org/webt/j1/zz/h_/j1zzh_hp8qcyklhx3zeldtjrsn4.jpeg"><br><br>  The component will listen for notifications about a change in the position of the agent, and move the character in the direction received from the notification (event). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityStandardAssets.Characters.ThirdPerson; [RequireComponent(typeof(ThirdPersonCharacter))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CharacterWrapperComponent</span></span></span><span class="hljs-class"> :</span></span> SharedStateComponent { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ThirdPersonCharacter character; <span class="hljs-meta"><span class="hljs-meta">#region Monobehaviour protected override void OnSharedStateChanged(SharedStateChangedEventData newState) { } protected override void OnStart() { character = GetComponent</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ThirdPersonCharacter&gt;(); Events.Subscribe&lt;AgentMoveEventData&gt;("agentmoved", OnAgentMove); } protected override void OnUpdate() { } #endregion private void OnAgentMove(AgentMoveEventData eventData) { //–î–≤–∏–≥–∞–µ—Ç –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ –≤ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ –∏ –∑–∞–ø—É—Å–∫–∞–µ—Ç –∞–Ω–∏–º–∞—Ü–∏–∏ character.Move(eventData.DesiredVelocity, false, false); } }</span></span></span></span></code> </pre> <br>  And it's all.  It remains to add these components to the game object of the character.  You need to create a copy from the existing one, delete the old component <b>AgentMouseControl</b> <br><br><img src="https://habrastorage.org/webt/az/_c/yk/az_cyk_etfyxuabjqhrbjiqxsoy.jpeg"><br><br>  And add new <b>MouseHandlerComponent</b> , <b>AgentWrapperComponent</b> and <b>CharacterWrapperComponent</b> . <br><br>  In <b>MouseHandlerComponent,</b> you need to transfer the camera from the scene, from which the position of the click will be calculated. <br><br><img src="https://habrastorage.org/webt/wv/fa/lm/wvfalm5obqvcach5uvnazlsuggu.jpeg"><br><br><img src="https://habrastorage.org/webt/vi/lq/b4/vilqb40pamgox4vbcmvogziuucw.jpeg"><br><br>  You can run and make sure everything works. <br><br>  It happened with the help of <b>SharedEvents</b> to control the character without having a direct connection between the components, as in the first example.  This will allow you to more flexibly configure different compositions of components and customize the interaction between them. <br><br><h2>  Asynchronous behavior for SharedEvents </h2><br>  The way the notification mechanism is now implemented is based on synchronous signal transmission and processing.  That is, the more listeners there are, the longer it will be processed.  In order to get away from this, you need to implement asynchronous processing of notifications.  The first thing to do is add an asynchronous version of the <b>Publish</b> method. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//–û—Ç–ø—Ä–∞–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö data –ø–æ–¥–ø–∏—Å—á–∏–∫–∞–º –Ω–∞ —Å–æ–±—ã—Ç–∏–µ eventName –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ public async Task PublishAsync&lt;T&gt;(string eventName, T data) where T : EventData { if (_subscribers.ContainsKey(eventName)) { var listOfDelegates = _subscribers[eventName]; var tasks = new List&lt;Task&gt;(); foreach (Action&lt;T&gt; callback in listOfDelegates) { tasks.Add(Task.Run(() =&gt; { callback(data); })); } await Task.WhenAll(tasks); } }</span></span></code> </pre> <br>  Now you need to change the <b>OnUpdate</b> abstract method in the <b>SharedStateComponent</b> base class to asynchronous, so that it returns the tasks that were initiated inside the implementation of this method and rename it to <b>OnUpdateAsync</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> abstract Task[] OnUpdateAsync();</code> </pre> <br>  You will also need a mechanism that will control the completion of tasks from the previous frame, prior to the start of the current <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Task[] _previosFrameTasks = null; <span class="hljs-comment"><span class="hljs-comment">//–ó–∞–≤–µ—Ä—à–∞–µ—Ç –ø—Ä–µ–¥—ã–¥—É—â–∏–µ –∑–∞–¥–∞—á–∏ private async Task CompletePreviousTasks() { if (_previosFrameTasks != null &amp;&amp; _previosFrameTasks.Length &gt; 0) await Task.WhenAll(_previosFrameTasks); }</span></span></code> </pre> <br>  The <b>Update</b> method in the base class should be marked as <b>async</b> and pre-checked the performance of previous tasks. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">async </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">await </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompletePreviousTasks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//–î–ª—è –≤—ã–∑–æ–≤–∞ –≤ –¥–æ—á–µ—Ä–Ω–∏—Ö –∫–ª–∞—Å—Å–∞—Ö _previosFrameTasks = OnUpdateAsync(); }</span></span></code> </pre> <br>  After these changes in the base class, you can proceed to change the implementation of the old <b>OnUpdate</b> method to the new <b>OnUpdateAsync</b> .  The first component where this will be done is <b>AgentWrapperComponent</b> .  Now this method is waiting for the return of the result.  This result will be an array of tasks.  An array because in the method several runs in parallel and we will process them in a bundle. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> override Task[] OnUpdateAsync() { <span class="hljs-comment"><span class="hljs-comment">//–ü–µ—Ä–µ–¥–∞—á–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø–æ –ø–æ–∑–∏—Ü–∏–∏ –∞–≥–µ–Ω—Ç–∞ if (agent.remainingDistance &gt; agent.stoppingDistance) { return new Task[] { Events.PublishAsync("agentmoved", new AgentMoveEventData { Sender = this, DesiredVelocity = agent.desiredVelocity }) }; } else { return new Task[] { Events.PublishAsync("agentmoved", new AgentMoveEventData { Sender = this, DesiredVelocity = Vector3.zero }) }; } }</span></span></code> </pre> <br>  The next candidate for changes to the <b>OnUpdate</b> method is <b>MouseHandlerController</b> .  Here the principle is the same <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> override Task[] OnUpdateAsync() { <span class="hljs-comment"><span class="hljs-comment">//–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–ª–∏–∫ –ª–µ–≤–æ–π –∫–Ω–æ–ø–∫–∏ –º—ã—à–∏ if (Input.GetMouseButtonDown(0)) { //–ë–µ—Ä–µ–º —Ç–æ—á–∫—É –ø–æ –∫–æ—Ç–æ—Ä–æ–π –∏–≥—Ä–æ–∫ –Ω–∞–∂–∞–ª –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤—Å–µ–º –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ var hit = GetMouseHit(); return new Task[] { Events.PublishAsync("pointtoground", new PointOnGroundEventData { Sender = this, Point = hit.point }) }; } return null; }</span></span></code> </pre><br>  In all other implementations where this method was empty, it is enough to replace with <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> override Task[] OnUpdateAsync() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; }</code> </pre> <br>  That's all.  Now you can run, and if the components that process notifications asynchronously do not access those components that should be processed in the main stream, such as Transform, for example, everything will work.  Otherwise, we will get errors in the console, indicating that we are accessing these components not from the main thread. <br><br><img src="https://habrastorage.org/webt/sp/hq/it/sphqitlfyw2zspaznnsu0tec3sy.jpeg"><br><br>  To solve this problem, you need to create a component that will process the code in the main thread.  Create a separate folder for the scripts and call it System, and add the <b>Dispatcher</b> script to it. <br><br><img src="https://habrastorage.org/webt/m2/gp/m2/m2gpm2tf3u8z6fn1ioov9brmhvu.jpeg"><br><br>  This component will be a singleton and have one public abstract method that will execute code in the main thread.  Dispatcher principle is quite simple.  We will hand him delegates who must be executed in the main thread; it will put them in a queue.  And in each frame, if something is in the queue, execute in the main thread.  This component will add itself to the stage in a single copy, I like this simple and effective approach. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Concurrent; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dispatcher</span></span></span><span class="hljs-class"> :</span></span> MonoBehaviour { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Dispatcher _instance; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _queued = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ConcurrentQueue&lt;Action&gt; _queue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentQueue&lt;Action&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly object _sync_ = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> object(); <span class="hljs-comment"><span class="hljs-comment">//–ó–∞–ø—É—Å–∫–∞–µ—Ç –¥–µ–ª–µ–≥–∞—Ç –≤ –≥–ª–∞–≤–Ω–æ–º –ø–æ—Ç–æ–∫–µ public static void RunOnMainThread(Action action) { _instance._queue.Enqueue(action); lock (_sync_) { _instance._queued = true; } } //–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç—Å—è –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π –∏–Ω—Å—Ç–∞–Ω—Å –∏ –ø–æ–º–µ—á–∞–µ—Ç—Å—è –∫–∞–∫ –Ω–µ—É–¥–∞–ª—è–µ–º—ã–π (—Å–∏–Ω–≥–ª—Ç–æ–Ω) [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)] private static void Initialize() { if (_instance == null) { _instance = new GameObject("Dispatcher").AddComponent&lt;Dispatcher&gt;(); DontDestroyOnLoad(_instance.gameObject); } } void Update() { if (_queued) //–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –æ—á–µ—Ä–µ–¥–∏ –¥–µ–ª–µ–≥–∞—Ç–æ–≤ { while (!_queue.IsEmpty) { if (_queue.TryDequeue(out Action a)) { StartCoroutine(ActionWrapper(a)); } } lock (_sync_) { _queued = false; } } } //–û–±–æ—Ä–∞—á–∏–≤–∞–µ—Ç –¥–µ–ª–µ–≥–∞—Ç –≤ —ç–Ω—É–º–µ—Ä–∞—Ç–æ—Ä IEnumerator ActionWrapper(Action a) { a(); yield return null; } }</span></span></code> </pre> <br>  The next thing to do is to apply the dispatcher.  There are 2 places where this needs to be done.  1st is the character decorator, where we give him direction.  In the <b>CharacterWrapperComponent</b> component <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnAgentMove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AgentMoveEventData eventData)</span></span></span><span class="hljs-function"> </span></span>{ Dispatcher.RunOnMainThread(() =&gt; character.Move(eventData.DesiredVelocity, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)); }</code> </pre> <br>  2nd is the agent decorator, where we specify the position for the agent.  In the <b>AgentWrapperComponent</b> component <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPointToGroundGot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PointOnGroundEventData eventData)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//–ù–∞–∑–Ω–∞—á–∞–µ–º –∞–≥–µ–Ω—Ç—É –Ω–æ–≤—É—é –ø–æ–∑–∏—Ü–∏—é Dispatcher.RunOnMainThread(() =&gt; agent.SetDestination(eventData.Point)); }</span></span></code> </pre> <br>  Now there will be no errors, the code will work correctly.  You can run and verify this. <br><br><h2>  Little refactoring </h2><br>  After everything is ready and everything works, you can brush the code a bit and make it a little more convenient and simple.  This will require several changes. <br><br>  In order not to create an array of tasks and place the only one in it manually, you can create an extension method.  For all extension methods, you can also use the same file as for all classes to pass to notifications.  It will be located in the <b>System</b> folder and called <b>Extensions.</b> <br><br><img src="https://habrastorage.org/webt/8z/nv/wx/8znvwxom9bvxipj5ctvuuasveky.jpeg"><br><br>  Inside we will create a simple generic extension method that will wrap any instance into an array <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Extensions</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//–û–±–æ—Ä–∞—á–∏–≤–∞–µ—Ç —ç–∫–∑–º–µ–ø–ª—è—Ä –≤ –º–∞—Å—Å–∏–≤ public static T[] WrapToArray&lt;T&gt;(this T source) { return new T[] { source }; } }</span></span></code> </pre> <br>  The next change is to hide the direct use of the dispatcher in the components.  Instead, create a method in the <b>SharedStateComponent</b> base class and use the dispatcher from there. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PerformInMainThread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Action action)</span></span></span><span class="hljs-function"> </span></span>{ Dispatcher.RunOnMainThread(action); }</code> </pre><br>  And now you need to apply these changes in several places.  First, change the methods, where we manually create arrays of tasks and add a single instance to them. <br>  In the <b>AgentWrapperComponent</b> component <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> override Task[] OnUpdateAsync() { <span class="hljs-comment"><span class="hljs-comment">//–ü–µ—Ä–µ–¥–∞—á–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø–æ –ø–æ–∑–∏—Ü–∏–∏ –∞–≥–µ–Ω—Ç–∞ if (agent.remainingDistance &gt; agent.stoppingDistance) { return Events.PublishAsync("agentmoved", new AgentMoveEventData { Sender = this, DesiredVelocity = agent.desiredVelocity }) .WrapToArray(); } else { return Events.PublishAsync("agentmoved", new AgentMoveEventData { Sender = this, DesiredVelocity = Vector3.zero }) .WrapToArray(); } }</span></span></code> </pre> <br>  And in the <b>MouseHandlerComponent</b> component <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> override Task[] OnUpdateAsync() { <span class="hljs-comment"><span class="hljs-comment">//–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–ª–∏–∫ –ª–µ–≤–æ–π –∫–Ω–æ–ø–∫–∏ –º—ã—à–∏ if (Input.GetMouseButtonDown(0)) { //–ë–µ—Ä–µ–º —Ç–æ—á–∫—É –ø–æ –∫–æ—Ç–æ—Ä–æ–π –∏–≥—Ä–æ–∫ –Ω–∞–∂–∞–ª –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤—Å–µ–º –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ var hit = GetMouseHit(); return Events.PublishAsync("pointtoground", new PointOnGroundEventData { Sender = this, Point = hit.point }) .WrapToArray(); } return null; }</span></span></code> </pre> <br>  Now we‚Äôll get rid of the direct use of the dispatcher in components and instead call the <b>PerformInMainThread</b> method in the base class. <br><br>  First in the <b>AgentWrapperComponent</b> component <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPointToGroundGot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PointOnGroundEventData eventData)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//–ù–∞–∑–Ω–∞—á–∞–µ–º –∞–≥–µ–Ω—Ç—É –Ω–æ–≤—É—é –ø–æ–∑–∏—Ü–∏—é PerformInMainThread(() =&gt; agent.SetDestination(eventData.Point)); }</span></span></code> </pre> <br>  and in the <b>CharacterWrapperComponent</b> component <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnAgentMove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AgentMoveEventData eventData)</span></span></span><span class="hljs-function"> </span></span>{ PerformInMainThread(() =&gt; character.Move(eventData.DesiredVelocity, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)); }</code> </pre> <br>  That's all.  It remains to start the game and make sure that during the refactoring nothing is broken and everything works correctly. </div><p>Source: <a href="https://habr.com/ru/post/439194/">https://habr.com/ru/post/439194/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>