<div class="post__text post__text-html js-mediator-article"><p>  Good day dear.  I would like to share my story and little life hacking. </p><br><p>  I think all office workers have a situation where after a tasty lunch they are very tense and want to take a nap.  In fact, daytime sleep is very useful both for the body and for work, as it has a very positive effect on productivity.  However, in my experience, more than 20 minutes is an obvious bust.  This is enough for the body to bring itself back to normal.  And after just a minute, during which you really want to continue to sleep, the body wakes up, you feel cheerfulness and a surge of strength. </p><br><p>  On the other hand, many prefer to drink a cup of coffee.  And although it seems that it helps, in fact, the body does not restore its resources, but only loses more.  Yes, and it is harmful. </p><a name="habracut"></a><br><p>  In general, it is clear what is at stake, right?  however, the question naturally arises how to do this in the office.  And the fact is that the majority of bosses do not approve of this.  And the sofa is not everywhere.  Yes, and you are unlikely to allow yourself to take a nap on it if you value your workplace. </p><br><p>  However, I was lucky, my chair can lean back very much, and I can generally look working, just thinking.  And all would be nothing if not one but. </p><br><p>  Absolutely static picture on the monitors gives me with giblets! </p><br><p>  I somehow shared this problem with a friend, and he jokingly offered to do a simulator of work. <br>  I really liked the idea, but to realize a full-fledged work simulator - what is that supposed to be?  could it work for me?  In general, it is clear that to create such a thing would be extremely difficult.  But you could simplify the task. </p><br><p>  By the nature of my work, I am a simple C ++ programmer, and therefore, I often crawl on the Internet and read various articles.  Without this in any way, everyone understands this. </p><br><p>  If you watch a person who reads a long and complex article, you will notice that he periodically scrolls the article up and down.  And this is what I decided to implement. <br>  After literally an hour of surfing the Internet, by combining the material of three articles (articles on a hidden application without a window, on intercepting keyboard events and articles on simulating mouse events), a simple program was implemented that I would like to share with people. </p><br><p>  The idea is simple at its core: random scrolling events on the mouse wheel.  That is, you simply choose an article that is more authentic and more complicated on the current task, turn on the simulator, and fall asleep calmly for yourself.  The program is not visible in the task manager (or Iâ€™m just blind and did not find it there), using the Ctrl + key combination pauses the space and resumes its execution, and when the down arrow is pressed, it closes.  You can see the program through the console, using the tasklist command, and if necessary, you can find out its PID so that you can close it via taskkill. </p><br><p>  I myself do not fully understand the program code, so there will be no comments. </p><br><p>  Actually, the code itself: </p><br><pre><code class="plaintext hljs">#define WIN32_LEAN_AND_MEAN #define _WIN32_WINNT 0x0500 #include &lt;stdio.h&gt; #include &lt;iostream&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #include &lt;conio.h&gt; #include &lt;string.h&gt; #include &lt;windows.h&gt; HHOOK hKeyboardHook; #define X 500 #define Y 500 #define SCREEN_WIDTH 1920 #define SCREEN_HEIGHT 1080 bool bQuit = false; bool bPause = false; __declspec(dllexport) LRESULT CALLBACK KeyboardEvent(int nCode, WPARAM wParam, LPARAM lParam) { DWORD SHIFT_key = 0; DWORD CTRL_key = 0; DWORD ALT_key = 0; if ((nCode == HC_ACTION) &amp;&amp; ((wParam == WM_SYSKEYDOWN) || (wParam == WM_KEYDOWN))) { KBDLLHOOKSTRUCT hooked_key = *((KBDLLHOOKSTRUCT*)lParam); DWORD dwMsg = 1; dwMsg += hooked_key.scanCode &lt;&lt; 16; dwMsg += hooked_key.flags &lt;&lt; 24; char lpszKeyName[1024] = { 0 }; int i = GetKeyNameText(dwMsg, (lpszKeyName + 1), 0xFF) + 1; int key = hooked_key.vkCode; SHIFT_key = GetAsyncKeyState(VK_SHIFT); CTRL_key = GetAsyncKeyState(VK_CONTROL); ALT_key = GetAsyncKeyState(VK_MENU); //printf("Keycode = %c\n", key); if (key == VK_DOWN) { bQuit = true; PostQuitMessage(0); } if (CTRL_key != 0 &amp;&amp; key == ' ') { bPause = !bPause; } //if (key &gt;= 'A' &amp;&amp; key &lt;= 'Z') //{ // if (GetAsyncKeyState(VK_SHIFT) &gt;= 0) key += 32; // /********************************************* // *** Hotkey scope *** // *** do stuff here *** // **********************************************/ // if (CTRL_key != 0 &amp;&amp; key == 'y') // { // MessageBox(NULL, "CTRL-y was pressed\nLaunch your app here", "HOTKE Y", MB_OK); // CTRL_key = 0; // //do stuff here // } // if (CTRL_key != 0 &amp;&amp; key == 'q') // { // MessageBox(NULL, "Shutting down", "HOTKE Y", MB_OK); // bQuit = true; // PostQuitMessage(0); // } // // SHIFT_key = 0; // CTRL_key = 0; // ALT_key = 0; //} } return CallNextHookEx(hKeyboardHook, nCode, wParam, lParam); } void MessageLoop() { MSG message; while (GetMessage(&amp;message, NULL, 0, 0)) { TranslateMessage(&amp;message); DispatchMessage(&amp;message); } } DWORD WINAPI my_HotKey(LPVOID lpParm) { HINSTANCE hInstance = GetModuleHandle(NULL); if (!hInstance) hInstance = LoadLibrary((LPCSTR)lpParm); if (!hInstance) return 1; hKeyboardHook = SetWindowsHookEx(WH_KEYBOARD_LL, (HOOKPROC)KeyboardEvent, hInstance, NULL); MessageLoop(); UnhookWindowsHookEx(hKeyboardHook); return 0; } void MouseSetup(INPUT *buffer) { buffer-&gt;type = INPUT_MOUSE; buffer-&gt;mi.dx = (0 * (0xFFFF / SCREEN_WIDTH)); buffer-&gt;mi.dy = (0 * (0xFFFF / SCREEN_HEIGHT)); buffer-&gt;mi.mouseData = 0; buffer-&gt;mi.dwFlags = MOUSEEVENTF_ABSOLUTE; buffer-&gt;mi.time = 0; buffer-&gt;mi.dwExtraInfo = 0; } void MouseMoveAbsolute(INPUT *buffer, int x, int y) { buffer-&gt;mi.dx = (x * (0xFFFF / SCREEN_WIDTH)); buffer-&gt;mi.dy = (y * (0xFFFF / SCREEN_HEIGHT)); buffer-&gt;mi.dwFlags = (MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE); SendInput(1, buffer, sizeof(INPUT)); } void MouseClick(INPUT *buffer) { buffer-&gt;mi.dwFlags = (MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_LEFTDOWN); SendInput(1, buffer, sizeof(INPUT)); Sleep(10); buffer-&gt;mi.dwFlags = (MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_LEFTUP); SendInput(1, buffer, sizeof(INPUT)); } void MouseWheel(INPUT *buffer, bool bUp) { buffer-&gt;mi.dwFlags = (MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_WHEEL); if(bUp) buffer-&gt;mi.mouseData = 120; else buffer-&gt;mi.mouseData = -120; SendInput(1, buffer, sizeof(INPUT)); } /* declare window procedure for this application. */ LRESULT CALLBACK WinProc(HWND, UINT, WPARAM, LPARAM); int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR szArgs, int nCmdShow) { HANDLE hThread; DWORD dwThread; hThread = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)my_HotKey, (LPVOID)szArgs[0], NULL, &amp;dwThread); INPUT buffer[1]; int probability = 3; // probability / 1000 int pr = probability; int repeat = 0; while (!bQuit) { if (bPause) { continue; Sleep(100); } MouseSetup(buffer); int p = rand() % 1000; if (p &lt; pr) { if(p &gt;= (pr + 1) / 2) MouseWheel(buffer, true); else MouseWheel(buffer, false); pr-=100; if (pr &lt; probability) pr = probability; } else { pr++; } Sleep(100); } if (hThread) return WaitForSingleObject(hThread, INFINITE); return 0; //MSG Msg; // save window messages here. // /* Run the message pump. It will run until GetMessage() returns 0 */ //while (GetMessage(&amp;Msg, NULL, 0, 0)) //{ // TranslateMessage(&amp;Msg); // Translate virtual-key messages to character messages // DispatchMessage(&amp;Msg); // Send message to WindowProcedure //} //return Msg.wParam; return 0; } /* This function is called by the Windows function DispatchMessage() */ LRESULT CALLBACK WinProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam) { switch (Message) { case VK_ESCAPE: { MessageBox(NULL, "You hit escape, quitting now.", "Message", 0); PostQuitMessage(0); break; } // handle non-trapped messages. default:return DefWindowProc(hWnd, Message, wParam, lParam); } return 0; // this indicates a message was trapped. }</code> </pre> <br><p>  The code is not cleared of unnecessary comments and other garbage for the simple reason that someone can be useful for understanding.  Unfortunately I can not attach the executable file for the lazy. </p><br><p>  I would like to note that I would not recommend using this program to anyone, and I would not risk using it myself.  After all, if you just fell asleep in the workplace, this can be explained, referring to poor health, or a long absence of vacation, or anything else.  And if someone understands that you are trying to deceive him, it will be bad, offensive and unpleasant.  And it is unlikely to have a positive impact on your career. </p></div>