<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Postgres in retrospect</title>
  <meta name="description" content="We bring to your attention a translation of the article ‚ÄúLooking Back at Postgres‚Äù by Joseph Hellerstein , published in accordance with the internatio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Postgres in retrospect</h1><div class="post__text post__text-html js-mediator-article">  <em>We bring to your attention a translation of the article <strong>‚ÄúLooking Back at Postgres‚Äù by Joseph Hellerstein</strong> , published in accordance with the international Creative Commons Attribution License version 4.0 (CC-BY 4.0).</em>  <em>The authors reserve the right to distribute this work on personal and corporate websites with proper reference to the source.</em> <br><br>  <em>Translated by Elena Indrupskaya.</em>  <em>From myself I would add that ‚Äúa programmer who desperately wanted to build a system with multi-versioning‚Äù - apparently, Vadim Mikheyev, and ‚Äúvolunteers from Russia‚Äù who rewritten GiST, we all know well.</em> <br><br><h1>  annotation </h1><br>  This is a reminder of the Postgres project run at UC Berkeley and led by Mike Stonebraker from the mid-1980s to the mid-1990s.  As one of many personal and historical memories, this article was requested for a book [ <a href="https://habr.com/ru/company/postgrespro/blog/438890/">Bro19</a> ] dedicated to awarding Turing a prize to Stonebreyker.  Therefore, the focus of the article is Stonebreaker‚Äôs leadership role and his thoughts on design.  But Stonebraker was never a programmer and did not interfere with his development team.  The Postgres codebase was the work of a team of brilliant students and, occasionally, full-time university programmers who had a little more experience (and only a little more salary) than students.  I was lucky to join this team as a student in the last years of the project.  I received useful material for this article from some of the older students involved in the project, but any errors or omissions are mine.  If you notice any of them, please contact me and I will try to fix them. <br><a name="habracut"></a><br><h1>  1. Introduction </h1><br>  Postgres was Michael Stounbraker‚Äôs most ambitious project - his serious attempt to create a universal database system.  Going on for a decade, the project has spawned more articles, candidates of science, professors and companies, than any other Stonebreaker activity.  The project also covered more technical areas than any other system he built.  Despite the risks inherent in this scale, Postgres has also become the most successful software artifact that came out of Stonbraker‚Äôs research teams, and its main contribution to open source.  This is an example of the ‚Äúsecond system‚Äù [ <a href="https://habr.com/ru/company/postgrespro/blog/438890/">Bro75</a> ], which was a success.  At the time of this writing, i.e. more than thirty years since the project began, the open source PostgreSQL system is the world's most popular independent open source database system and the fourth most popular database system.  In the meantime, Postgres companies produced a total of over $ 2.6 billion (in acquisition value).  By any measure, Stonebreyker‚Äôs Postgres vision had a huge long-lasting resonance. <br><br><h2>  1.1.  Prehistory </h2><br>  Stonebreaker was a huge success early in his career with the Ingres Berkeley research project [ <a href="https://habr.com/ru/company/postgrespro/blog/438890/">SHWK76</a> ] and the subsequent startup that he founded along with Larry Rowe and Eugene Wong: Relational Technology, Inc.  (RTI). <br><br>  As RTI developed in the early 1980s, Stonebriker began working on supporting data types in the DBMS that went beyond the traditional rows and columns of the original Codd relational model (Edgar Frank Codd).  The motivating example at that time was the need to support databases of computer-aided design tools (CAD) for the microelectronic industry.  In a 1983 paper, Stonebreaker and students Brad Rubenstein (Brad Rubenstein) and Antonin Guttman explained how much this industry needs to support ‚Äúnew data types, such as polygons, rectangles, text strings, etc.‚Äù, ‚Äú effective spatial search "," complex integrity constraints ", as well as" design hierarchies and multiple representations "in the same physical structures [ <a href="https://habr.com/ru/company/postgrespro/blog/438890/">SRG83</a> ].  Having such a motivation, the group began work on indexing (including using Guttman‚Äôs R-trees for spatial indexing [ <a href="https://habr.com/ru/company/postgrespro/blog/438890/">Gut84</a> ]) and on adding abstract data types (ATDs) to the relational database system.  At the time, ADTs were a popular new programming language design that was first introduced by Barbara Liskov, later a Turing Award winner, and researched in application programming of databases by a new employee of Stonebreaker - Larry Row.  An article in a 1983 SIGMOD Record [ <a href="https://habr.com/ru/company/postgrespro/blog/438890/">OFS83</a> ] Stonebreaker and students James Ong and Dennis Fogg describe the study of this concept in an Ingres extension called ADT-Ingres, which included many of the presentation concepts studied more deeply and with better system support in Postgres. <br><br><h1>  2. Postgres: General Information </h1><br>  As the name implies, Postgres is ‚ÄúPost-Ingres‚Äù: a system designed to take what Ingres could do and go beyond.  A distinctive feature of Postgres was the introduction of what he ultimately called the object-relational properties of a database: supporting the concept of object-oriented programming in the data model and the declarative query language of the database system.  But Stonebreaker also decided to solve a number of other object-independent support for technological problems in Postgres, such as active database rules, versioned data, tertiary storage, and concurrency. <br><br>  Two articles were written on Postgres design: the description of the early design in SIGMOD 1986 [ <a href="https://habr.com/ru/company/postgrespro/blog/438890/">SR86</a> ] and the intermediate description in CACM 1991 [ <a href="https://habr.com/ru/company/postgrespro/blog/438890/">SK91</a> ].  The Postgres research project gradually came to naught in 1992 with the founding of Illustra, a start-up by Stonebreaker, which involved Stonebreyker, lead graduate student Wei Hong, and later Jeff Meredith, the chief programmer.  In the list below, the possibilities mentioned in the article of 1986 are marked with an asterisk *, and the possibilities from the article of 1991, which were not in the article of 1986, are marked with a cross.  Other tasks listed below were taken in the system and research literature, but they are not in any design specification.  Many of these topics were considered in Postgres long before they were studied or reinvented by others.  In many cases, Postgres was too ahead of its time, and interest in topics started later, from a modern point of view. <br><br><ol><li>  ADT support in the database system <br><ul><li>  Complex objects (i.e. nested data or non-first normal form data (non-first-normal form - NF2)) * </li><li>  Custom abstract data types and functions * </li><li>  Extensible access methods for new data types * </li><li>  Optimized query processing with expensive custom features </li></ul></li><li>  Active databases and rule systems (triggers, warnings) * <br><ul><li>  Rules implemented as query rewrite <sup>‚Ä†</sup> </li><li>  Rules implemented as record level triggers <sup>‚Ä†</sup> </li></ul></li><li>  Log-based storage and recovery <br><ul><li>  Reduced complexity recovery code, viewing the log as data *, using non-volatile memory for a commit state <sup>‚Ä†</sup> </li><li>  Storage without rewriting and temporal queries <sup>‚Ä†</sup> </li></ul></li><li>  Support for new deep data storage technologies, especially optical discs * </li><li>  Support for multiprocessors and specialized processors * </li><li>  Support for various language models <br><ul><li>  Minimal changes to the relational model and support for declarative queries * </li><li>  Access to the ‚Äúfast path‚Äù from internal APIs bypassing the query language <sup>‚Ä†</sup> </li><li>  Multilingual <sup>‚Ä†</sup> </li></ul></li></ol><br>  We briefly discuss the contribution of Postgres for each of these positions in its relationship with subsequent work in the field of computing. <br><br><h2>  2.1.  ADT support in the database system </h2><br>  Postgres' well-articulated goal was to support new object-relational properties: expanding database technology to provide the benefits of both relational query processing and object-oriented programming.  Over time, the object-relational concept, first introduced in Postgres, became standard functionality in most modern database systems. <br><br><h3>  2.1.1.  Complex objects </h3><br>  Quite often, data is presented as nested entities or ‚Äúobjects‚Äù.  A classic example is a purchase order that has an embedded set of products, their quantities and prices.  Religion of relational modeling dictated that such data should be restructured and stored in a format without nesting, using several flat tables of objects (orders, products) with flat tables of relations connecting them (product_ in order).  A typical reason for this flattening is that it reduces duplication of data (because the product is redundantly described in many purchase orders), which, in turn, avoids complexity or errors when updating all redundant copies.  But in some cases you want to save the nested view, because it is natural for the application (for example, the layout scheme in CAD), and updates are rare.  This argument about data modeling is at least as old as the relational model. <br><br>  Postgres' key approach was to ‚Äúsit on two chairs‚Äù in terms of data modeling: Postgres retained the tables as the ‚Äúoutermost‚Äù data type, but allowed the columns to have ‚Äúcomplex‚Äù types, including nested tuples or tables.  One of its rare implementations, first explored in the ADT-Ingres prototype, was to allow table type columns to be <a href="https://habr.com/ru/company/postgrespro/blog/438890/">declared</a> declaratively as a query definition: ‚ÄúQuel as data type‚Äù [ <a href="https://habr.com/ru/company/postgrespro/blog/438890/">SAHR84</a> ] <em>(Quel - Ingres query language. - Note .)</em> . <br><br>  The ‚Äúpost-relational‚Äù topic of support for both declarative queries and nested data has reappeared over the years, often spawned by disputes about what is best.  During the Postgres era in the 1980s and 1990s, some groups focused on object-oriented databases picked up this idea and developed it into the standard OQL language, which then ceased to be used. <br><br>  At the turn of the millennium, declarative requests for nested objects became an obsessive research idea for the segment of the database development community in the form of XML databases.  The resulting XQuery language (led by Don Chamberlin - person SQL) is obliged to support complex objects Postquel language Postgres.  XQuery is widely used and used in industry, but has never been popular with users.  Today, these concepts are re-examined in the query language projects for the JSON data model, popular in browser applications.  Like OQL, in groups that initially rejected declarative requests in favor of developer-oriented programming (the ‚ÄúNoSQL‚Äù movement), these languages ‚Äã‚Äãoften arise as a late addition solely from the desire to add queries back to the systems.  At the same time, as Postgres has grown over the years (and the transition from Postquel query language to SQL versions that meet many of the goals under consideration), it has included support for embedded data, such as XML and JSON, in general-purpose DBMS, without requiring any or significant redesign.  Disputes proceed with varying success, and Postgres‚Äôs approach to expanding the relational structure with extensions for nested data has repeatedly shown itself to be a natural end state for all parties after the arguments have subsided. <br><br><h3>  2.1.2.  Custom abstract data types and functions </h3><br>  In addition to proposing nested types, Postgres put forward the idea of ‚Äã‚Äãintroducing opaque, extensible ADTs that are stored in the database, but not interpreted by the kernel.  In principle, this has always been part of Codd's relational model: integers and strings were traditional, but in fact the relational model covers any atomic data types with predicates.  The task was to provide such mathematical flexibility in software.  In order to use queries that interpret and manipulate these objects, an application programmer must be able to register user-defined functions (UDFs) for these types in the system and call these functions in queries.  It is also desirable that user-defined aggregate (user-defined aggregate - UDA) functions summarize collections of these objects in queries.  The Postgres database system was innovative, fully supporting these features. <br><br>  Why put such functionality in a DBMS, and not in high-level applications?  A typical answer to this question was a significant performance advantage of the code placed on the data, before pulling the data to the code.  Postgres showed that this was quite natural within the framework of the relational environment: only minor changes were required in the relational metadata catalog and mechanisms for calling third-party code were created, but the query syntax, semantics and system architecture worked simply and elegantly. <br><br>  Postgres was a bit ahead of its time in exploring this functionality.  In particular, at that time the community of database researchers was not particularly worried about the security implications of downloading unsafe code to the server.  This became perceived as a problem when technology was noticed in the industry.  Stonebreaker brought Postgres to the market in its Illustra startup, which was acquired by Informix largely for its ability to support DataBlade expansion packs, including UDF.  Informix with Postgres-based technology and a strong offering of parallel databases has become a significant threat to Oracle.  Oracle has invested heavily in negative marketing risks related to Informix‚Äôs ability to run unprotected custom C code.  Some attribute the death of Informix to this campaign, although the financial fraud of Informix (and the subsequent federal accusation of its then CEO) certainly represented more serious problems.  Now, decades later, all major database providers support the execution of user-defined functions in one or more languages, using new technologies to protect against server failures or data corruption. <br><br>  Meanwhile, the 2000s' big-data technology stacks, including the MapReduce phenomenon, which ‚Äúspoiled a lot of blood‚Äù for Stonebreyker and David DeWitt [ <a href="https://habr.com/ru/company/postgrespro/blog/438890/">DS08</a> ], are a re-implementation of the Postgres idea, a custom code placed within the request.  It appears that MapReduce largely combines Postgres software development ideas with concurrency ideas from systems such as Gamma and Teradata, with some minor innovations around restarting in the process of executing a query for workloads with extreme scalability.  Postgres, Greenplum and Aster startups around 2007 showed that Postgres paralleling could lead to something much more functional and practical than MapReduce for most customers, but in 2008 the market was still not ready for this technology. .  So far, in 2018, almost every big data stack basically serves the parallel SQL workload with UDF, which is very similar to the design that Stonebraker and the team used for the first time in Postgres. <br><br><h3>  2.1.3.  Extensible access methods for new data types </h3><br>  Relational databases evolved around the same time as B-trees in the early 1970s, and B-trees helped give impetus to Codd‚Äôs ‚Äúindependence from physical data storage‚Äù: indexing B-trees provides a level of indirection that adaptively reorganizes physical storage without requiring changes to applications.  The main limitation of B-trees and related structures was that they only support equality search and one-dimensional range queries.  And what if you have 2-dimensional range queries that are typical for mapping and CAD applications?  This problem was known during Postgres, and the R-tree [ <a href="https://habr.com/ru/company/postgrespro/blog/438890/">Gut84</a> ], developed by Antonin Guttman in the Stonebreaker group, was one of the most successful new indices designed to solve this problem in practice.  Nevertheless, the invention of the index structure does not solve for complex systems the task of supporting multidimensional ranges in a DBMS.  There are many questions.  Can you easily add an access method, such as R-trees, to your DBMS?  Can you teach the optimizer to understand that the specified access method will be useful for certain queries?  Can you ensure correct recovery and simultaneous access?  It was a very bold postgres action point: a software architecture problem affecting most of the database engine, from the optimizer to the storage layer, as well as the logging and recovery system.  Postgres R-trees have become a powerful driving force and a prime example of the elegant extensibility of the access method level and its integration into the query optimizer.  Postgres showed how to register an abstractly described access method (in this case, an R-tree), and how a query optimizer can recognize an abstract predicate of a sample (in this case, a range selection) and compare it with this abstractly described access method.  The issue of simultaneous access control was given less attention in the original work: the lack of one-dimensional ordering of keys made in this case the lock used in B-trees inapplicable. <br><br>  <em>The promising possibilities of Postgres extensible access methods inspired one of my first research projects at the end of graduate school: Generalized Search Trees ‚Äî GiST [ <a href="https://habr.com/ru/company/postgrespro/blog/438890/">HNP95</a> ] and the subsequent concept of <a href="https://habr.com/ru/company/postgrespro/blog/438890/">indexability</a> theory [ <a href="https://habr.com/ru/company/postgrespro/blog/438890/">HKM <sup>+</sup> 02</a> ].</em>  <em>I implemented GiST in Postgres during the semester after receiving my doctoral degree, which made adding new indexing logic to Postgres even easier.</em>  <em>In his thesis, Marcel Kornacker from Berkeley (Marcel Kornacker) solved the complex problems of recovery and simultaneous access posed by the extensible ‚Äútemplate‚Äù type of the GiST index [ <a href="https://habr.com/ru/company/postgrespro/blog/438890/">KMH97</a> ].</em> <br><br>  Today, PostgreSQL advantageously combines the original software architecture of extensible access methods (it has B-tree, GiST, SP-GiST and Gin indices) with extensibility and intensive concurrent access of the Generalized Search Tree Interface (GiST).  GiST indexes support PostgIS's popular PostGreSQL geo-information system.  Gin indices provide internal support for text indexing in PostgreSQL. <br><br><h3>  2.1.4.  Query Optimizer with Costly UDFs </h3><br>  In the traditional query optimization, the task was to minimize the stream volume of the tuples (and, therefore, I / O operations) generated during the processing of the request.  This meant that operators that filter tuples (sampling) are good at the beginning of the query plan, while operators that can generate new tuples (connection) must be executed later.  As a result, query optimizers will ‚Äúpush‚Äù the sample operators below the connections and arrange them arbitrarily, focusing instead on smart optimization of connections and disk accesses.  UDFs have changed the approach: if you have expensive UDFs in your sample operators, the order in which UDFs are executed can be crucial for optimizing performance.  Moreover, if the UDF in the sample operator really takes a lot of time, it is possible that the sample should be performed after the connections (i.e., ‚Äúpullup‚Äù the sample pull up).  Accounting for these factors has complicated the search space for the optimizer.  I took this problem as the first difficult task in graduate school, and ended up being the subject of my master's work with Stoneblock at Berkeley and my Ph.D. in Wisconsin under the guidance of Jeff Naughton, but with constant help from Stonebreyker.  DBMS Postgres was the first to save the cost and selectivity of user-defined functions in a database directory.  We approached the optimization problem by inventing the optimal order of the sampling operations, and then the optimal alternation of sampling operations along the branches of each connection tree considered when searching for a plan.  This allowed the optimizer to support the classic System R dynamic programming architecture with a small additional sorting cost to properly streamline expensive sample operators. <br><br>  <em>When I entered graduate school, it was one of the three topics that Stonebraker wrote on the blackboard in his office as options for choosing a topic for my dissertation.</em>  <em>It seems that the second topic was the indexing of functions, and I do not remember the third one.</em> <br><br>  Cost-effective optimization was disabled in PostgreSQL's source tree trees at an early stage, largely because there were no convincing options for using expensive user-defined functions at that time.  The examples we used revolved around image processing, and finally, in 2018, they became popular data processing tasks.  Of course, today, in the era of big data and machine learning workloads, costly functions have become quite common, and I expect this problem to return to the fore.  Once again, Postgres is well ahead of its time. <br><br>  <em>Ironically, the code I wrote in graduate school was completely removed from the PostgreSQL source tree by a young programmer named Neil Conway, who several years later began doing his PhD thesis under my supervision at UC Berkeley and is now one from Stonebreyker's ‚ÄúCandidate Grandchildren‚Äù.</em> <br><br><h2>  2.2.  Active databases and rule systems </h2><br>  The Postgres project began at the end of the artificial intelligence community‚Äôs interest in rule-based programming as a way to represent knowledge in expert systems.  Such a course of thought did not lead to success: many believe that this caused the widely discussed "winter of artificial intelligence," which continued throughout the 1990s. <br><br>  However, rule-based programming was maintained in the database developer community in two forms.  The first is theoretical work around declarative logic programming using Datalog.  She was a ‚Äúbone-in-the-throat‚Äù for Stonebreaker: he seemed to really hated the subject and criticized it bitterly in several community reports over the years. <br><br>  <em>Datalog has survived as a mathematical basis for declarative languages ‚Äã‚Äãand, over time, has found application in various areas of computer science, including software-configurable networks and compilers.</em>  <em>Datalog is a declarative construction of requests "on steroids" as a completely expressive programming model.</em>  <em>In the end, I was involved in this, as in the natural design option, and followed this in various application settings outside of traditional database systems.</em> <br><br>  The second set of questions related to database rules was a practical work on what was ultimately called active databases and database triggers, which evolved into the standard functionality of relational DBMSs.  Stonebreaker, in his peculiar manner, kicked in to work on a more practical option. <br><br>  Stonebreaker‚Äôs work on database rules began with Eric Hanson‚Äôs Ph.D. work, which was originally done for Ingres, but quickly moved into a new Postgres project.  It was expanded in the Ph.D. work of Spyros Potamianos on PRS2: Postgres Rules System 2. The theme in both implementations was the ability to implement the rules in two different ways.  One of them is to interpret the rules as rewriting requests.  This is reminiscent of the work on re-recording the submissions that Stonebreaker did at Ingres for the first time.  In this scenario, the logic of the rule ‚Äúsubject to perform an action‚Äù is converted to ‚Äúwhen prompted to overwrite it and execute instead of the original one‚Äù.  For example, a request like "add a new line to the list of Mike awards" can be rewritten as "raise Mike's salary by 10%."  Another way was to implement a more natural ‚Äúsubject to perform an action‚Äù by checking the conditions at the row level using locks inside the database.  When such locks were detected, the result was not a wait (as in the traditional simultaneous access control), but the execution of the corresponding action. <br><br>  <em>The code for the row level rules in PRS2 was, sadly, difficult.</em>  <em>A small search in the Postgres archives in Berkeley found the following comment (probably Spiros Potamianos) to the Postgres source code version 3.1 from about 1991 (given in translation):</em> <br><br><pre> <em>
</em>  <em>* ABOUT AND WITH A N AND E:</em> <em>
</em>  <em>* Take a deep breath and read.</em>  <em>If you can not get into the following</em> <em>
</em>  <em>* code (i.e. if the boss did not force you to voluntarily do it</em> <em>
</em>  <em>* dirty business) avoid it at all costs.</em>  <em>Try to do something less dangerous.</em> <em>
</em>  <em>* for your (mental) health.</em>  <em>Go home and watch horror movies on TV.</em> <em>
</em>  <em>* Read a little Lovecraft.</em>  <em>Go to serve in the army.</em>  <em>Go and spend some nights</em> <em>
</em>  <em>* in the national park.</em>  <em>Commit suicide ...</em> <em>
</em>  <em>* What, you continue to read, really?</em>  <em>Well, then you deserve what you got.</em> <em>
</em>  <em>* Welcome to the dark labyrinth of tuple-level rules system, my</em> <em>
</em>  <em>* poor colleague ...</em> </pre><br>  As a result, to implement the rules in Postgres, neither the query rewrite method nor the row-level blocking method were declared ‚Äúwinners‚Äù ‚Äî both were stored in the released system.  In the end, the code for all the rules was rejected and rewritten in PostgreSQL, but the current source code still retains both the notion of triggers at the operator level and at the row level. <br><br>  Postgres rules systems at one time had a very big impact and went "nostrils to nostrils" with research on the IBM Starburst and MCC HiPAC projects.  Today, triggers are part of the SQL standard and are implemented in the engines of many major databases.  However, they are used with some caution.  One of the problems is that the developments mentioned above have not overcome the negative aspects that led to the ‚Äúwinter of artificial intelligence‚Äù: interactions in the pile of rules can become unacceptably confusing, even when the set of rules grows only slightly.  In addition, in practice, the execution of triggers usually takes a relatively long time, so the databases being implemented that should work quickly tend to avoid the use of triggers.  However, there was some artisanal in related areas, such as supporting materialized views, handling complex events, and streaming requests, each of which is in some way extensions of ideas explored in Postgres rule systems. <br><br><h2>  2.3.  Log-based storage and recovery </h2><br>  Stonebraker described his Postgres storage design in this way: <br><blockquote>  When considering Postgres storage, we were guided by missionary zeal to do something unusual.  All modern commercial systems use a write-ahead log (WAL) storage manager, and we felt that this technology is well understood.  Moreover, the original Ingres prototype of the 1970s was used by a similar storage manager, and we had no desire to make another implementation.  [ <a href="https://habr.com/ru/company/postgrespro/blog/438890/">SK91</a> ] <br></blockquote>  Although it looks like pure intellectual restlessness, there were technological grounds for this work.  Over the years, Stonebriker has repeatedly expressed dislike for complex proactive logging schemes, first developed by IBM and Tandem to restore databases.  One of his main objections is based on the intuition of a software developer: no one should rely on something so complex, especially for functionality that will be used only in rare, critical scenarios after a failure. <br><br>  Postgres repository combines the concepts of core storage and journaling historical information into a single, simple disk view.  Basically, the idea was to store each record in the database in a linked list of versions marked with transaction identifiers ‚Äî in a sense, this is ‚Äúlog as data‚Äù or ‚Äúdata as log‚Äù depending on your point of view.  The only additional metadata that is needed is a list of identifiers of completed transactions and the time they were committed.  This approach greatly simplifies recovery, since there is no ‚Äútranslation‚Äù from the journal view back to the main view. –û–Ω —Ç–∞–∫–∂–µ –¥–µ–ª–∞–µ—Ç –≤–æ–∑–º–æ–∂–Ω—ã–º–∏ —Ç–µ–º–ø–æ—Ä–∞–ª—å–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã: –≤—ã –º–æ–∂–µ—Ç–µ –≤—ã–ø–æ–ª–Ω—è—Ç—å –∑–∞–ø—Ä–æ—Å—ã –ø–æ —Å–æ—Å—Ç–æ—è–Ω–∏—é –Ω–∞ –Ω–µ–∫–æ—Ç–æ—Ä—ã–π –º–æ–º–µ–Ω—Ç –≤—Ä–µ–º–µ–Ω–∏ –∏ –ø–æ–ª—É—á–∞—Ç—å –¥–æ—Å—Ç—É–ø –∫ –≤–µ—Ä—Å–∏—è–º –¥–∞–Ω–Ω—ã—Ö, –∫–æ—Ç–æ—Ä—ã–µ –±—ã–ª–∏ –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω—ã –≤ —ç—Ç–æ –≤—Ä–µ–º—è. –ü–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω—ã–π –¥–∏–∑–∞–π–Ω —Å–∏—Å—Ç–µ–º—ã —Ö—Ä–∞–Ω–µ–Ω–∏—è Postgres, –∫–æ—Ç–æ—Ä—ã–π –≤—ã–≥–ª—è–¥–∏—Ç —Ç–∞–∫, –∫–∞–∫ –±—É–¥—Ç–æ –°—Ç–æ—É–Ω–±—Ä–µ–π–∫–µ—Ä –æ–ø–∏—Å–∞–ª –µ–≥–æ –≤ –æ–¥–Ω–æ–º —Ç–≤–æ—Ä—á–µ—Å–∫–æ–º —Å–µ–∞–Ω—Å–µ –º–æ–∑–≥–æ–≤–æ–≥–æ —à—Ç—É—Ä–º–∞, —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞–ª —Ä—è–¥ –ø—Ä–æ–±–ª–µ–º —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –±–∞–∑–æ–≤–æ–π —Å—Ö–µ–º—ã –Ω–∞—Ä—è–¥—É —Å –≥—Ä—É–±—ã–º –∞–Ω–∞–ª–∏–∑–æ–º —Ç–æ–≥–æ, –∫–∞–∫ –º–æ–∂–µ—Ç –ø–æ–≤–µ—Å—Ç–∏ —Å–µ–±—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å [ <a href="https://habr.com/ru/company/postgrespro/blog/438890/">Sto87</a> ]. –ò—Ç–æ–≥–æ–≤–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –≤ Postgres –±—ã–ª–∞ –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø—Ä–æ—â–µ. <br><br> –ú–Ω–µ–Ω–∏–µ –°—Ç–æ—É–Ω–±—Ä–µ–π–∫–µ—Ä–∞ –æ ¬´—Ä–∞–¥–∏–∫–∞–ª—å–Ω–æ–π –ø—Ä–æ—Å—Ç–æ—Ç–µ¬ª —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–æ–Ω–Ω–æ–≥–æ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞ –±—ã–ª–æ –≥–ª—É–±–æ–∫–æ –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω–æ –ø—Ä–∏–Ω—è—Ç—ã–º –≤ —Å–æ–æ–±—â–µ—Å—Ç–≤–µ –≤ —Ç–æ –≤—Ä–µ–º—è, –∫–æ–≥–¥–∞ –ø–æ—Å—Ç–∞–≤—â–∏–∫–∏ –±–∞–∑ –¥–∞–Ω–Ω—ã—Ö –≤—ã–¥–µ–ª—è–ª–∏ —Å–µ–±—è, –∏–Ω–≤–µ—Å—Ç–∏—Ä—É—è –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω—ã–µ —Å—Ä–µ–¥—Å—Ç–≤–∞ –≤ –∞–ª–≥–æ—Ä–∏—Ç–º—ã –≤—ã—Å–æ–∫–æ–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π. –í —Ç–æ –≤—Ä–µ–º—è –ø–æ–±–µ–¥–∏—Ç–µ–ª–∏ —Å—Ä–∞–≤–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö —Ç–µ—Å—Ç–æ–≤ –¥–æ—Å—Ç–∏–≥–∞–ª–∏ –≤—ã—Å–æ–∫–æ–π –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –∏ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –±–ª–∞–≥–æ–¥–∞—Ä—è —Ö–æ—Ä–æ—à–æ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–º —Å–∏—Å—Ç–µ–º–∞–º –≤–µ–¥–µ–Ω–∏—è –∂—É—Ä–Ω–∞–ª–∞ —É–ø—Ä–µ–∂–¥–∞—é—â–µ–π –∑–∞–ø–∏—Å–∏. –ü–æ—Å–ª–µ —Ç–æ–≥–æ, –∫–∞–∫ –æ–Ω–∏ –ø–æ–ª—É—á–∏–ª–∏ —Ö–æ—Ä–æ—à–æ —Ä–∞–±–æ—Ç–∞—é—â–∏–µ –∂—É—Ä–Ω–∞–ª—ã —É–ø—Ä–µ–∂–¥–∞—é—â–µ–π –∑–∞–ø–∏—Å–∏, –ø–æ—Å—Ç–∞–≤—â–∏–∫–∏ —Ç–∞–∫–∂–µ –Ω–∞—á–∞–ª–∏ –Ω–æ–≤–æ–≤–≤–µ–¥–µ–Ω–∏—è —Å–ª–µ–¥—É—é—â–µ–≥–æ —ç—Ç–∞–ø–∞, —Ç–∞–∫–∏–µ –∫–∞–∫ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–æ–Ω–Ω–∞—è —Ä–µ–ø–ª–∏–∫–∞—Ü–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–æ—Å—Ç–∞–≤–∫–∏ –∂—É—Ä–Ω–∞–ª–∞, —á—Ç–æ –±—ã–ª–æ —Ç—Ä—É–¥–Ω–æ –æ—Å—É—â–µ—Å—Ç–≤–∏—Ç—å –≤ Postgres. –í –∏—Ç–æ–≥–µ —Å–∏—Å—Ç–µ–º–∞ —Ö—Ä–∞–Ω–µ–Ω–∏—è Postgres —Ç–∞–∫ –∏ –Ω–µ –æ—Ç–ª–∏—á–∏–ª–∞—Å—å –≤ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏. –í–µ—Ä—Å–∏–æ–Ω–Ω–æ—Å—Ç—å –∏ —Ç–µ–º–ø–æ—Ä–∞–ª—å–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã –±—ã–ª–∏ –ø–æ–∑–∂–µ —É–¥–∞–ª–µ–Ω—ã –∏–∑ PostgreSQL –∏ –∑–∞–º–µ–Ω–µ–Ω—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –∂—É—Ä–Ω–∞–ª–∞ —É–ø—Ä–µ–∂–¥–∞—é—â–µ–π –∑–∞–ø–∏—Å–∏. <br><br> <em>–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, PostgreSQL –≤—Å–µ –µ—â–µ –Ω–µ –æ—Å–æ–±–µ–Ω–Ω–æ –±—ã—Å—Ç—Ä–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏: –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≤ –Ω–µ–º –∂—É—Ä–Ω–∞–ª–∞ —É–ø—Ä–µ–∂–¥–∞—é—â–µ–π –∑–∞–ø–∏—Å–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–æ–ª–æ–≤–∏–Ω—á–∞—Ç–æ. –ö–∞–∫ –Ω–∏ —Å—Ç—Ä–∞–Ω–Ω–æ, –∫–æ–º–∞–Ω–¥–∞ PostgreSQL —Å–æ—Ö—Ä–∞–Ω–∏–ª–∞ –º–Ω–æ–≥–æ —Å–ª—É–∂–µ–±–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏, —Ö—Ä–∞–Ω–∏–º–æ–π –≤–º–µ—Å—Ç–µ —Å –∫–æ—Ä—Ç–µ–∂–∞–º–∏ –≤ Postgres, –¥–ª—è –æ–±–µ—Å–ø–µ—á–µ–Ω–∏—è –º–Ω–æ–≥–æ–≤–µ—Ä—Å–∏–æ–Ω–Ω–æ—Å—Ç–∏, —á—Ç–æ –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –±—ã–ª–æ —Ü–µ–ª—å—é –ø—Ä–æ–µ–∫—Ç–∞ Postgres –≤ –ë–µ—Ä–∫–ª–∏. –†–µ–∑—É–ª—å—Ç–∞—Ç–æ–º —è–≤–ª—è–µ—Ç—Å—è —Å–∏—Å—Ç–µ–º–∞ —Ö—Ä–∞–Ω–µ–Ω–∏—è, –∫–æ—Ç–æ—Ä–∞—è –º–æ–∂–µ—Ç —ç–º—É–ª–∏—Ä–æ–≤–∞—Ç—å –∏–∑–æ–ª—è—Ü–∏—é —Å–Ω–∏–º–∫–æ–≤ (snapshot isolation) Oracle —Å –∏–∑—Ä—è–¥–Ω—ã–º –æ–±—ä–µ–º–æ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –Ω–∞–∫–ª–∞–¥–Ω—ã—Ö —Ä–∞—Å—Ö–æ–¥–æ–≤ –≤–≤–æ–¥–∞-–≤—ã–≤–æ–¥–∞, –Ω–æ –∫–æ—Ç–æ—Ä–∞—è –Ω–µ —Å–ª–µ–¥—É–µ—Ç –ø–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω–æ–π –º—ã—Å–ª–∏ –°—Ç–æ—É–Ω–±—Ä–µ–π–∫–µ—Ä–∞ –æ —Ç–µ–º–ø–æ—Ä–∞–ª—å–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–∞—Ö –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ–º –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–∏.</em> <br><br> <em>–ú–∞–π–∫ –û–ª—Å–æ–Ω (Mike Olson) –æ—Ç–º–µ—á–∞–µ—Ç, —á—Ç–æ –µ–≥–æ –ø–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω–æ–µ –Ω–∞–º–µ—Ä–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–ª–æ –≤ —Ç–æ–º, —á—Ç–æ–±—ã –∑–∞–º–µ–Ω–∏—Ç—å —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é B-–¥–µ—Ä–µ–≤–∞ Postgres —Å–≤–æ–µ–π —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–µ–π B-–¥–µ—Ä–µ–≤–∞ –∏–∑ –ø—Ä–æ–µ–∫—Ç–∞ Berkeley DB, –∫–æ—Ç–æ—Ä—ã–π —Ä–∞–∑—Ä–∞–±–∞—Ç—ã–≤–∞–ª—Å—è –≤ –ë–µ—Ä–∫–ª–∏ –≤ —ç–ø–æ—Ö—É Postgres. –ù–æ –û–ª—Å–æ–Ω —Ç–∞–∫ –∏ –Ω–µ –Ω–∞—à–µ–ª –Ω–∞ —ç—Ç–æ –≤—Ä–µ–º–µ–Ω–∏. –ö–æ–≥–¥–∞ –≥–æ–¥—ã —Å–ø—É—Å—Ç—è Berkeley DB –ø–æ–ª—É—á–∏–ª–∞ –ø–æ–¥–¥–µ—Ä–∂–∫—É —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π –≤ Sleepycat Corp., –û–ª—Å–æ–Ω –ø–æ–ø—ã—Ç–∞–ª—Å—è —É–±–µ–¥–∏—Ç—å (—Ç–æ–≥–¥–∞—à–Ω–µ–µ) —Å–æ–æ–±—â–µ—Å—Ç–≤–æ PostgreSQL –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ–≥–æ –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –≤–º–µ—Å—Ç–æ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞ ¬´–±–µ–∑ –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∏¬ª. –û–Ω–∏ –æ—Ç–∫–∞–∑–∞–ª–∏—Å—å: –≤ –ø—Ä–æ–µ–∫—Ç–µ –±—ã–ª –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç, –∫–æ—Ç–æ—Ä—ã–π –æ—Ç—á–∞—è–Ω–Ω–æ —Ö–æ—Ç–µ–ª –ø–æ—Å—Ç—Ä–æ–∏—Ç—å —Å–∏—Å—Ç–µ–º—É —Å –º–Ω–æ–≥–æ–≤–µ—Ä—Å–∏–æ–Ω–Ω–æ—Å—Ç—å—é (MVCC), –∏ –ø–æ—Å–∫–æ–ª—å–∫—É –æ–Ω –±—ã–ª –≥–æ—Ç–æ–≤ –≤—ã–ø–æ–ª–Ω–∏—Ç—å —Ä–∞–±–æ—Ç—É, –æ–Ω –≤—ã–∏–≥—Ä–∞–ª —Å–ø–æ—Ä.</em> <br><br> <em>–ú–µ–¥–ª–µ–Ω–Ω–æ —Ä–∞–±–æ—Ç–∞—é—â–µ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ PostgreSQL –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ –ø—Ä–∏—Å—É—â–∏–º —Å–∏—Å—Ç–µ–º–µ. –í Greenplum –≤–µ—Ç–∫–∞ PostgreSQL –≤ –∫–∞—á–µ—Å—Ç–≤–µ –∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ–π –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤—ã –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–ª–∞ –≤—ã—Å–æ–∫–æ–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ–µ —Å–∂–∞—Ç–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ. –û–Ω–æ –±—ã–ª–æ —Ä–∞–∑—Ä–∞–±–æ—Ç–∞–Ω–æ –ú—ç—Ç—Ç–æ–º –ú–∞–∫–ö–ª–∏–Ω–æ–º (Matt McCline)‚Äî–≤–µ—Ç–µ—Ä–∞–Ω–æ–º –∫–æ–º–∞–Ω–¥—ã –î–∂–∏–º–∞ –ì—Ä–µ—è (Jim Gray) –≤ –∫–æ–º–ø–∞–Ω–∏–∏ Tandem. –û–Ω–æ —Ç–∞–∫–∂–µ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–ª–æ —Ç–µ–º–ø–æ—Ä–∞–ª—å–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤.</em> <br><br> –ù–æ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å —Ç–µ–º–ø–æ—Ä–∞–ª—å–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤ –±—ã–ª–∞ –∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ–π –∏ –æ—Å—Ç–∞–≤–∞–ª–∞—Å—å —É–Ω–∏–∫–∞–ª—å–Ω–æ–π. –ë–æ–ª–µ–µ —Ç–æ–≥–æ, –∫—Ä–µ–¥–æ –°—Ç–æ—É–Ω–±—Ä–µ–π–∫–µ—Ä–∞ –≤ –æ—Ç–Ω–æ—à–µ–Ω–∏–∏ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏ –ø—Ä–æ—Å—Ç–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º–º–Ω–æ–≥–æ –æ–±–µ—Å–ø–µ—á–µ–Ω–∏—è –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö —Å–µ–≥–æ–¥–Ω—è –∏–º–µ–µ—Ç –æ—Ç–≥–æ–ª–æ—Å–∫–∏ –∫–∞–∫ –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ —Å–∏—Å—Ç–µ–º NoSQL (–∫–æ—Ç–æ—Ä—ã–µ –≤—ã–±–∏—Ä–∞—é—Ç —Ä–µ–ø–ª–∏–∫–∞—Ü–∏—é, –∞ –Ω–µ WAL), —Ç–∞–∫ –∏ –≤ –±–∞–∑–∞—Ö –¥–∞–Ω–Ω—ã—Ö –æ—Å–Ω–æ–≤–Ω–æ–π –ø–∞–º—è—Ç–∏ (MMDB ‚Äî main memory databases, –∫–æ—Ç–æ—Ä—ã–µ —á–∞—Å—Ç–æ –∏—Å–ø–æ–ª—å–∑—É—é—Ç –º–Ω–æ–≥–æ–≤–µ—Ä—Å–∏–æ–Ω–Ω–æ—Å—Ç—å –∏ —Å–∂–∞—Ç—ã–µ –∂—É—Ä–Ω–∞–ª—ã —Ñ–∏–∫—Å–∞—Ü–∏–∏). –ò–¥–µ—è –≤–µ—Ä—Å–∏–æ–Ω–Ω—ã—Ö —Ä–µ–ª—è—Ü–∏–æ–Ω–Ω—ã—Ö –±–∞–∑ –¥–∞–Ω–Ω—ã—Ö –∏ —Ç–µ–º–ø–æ—Ä–∞–ª—å–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤ —Å–µ–≥–æ–¥–Ω—è –≤—Å–µ –µ—â–µ –æ—Ç–Ω–µ—Å–µ–Ω–∞ –∫ —ç–∑–æ—Ç–µ—Ä–∏–∫–µ, –ø–æ—è–≤–ª—è—è—Å—å –≤ —Å–ª—É—á–∞–π–Ω—ã—Ö –∏—Å—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –ø—Ä–æ—Ç–æ—Ç–∏–ø–∞—Ö –∏ –Ω–µ–±–æ–ª—å—à–∏—Ö –ø—Ä–æ–µ–∫—Ç–∞—Ö —Å –æ—Ç–∫—Ä—ã—Ç—ã–º –∏—Å—Ö–æ–¥–Ω—ã–º –∫–æ–¥–æ–º. –≠—Ç–æ –∏–¥–µ—è, –∫–æ—Ç–æ—Ä–∞—è —Å–æ–∑—Ä–µ–ª–∞ –¥–ª—è –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏—è –≤ –Ω–∞—à—É —ç–ø–æ—Ö—É –¥–µ—à–µ–≤–æ–≥–æ —Ö—Ä–∞–Ω–µ–Ω–∏—è –∏ –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω—ã—Ö –ø–æ—Ç–æ–∫–æ–≤ –¥–∞–Ω–Ω—ã—Ö. <br><br><h2>  2.4. –ó–∞–ø—Ä–æ—Å—ã –∫ –¥–∞–Ω–Ω—ã–º –Ω–∞ –Ω–æ—Å–∏—Ç–µ–ª—è—Ö —Å –Ω–æ–≤—ã–º–∏ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—è–º–∏ –≥–ª—É–±–æ–∫–æ–≥–æ —Ö—Ä–∞–Ω–µ–Ω–∏—è </h2><br> –í —Å–µ—Ä–µ–¥–∏–Ω–µ –ø—Ä–æ–µ–∫—Ç–∞ Postgres –°—Ç–æ—É–Ω–±—Ä–µ–π–∫–µ—Ä –ø–æ–¥–ø–∏—Å–∞–ª—Å—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ –æ–¥–Ω–æ–≥–æ –∏–∑ —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª–µ–π –Ω–∞ –±–æ–ª—å—à–æ–π –≥—Ä–∞–Ω—Ç –ø–æ –Ω–∞—É—á–Ω–æ–º—É –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—é ¬´—Ü–∏—Ñ—Ä–æ–≤–∞—è –∑–µ–º–ª—è¬ª –ø–æ–¥ –Ω–∞–∑–≤–∞–Ω–∏–µ–º Project Sequoia. –ß–∞—Å—Ç—å –≥—Ä–∞–Ω—Ç–æ–≤–æ–≥–æ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –∑–∞–∫–ª—é—á–∞–ª–∞—Å—å –≤ –æ–±—Ä–∞–±–æ—Ç–∫–µ –±–µ—Å–ø—Ä–µ—Ü–µ–¥–µ–Ω—Ç–Ω—ã—Ö –æ–±—ä–µ–º–æ–≤ —Ü–∏—Ñ—Ä–æ–≤—ã—Ö —Å–ø—É—Ç–Ω–∏–∫–æ–≤—ã—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π, —Ç—Ä–µ–±—É—é—â–∏—Ö –¥–æ 100 —Ç–µ—Ä–∞–±–∞–π—Ç –ø–∞–º—è—Ç–∏, —Ç. –µ. –Ω–∞–º–Ω–æ–≥–æ –±–æ–ª—å—à–µ–≥–æ –æ–±—ä–µ–º–∞ –¥–∞–Ω–Ω—ã—Ö, —á–µ–º –≤ —Ç–æ –≤—Ä–µ–º—è –±—ã–ª–æ –±—ã —Ä–∞–∑—É–º–Ω–æ —Ö—Ä–∞–Ω–∏—Ç—å –Ω–∞ –º–∞–≥–Ω–∏—Ç–Ω—ã—Ö –¥–∏—Å–∫–∞—Ö. –í –æ—Å–Ω–æ–≤–µ –ø—Ä–µ–¥–ª–∞–≥–∞–µ–º–æ–≥–æ —Ä–µ—à–µ–Ω–∏—è –±—ã–ª–æ –∏—Å—Å–ª–µ–¥–æ–≤–∞—Ç—å –∏–¥–µ—é —Å–æ–∑–¥–∞–Ω–∏—è –°–£–ë–î (–∞ –∏–º–µ–Ω–Ω–æ Postgres), –æ–±–ª–µ–≥—á–∞—é—â–µ–π –¥–æ—Å—Ç—É–ø –∫ –ø–æ–ª—É–∞–≤—Ç–æ–Ω–æ–º–Ω–æ–º—É ¬´—Ç—Ä–µ—Ç–∏—á–Ω–æ–º—É¬ª —Ö—Ä–∞–Ω–∏–ª–∏—â—É, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ–º–æ–º—É —Ä–æ–±–æ—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ –Ω–∞–∫–æ–ø–∏—Ç–µ–ª—è–º–∏ —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π —Å–º–µ–Ω–æ–π –¥–∏—Å–∫–æ–≤ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞–º–∏ –æ–ø—Ç–∏—á–µ—Å–∫–∏—Ö –¥–∏—Å–∫–æ–≤ –∏–ª–∏ –ª–µ–Ω—Ç. <br><br> –ò–∑ —ç—Ç–æ–≥–æ –≤—ã—Ç–µ–∫–∞–ª–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ä–∞–∑–Ω—ã—Ö –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–π. –û–¥–Ω–∏–º –∏–∑ –Ω–∏—Ö –±—ã–ª–∞ —Ñ–∞–π–ª–æ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞ Inversion ‚Äî –ø–æ–ø—ã—Ç–∫–∞ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–∏—Ç—å –∞–±—Å—Ç—Ä–∞–∫—Ü–∏—é —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã UNIX –Ω–∞–¥ —Ä–µ–ª—è—Ü–∏–æ–Ω–Ω–æ–π –°–£–ë–î. –í –æ–±–∑–æ—Ä–Ω–æ–π —Å—Ç–∞—Ç—å–µ –¥–ª—è Sequoia –°—Ç–æ—É–Ω–±—Ä–µ–π–∫–µ—Ä –æ–ø–∏—Å–∞–ª —ç—Ç–æ –≤ —Å–≤–æ–µ–º –æ–±—ã—á–Ω–æ–º —Å—Ç–∏–ª–µ —Å–≤—ã—Å–æ–∫–∞ –∫–∞–∫ ¬´–ø—Ä–æ—Å—Ç–æ–µ —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–µ¬ª [ <a href="https://habr.com/ru/company/postgrespro/blog/438890/">Sto95</a> ]. –ù–∞ —Å–∞–º–æ–º –¥–µ–ª–µ –ú–∞–π–∫ –û–ª—Å–æ–Ω, —Å—Ç—É–¥–µ–Ω—Ç –°—Ç–æ—É–Ω–±—Ä–µ–π–∫–µ—Ä–∞ (–∏ –ø–æ—Å–ª–µ–¥—É—é—â–∏–π –æ—Å–Ω–æ–≤–∞—Ç–µ–ª—å –∫–æ–º–ø–∞–Ω–∏–∏ Cloudera), –±—ã–ª –∑–∞–Ω—è—Ç —ç—Ç–∏–º –≤ —Ç–µ—á–µ–Ω–∏–µ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –ª–µ—Ç, –¥–∞ –∏ –∫–æ–Ω–µ—á–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –Ω–µ –±—ã–ª –≤–ø–æ–ª–Ω–µ –æ–¥–Ω–æ–∑–Ω–∞—á–Ω—ã–º [ <a href="https://habr.com/ru/company/postgrespro/blog/438890/">Ols93</a> ] –∏ –Ω–µ –≤—ã–∂–∏–ª –Ω–∞ –ø—Ä–∞–∫—Ç–∏–∫–µ. <br><br> <em>–ù–∞ –Ω–µ—Å–∫–æ–ª—å–∫–æ –ª–µ—Ç –ø–æ–∑–∂–µ Inversion –ë–∏–ª–ª –ì–µ–π—Ç—Å ¬´–±–∏–ª—Å—è —Å —Ç–µ–º–∏ –∂–µ –≤–µ—Ç—Ä—è–Ω—ã–º–∏ –º–µ–ª—å–Ω–∏—Ü–∞–º–∏¬ª –≤ WinFS ‚Äî –ø–æ–ø—ã—Ç–∫–µ –≤–æ—Å—Å–æ–∑–¥–∞—Ç—å –Ω–∞–∏–±–æ–ª–µ–µ —à–∏—Ä–æ–∫–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º—É—é –≤ –º–∏—Ä–µ —Ñ–∞–π–ª–æ–≤—É—é —Å–∏—Å—Ç–µ–º—É –Ω–∞–¥ —Å–µ—Ä–≤–µ—Ä–Ω–æ–π —á–∞—Å—Ç—å—é —Ä–µ–ª—è—Ü–∏–æ–Ω–Ω–æ–π –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö. WinFS –ø–æ—Å—Ç–∞–≤–ª—è–ª–∞—Å—å –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–µ—Å–∫–∏—Ö –≤–µ—Ä—Å–∏—è—Ö Windows, –Ω–æ —Ç–∞–∫ –∏ –Ω–µ –≤—ã—à–ª–∞ –Ω–∞ —Ä—ã–Ω–æ–∫. –ì–µ–π—Ç—Å –ø–æ–∑–∂–µ –Ω–∞–∑–≤–∞–ª —ç—Ç–æ —Å–≤–æ–∏–º —Å–∞–º—ã–º –±–æ–ª—å—à–∏–º –≤ Microsoft —Ä–∞–∑–æ—á–∞—Ä–æ–≤–∞–Ω–∏–µ–º.</em> <br><br> –î—Ä—É–≥–∏–º –æ—Å–Ω–æ–≤–Ω—ã–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–π –Ω–∞ —ç—Ç–æ–º —Ñ—Ä–æ–Ω—Ç–µ –±—ã–ª–æ –≤–∫–ª—é—á–µ–Ω–∏–µ —Ç—Ä–µ—Ç–∏—á–Ω–æ–≥–æ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞ –≤ —Å—Ç–µ–∫ –±–æ–ª–µ–µ —Ç–∏–ø–∏—á–Ω—ã—Ö —Ä–µ–ª—è—Ü–∏–æ–Ω–Ω—ã—Ö –±–∞–∑ –¥–∞–Ω–Ω—ã—Ö, —á—Ç–æ –±—ã–ª–æ –ø—Ä–µ–¥–º–µ—Ç–æ–º –∫–∞–Ω–¥–∏–¥–∞—Ç—Å–∫–æ–π –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–∏ –°—É–Ω–∏—Ç—ã –°–∞—Ä–∞–≤–∞–≥–∏ (Sunita Sarawagi). –û—Å–Ω–æ–≤–Ω–æ–π —Ç–µ–º–æ–π –±—ã–ª–æ –∏–∑–º–µ–Ω–µ–Ω–∏–µ –º–∞—Å—à—Ç–∞–±–∞, –≤ –∫–æ—Ç–æ—Ä–æ–º –≤—ã –º—ã—Å–ª–∏—Ç–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ–º (—Ç. –µ. –¥–∞–Ω–Ω—ã–º–∏ –≤ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ –∏ –∏–µ—Ä–∞—Ä—Ö–∏–∏ –ø–∞–º—è—Ç–∏) –∏ –≤—Ä–µ–º–µ–Ω–µ–º (–∫–æ–æ—Ä–¥–∏–Ω–∞—Ü–∏—è –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –∑–∞–ø—Ä–æ—Å–æ–≤ –∏ –∫–µ—à–∞ –¥–ª—è –º–∏–Ω–∏–º–∏–∑–∞—Ü–∏–∏ –Ω–µ–∂–µ–ª–∞—Ç–µ–ª—å–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π –≤–≤–æ–¥–∞-–≤—ã–≤–æ–¥–∞). –û–¥–Ω–æ–π –∏–∑ –∫–ª—é—á–µ–≤—ã—Ö –ø—Ä–æ–±–ª–µ–º –≤ —ç—Ç–æ–π —Ä–∞–±–æ—Ç–µ –±—ã–ª–æ —Ö—Ä–∞–Ω–µ–Ω–∏–µ –±–æ–ª—å—à–∏—Ö –º–Ω–æ–≥–æ–º–µ—Ä–Ω—ã—Ö –º–∞—Å—Å–∏–≤–æ–≤ –≤ —Ç—Ä–µ—Ç–∏—á–Ω–æ–º —Ö—Ä–∞–Ω–∏–ª–∏—â–µ –∏ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ –∏—Ö, —á—Ç–æ –ø–µ—Ä–µ–∫–ª–∏–∫–∞–µ—Ç—Å—è —Å —Ä–∞–±–æ—Ç–∞–º–∏ –≤ –æ–±–ª–∞—Å—Ç–∏ –º–Ω–æ–≥–æ–º–µ—Ä–Ω–æ–≥–æ –∏–Ω–¥–µ–∫—Å–∏—Ä–æ–≤–∞–Ω–∏—è. –û—Å–Ω–æ–≤–Ω—ã–µ –∏–¥–µ–∏ –≤–∫–ª—é—á–∞–ª–∏ —Ä–∞–∑–±–∏–µ–Ω–∏–µ –º–∞—Å—Å–∏–≤–∞ –Ω–∞ –ø–æ—Ä—Ü–∏–∏ –∏ —Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤–º–µ—Å—Ç–µ –ø–æ—Ä—Ü–∏–π, –∫–æ—Ç–æ—Ä—ã–µ –≤—ã–±–∏—Ä–∞—é—Ç—Å—è –≤–º–µ—Å—Ç–µ, –∞ —Ç–∞–∫–∂–µ —Ä–µ–ø–ª–∏–∫–∞—Ü–∏—é –ø–æ—Ä—Ü–∏–π, —á—Ç–æ–±—ã —É–∫–∞–∑–∞–Ω–Ω–∞—è –ø–æ—Ä—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö –º–æ–≥–ª–∞ –∏–º–µ—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Ñ–∏–∑–∏—á–µ—Å–∫–∏—Ö ¬´—Å–æ—Å–µ–¥–µ–π¬ª. –í—Ç–æ—Ä–∞—è –ø—Ä–æ–±–ª–µ–º–∞ ‚Äî –ø–æ–¥—É–º–∞—Ç—å –æ —Ç–æ–º, –∫–∞–∫ –¥–∏—Å–∫ —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –∫–µ—à–µ–º –¥–ª—è —Ç—Ä–µ—Ç–∏—á–Ω–æ–≥–æ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞. –ù–∞–∫–æ–Ω–µ—Ü, –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –∑–∞–ø—Ä–æ—Å–æ–≤ –∏ –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–æ–ª–∂–Ω—ã –±—ã–ª–∏ —É—á–∏—Ç—ã–≤–∞—Ç—å –¥–ª–∏—Ç–µ–ª—å–Ω–æ–µ –≤—Ä–µ–º—è –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö –∏–∑ —Ç—Ä–µ—Ç–∏—á–Ω–æ–≥–æ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞ –∏ –≤–∞–∂–Ω–æ—Å—Ç—å –ø–æ–ø–∞–¥–∞–Ω–∏–π (hits) –∫–µ—à–∞ –¥–∏—Å–∫–∞. –≠—Ç–æ –≤–ª–∏—è–µ—Ç –∫–∞–∫ –Ω–∞ –ø–ª–∞–Ω, –≤—ã–±–∏—Ä–∞–µ–º—ã–π –æ–ø—Ç–∏–º–∏–∑–∞—Ç–æ—Ä–æ–º –∑–∞–ø—Ä–æ—Å–æ–≤, —Ç–∞–∫ –∏ –Ω–∞ –≤—Ä–µ–º—è, –Ω–∞ –∫–æ—Ç–æ—Ä–æ–µ —ç—Ç–æ—Ç –ø–ª–∞–Ω –Ω–∞–º–µ—á–µ–Ω –∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—é. <br><br> –†–æ–±–æ—Ç—ã –Ω–∞ –ª–µ–Ω—Ç–∞—Ö –∏ –æ–ø—Ç–∏—á–µ—Å–∫–∏—Ö –¥–∏—Å–∫–∞—Ö –≤ –Ω–∞—Å—Ç–æ—è—â–µ–µ –≤—Ä–µ–º—è —à–∏—Ä–æ–∫–æ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è. –ù–æ –ø—Ä–æ–±–ª–µ–º—ã —Ç—Ä–µ—Ç–∏—á–Ω–æ–≥–æ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞ –æ—á–µ–Ω—å —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω—ã –≤ –æ–±–ª–∞–∫–µ, –∫–æ—Ç–æ—Ä–æ–µ –≤ 2018 –≥–æ–¥—É –∏–º–µ–µ—Ç –≥–ª—É–±–æ–∫—É—é –∏–µ—Ä–∞—Ä—Ö–∏—é —Ö—Ä–∞–Ω–µ–Ω–∏—è: –æ—Ç –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–Ω—ã—Ö —Ç–≤–µ—Ä–¥–æ—Ç–µ–ª—å–Ω—ã—Ö –¥–∏—Å–∫–æ–≤ –∫ —É—Å–ª—É–≥–∞–º –Ω–∞–¥–µ–∂–Ω–æ–≥–æ –¥–∏—Å–∫–æ–ø–æ–¥–æ–±–Ω–æ–≥–æ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, AWS EBS), –∫ –∞—Ä—Ö–∏–≤–Ω–æ–º—É —Ö—Ä–∞–Ω–∏–ª–∏—â—É (–Ω–∞–ø—Ä–∏–º–µ—Ä, –≤ AWS S3), –∫ –≥–ª—É–±–æ–∫–æ–º—É —Ö—Ä–∞–Ω–∏–ª–∏—â—É (–Ω–∞–ø—Ä–∏–º–µ—Ä, AWS Glacier). –°–µ–≥–æ–¥–Ω—è —ç—Ç–∏ —É—Ä–æ–≤–Ω–∏ —Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–æ-–ø—Ä–µ–∂–Ω–µ–º—É –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –æ–±–æ—Å–æ–±–ª–µ–Ω—ã, –∏ —Ä–∞—Å—Å—É–∂–¥–µ–Ω–∏—è –æ —Å–∫–≤–æ–∑–Ω–æ–º —Ö—Ä–∞–Ω–∏–ª–∏—â–µ, –æ—Ö–≤–∞—Ç—ã–≤–∞—é—â–µ–º —ç—Ç–∏ —É—Ä–æ–≤–Ω–∏, –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö. –Ø –Ω–µ —É–¥–∏–≤–ª—é—Å—å, –µ—Å–ª–∏ –≤–æ–ø—Ä–æ—Å—ã, –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–Ω—ã–µ –Ω–∞ —ç—Ç–æ–º —Ñ—Ä–æ–Ω—Ç–µ –≤ Postgres, –±—É–¥—É—Ç –ø–µ—Ä–µ—Å–º–æ—Ç—Ä–µ–Ω—ã –≤ –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è. <br><br><h2>  2.5. –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –º—É–ª—å—Ç–∏–ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–æ–≤: XPRS </h2><br> –°—Ç–æ—É–Ω–±—Ä–µ–π–∫–µ—Ä –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ —Å–æ–∑–¥–∞–≤–∞–ª –±–æ–ª—å—à—É—é –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—É—é —Å–∏—Å—Ç–µ–º—É –±–∞–∑ –¥–∞–Ω–Ω—ã—Ö, –Ω–æ –æ–Ω —Ä—É–∫–æ–≤–æ–¥–∏–ª –º–Ω–æ–≥–∏–º–∏ —Å—Ç–∏–º—É–ª–∏—Ä—É—é—â–∏–º–∏ –¥–∏—Å–∫—É—Å—Å–∏—è–º–∏ –≤ —ç—Ç–æ–π –æ–±–ª–∞—Å—Ç–∏. –ï–≥–æ —Å—Ç–∞—Ç—å—è ¬´Case for Shared Nothing¬ª (–°–ª—É—á–∞–π –¥–ª—è —Å–∏—Å—Ç–µ–º –±–µ–∑ —Ä–∞–∑–¥–µ–ª—è–µ–º—ã—Ö —Ä–µ—Å—É—Ä—Å–æ–≤) [ <a href="https://habr.com/ru/company/postgrespro/blog/438890/">Sto86</a> ] –∑–∞–¥–æ–∫—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–ª –∫—Ä—É–ø–Ω–æ–º–æ–¥—É–ª—å–Ω—ã–µ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ —Ä–µ—à–µ–Ω–∏—è –≤ —ç—Ç–æ–π –æ–±–ª–∞—Å—Ç–∏. –û–Ω –ø–æ–ø—É–ª—è—Ä–∏–∑–∏—Ä–æ–≤–∞–ª —Ç–µ—Ä–º–∏–Ω–æ–ª–æ–≥–∏—é, –∏—Å–ø–æ–ª—å–∑—É–µ–º—É—é –≤ –æ—Ç—Ä–∞—Å–ª–∏, –∏ –æ–∑–∞–¥–∞—á–∏–ª –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä –±–µ–∑ —Å–æ–≤–º–µ—Å—Ç–Ω–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö —Ä–µ—Å—É—Ä—Å–æ–≤, —Ç–∞–∫–∏—Ö –∫–∞–∫ Gamma –∏ Teradata, –∫–æ—Ç–æ—Ä—ã–µ –±—ã–ª–∏ –∑–∞–Ω–æ–≤–æ –æ—Ç–∫—Ä—ã—Ç—ã –≤ 2000-—Ö –≥–æ–¥–∞—Ö —Å–æ–æ–±—â–µ—Å—Ç–≤–æ–º —Ä–∞–±–æ—Ç–∞—é—â–∏—Ö –Ω–∞–¥ –±–æ–ª—å—à–∏–º–∏ –¥–∞–Ω–Ω—ã–º–∏. <br><br> –ü–æ –∏—Ä–æ–Ω–∏–∏ —Å—É–¥—å–±—ã, —Å–∞–º—ã–º —Å—É—â–µ—Å—Ç–≤–µ–Ω–Ω—ã–º –≤–∫–ª–∞–¥–æ–º –°—Ç–æ—É–Ω–±—Ä–µ–π–∫–µ—Ä–∞ –≤ –æ–±–ª–∞—Å—Ç—å –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã—Ö –±–∞–∑ –¥–∞–Ω–Ω—ã—Ö –±—ã–ª–∞ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ ¬´–æ–±—â–µ–π –ø–∞–º—è—Ç–∏¬ª –ø–æ–¥ –Ω–∞–∑–≤–∞–Ω–∏–µ–º XPRS, —á—Ç–æ –æ–∑–Ω–∞—á–∞–ª–æ ¬´eXtended Postgres on RAID and Sprite¬ª. –í –Ω–∞—á–∞–ª–µ 1990-—Ö –≥–æ–¥–æ–≤ XPRS –±—ã–ª–∞ ¬´–ª–∏–≥–æ–π —Å–ø—Ä–∞–≤–µ–¥–ª–∏–≤–æ—Å—Ç–∏¬ª —Å–∏—Å—Ç–µ–º –ë–µ—Ä–∫–ª–∏: –æ–Ω–∞ –æ–±—ä–µ–¥–∏–Ω—è–µ—Ç –≤ —Å–æ–∫—Ä–∞—â–µ–Ω–Ω–æ–º –≤–∏–¥–µ —Å–∏—Å—Ç–µ–º—É Postgres –°—Ç–æ—É–Ω–±—Ä–µ–π–∫–µ—Ä–∞, —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—É—é –û–° Sprite –î–∂–æ–Ω–∞ –û—Å—Ç–µ—Ä—Ö–∞—É—Ç–∞ (John Ousterhout) –∏ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—É RAID-—Ö—Ä–∞–Ω–∏–ª–∏—â –î–µ–π–≤–∞ –ü–∞—Ç—Ç–µ—Ä—Å–æ–Ω–∞ (Dave Patterson) –∏ –†—ç–Ω–¥–∏ –ö–∞—Ü–∞ (Randy Katz). –ö–∞–∫ –∏ –¥–ª—è –º–Ω–æ–≥–∏—Ö –º–µ–∂—Ñ–∞–∫—É–ª—å—Ç–µ—Ç—Å–∫–∏—Ö —Ä–∞–±–æ—Ç, –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–∞ XPRS —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏ –æ–ø—Ä–µ–¥–µ–ª—è–ª–æ—Å—å –∞—Å–ø–∏—Ä–∞–Ω—Ç–∞–º–∏, –∫–æ—Ç–æ—Ä—ã–µ —Ä–∞–±–æ—Ç–∞–ª–∏ –Ω–∞–¥ –Ω–∏–º. –û–∫–∞–∑–∞–ª–æ—Å—å, —á—Ç–æ –æ—Å–Ω–æ–≤–Ω–æ–π –≤–∫–ª–∞–¥ –≤–Ω–µ—Å –í—ç–π –•–æ–Ω–≥, –∫–æ—Ç–æ—Ä—ã–π –Ω–∞–ø–∏—Å–∞–ª —Å–≤–æ—é –∫–∞–Ω–¥–∏–¥–∞—Ç—Å–∫—É—é –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏—é –ø–æ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ XPRS. –¢–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, –æ—Å–Ω–æ–≤–Ω—ã–º –≤–∫–ª–∞–¥–æ–º XPRS –≤ –ª–∏—Ç–µ—Ä–∞—Ç—É—Ä—É –∏ –∏–Ω–¥—É—Å—Ç—Ä–∏—é –±—ã–ª–∞ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤ –±–µ–∑ —Å—É—â–µ—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–∏—è –ø—Ä–æ–±–ª–µ–º, —Å–≤—è–∑–∞–Ω–Ω—ã—Ö —Å RAID –∏–ª–∏ Sprite. <br><br> <em>–ò–∑ —ç—Ç–∏—Ö —Ç—Ä–µ—Ö –ø—Ä–æ–µ–∫—Ç–æ–≤ –æ–≥—Ä–æ–º–Ω–æ–µ –≤–ª–∏—è–Ω–∏–µ –Ω–∞ –¥–∞–ª—å–Ω–µ–π—à–µ–µ –æ–∫–∞–∑–∞–ª–∏ Postgres –∏ RAID. Sprite –ª—É—á—à–µ –≤—Å–µ–≥–æ –ø–æ–º–Ω—è—Ç –ø–æ –∫–∞–Ω–¥–∏–¥–∞—Ç—Å–∫–æ–π –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–∏ –ú–µ–Ω–¥–µ–ª—è –†–æ–∑–µ–Ω–±–ª—é–º–∞ (Mendel Rosenblum) –æ —Ñ–∞–π–ª–æ–≤—ã—Ö —Å–∏—Å—Ç–µ–º–∞—Ö —Å –∂—É—Ä–Ω–∞–ª—å–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–π (Log Structured File Systems ‚Äî LFS), –∫–æ—Ç–æ—Ä–∞—è –Ω–µ –∏–º–µ–ª–∞ –Ω–∏—á–µ–≥–æ –ø—Ä–∏–º–µ—á–∞—Ç–µ–ª—å–Ω–æ –æ–±—â–µ–≥–æ —Å —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–º–∏ –æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–Ω—ã–º–∏ —Å–∏—Å—Ç–µ–º–∞–º–∏. –í—Å–µ —Ç—Ä–∏ –ø—Ä–æ–µ–∫—Ç–∞ —Å–æ–¥–µ—Ä–∂–∞–ª–∏ –Ω–æ–≤—ã–µ –∏–¥–µ–∏ –¥–ª—è –¥–∏—Å–∫–æ–≤–æ–≥–æ —Ö—Ä–∞–Ω–µ–Ω–∏—è, –ø–æ–º–∏–º–æ –≤–∏–¥–æ–∏–∑–º–µ–Ω–µ–Ω–∏—è –æ—Ç–¥–µ–ª—å–Ω—ã—Ö –∫–æ–ø–∏–π –ø–æ –º–µ—Å—Ç—É. LFS –∏ –º–µ–Ω–µ–¥–∂–µ—Ä —Ö—Ä–∞–Ω–∏–ª–∏—â–∞ Postgres –¥–æ–≤–æ–ª—å–Ω–æ –ø–æ—Ö–æ–∂–∏ –Ω–æ–≤—ã–º –æ—Ç–Ω–æ—à–µ–Ω–∏–µ–º –∫ –∂—É—Ä–Ω–∞–ª—É –∫–∞–∫ –∫ –æ—Å–Ω–æ–≤–Ω–æ–º—É —Ö—Ä–∞–Ω–∏–ª–∏—â—É –∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç—å—é –¥–æ—Ä–æ–≥–æ—Å—Ç–æ—è—â–µ–π —Ñ–æ–Ω–æ–≤–æ–π —Ä–µ–æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏. –û–¥–Ω–∞–∂–¥—ã —è –æ—Å—Ç–æ—Ä–æ–∂–Ω–æ –ø—Ä–æ—â—É–ø—ã–≤–∞–ª –°—Ç–æ—É–Ω–±—Ä–µ–π–∫–µ—Ä–∞ –Ω–∞ –ø—Ä–µ–¥–º–µ—Ç —Å–æ–ø–µ—Ä–Ω–∏—á–µ—Å—Ç–≤–∞ LFS –∏ Postgres –∏–ª–∏ –∞–∫–∞–¥–µ–º–∏—á–µ—Å–∫–∏—Ö ¬´–∂–∞—Ä–µ–Ω—ã—Ö —Ñ–∞–∫—Ç–æ–≤¬ª –æ–± –∏—Ö –≤–∑–∞–∏–º–æ–æ—Ç–Ω–æ—à–µ–Ω–∏—è—Ö, –Ω–æ —è —Ç–∞–∫ –∏ –Ω–µ —É–∑–Ω–∞–ª –æ—Ç –Ω–µ–≥–æ –Ω–∏—á–µ–≥–æ –∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ–≥–æ. –í–æ–∑–º–æ–∂–Ω–æ, –≤ —Ç–æ –≤—Ä–µ–º—è –≤ –ë–µ—Ä–∫–ª–∏ –∫—Ç–æ-—Ç–æ ¬´–º—É—Ç–∏–ª –≤–æ–¥—É¬ª.</em> <br><br> –í –ø—Ä–∏–Ω—Ü–∏–ø–µ, –ø–∞—Ä–∞–ª–ª–µ–ª–∏–∑–º ¬´–≤–∑—Ä—ã–≤–∞–µ—Ç¬ª –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ –ø–ª–∞–Ω–æ–≤ –æ–ø—Ç–∏–º–∏–∑–∞—Ç–æ—Ä–∞ –∑–∞–ø—Ä–æ—Å–æ–≤, —É–º–Ω–æ–∂–∞—è —Ç—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã –≤—ã–±–æ—Ä–∞, —Å–¥–µ–ª–∞–Ω–Ω—ã–µ –≤–æ –≤—Ä–µ–º—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –∑–∞–ø—Ä–æ—Å–æ–≤ (–¥–æ—Å—Ç—É–ø –∫ –¥–∞–Ω–Ω—ã–º, –∞–ª–≥–æ—Ä–∏—Ç–º—ã —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π, –ø–æ—Ä—è–¥–æ–∫ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π), –Ω–∞ –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ —Å–ø–æ—Å–æ–±—ã —Ä–∞—Å–ø–∞—Ä–∞–ª–ª–µ–ª–∏–≤–∞–Ω–∏—è –∫–∞–∂–¥–æ–≥–æ –≤–∞—Ä–∏–∞–Ω—Ç–∞ –≤—ã–±–æ—Ä–∞. –û—Å–Ω–æ–≤–Ω–∞—è –∏–¥–µ—è –Ω–∞–∑–≤–∞–Ω–Ω–æ–≥–æ –°—Ç–æ—É–Ω–±—Ä–µ–π–∫–µ—Ä–æ–º ¬´–æ–ø—Ç–∏–º–∏–∑–∞—Ç–æ—Ä–∞ –í—ç—è –•–æ–Ω–≥–∞¬ª –∑–∞–∫–ª—é—á–∞–ª–∞—Å—å –≤ —Ç–æ–º, —á—Ç–æ–±—ã —Ä–∞–∑–±–∏—Ç—å –ø—Ä–æ–±–ª–µ–º—É –Ω–∞ –¥–≤–µ: –∑–∞–ø—É—Å—Ç–∏—Ç—å —Ç—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω—ã–π –æ–ø—Ç–∏–º–∏–∑–∞—Ç–æ—Ä –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ –¥—É—Ö–µ System R –¥–ª—è –æ–¥–Ω–æ–≥–æ —É–∑–ª–∞, –∞ –∑–∞—Ç–µ–º ¬´—Ä–∞—Å–ø–∞—Ä–∞–ª–ª–µ–ª–∏—Ç—å¬ª –ø–æ–ª—É—á–∏–≤—à–∏–π—Å—è –ø–ª–∞–Ω, –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–≤ —Å—Ç–µ–ø–µ–Ω—å –ø–∞—Ä–∞–ª–ª–µ–ª–∏–∑–º–∞ –∏ —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ –∫–∞–∂–¥–æ–≥–æ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞, –∏—Å—Ö–æ–¥—è –∏–∑ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ —Å–∏—Å—Ç–µ–º—ã. –≠—Ç–æ—Ç –ø–æ–¥—Ö–æ–¥ —ç–≤—Ä–∏—Å—Ç–∏—á–µ–Ω, –Ω–æ –≤ –Ω–µ–º –ø–∞—Ä–∞–ª–ª–µ–ª–∏–∑–º –Ω–∞—Ä–∞—â–∏–≤–∞–µ—Ç —Å—Ç–æ–∏–º–æ—Å—Ç—å —Ç—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω–æ–π –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –∑–∞–ø—Ä–æ—Å–æ–≤ –∞–¥–¥–∏—Ç–∏–≤–Ω–æ, –∞ –Ω–µ –º—É–ª—å—Ç–∏–ø–ª–∏–∫–∞—Ç–∏–≤–Ω–æ. <br><br> –•–æ—Ç—è –æ–ø—Ç–∏–º–∏–∑–∞—Ç–æ—Ä –í—ç—è –•–æ–Ω–≥–∞ –±—ã–ª —Ä–∞–∑—Ä–∞–±–æ—Ç–∞–Ω –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ Postgres, –æ–Ω —Å—Ç–∞–ª —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–º –ø–æ–¥—Ö–æ–¥–æ–º –¥–ª—è –º–Ω–æ–≥–∏—Ö –æ–ø—Ç–∏–º–∏–∑–∞—Ç–æ—Ä–æ–≤ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ –æ—Ç—Ä–∞—Å–ª–∏. <br><br><h2>  2.6. –ü–æ–¥–¥–µ—Ä–∂–∫–∞ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —è–∑—ã–∫–æ–≤—ã—Ö –º–æ–¥–µ–ª–µ–π </h2><br> –°—Ä–µ–¥–∏ –∏–Ω—Ç–µ—Ä–µ—Å–æ–≤ –°—Ç–æ—É–Ω–±—Ä–µ–π–∫–µ—Ä–∞, –Ω–µ–æ–¥–Ω–æ–∫—Ä–∞—Ç–Ω–æ –≤–æ–∑–æ–±–Ω–æ–≤–ª—è—é—â–∏—Ö—Å—è —Å–æ –≤—Ä–µ–º–µ–Ω Ingres, –±—ã–ª –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –ø—Ä–∏–∫–ª–∞–¥–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è (API) —Å–∏—Å—Ç–µ–º—ã –±–∞–∑ –¥–∞–Ω–Ω—ã—Ö. –í —Å–≤–æ–∏ –ª–µ–∫—Ü–∏–∏ –∏–∑ —Å–µ—Ä–∏–∏ Database Systems (–°–∏—Å—Ç–µ–º—ã –±–∞–∑ –¥–∞–Ω–Ω—ã—Ö) –æ–Ω —á–∞—Å—Ç–æ –≤–∫–ª—é—á–∞–ª —è–∑—ã–∫ GEM –ö–∞—Ä–ª–æ –ó–∞–Ω–∏–æ–ª–æ (Carlo Zaniolo) –∫–∞–∫ —Ç–µ–º—É, –∫–æ—Ç–æ—Ä—É—é –≤–∞–∂–Ω–æ –ø–æ–Ω—è—Ç—å –ø–æ–±–æ—Ä–Ω–∏–∫–∞–º —Å–∏—Å—Ç–µ–º –±–∞–∑ –¥–∞–Ω–Ω—ã—Ö. –≠—Ç–æ—Ç –∏–Ω—Ç–µ—Ä–µ—Å –∫ —è–∑—ã–∫—É, –Ω–µ—Å–æ–º–Ω–µ–Ω–Ω–æ, –ø—Ä–∏–≤–µ–ª –µ–≥–æ –∫ –ø–∞—Ä—Ç–Ω–µ—Ä—Å—Ç–≤—É —Å –õ–∞—Ä—Ä–∏ –†–æ—É –≤ Postgres, —á—Ç–æ, –≤ —Å–≤–æ—é –æ—á–µ—Ä–µ–¥—å, –≥–ª—É–±–æ–∫–æ –ø–æ–≤–ª–∏—è–ª–æ –Ω–∞ –¥–∏–∑–∞–π–Ω –º–æ–¥–µ–ª–∏ –¥–∞–Ω–Ω—ã—Ö Postgres –∏ –µ–µ –æ–±—ä–µ–∫—Ç–Ω–æ-—Ä–µ–ª—è—Ü–∏–æ–Ω–Ω—ã–π –ø–æ–¥—Ö–æ–¥. –ò—Ö —Ä–∞–±–æ—Ç–∞ –±—ã–ª–∞ —Å–æ—Å—Ä–µ–¥–æ—Ç–æ—á–µ–Ω–∞ –≤ –æ—Å–Ω–æ–≤–Ω–æ–º –Ω–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è—Ö –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –±–æ–ª—å—à–∏–º –æ–±—ä–µ–º–æ–º –¥–∞–Ω–Ω—ã—Ö –∏–∑ –∫–æ–º–º–µ—Ä—á–µ—Å–∫–æ–π —Å—Ñ–µ—Ä—ã, –≤–∫–ª—é—á–∞—é—â–∏—Ö –∫–∞–∫ –æ–±—Ä–∞–±–æ—Ç–∫—É –¥–µ–ª–æ–≤–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏, —Ç–∞–∫ –∏ –Ω–æ–≤—ã–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è, —Ç–∞–∫–∏–µ –∫–∞–∫ –°–ê–ü–†/–ê–°–£–ü –∏ –ì–ò–°. <br><br> –û–¥–Ω–æ–π –∏–∑ –ø—Ä–æ–±–ª–µ–º, –∫–æ—Ç–æ—Ä–∞—è –±—ã–ª–∞ –Ω–∞–≤—è–∑–∞–Ω–∞ –≤ —Ç–æ –≤—Ä–µ–º—è –°—Ç–æ—É–Ω–±—Ä–µ–π–∫–µ—Ä—É, –±—ã–ª–∞ –∏–¥–µ—è ¬´—Å–ø—Ä—è—Ç–∞—Ç—å¬ª –≥—Ä–∞–Ω–∏—Ü—ã –º–µ–∂–¥—É –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏—è–º–∏ —è–∑—ã–∫–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è –∏ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ–º –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö. –†–∞–∑–ª–∏—á–Ω—ã–µ –∫–æ–Ω–∫—É—Ä–∏—Ä—É—é—â–∏–µ –∏—Å—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ –ø—Ä–æ–µ–∫—Ç—ã –∏ –∫–æ–º–ø–∞–Ω–∏–∏, –∏—Å—Å–ª–µ–¥—É—é—â–∏–µ –æ–±—ä–µ–∫—Ç–Ω–æ-–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö (Object-Oriented Databases ‚Äî OODB), –±—ã–ª–∏ –Ω–∞—Ü–µ–ª–µ–Ω—ã –Ω–∞ —Ç–∞–∫ –Ω–∞–∑—ã–≤–∞–µ–º—É—é ¬´–ø–æ—Ç–µ—Ä—é —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è¬ª –º–µ–∂–¥—É –∏–º–ø–µ—Ä–∞—Ç–∏–≤–Ω—ã–º–∏ –æ–±—ä–µ–∫—Ç–Ω–æ-–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ —è–∑—ã–∫–∞–º–∏ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è, —Ç–∞–∫–∏–º–∏ –∫–∞–∫ Smalltalk, C++ –∏ Java, –∏ –¥–µ–∫–ª–∞—Ä–∞—Ç–∏–≤–Ω–æ–π —Ä–µ–ª—è—Ü–∏–æ–Ω–Ω–æ–π –º–æ–¥–µ–ª—å—é. –ò–¥–µ—è OODB —Å–æ—Å—Ç–æ—è–ª–∞ –≤ —Ç–æ–º, —á—Ç–æ–±—ã —Å–¥–µ–ª–∞—Ç—å –æ–±—ä–µ–∫—Ç—ã —è–∑—ã–∫–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è –ø—Ä–∏ –∂–µ–ª–∞–Ω–∏–∏ –ø–æ–º–µ—á–∞–µ–º—ã–º–∏ –∫–∞–∫ ¬´–ø–æ—Å—Ç–æ—è–Ω–Ω—ã–µ¬ª –∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º—ã–º–∏ –≤—Å—Ç—Ä–æ–µ–Ω–Ω–æ–π –°–£–ë–î. Postgres –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–ª —Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤–ª–æ–∂–µ–Ω–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤ –∏ –∞–±—Å—Ç—Ä–∞–∫—Ç–Ω—ã—Ö —Ç–∏–ø–æ–≤ –¥–∞–Ω–Ω—ã—Ö, –Ω–æ –µ–≥–æ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å, –æ—Å–Ω–æ–≤–∞–Ω–Ω—ã–π –Ω–∞ –¥–µ–∫–ª–∞—Ä–∞—Ç–∏–≤–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–∞—Ö –≤ —Ä–µ–ª—è—Ü–∏–æ–Ω–Ω–æ–º —Å—Ç–∏–ª–µ, –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–ª –Ω–µ–µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –¥–ª—è –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç–∞ –æ–±—Ä–∞—â–µ–Ω–∏—è –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö (—Ç—Ä–µ–±–æ–≤–∞–ª –æ—Ç –Ω–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –¥–µ–∫–ª–∞—Ä–∞—Ç–∏–≤–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤), –∫–æ—Ç–æ—Ä—ã–µ –∫ —Ç–æ–º—É –∂–µ –±—ã–ª–∏ –¥–æ—Ä–æ–≥–æ—Å—Ç–æ—è—â–∏–º–∏ (—Ç—Ä–µ–±–æ–≤–∞–ª–∏ —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–æ–≥–æ —Ä–∞–∑–±–æ—Ä–∞ –∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏). –ß—Ç–æ–±—ã –∫–æ–Ω–∫—É—Ä–∏—Ä–æ–≤–∞—Ç—å —Å –ø–æ—Å—Ç–∞–≤—â–∏–∫–∞–º–∏ OODB, Postgres –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–∏–ª —Ç–∞–∫ –Ω–∞–∑—ã–≤–∞–µ–º—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å ¬´–±—ã—Å—Ç—Ä–æ–≥–æ –ø—É—Ç–∏¬ª (Fast Path): –ø–æ —Å—É—Ç–∏ API C/C++ –∫ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–º—É —É—Å—Ç—Ä–æ–π—Å—Ç–≤—É —Ö—Ä–∞–Ω–µ–Ω–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö. –≠—Ç–æ –ø–æ–∑–≤–æ–ª–∏–ª–æ Postgres –∏–º–µ—Ç—å —Å—Ä–µ–¥–Ω—é—é –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –ø–æ –∞–∫–∞–¥–µ–º–∏—á–µ—Å–∫–∏–º —Ç–µ—Å—Ç–∞–º OODB, –Ω–æ —Ç–∞–∫ –Ω–∏–∫–æ–≥–¥–∞ –∏ –Ω–µ —Ä–µ—à–∏–ª–æ –∑–∞–¥–∞—á–∏ –ø–æ–∑–≤–æ–ª–∏—Ç—å –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç–∞–º –Ω–∞ —Ä–∞–∑–Ω—ã—Ö —è–∑—ã–∫–∞—Ö –∏–∑–±–µ–∂–∞—Ç—å –ø—Ä–æ–±–ª–µ–º—ã –ø–æ—Ç–µ—Ä–∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è. –í–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ –°—Ç–æ—É–Ω–±—Ä–µ–π–∫–µ—Ä –Ω–∞–≤–µ—Å–∏–ª –Ω–∞ –º–æ–¥–µ–ª—å Postgres —è—Ä–ª—ã–∫ ¬´–æ–±—ä–µ–∫—Ç–Ω–æ-—Ä–µ–ª—è—Ü–∏–æ–Ω–Ω–æ–π¬ª –∏ –ø—Ä–æ—Å—Ç–æ –æ–±–æ—à–µ–ª —Å—Ç–æ—Ä–æ–Ω–æ–π –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–Ω–æ-–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –±–∞–∑ –∫–∞–∫ –Ω–µ–≤—ã–≥–æ–¥–Ω—ã–π —Ä—ã–Ω–æ–∫ (zero-billion dollar market). –°–µ–≥–æ–¥–Ω—è –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏ –≤—Å–µ –∫–æ–º–º–µ—Ä—á–µ—Å–∫–∏–µ —Å–∏—Å—Ç–µ–º—ã —Ä–µ–ª—è—Ü–∏–æ–Ω–Ω—ã—Ö –±–∞–∑ –¥–∞–Ω–Ω—ã—Ö —è–≤–ª—è—é—Ç—Å—è ¬´–æ–±—ä–µ–∫—Ç–Ω–æ-—Ä–µ–ª—è—Ü–∏–æ–Ω–Ω—ã–º–∏¬ª —Å–∏—Å—Ç–µ–º–∞–º–∏ –±–∞–∑ –¥–∞–Ω–Ω—ã—Ö. <br><br> –≠—Ç–æ –æ–∫–∞–∑–∞–ª–æ—Å—å —Ä–∞–∑—É–º–Ω—ã–º —Ä–µ—à–µ–Ω–∏–µ–º. –°–µ–≥–æ–¥–Ω—è –Ω–∏ –æ–¥–∏–Ω –∏–∑ –ø—Ä–æ–¥—É–∫—Ç–æ–≤ OODB –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –≤ —Å–≤–æ–µ–π –∑–∞–¥—É–º–∞–Ω–Ω–æ–π —Ñ–æ—Ä–º–µ, –∏ –∏–¥–µ—è ¬´–ø–æ—Å—Ç–æ—è–Ω–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤¬ª –≤ —è–∑—ã–∫–∞—Ö –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è –±—ã–ª–∞ –±–æ–ª—å—à–µ–π —á–∞—Å—Ç—å—é –æ—Ç–±—Ä–æ—à–µ–Ω–∞. –í –æ—Ç–ª–∏—á–∏–µ –æ—Ç —ç—Ç–æ–≥–æ, —à–∏—Ä–æ–∫–æ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Å–ª–æ–µ–≤ –æ–±—ä–µ–∫—Ç–Ω–æ-—Ä–µ–ª—è—Ü–∏–æ–Ω–Ω–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è (object-relational mapping ‚Äî ORM, –ø–æ–¥–ø–∏—Ç—ã–≤–∞–µ–º–æ–µ —Ä–∞–Ω–Ω–∏–º–∏ —Ä–∞–±–æ—Ç–∞–º–∏, —Ç–∞–∫–∏–º–∏ –∫–∞–∫ Java Hibernate –∏ Ruby on Rails), —á—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –≥–ª–∞–¥–∫–æ ¬´–ø–æ–¥–≥–æ–Ω—è—Ç—å¬ª –¥–µ–∫–ª–∞—Ä–∞—Ç–∏–≤–Ω—ã–µ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø–æ—á—Ç–∏ –ø–æ–¥ –ª—é–±–æ–π –∏–º–ø–µ—Ä–∞—Ç–∏–≤–Ω—ã–π –æ–±—ä–µ–∫—Ç–Ω–æ-–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —è–∑—ã–∫ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ –±–∏–±–ª–∏–æ—Ç–µ–∫. –≠—Ç–æ—Ç –ø–æ–¥—Ö–æ–¥ –Ω–∞ —É—Ä–æ–≤–Ω–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –∫–∞–∫ –æ—Ç OODB, —Ç–∞–∫ –∏ –æ—Ç –æ–±—ä–µ–∫—Ç–Ω–æ-—Ä–µ–ª—è—Ü–∏–æ–Ω–Ω—ã—Ö –±–∞–∑ –¥–∞–Ω–Ω—ã—Ö –ø–æ –°—Ç–æ—É–Ω–±—Ä–µ–π–∫–µ—Ä—É. –ö—Ä–æ–º–µ —Ç–æ–≥–æ, –ª–µ–≥–∫–æ–≤–µ—Å–Ω—ã–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞ ¬´–∫–ª—é—á-–∑–Ω–∞—á–µ–Ω–∏–µ¬ª —Ç–∞–∫–∂–µ —É—Å–ø–µ—à–Ω–æ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –∫–∞–∫ –≤ –±–µ—Å—Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–æ–Ω–Ω–æ–π, —Ç–∞–∫ –∏ –≤ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–æ–Ω–Ω–æ–π —Ñ–æ—Ä–º–µ. –ò—Ö –ø–µ—Ä–≤–æ–æ—Ç–∫—Ä—ã–≤–∞—Ç–µ–ª–µ–º –±—ã–ª–∞ –∞—Å–ø–∏—Ä–∞–Ω—Ç–∫–∞ –°—Ç–æ—É–Ω–±—Ä–µ–π–∫–µ—Ä–∞ –ú–∞—Ä–≥–æ –ó–µ–ª—å—Ü–µ—Ä (Margo Seltzer), –∫–æ—Ç–æ—Ä–∞—è —Ä–∞–±–æ—Ç–∞–ª–∞ –Ω–∞–¥ –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö Berkeley DB –≤ —Ä–∞–º–∫–∞—Ö —Å–≤–æ–µ–π –∫–∞–Ω–¥–∏–¥–∞—Ç—Å–∫–æ–π –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–∏ –≤ —Ç–æ –∂–µ –≤—Ä–µ–º—è, —á—Ç–æ –∏ –≥—Ä—É–ø–ø–∞ Postgres, —á—Ç–æ –ø—Ä–µ–¥–≤–æ—Å—Ö–∏—Ç–∏–ª–æ —Ä–æ—Å—Ç —Ç–∞–∫–∏—Ö —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã—Ö NoSQL-—Ö—Ä–∞–Ω–∏–ª–∏—â ¬´–∫–ª—é—á-–∑–Ω–∞—á–µ–Ω–∏–µ¬ª, –∫–∞–∫ Dynamo, MongoDB –∏ Cassandra. <br><br><h1> 3. –í–ª–∏—è–Ω–∏–µ –Ω–∞ –ø—Ä–æ–≥—Ä–∞–º–º–Ω–æ–µ –æ–±–µ—Å–ø–µ—á–µ–Ω–∏–µ </h1><br><h2>  3.1. –û—Ç–∫—Ä—ã—Ç—ã–π –∏—Å—Ö–æ–¥–Ω—ã–π –∫–æ–¥ </h2><br>  Postgres has always been an open source project with even releases, but for a long time at first it was intended to be used in research, not in production. <br><br>  As the Postgres research project collapsed, two students of Stonebreaker, Andrew Yu and Jolly Chen, modified the system's parser to replace the original Postquel language with an extensible SQL.  The first release of Postgres that supports SQL was Postgres95, and the next one was named PostgreSQL. <br><br>  The open source development team became interested in PostgreSQL and ‚Äúadopted‚Äù it even when the interests of the rest of the Berkeley team changed.  The core PostgreSQL developers group has remained relatively stable over time, and the open source project has become highly developed.  Initially, efforts were focused on the stability of the code and the functionality visible to the user, but over time, the open source community has significantly changed and improved the core of the system, from the optimizer to access methods and the underlying transaction and storage system.  Since the mid-1990s, a very small part of the internal components of PostgreSQL came from the academic group at Berkeley.  Her last contribution was probably my GiST implementation in the second half of the 1990s, but even it was substantially rewritten and cleaned up by volunteers from the open source community (in this case, from Russia).  The part of the open source community that works on PostgreSQL deserves the greatest praise for implementing an orderly process that has served for decades to create a highly efficient and long-term project. <br><br>  Although things have changed in 25 years, the basic architecture of PostgreSQL remains very similar to the Postgres university releases of the early 1990s, and developers familiar with the current PostgreSQL source code will easily read the Postgres 3.1 source code (1991).  Everything, from the source code directory structure to the process structure and data structure, remains remarkably similar.  The code from the Postgres team at Berkeley had excellent backbone. <br><br>  Today, PostgreSQL is, without a doubt, the most high-performance open source database, and it supports the functionality that is often missing in commercial products.  It is also (according to one influential rating site) the most widely used independent open source database in the world, and its influence continues to grow: in 2017 and 2018, it was the database with the fastest growing popularity in the world [ <a href="https://habr.com/ru/company/postgrespro/blog/438890/">DE19c</a> ].  PostgreSQL is used in a wide variety of industries and applications, which is not surprising, given its focus on wide opportunities. <br><br>  <em>According to DB-Engines, PostgreSQL is today the fourth most popular DBMS in the world, after Oracle, MySQL and MS SQL Server, all three being offered by specific companies (MySQL was acquired by Oracle many years ago) [ <a href="https://habr.com/ru/company/postgrespro/blog/438890/">DE19a</a> ].</em>  <em>Ranking rules are discussed in the description of the DB-Engines [ <a href="https://habr.com/ru/company/postgrespro/blog/438890/">DE19b</a> ] ranking methodology.</em> <br><br>  Heroku is a cloud-based SaaS provider that is now part of Salesforce.  Postgres was introduced in Heroku in 2010 as the default database for its platform.  Heroku chose Postgres for reliability.  With support from Heroku, larger application development platforms, such as Ruby on Rails and Python for Django, have begun to recommend Postgres as the default database. <br><br>  Today, PostgreSQL supports an extension infrastructure that makes it easy to add additional features to the system through user-defined functions and associated modifications.  Now there is an ecosystem of PostgreSQL extensions, akin to the concept of llustra DataBlade extension packs, but with open source.  The most interesting extensions include, for example, the Apache MADlib library for machine learning in the SQL interface and the Citus library for parallel query execution. <br><br>  One of the most interesting open source applications built on Postgres is the PostGIS geographic information system, which uses many of the features of Postgres that initially inspired Stonebraker to launch the project. <br><br><h2>  3.2.  Commercial introduction </h2><br>  PostgreSQL has long been an attractive starting point for creating commercial database systems, given its use under an ‚Äúall-pervading‚Äù open source software license, reliable code, flexibility, and extensive functionality.  Summarizing the acquisition costs listed below, we see that Postgres has generated over $ 2.6 billion in acquisition costs. <br><br>  <em>Please note that this is a measure in dollars of real financial transactions and is much more significant than the values ‚Äã‚Äãthat are often used in high technology.</em>  <em>Figures in the billions are often used to describe the assessed value of shareholdings, but often overestimated by a factor of 10 or more compared to the present value in the hope of its future value.</em>  <em>The purchase transaction dollars of a company measure its actual market value at the time of the acquisition.</em>  <em>It is fair to say that Postgres has created over $ 2.6 billion in real commercial value.</em> <br><br>  Many commercial efforts related to PostgreSQL have focused on what is probably its main limitation: the ability to scale to a parallel architecture without sharing resources. <br><br>  <em>PostgreSQL parallelization requires a fair amount of work, but a highly doable little experienced team.</em>  <em>Today, PostgreSQL open source industry branches, such as Greenplum and CitusDB, provide this capability.</em>  <em>It is a pity that PostgreSQL was not properly parallelized in open source much earlier.</em>  <em>If in the early 2000s, PostgreSQL had been expanded in open source to support an architecture without resource sharing, it is possible that the direction of big data with open source would have evolved quite differently and more efficiently.</em> <br><br><ol><li>  Illustra was Stonebreyker‚Äôs second major startup, founded in 1992 to commercialize Postgres, since RTI brought Ingres to the market. <br><br>  <em>Illustra was actually the third name suggested for the company.</em>  <em>Continuing the theme of painting, given the name Ingres, Illustra was originally called Miro.</em>  <em>Due to trademark issues, the name was changed to Montage, but it also ran into problems with trademarks.</em> <br><br>  The founding team included some of the core of the Postgres team, including recent graduate student Wei Hong and then chief programmer Jeff Meredith, as well as Ingres graduates Paula Hawthorn and Michael Ubell.  Postgres undergraduate Mike Olson joined shortly after founding, and I worked at Illustra in optimizing costly functions as part of my PhD work.  There were three major works in Illustra: expanding SQL92 to support custom types and functions, such as Postquel, make the Postgres code base robust enough for commercial use, and stimulate the market for expandable database servers with examples of DataBlade extensions ‚Äî specialized plug-in components of data types and functions.  Illustra was acquired by Informix in 1997 at an estimated cost of $ 400 million [ <a href="https://habr.com/ru/company/postgrespro/blog/438890/">Mon96</a> ], and its DataBlade architecture was integrated into the more well-established Informix request processing code as Informix Universal Server. <br></li><li>  Netezza was a startup founded in 1999 that branched PostgreSQL code to create a high-performance parallel processing mechanism for requests for custom-made equipment based on FPGA.  Netezza was a fairly successful independent company that conducted the first public sale of shares in 2007.  It was eventually acquired by IBM for $ 1.7 billion [ <a href="https://habr.com/ru/company/postgrespro/blog/438890/">IBM10</a> ]. <br></li><li>  Greenplum made the first attempt to offer a parallel, horizontally scalable version of PostgreSQL without resource sharing.  Founded in 2003, Greenplum was branched from the PostgreSQL public distribution, but largely preserved the PostgreSQL API, including the API for user-defined functions.  In addition to parallelization, Greenplum has expanded PostgreSQL with an alternative, high-performance, compressed column repository and parallel query-based optimizer of rules called Orca.  Greenplum was acquired by EMC in 2010 for $ 300 million [ <a href="https://habr.com/ru/company/postgrespro/blog/438890/">Mal10</a> ], and in 2012 EMC incorporated Greenplum into its subsidiary, Pivotal.  In 2015, Pivotal decided to release open source Greenplum and Orca again.  One of Greenplum's Postgres API optimization achievements was the MADlib library for machine learning in SQL [ <a href="https://habr.com/ru/company/postgrespro/blog/438890/">HRS + 12</a> ].  MADlib lives today as an Apache project.  Another interesting open source project based on Greenplum is Apache HAWQ, developed by Pivotal, which runs the ‚Äúupper half‚Äù of Greenplum (i.e., the parallel query handler and PostgreSQL extensibility application programming interfaces) over big data storages such as Hadoop file system. <br></li><li>  EnterpriseDB was created in 2004 as an open source software business that sells PostgreSQL in both basic and advanced versions and provides related services to corporate clients.  A key feature of the improved EnterpriseDB Advanced Server is database compatibility with Oracle, which ensures the migration of applications from Oracle. <br></li><li>  Aster Data was founded in 2005 by two Stanford students to create a parallel analytics engine.  Its main single-node engine was based on PostgreSQL.  Aster focused on graph queries and analytics packages based on user-defined functions that could be programmed using the SQL or MapReduce interface.  Aster Data was acquired by Teradata in 2011 for $ 263 million [ <a href="https://habr.com/ru/company/postgrespro/blog/438890/">Sho11</a> ].  Although Teradata has never integrated Aster into its core parallel database engine, it still supports Aster as a standalone product for use cases outside the main Teradata data warehouse market. <br></li><li>  ParAccel was founded in 2006, selling a parallel version of PostgreSQL with column storage without resource sharing.  ParAccel has extended the Postgres optimizer with new heuristics for queries with many connections.  In 2011, Amazon invested in ParAccel, and in 2012 announced AWS Redshift, a data warehouse as a service with deployment in a public cloud based on ParAccel technology.  In 2013, ParAccel was acquired by Actian (which also acquired Ingres) for an undisclosed amount of the transaction, which means that this was not a material expense for Actian.  Meanwhile, the AWS Redshift offer was a huge success for Amazon ‚Äî for many years it was Amazon‚Äôs fastest growing data warehousing service, and many believe that it is ready to take long-existing data warehousing products, such as Teradata and Oracle Exadata, out of business.  In this sense, Postgres can achieve its ultimate dominance in the cloud. <br></li><li>  CitusDB <em>(CitusDB is the name of the DBMS; the company is called Citus Data. - Note.)</em> Was founded in 2010 to offer a parallel implementation of PostgreSQL without resource sharing.  Although it started as a PostgreSQL branch, since 2016 CitusDB has been implemented through the PostgreSQL open extensions API and can be installed into the basic PostgreSQL installation.  Since 2016, CitusDB extensions are available in open source. <br></li></ol><br><h1>  4. Lessons </h1><br>  You can learn a lot from Postgres success, some of which are challenging conventional wisdom. <br><br>  The lesson I‚Äôm learning of a higher order is that Postgres challenged the ‚ÄúSecond System Effect‚Äù syndrome by Fred Brooks [ <a href="https://habr.com/ru/company/postgrespro/blog/438890/">Bro75</a> ].  Brooks argued that after the successful first system, designers often create a second one that fails because of overloading with opportunities and ideas.  Postgres was Stonebreyker‚Äôs second system, and it certainly was full of opportunities and ideas.  The system also successfully prototyped many ideas, while delivering a software infrastructure that brought many ideas to a successful conclusion.  This was not an accident - at its core, Postgres was designed with the possibility of extensibility, and this design was well thought out.  With expandability as the core of the architecture, the opportunity to be creative and to worry less about frameworks appeared: you can try different extensions and let the strongest win.  Done well, the ‚Äúsecond system‚Äù is not doomed.  She benefits from trust, favorite projects and aspirations that have emerged during the use of the first system.  This is an early architectural lesson from a more "server-oriented" school of database development that challenges the well-established view of the "component-oriented" school of operating system development. <br><br>  Another lesson is that the emphasis on universality, ‚Äúone size fits all‚Äù, can be a winning approach for both research and practice.  However, the Stonebreaker since MIT <em>(In 2001, Stonebreyker took the position of a computer science professor at the Massachusetts Institute of Technology (MIT). - Approx. Trans.)</em> Made a stir in the world of databases in the early 2000s with the thesis ‚Äúone size is not suitable for everyone‚Äù.  Under this banner, he launched a flotilla of important projects and start-ups, but none of them could scale with Postgres.  It seems that the Stonebreaker of the time of Berkeley is challenging the later experience of the Stonebreaker of the times of MIT, and I see no problems in that. <br><br>  <em>As Emerson (Ralph Waldo Emerson) said, "a stupid sequence is a scarecrow of small minds."</em> <br><br>  Of course, there is wisdom in the motto ‚Äúone size doesn‚Äôt suit everybody‚Äù (you can always find modest markets for non-standard solutions), but the success of the system, which is Berkeley‚Äôs Stonebreaker card, far beyond its original goals, shows that the overwhelming majority of problems with databases data is completely solved using a good general purpose architecture.  In addition, the design of this architecture in itself is a technological challenge and achievement.  In the end, as in most scientific and technical debates, there is not only one good way to do something.  Both Stonebreakers have something to teach us.  But by nature I am still a fan of the wider program that the Stonebreaker of the time of Berkeley adopted. <br><br>  The last lesson I learn from Postgres is the unpredictable potential that can be found in the open source you are exploring.  In his Turing lecture, Stonebriker talks about the ‚Äúintuitive insight‚Äù of the PostgreSQL system, which is successfully developed in open source code, mainly due to people not from Stonebriker‚Äôs environment.  Here is a quote that sounds remarkably modest: <br><blockquote>  A team of volunteers who have picked up the project, none of which has anything to do with me or Berkeley, has been watching this open source system since 1995.  The Postgres system, which you get from the Internet, is the result of this command.  This is open source at its best, and I just want to mention that I have nothing to do with this and with this group of people to whom we are all in a huge debt.  [ <a href="https://habr.com/ru/company/postgrespro/blog/438890/">Sto14</a> ] <br></blockquote>  I‚Äôm sure that all of us who wrote open source would like to see such "intuitive insight" come to us.  But the point is not only in ‚Äúintuitive foresight‚Äù.  The source of luck is undoubtedly rooted in the aspirations, breadth and insight of Stonebreyker in the project and in the team, which he oversaw the creation of the prototype Postgres.  If there is any lesson in it, it can be like this: ‚Äúdo something important and let it go‚Äù.  It seems to me (learning from Stonebreaker) that you cannot miss a single part of this lesson. <br><br><h1>  5. Thanks </h1><br>  I‚Äôm grateful to my old Postgres buddies Wei Hong, Jeff Meredith and Mike Olson for their memories and information, as well as Craig Kerstiens for his contribution to modern PostgreSQL. <br><br><h1>  Literature </h1><br><ul><li><a name="Bro75"></a>  [Bro75] Frederick P Brooks.  The mythical man-month, 1975. </li><li><a name="Bro19"></a>  [Bro19] Michael L. Brodie, editor.  Making Databases Work.  Morgan &amp; Claypool, 2019. </li><li><a name="DE19a"></a>  [DE19a] DB-Engines.  DB-Engines ranking, 2019. <a href="https://db-engines.com/en/ranking">db-engines.com/en/ranking</a> .  (Last accessed January 4, 2019). </li><li><a name="DE19b"></a>  [DE19b] DB-Engines.  Method of calculating the scores for the DB-Engines ranking, 2019. <a href="https://db-engines.com/en/ranking_definition">db-engines.com/en/ranking_definition</a> (Last accessed January 4, 2019). </li><li><a name="DE19c"></a>  [DE19c] DB-Engines.  PostgreSQL is the DBMS of the year 2018, January 2019. <a href="https://db-engines.com/en/blog_post/79">db-engines.com/en/blog_post/79</a> (Last accessed January 4, 2019). </li><li><a name="DS08"></a>  [DS08] David DeWitt and Michael Stonebraker.  Mapreduce: A major step backwards.  The Database Column, 1:23, 2008. </li><li><a name="Gut84"></a>  [Gut84] Antonin Guttman.  R-trees: A dynamic index structure for spatial searching.  In Proceedings of the 1984 ACM SIGMOD International Conference on Data Management, SIGMOD '84, pages 47‚Äì57, New York, NY, USA, 1984. ACM. </li><li><a name="HKM02"></a>  [HKM <sup>+</sup> 02] Joseph M. Hellerstein, Elias Koutsoupias, Daniel P. Miranker, Christos H. Papadimitriou, and Vasilis Samoladas.  Bounds for range queries.  J. ACM, 49 (1): 35‚Äì55, January 2002. </li><li><a name="HNP95"></a>  [HNP95] Joseph M. Hellerstein, Jeffrey F. Naughton, and Avi Pfeffer.  Generalized search trees for database systems.  International Conference on Very Large Data Bases, VLDB '95, pages 562‚Äì573, San Francisco, CA, USA, 1995. Morgan Kaufmann Publishers Inc. </li><li><a name="HRS12"></a>  [HRS <sup>+</sup> 12] Joseph M Hellerstein, Christoper Re, Florian Schoppmann, Daisy Zhe Wang, Eugene Fratkin, Aleksander Gorajek, Kee Siong Ng, Caleb Welton, Xixuan Feng, Kun Li, et al.  The MADlib analytics library: or MAD skills, the SQL.  Proceedings of the VLDB Endowment, 5 (12): 1700‚Äì1711, 2012. </li><li><a name="IBM10"></a>  [IBM10] IBM to acquire Netezza, September 2010. <a href="http://www-03.ibm.com/press/us/en/pressrelease/32514.wss">www-03.ibm.com/press/us/en/pressrelease/32514.wss#release</a> (Last accessed January 22, 2018). </li><li><a name="KMH97"></a>  [KMH97] Marcel Kornacker, C. Mohan, and Joseph M. Hellerstein.  Concurrency and generalized search trees.  ACM SIGMOD International Conference on Data Management, SIGMOD '97, pages 62‚Äì72, New York, NY, USA, 1997. ACM. </li><li><a name="Mal10"></a>  [Mal10] Om Malik.  Big Data = Big Money: EMC Buys Greenplum.  In GigaOm, July 2010. <a href="https://gigaom.com/2010/07/06/emc-buys-greenplum/">gigaom.com/2010/07/06/emc-buys-greenplum</a> . </li><li><a name="Mon96"></a>  [Mon96] John Monroe.  Informix acquires illustra for complex data management.  In Federal Computer Week, January 1996. </li><li><a name="OFS83"></a>  [OFS83] James Ong, Dennis Fogg, and Michael Stonebraker.  Implementation of data abstraction in the relational database system ingres.  ACM Sigmod Record, 14 (1): 1‚Äì14, 1983. </li><li><a name="Ols93"></a>  [Ols93] Michael A. Olson.  Inversion of file system.  1993. </li><li><a name="SAHR84"></a>  [SAHR84] Michael Stonebraker, Erika Anderson, Eric Hanson, and Brad Rubenstein.  Quel as a data type. In Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data, SIGMOD '84, pages 208‚Äì214, New York, NY, USA, 1984. ACM. </li><li><a name="Sho11"></a> [Sho11] Erick Shonfeld. Big pay day for big data. teradata buys aster data for $263 million. In TechCrunch, May 2011. <a href="https://techcrunch.com/2011/03/03/teradata-buys-aster-data-263-million/">techcrunch.com/2011/03/03/teradata-buys-aster-data-263-million</a> (Last accessed January 22, 2018). </li><li><a name="SHWK76"></a> [SHWK76] Michael Stonebraker, Gerald Held, Eugene Wong, and Peter Kreps. The design and implementation of ingres. ACM Transactions on Database Systems (TODS), 1(3):189‚Äì222, 1976. </li><li><a name="SK91"></a> [SK91] Michael Stonebraker and Greg Kemnitz. The postgres next generation database management system. Commun. ACM, 34(10):78‚Äì92, October 1991. </li><li><a name="SR86"></a> [SR86] Michael Stonebraker and Lawrence A. Rowe. The design of postgres. In Proceedings of the 1986 ACM SIGMOD International Conference on Management of Data, SIGMOD '86, pages 340‚Äì355, New York, NY, USA, 1986. ACM. </li><li><a name="SRG83"></a> [SRG83] M Stonebraker, B Rubenstein, and A Guttman. Application of abstract data types and abstract indices to cad bases. IEEE Trans, on Software Engineering, 1983. </li><li><a name="Sto86"></a> [Sto86] Michael Stonebraker. The case for shared nothing. IEEE Database Eng. Bull., 9(1):4‚Äì9, 1986. </li><li><a name="Sto87"></a> [Sto87] Michael Stonebraker. The design of the postgres storage system. In Proceedings of the 13th International Conference on Very Large Data Bases, VLDB '87, pages 289‚Äì300, San Francisco, CA, USA, 1987. Morgan Kaufmann Publishers Inc. </li><li><a name="Sto95"></a> [Sto95] Michael Stonebraker. An overview of the sequoia 2000 project. Digital Technical Journal, 7(3):39‚Äì49, 1995. </li><li><a name="Sto14"></a> [Sto14] Michael Stonebraker. The land sharks are on the squawk box, 2014. <a href="https://www.acm.org/turing-lecture-stonebraker">www.acm.org/turing-lecture-stonebraker</a> (Last accessed January 4, 2019). </li></ul></div><p>Source: <a href="https://habr.com/ru/post/438890/">https://habr.com/ru/post/438890/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>