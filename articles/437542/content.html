<div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/qg/pm/pf/qgpmpfivqp5xqw2c8-qvxjp4-dq.jpeg"><br><br>  Once again, driving a car through my native city and going around the next hole, I thought: are there such “good” roads everywhere in our country and I decided - we need to objectively evaluate the situation with the quality of roads in our country. <br><a name="habracut"></a><br><h2>  Task formalization </h2><br>  In Russia, the requirements for the quality of roads are described in GOST R 50597-2017 “Roads and streets.  Requirements for the operational state, acceptable under the terms of road safety.  Control methods".  This document defines the requirements for roadway coverage, roadsides, dividing lanes, sidewalks, footpaths, etc., as well as establishes the types of damage. <br><br>  Since the task of determining all the parameters of the roads is quite extensive, I decided to narrow it down for myself and dwell only on the task of determining the roadway coverage defects.  In GOST R 50597-2017, the following defects in roadway coverage are distinguished: <br><br><ul><li>  potholes </li><li>  breaks </li><li>  drawdowns </li><li>  shifts </li><li>  combs </li><li>  track </li><li>  bleeding binder </li></ul><br>  Identifying these defects I decided to do. <br><br><h2>  Dataset collection </h2><br>  Where can I get photographs that show fairly large sections of the roadway, and even with reference to geolocation?  The answer came to the rhinestone - panoramas on Yandex (or Google) maps, however, looking a bit, I found some more alternative options: <br><br><ul><li>  issuance of search engines on the pictures for relevant requests; </li><li>  photos on the sites for receiving complaints (Rosyama, Angry citizen, Dobrodel, etc.) </li><li>  on Opendatascience suggested a project for detecting road defects with marked datasets - <a href="https://github.com/sekilab/RoadDamageDetector">github.com/sekilab/RoadDamageDetector</a> </li></ul><br>  Unfortunately, the analysis of these options showed that they are not very suitable for me: search engines have a lot of noise (many photos that are not roads, various renders, etc.), photos from the sites for receiving complaints contain only photos with large violations of the asphalt pavement , there are quite a few photos with small violations of coverage and without violations on these sites, datasets from the RoadDamageDetector project are assembled in Japan and do not contain samples with large violations of coverage, as well as no roads at all. <br><br>  If alternative options are not suitable, we will use Yandex panoramas (I excluded the Google panoramas option, since the service is presented in a smaller number of Russian cities and is updated less frequently).  I decided to collect data in cities with a population of more than 100 thousand people, as well as in federal centers.  Compiled a list of names of cities - there were 176 of them, later it turns out that there are only 149 panoramas in them.  I will not go deeper into the particular parsing of tiles, I’ll say that I ended up with 149 folders (one for each city) containing 1.7 million photos in total.  For example, for Novokuznetsk, the folder looked like this: <br><br><img src="https://habrastorage.org/webt/aw/fa/73/awfa73gw128fyrvl8au2b_brjb8.png"><br><br>  By the number of downloaded photos of the city were as follows: <br><br><div class="spoiler">  <b class="spoiler_title">Table</b> <div class="spoiler_text"><table><tbody><tr><th>  City <br></th><th>  Number of photos, pcs <br></th></tr><tr><td>  Moscow <br><br></td><td>  86048 <br><br></td></tr><tr><td>  St. Petersburg <br><br></td><td>  41376 <br><br></td></tr><tr><td>  Saransk <br><br></td><td>  18880 <br><br></td></tr><tr><td>  Podolsk <br><br></td><td>  18560 <br><br></td></tr><tr><td>  Krasnogorsk <br><br></td><td>  18208 <br><br></td></tr><tr><td>  Lyubertsy <br><br></td><td>  17760 <br><br></td></tr><tr><td>  Kaliningrad <br><br></td><td>  16928 <br><br></td></tr><tr><td>  Kolomna <br><br></td><td>  16832 <br><br></td></tr><tr><td>  Mytishchi <br><br></td><td>  16192 <br><br></td></tr><tr><td>  Vladivostok <br><br></td><td>  16096 <br><br></td></tr><tr><td>  Balashikha <br><br></td><td>  15968 <br><br></td></tr><tr><td>  Petrozavodsk <br><br></td><td>  15968 <br><br></td></tr><tr><td>  Yekaterinburg <br><br></td><td>  15808 <br><br></td></tr><tr><td>  Velikiy Novgorod <br><br></td><td>  15744 <br><br></td></tr><tr><td>  Naberezhnye Chelny <br><br></td><td>  15680 <br><br></td></tr><tr><td>  Krasnodar <br><br></td><td>  15520 <br><br></td></tr><tr><td>  Nizhny Novgorod <br><br></td><td>  15488 <br><br></td></tr><tr><td>  Khimki <br><br></td><td>  15296 <br><br></td></tr><tr><td>  Tula <br><br></td><td>  15296 <br><br></td></tr><tr><td>  Novosibirsk <br><br></td><td>  15264 <br><br></td></tr><tr><td>  Tver <br><br></td><td>  15200 <br><br></td></tr><tr><td>  Miass <br><br></td><td>  15104 <br><br></td></tr><tr><td>  Ivanovo <br><br></td><td>  15072 <br><br></td></tr><tr><td>  Vologda <br><br></td><td>  15008 <br><br></td></tr><tr><td>  Zhukovsky <br><br></td><td>  14976 <br><br></td></tr><tr><td>  Kostroma <br><br></td><td>  14912 <br><br></td></tr><tr><td>  Samara <br><br></td><td>  14880 <br><br></td></tr><tr><td>  Korolev <br><br></td><td>  14784 <br><br></td></tr><tr><td>  Kaluga <br><br></td><td>  14720 <br><br></td></tr><tr><td>  Cherepovets <br><br></td><td>  14720 <br><br></td></tr><tr><td>  Sevastopol <br><br></td><td>  14688 <br><br></td></tr><tr><td>  Pushkino <br><br></td><td>  14528 <br><br></td></tr><tr><td>  Yaroslavl <br><br></td><td>  14464 <br><br></td></tr><tr><td>  Ulyanovsk <br><br></td><td>  14400 <br><br></td></tr><tr><td>  Rostov-on-Don <br><br></td><td>  14368 <br><br></td></tr><tr><td>  Domodedovo <br><br></td><td>  14304 <br><br></td></tr><tr><td>  Kamensk-Uralsky <br><br></td><td>  14208 <br><br></td></tr><tr><td>  Pskov <br><br></td><td>  14144 <br><br></td></tr><tr><td>  Yoshkar-Ola <br><br></td><td>  14080 <br><br></td></tr><tr><td>  Kerch <br><br></td><td>  14080 <br><br></td></tr><tr><td>  Murmansk <br><br></td><td>  13920 <br><br></td></tr><tr><td>  Tolyatti <br><br></td><td>  13920 <br><br></td></tr><tr><td>  Vladimir <br><br></td><td>  13792 <br><br></td></tr><tr><td>  Eagle <br><br></td><td>  13792 <br><br></td></tr><tr><td>  Syktyvkar <br><br></td><td>  13728 <br><br></td></tr><tr><td>  Dolgoprudny <br><br></td><td>  13696 <br><br></td></tr><tr><td>  Khanty-Mansiysk <br><br></td><td>  13664 <br><br></td></tr><tr><td>  Kazan <br><br></td><td>  13600 <br><br></td></tr><tr><td>  Engels <br><br></td><td>  13440 <br><br></td></tr><tr><td>  Arkhangelsk <br><br></td><td>  13280 <br><br></td></tr><tr><td>  Bryansk <br><br></td><td>  13216 <br><br></td></tr><tr><td>  Omsk <br><br></td><td>  13120 <br><br></td></tr><tr><td>  Sizran <br><br></td><td>  13088 <br><br></td></tr><tr><td>  Krasnoyarsk <br><br></td><td>  13056 <br><br></td></tr><tr><td>  Schyolkovo <br><br></td><td>  12928 <br><br></td></tr><tr><td>  Penza <br><br></td><td>  12864 <br><br></td></tr><tr><td>  Chelyabinsk <br><br></td><td>  12768 <br><br></td></tr><tr><td>  Cheboksary <br><br></td><td>  12768 <br><br></td></tr><tr><td>  Nizhny Tagil <br><br></td><td>  12672 <br><br></td></tr><tr><td>  Stavropol <br><br></td><td>  12672 <br><br></td></tr><tr><td>  Ramenskoye <br><br></td><td>  12640 <br><br></td></tr><tr><td>  Irkutsk <br><br></td><td>  12608 <br><br></td></tr><tr><td>  Angarsk <br><br></td><td>  12608 <br><br></td></tr><tr><td>  Tyumen <br><br></td><td>  12512 <br><br></td></tr><tr><td>  Odintsovo <br><br></td><td>  12512 <br><br></td></tr><tr><td>  Ufa <br><br></td><td>  12512 <br><br></td></tr><tr><td>  Magadan <br><br></td><td>  12512 <br><br></td></tr><tr><td>  Permian <br><br></td><td>  12448 <br><br></td></tr><tr><td>  Kirov <br><br></td><td>  12256 <br><br></td></tr><tr><td>  Nizhnekamsk <br><br></td><td>  12224 <br><br></td></tr><tr><td>  Makhachkala <br><br></td><td>  12096 <br><br></td></tr><tr><td>  Nizhnevartovsk <br><br></td><td>  11936 <br><br></td></tr><tr><td>  Kursk <br><br></td><td>  11904 <br><br></td></tr><tr><td>  Sochi <br><br></td><td>  11872 <br><br></td></tr><tr><td>  Tambov <br><br></td><td>  11840 <br><br></td></tr><tr><td>  Pyatigorsk <br><br></td><td>  11808 <br><br></td></tr><tr><td>  Volgodonsk <br><br></td><td>  11712 <br><br></td></tr><tr><td>  Ryazan <br><br></td><td>  11680 <br><br></td></tr><tr><td>  Saratov <br><br></td><td>  11616 <br><br></td></tr><tr><td>  Dzerzhinsk <br><br></td><td>  11456 <br><br></td></tr><tr><td>  Orenburg <br><br></td><td>  11456 <br><br></td></tr><tr><td>  Mound <br><br></td><td>  11424 <br><br></td></tr><tr><td>  Volgograd <br><br></td><td>  11264 <br><br></td></tr><tr><td>  Izhevsk <br><br></td><td>  11168 <br><br></td></tr><tr><td>  Chrysostom <br><br></td><td>  11136 <br><br></td></tr><tr><td>  Lipetsk <br><br></td><td>  11072 <br><br></td></tr><tr><td>  Kislovodsk <br><br></td><td>  11072 <br><br></td></tr><tr><td>  Surgut <br><br></td><td>  11040 <br><br></td></tr><tr><td>  Magnitogorsk <br><br></td><td>  10912 <br><br></td></tr><tr><td>  Smolensk <br><br></td><td>  10784 <br><br></td></tr><tr><td>  Khabarovsk <br><br></td><td>  10752 <br><br></td></tr><tr><td>  Kopeisk <br><br></td><td>  10688 <br><br></td></tr><tr><td>  Maykop <br><br></td><td>  10656 <br><br></td></tr><tr><td>  Petropavlovsk-Kamchatsky <br><br></td><td>  10624 <br><br></td></tr><tr><td>  Taganrog <br><br></td><td>  10560 <br><br></td></tr><tr><td>  Barnaul <br><br></td><td>  10528 <br><br></td></tr><tr><td>  Sergiev Posad <br><br></td><td>  10368 <br><br></td></tr><tr><td>  Elista <br><br></td><td>  10304 <br><br></td></tr><tr><td>  Sterlitamak <br><br></td><td>  9920 <br><br></td></tr><tr><td>  Simferopol <br><br></td><td>  9824 <br><br></td></tr><tr><td>  Tomsk <br><br></td><td>  9760 <br><br></td></tr><tr><td>  Orekhovo-Zuyevo <br><br></td><td>  9728 <br><br></td></tr><tr><td>  Astrakhan <br><br></td><td>  9664 <br><br></td></tr><tr><td>  Evpatoria <br><br></td><td>  9568 <br><br></td></tr><tr><td>  Noginsk <br><br></td><td>  9344 <br><br></td></tr><tr><td>  Chita <br><br></td><td>  9216 <br><br></td></tr><tr><td>  Belgorod <br><br></td><td>  9120 <br><br></td></tr><tr><td>  Biysk <br><br></td><td>  8928 <br><br></td></tr><tr><td>  Rybinsk <br><br></td><td>  8896 <br><br></td></tr><tr><td>  Severodvinsk <br><br></td><td>  8832 <br><br></td></tr><tr><td>  Voronezh <br><br></td><td>  8768 <br><br></td></tr><tr><td>  Blagoveshchensk <br><br></td><td>  8672 <br><br></td></tr><tr><td>  Novorossiysk <br><br></td><td>  8608 <br><br></td></tr><tr><td>  Ulan-Ude <br><br></td><td>  8576 <br><br></td></tr><tr><td>  Serpukhov <br><br></td><td>  8320 <br><br></td></tr><tr><td>  Komsomolsk-on-Amur <br><br></td><td>  8192 <br><br></td></tr><tr><td>  Abakan <br><br></td><td>  8128 <br><br></td></tr><tr><td>  Norilsk <br><br></td><td>  8096 <br><br></td></tr><tr><td>  Yuzhno-Sakhalinsk <br><br></td><td>  8032 <br><br></td></tr><tr><td>  Obninsk <br><br></td><td>  7904 <br><br></td></tr><tr><td>  Essentuki <br><br></td><td>  7712 <br><br></td></tr><tr><td>  Bataysk <br><br></td><td>  7648 <br><br></td></tr><tr><td>  Volzhsky <br><br></td><td>  7584 <br><br></td></tr><tr><td>  Novocherkassk <br><br></td><td>  7488 <br><br></td></tr><tr><td>  Berdsk <br><br></td><td>  7456 <br><br></td></tr><tr><td>  Arzamas <br><br></td><td>  7424 <br><br></td></tr><tr><td>  Pervouralsk <br><br></td><td>  7392 <br><br></td></tr><tr><td>  Kemerovo <br><br></td><td>  7104 <br><br></td></tr><tr><td>  Elektrostal <br><br></td><td>  6720 <br><br></td></tr><tr><td>  Derbent <br><br></td><td>  6592 <br><br></td></tr><tr><td>  Yakutsk <br><br></td><td>  6528 <br><br></td></tr><tr><td>  Moore <br><br></td><td>  6240 <br><br></td></tr><tr><td>  Nefteyugansk <br><br></td><td>  5792 <br><br></td></tr><tr><td>  Reutov <br><br></td><td>  5696 <br><br></td></tr><tr><td>  Birobidzhan <br><br></td><td>  5440 <br><br></td></tr><tr><td>  Novokuibyshevsk <br><br></td><td>  5248 <br><br></td></tr><tr><td>  Salekhard <br><br></td><td>  5184 <br><br></td></tr><tr><td>  Novokuznetsk <br><br></td><td>  5152 <br><br></td></tr><tr><td>  New Urengoy <br><br></td><td>  4736 <br><br></td></tr><tr><td>  Noyabrsk <br><br></td><td>  4416 <br><br></td></tr><tr><td>  Novocheboksarsk <br><br></td><td>  4352 <br><br></td></tr><tr><td>  Dace <br><br></td><td>  3968 <br><br></td></tr><tr><td>  Kaspiysk <br><br></td><td>  3936 <br><br></td></tr><tr><td>  Stary Oskol <br><br></td><td>  3840 <br><br></td></tr><tr><td>  Artyom <br><br></td><td>  3744 <br><br></td></tr><tr><td>  Zheleznogorsk <br><br></td><td>  3584 <br><br></td></tr><tr><td>  Salavat <br><br></td><td>  3584 <br><br></td></tr><tr><td> Prokopyevsk <br><br></td><td>  2816 <br><br></td></tr><tr><td>  Gorno-Altaisk <br><br></td><td>  2464 <br><br></td></tr></tbody></table><br></div></div><br><h2>  Preparation of dataset for training </h2><br>  And so, it is assembled, how now, having a photo of the road section and the attached objects, find out the quality of the asphalt depicted on it?  I decided to cut a piece of a photo of 350 * 244 pixels in the center of the original photo just below the middle.  Then reduce the cut piece horizontally to the size of 244 pixels.  The resulting image (244 * 244 in size) will be the input for a convolutional encoder: <br><br><img src="https://habrastorage.org/webt/ya/tt/s8/yatts8qbzq9ddnxql_cydrmfeug.png"><br><br>  In order to better understand what data I deal with the first 2000 pictures I have marked myself, the rest of the pictures were marked up by Yandex.Toloki employees.  Before them I put the question in the following formulation. <br><br>  Indicate which road surface you see in the photo: <br><br><ol><li>  Ground / Rubble </li><li>  Stone blocks, tile, pavement </li><li>  Rails, railway tracks </li><li>  Water, large puddles </li><li>  Asphalt </li><li>  There is no road on the picture / Foreign objects / The coating is not visible because of the cars. </li></ol><br>  If the performer chose “Asphalt”, then a menu appeared offering to evaluate its quality: <br><br><ol><li>  Excellent coverage </li><li>  Minor single cracks / shallow single potholes </li><li>  Large cracks / Cracked mesh / single small gaps </li><li>  Large number of potholes / Deep potholes / Destroyed cover </li></ol><br>  As the test launches of tasks have shown, the performers of Ya. Toloki do not differ in the good faith of work - they accidentally click the mouse on the fields and consider the task to be completed.  I had to add test questions (there were 46 photographs in the assignment, 12 of which were control ones) and to include pending acceptance.  As control questions, I used those pictures that I marked out myself.  I automated the delayed acceptance - Ya.Toloka allows you to upload the results of work to a CSV-file, and upload the results of checking the answers.  Verification of answers worked as follows - if the task contains more than 5% of incorrect answers to test questions, then it is considered unfulfilled.  In this case, if the performer indicated an answer logically close to the correct one, then his answer is considered correct. <br>  As a result, I received about 30 thousand marked-up photos, which I decided to distribute in three classes for training: <br><br><ul><li>  "Good" - photos with the tags "Asphalt: Excellent coverage" and "Asphalt: Minor single cracks" </li><li>  “Middle” - photos with the tags “Paving, tile, pavement”, “Rails, railway tracks” and “Asphalt: Large cracks / Cracking grid / single not significant hollows” </li><li>  “Large” - photos tagged “Ground / Crushed Stone”, “Water, Large Puddles” and “Asphalt: Large Number of Potholes / Deep Potholes / Destroyed Coverage” </li><li>  Photos with tags “There is no road on the photo / Foreign objects / Coverage is not visible because of the machines” turned out to be very small (22 pcs.) And I excluded them from further work </li></ul><br><h2>  Development and training of the classifier </h2><br>  So, the data is collected and marked up, we proceed to the development of the classifier.  Usually, for image classification tasks, especially when training on small datasets, a ready convolutional encoder is used, to the output of which a new classifier is connected.  I decided to use a simple classifier without a hidden layer, an input layer of size 128 and an output layer of size 3. I chose to use several ready-made variants trained on ImageNet as encoders: <br><br><ul><li>  Xception </li><li>  Resnet </li><li>  Inception </li><li>  Vgg16 </li><li>  Densenet121 </li><li>  Mobilenet </li></ul><br>  Here is the function that creates the Keras-model with a given encoder: <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createModel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(typeModel)</span></span></span><span class="hljs-function">:</span></span> conv_base = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeModel == <span class="hljs-string"><span class="hljs-string">"nasnet"</span></span>): conv_base = keras.applications.nasnet.NASNetMobile(include_top=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, input_shape=(<span class="hljs-number"><span class="hljs-number">224</span></span>,<span class="hljs-number"><span class="hljs-number">224</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>), weights=<span class="hljs-string"><span class="hljs-string">'imagenet'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeModel == <span class="hljs-string"><span class="hljs-string">"xception"</span></span>): conv_base = keras.applications.xception.Xception(include_top=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, input_shape=(<span class="hljs-number"><span class="hljs-number">224</span></span>,<span class="hljs-number"><span class="hljs-number">224</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>), weights=<span class="hljs-string"><span class="hljs-string">'imagenet'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeModel == <span class="hljs-string"><span class="hljs-string">"resnet"</span></span>): conv_base = keras.applications.resnet50.ResNet50(include_top=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, input_shape=(<span class="hljs-number"><span class="hljs-number">224</span></span>,<span class="hljs-number"><span class="hljs-number">224</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>), weights=<span class="hljs-string"><span class="hljs-string">'imagenet'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeModel == <span class="hljs-string"><span class="hljs-string">"inception"</span></span>): conv_base = keras.applications.inception_v3.InceptionV3(include_top=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, input_shape=(<span class="hljs-number"><span class="hljs-number">224</span></span>,<span class="hljs-number"><span class="hljs-number">224</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>), weights=<span class="hljs-string"><span class="hljs-string">'imagenet'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeModel == <span class="hljs-string"><span class="hljs-string">"densenet121"</span></span>): conv_base = keras.applications.densenet.DenseNet121(include_top=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, input_shape=(<span class="hljs-number"><span class="hljs-number">224</span></span>,<span class="hljs-number"><span class="hljs-number">224</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>), weights=<span class="hljs-string"><span class="hljs-string">'imagenet'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeModel == <span class="hljs-string"><span class="hljs-string">"mobilenet"</span></span>): conv_base = keras.applications.mobilenet_v2.MobileNetV2(include_top=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, input_shape=(<span class="hljs-number"><span class="hljs-number">224</span></span>,<span class="hljs-number"><span class="hljs-number">224</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>), weights=<span class="hljs-string"><span class="hljs-string">'imagenet'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeModel == <span class="hljs-string"><span class="hljs-string">"vgg16"</span></span>): conv_base = keras.applications.vgg16.VGG16(include_top=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, input_shape=(<span class="hljs-number"><span class="hljs-number">224</span></span>,<span class="hljs-number"><span class="hljs-number">224</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>), weights=<span class="hljs-string"><span class="hljs-string">'imagenet'</span></span>) conv_base.trainable = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> model = Sequential() model.add(conv_base) model.add(Flatten()) model.add(Dense(<span class="hljs-number"><span class="hljs-number">128</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>, kernel_regularizer=regularizers.l2(<span class="hljs-number"><span class="hljs-number">0.0002</span></span>))) model.add(Dropout(<span class="hljs-number"><span class="hljs-number">0.3</span></span>)) model.add(Dense(<span class="hljs-number"><span class="hljs-number">3</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'softmax'</span></span>)) model.compile(optimizer=keras.optimizers.Adam(lr=<span class="hljs-number"><span class="hljs-number">1e-4</span></span>), loss=<span class="hljs-string"><span class="hljs-string">'binary_crossentropy'</span></span>, metrics=[<span class="hljs-string"><span class="hljs-string">'accuracy'</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model</code> </pre> <br>  I used a generator with augmentation for training (since the augmentation built into Keras seemed to me insufficient, I used the <a href="https://github.com/mdbloice/Augmentor">Augmentor</a> library): <br><br><ul><li>  Slopes </li><li>  Random distortion </li><li>  Turns </li><li>  Color swap </li><li>  Shifts </li><li>  Change in contrast and brightness </li><li>  Adding random noise </li><li>  Crop </li></ul><br>  After augmentation, the photos were ironed like this: <br><br><img src="https://habrastorage.org/webt/yc/qy/uh/ycqyuh1no4h57-or062y3epc4yy.png"><br><br>  Generator code: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_datagen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> train_dir=<span class="hljs-string"><span class="hljs-string">'~/data/train_img'</span></span> test_dir=<span class="hljs-string"><span class="hljs-string">'~/data/test_img'</span></span> testDataGen = ImageDataGenerator(rescale=<span class="hljs-number"><span class="hljs-number">1.</span></span> / <span class="hljs-number"><span class="hljs-number">255</span></span>) train_generator = datagen.flow_from_directory( train_dir, target_size=img_size, batch_size=<span class="hljs-number"><span class="hljs-number">16</span></span>, class_mode=<span class="hljs-string"><span class="hljs-string">'categorical'</span></span>) p = Augmentor.Pipeline(train_dir) p.skew(probability=<span class="hljs-number"><span class="hljs-number">0.9</span></span>) p.random_distortion(probability=<span class="hljs-number"><span class="hljs-number">0.9</span></span>,grid_width=<span class="hljs-number"><span class="hljs-number">3</span></span>,grid_height=<span class="hljs-number"><span class="hljs-number">3</span></span>,magnitude=<span class="hljs-number"><span class="hljs-number">8</span></span>) p.rotate(probability=<span class="hljs-number"><span class="hljs-number">0.9</span></span>, max_left_rotation=<span class="hljs-number"><span class="hljs-number">5</span></span>, max_right_rotation=<span class="hljs-number"><span class="hljs-number">5</span></span>) p.random_color(probability=<span class="hljs-number"><span class="hljs-number">0.7</span></span>, min_factor=<span class="hljs-number"><span class="hljs-number">0.8</span></span>, max_factor=<span class="hljs-number"><span class="hljs-number">1</span></span>) p.flip_left_right(probability=<span class="hljs-number"><span class="hljs-number">0.7</span></span>) p.random_brightness(probability=<span class="hljs-number"><span class="hljs-number">0.7</span></span>, min_factor=<span class="hljs-number"><span class="hljs-number">0.8</span></span>, max_factor=<span class="hljs-number"><span class="hljs-number">1.2</span></span>) p.random_contrast(probability=<span class="hljs-number"><span class="hljs-number">0.5</span></span>, min_factor=<span class="hljs-number"><span class="hljs-number">0.9</span></span>, max_factor=<span class="hljs-number"><span class="hljs-number">1</span></span>) p.random_erasing(probability=<span class="hljs-number"><span class="hljs-number">1</span></span>,rectangle_area=<span class="hljs-number"><span class="hljs-number">0.2</span></span>) p.crop_by_size(probability=<span class="hljs-number"><span class="hljs-number">1</span></span>, width=<span class="hljs-number"><span class="hljs-number">244</span></span>, height=<span class="hljs-number"><span class="hljs-number">244</span></span>, centre=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) train_generator = keras_generator(p,batch_size=<span class="hljs-number"><span class="hljs-number">16</span></span>) test_generator = testDataGen.flow_from_directory( test_dir, target_size=img_size, batch_size=<span class="hljs-number"><span class="hljs-number">32</span></span>, class_mode=<span class="hljs-string"><span class="hljs-string">'categorical'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (train_generator, test_generator)</code> </pre> <br>  The code shows that augmentation is not used for test data. <br><br>  Having a tuned generator it is possible to study the model, we will carry it out in two stages: first, only our classifier will be trained, then the entire model will be completely. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evalModelstep1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(typeModel)</span></span></span><span class="hljs-function">:</span></span> K.clear_session() gc.collect() model=createModel(typeModel) traiGen,testGen=getDatagen() model.fit_generator(generator=traiGen, epochs=<span class="hljs-number"><span class="hljs-number">4</span></span>, steps_per_epoch=<span class="hljs-number"><span class="hljs-number">30000</span></span>/<span class="hljs-number"><span class="hljs-number">16</span></span>, validation_steps=len(testGen), validation_data=testGen, ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evalModelstep2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(model)</span></span></span><span class="hljs-function">:</span></span> early_stopping_callback = EarlyStopping(monitor=<span class="hljs-string"><span class="hljs-string">'val_loss'</span></span>, patience=<span class="hljs-number"><span class="hljs-number">3</span></span>) model.layers[<span class="hljs-number"><span class="hljs-number">0</span></span>].trainable=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span> model.trainable=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span> model.compile(optimizer=keras.optimizers.Adam(lr=<span class="hljs-number"><span class="hljs-number">1e-5</span></span>), loss=<span class="hljs-string"><span class="hljs-string">'binary_crossentropy'</span></span>, metrics=[<span class="hljs-string"><span class="hljs-string">'accuracy'</span></span>]) traiGen,testGen=getDatagen() model.fit_generator(generator=traiGen, epochs=<span class="hljs-number"><span class="hljs-number">25</span></span>, steps_per_epoch=<span class="hljs-number"><span class="hljs-number">30000</span></span>/<span class="hljs-number"><span class="hljs-number">16</span></span>, validation_steps=len(testGen), validation_data=testGen, callbacks=[early_stopping_callback] ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">full_fit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> model_names=[ <span class="hljs-string"><span class="hljs-string">"xception"</span></span>, <span class="hljs-string"><span class="hljs-string">"resnet"</span></span>, <span class="hljs-string"><span class="hljs-string">"inception"</span></span>, <span class="hljs-string"><span class="hljs-string">"vgg16"</span></span>, <span class="hljs-string"><span class="hljs-string">"densenet121"</span></span>, <span class="hljs-string"><span class="hljs-string">"mobilenet"</span></span> ] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> model_name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> model_names: print(<span class="hljs-string"><span class="hljs-string">"#########################################"</span></span>) print(<span class="hljs-string"><span class="hljs-string">"#########################################"</span></span>) print(<span class="hljs-string"><span class="hljs-string">"#########################################"</span></span>) print(model_name) print(<span class="hljs-string"><span class="hljs-string">"#########################################"</span></span>) print(<span class="hljs-string"><span class="hljs-string">"#########################################"</span></span>) print(<span class="hljs-string"><span class="hljs-string">"#########################################"</span></span>) model = evalModelstep1(model_name) model = evalModelstep2(model) model.save(<span class="hljs-string"><span class="hljs-string">"~/data/models/model_new_"</span></span>+str(model_name)+<span class="hljs-string"><span class="hljs-string">".h5"</span></span>)</code> </pre><br>  Call full_fit () and wait.  We wait for a long time. <br><br>  According to the result, we will have six trained models, we will check the accuracy of these models on a separate portion of the marked ones: I received the following: <br><br><table><tbody><tr><td><p>  Model name </p><br></td><td><p>  Accuracy,% </p><br></td></tr><tr><td><p>  Xception </p><br></td><td><p>  87.3 </p><br></td></tr><tr><td><p>  Resnet </p><br></td><td><p>  90.8 </p><br></td></tr><tr><td><p>  Inception </p><br></td><td><p>  90.2 </p><br></td></tr><tr><td><p>  Vgg16 </p><br></td><td><p>  89.2 </p><br></td></tr><tr><td><p>  Densenet121 </p><br></td><td><p>  90.6 </p><br></td></tr><tr><td><p>  Mobilenet </p><br></td><td><p>  86.5 </p><br></td></tr></tbody></table><br>  In general, it is not thick, but with such a small training sample one should not expect more.  To further improve the accuracy I combined the outputs of the models by averaging: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_meta_model</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> model_names=[ <span class="hljs-string"><span class="hljs-string">"xception"</span></span>, <span class="hljs-string"><span class="hljs-string">"resnet"</span></span>, <span class="hljs-string"><span class="hljs-string">"inception"</span></span>, <span class="hljs-string"><span class="hljs-string">"vgg16"</span></span>, <span class="hljs-string"><span class="hljs-string">"densenet121"</span></span>, <span class="hljs-string"><span class="hljs-string">"mobilenet"</span></span> ] model_input = Input(shape=(<span class="hljs-number"><span class="hljs-number">244</span></span>,<span class="hljs-number"><span class="hljs-number">244</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>)) submodels=[] i=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> model_name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> model_names: filename= <span class="hljs-string"><span class="hljs-string">"~/data/models/model_new_"</span></span>+str(model_name)+<span class="hljs-string"><span class="hljs-string">".h5"</span></span> submodel = keras.models.load_model(filename) submodel.name = model_name+<span class="hljs-string"><span class="hljs-string">"_"</span></span>+str(i) i+=<span class="hljs-number"><span class="hljs-number">1</span></span> submodels.append(submodel(model_input)) out=average(submodels) model = Model(inputs = model_input,outputs=out) model.compile(optimizer=keras.optimizers.Adam(lr=<span class="hljs-number"><span class="hljs-number">1e-4</span></span>), loss=<span class="hljs-string"><span class="hljs-string">'binary_crossentropy'</span></span>, metrics=[<span class="hljs-string"><span class="hljs-string">'accuracy'</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model</code> </pre><br>  The final accuracy was 91.3%.  At this result, I decided to stop. <br><br><h2>  Classifier use </h2><br>  At last the classifier is ready and it can be launched into the business!  I prepare the input data and run the classifier - a little more than a day and 1.7 million photos processed.  Now the most interesting is the results.  Immediately quote the first and last ten cities on the relative number of roads with good coverage: <br><br><img src="https://habrastorage.org/webt/mf/vl/xu/mfvlxuvjesvy2leqhplfnik4mm8.png"><br><br><div class="spoiler">  <b class="spoiler_title">Full table (clickable image)</b> <div class="spoiler_text"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/9d8/4fd/38c/9d84fd38c07014be4f68499489ce19bc.png"></a> <br></div></div><br><br>  But the rating of the quality of roads by regions of the federation: <br><br><img src="https://habrastorage.org/webt/ih/kq/xq/ihkqxqskkfcfib90gc68ivmxo2i.png"><br><br><div class="spoiler">  <b class="spoiler_title">Full table</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/md/6j/-m/md6j-mv6jt27zsxgu8wkd2pimmy.png"><br></div></div><br>  Rating by Federal Districts: <br><br><img src="https://habrastorage.org/webt/ro/qq/ry/roqqryu12toajz6cgeals3vzuxc.png"><br><br>  The quality distribution of roads in Russia as a whole: <br><br><img src="https://habrastorage.org/webt/ow/rt/h1/owrth1ro6yu3svxdpwiyfedzeby.png"><br><br>  Well, that's all, everyone can draw conclusions himself. <br><br>  Finally, I will give the best photos in each category (which received the maximum value in its class): <br><br><div class="spoiler">  <b class="spoiler_title">Picture</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/k9/yf/dl/k9yfdlmiuynquyqhoxjuowvzcsu.jpeg"><br></div></div><br><br>  PS In the comments quite rightly pointed out the lack of statistics on the years of receiving photographs.  Correct and quote the table: <br><table><tbody><tr><td><p>  Year </p><br></td><td><p>  Number of photos, pcs </p><br></td></tr><tr><td>  2008 </td><td>  37 </td></tr><tr><td>  2009 </td><td>  13 </td></tr><tr><td>  2010 </td><td>  157030 </td></tr><tr><td>  2011 </td><td>  60724 </td></tr><tr><td>  2012 </td><td>  42387 </td></tr><tr><td>  2013 </td><td>  12148 <br><br></td></tr><tr><td>  2014 </td><td>  141021 <br><br></td></tr><tr><td>  2015 </td><td>  46143 <br><br></td></tr><tr><td>  2016 </td><td>  410385 <br><br></td></tr><tr><td>  2017 </td><td>  324279 <br><br></td></tr><tr><td>  2018 </td><td>  581961 <br><br></td></tr></tbody></table></div>