<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Julia, Gradient descent and simplex method</title>
  <meta name="description" content="We continue our acquaintance with the methods of multidimensional optimization. 


 Further, the implementation of the method of fastest descent with ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Julia, Gradient descent and simplex method</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/1d/dr/ms/1ddrmshpanmg5fsnpwbzgy-fi8e.png"></p><br><p>  <a href="https://habr.com/ru/post/439900/">We continue our</a> acquaintance with the methods of multidimensional optimization. </p><br><p>  Further, the implementation of the method of fastest descent with the analysis of the speed of execution, as well as the implementation of the Nelder-Mead method by means of the Julia and C ++ language, are proposed. </p><a name="habracut"></a><br><h2 id="metod-gradientnogo-spuska">  Gradient descent method </h2><br><p>  The search for extremum is conducted in steps in the direction of the gradient (max) or anti-gradient (min).  At each step in the direction of the gradient (antigradient), the movement is carried out as long as the function increases (decreases). </p><br><p>  Follow the theory to follow the links: </p><br><ul><li>  <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D1%2580%25D0%25B0%25D0%25B4%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25BD%25D1%258B%25D0%25B9_%25D1%2581%25D0%25BF%25D1%2583%25D1%2581%25D0%25BA">Gradient descent</a> </li><li>  <a href="http://www.machinelearning.ru/wiki/index.php%3Ftitle%3D%25D0%259C%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_%25D1%2581%25D0%25BE%25D0%25BF%25D1%2580%25D1%258F%25D0%25B6%25D1%2591%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585_%25D0%25B3%25D1%2580%25D0%25B0%25D0%25B4%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25BE%25D0%25B2">Conjugate Gradient Method</a> </li><li>  <a href="http://www.machinelearning.ru/wiki/index.php%3Ftitle%3D%25D0%259C%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_%25D0%259D%25D0%25B5%25D0%25BB%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B0-%25D0%259C%25D0%25B8%25D0%25B4%25D0%25B0">Nelder-Mead Method</a> </li><li>  <a href="https://habr.com/ru/post/413853/">Gradient Method Overview</a> </li><li>  <a href="https://habr.com/ru/post/439288/">SciPy Optimization</a> </li><li>  <a href="https://habr.com/ru/post/428794/">Overview of the main mathematical optimization methods for problems with constraints</a> </li><li>  <a href="https://habr.com/ru/post/332092/">Nelder-Mead optimization method.</a>  <a href="https://habr.com/ru/post/332092/">Python implementation</a> </li><li>  <a href="http://ppent.samsu.ru/docs/num_met_for_fiz_3.pdf">Zaitsev V.V. Numerical methods for physicists.</a>  <a href="http://ppent.samsu.ru/docs/num_met_for_fiz_3.pdf">Nonlinear equations and optimization</a> <br>  As a basis, examples from the last source were used. </li></ul><br><p>  The model function will choose an elliptical paraboloid and set the relief drawing function: </p><br><pre><code class="python hljs">using Plots plotly() <span class="hljs-comment"><span class="hljs-comment"># –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–µ –≥—Ä–∞—Ñ–∏–∫–∏ function plotter(plot_fun; low, up) Xs = range(low[1], stop = up[1], length = 80) Ys = range(low[2], stop = up[2], length = 80) Zs = [ fun([xy]) for x in Xs, y in Ys ]; plot_fun(Xs, Ys, Zs) xaxis!( (low[1], up[1]), low[1]:(up[1]-low[1])/5:up[1] ) # –ª–∏–Ω–æ–≤–∫–∞ –æ—Å–µ–π yaxis!( (low[2], up[2]), low[2]:(up[2]-low[2])/5:up[2] ) end parabol(x) = sum(u-&gt;u*u, x) # —Å—É–º–º–∞ –∫–≤–∞–¥—Ä–∞—Ç–æ–≤ fun = parabol plotter(surface, low = [-1 -1], up = [1 1])</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/oo/ln/4x/ooln4xwtmg_yie4ikccevpjbpxy.png"></p><br><p>  Let us set a function implementing the method of steepest descent, which takes the dimension of the problem, the accuracy, the step length, the initial approximation, and the size of the bounding box: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># —Ç–æ—á–∫–∞-—Å-–∑–∞–ø—è—Ç–æ–π –∑–Ω–∞—á–∏—Ç, —á—Ç–æ –≤—Å–µ –ø–æ—Å–ª–µ–¥—É—é—â–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã - –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ function ofGradient(; ndimes = 2, Œµ = 1e-4, st = 0.9, fit = [9.9, 9.9], low = [-1 -1], up = [10 10]) k = 0 while st &gt; Œµ g = grad(fit, 0.01) fung = fun(fit) fit -= st*g if fun(fit) &gt;= fung st *= 0.5 fit += st*g end k += 1 #println(k, " ", fit) end #println(fun(fit)) end</span></span></code> </pre> <br><p>  On the function of calculating the direction of the gradient can be sharpened in terms of optimization. </p><br><p>  The first thing that comes to mind is actions with matrices: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># \delta - –ø—Ä–∏—Ä–∞—â–µ–Ω–∏–µ –∞—Ä–≥—É–º–µ–Ω—Ç–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º–æ–µ –¥–ª—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è # –ø—Ä–æ–∏–∑–≤–æ–¥–Ω—ã—Ö –ø–æ —Ñ–æ—Ä–º—É–ª–µ —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã—Ö —Ä–∞–∑–Ω–æ—Å—Ç–µ–π function grad(fit, Œ¥) ndimes = length(fit) Œî = zeros(ndimes, ndimes) for i = 1:ndimes Œî[i,i] = Œ¥ end fr = [ fun( fit + Œî[:,i] ) for i=1:ndimes] fl = [ fun( fit - Œî[:,i] ) for i=1:ndimes] g = 0.5(fr - fl)/Œ¥ modg = sqrt( sum(x -&gt; x*x, g) ) g /= modg end</span></span></code> </pre> <br><p>  What makes Julia really good is that problem areas can be easily tested: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#]add BenchmarkTools using BenchmarkTools @benchmark ofGradient() BenchmarkTools.Trial: memory estimate: 44.14 KiB allocs estimate: 738 -------------- minimum time: 76.973 Œºs (0.00% GC) median time: 81.315 Œºs (0.00% GC) mean time: 92.828 Œºs (9.14% GC) maximum time: 5.072 ms (94.37% GC) -------------- samples: 10000 evals/sample: 1</span></span></code> </pre> <br><p>  You can rush to reprint everything in Cishny style </p><br><pre> <code class="python hljs">function grad(fit::Array{Float64,<span class="hljs-number"><span class="hljs-number">1</span></span>}, Œ¥::Float64) ndimes::Int8 = <span class="hljs-number"><span class="hljs-number">2</span></span> g = zeros(ndimes) modg::Float64 = <span class="hljs-number"><span class="hljs-number">0.</span></span> Fr::Float64 = <span class="hljs-number"><span class="hljs-number">0.</span></span> Fl::Float64 = <span class="hljs-number"><span class="hljs-number">0.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>:ndimes fit[i] += Œ¥ Fr = fun(fit) fit[i] -= <span class="hljs-number"><span class="hljs-number">2</span></span>Œ¥ Fl = fun(fit) fit[i] += Œ¥ g[i] = <span class="hljs-number"><span class="hljs-number">0.5</span></span>(Fr - Fl)/Œ¥ modg += g[i]*g[i] end modg = sqrt( modg ) g /= modg end @benchmark ofGradient() BenchmarkTools.Trial: memory estimate: <span class="hljs-number"><span class="hljs-number">14.06</span></span> KiB allocs estimate: <span class="hljs-number"><span class="hljs-number">325</span></span> -------------- minimum time: <span class="hljs-number"><span class="hljs-number">29.210</span></span> Œºs (<span class="hljs-number"><span class="hljs-number">0.00</span></span>% GC) median time: <span class="hljs-number"><span class="hljs-number">30.395</span></span> Œºs (<span class="hljs-number"><span class="hljs-number">0.00</span></span>% GC) mean time: <span class="hljs-number"><span class="hljs-number">33.603</span></span> Œºs (<span class="hljs-number"><span class="hljs-number">6.88</span></span>% GC) maximum time: <span class="hljs-number"><span class="hljs-number">4.287</span></span> ms (<span class="hljs-number"><span class="hljs-number">98.88</span></span>% GC) -------------- samples: <span class="hljs-number"><span class="hljs-number">10000</span></span> evals/sample: <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>  But as it turns out, it itself and without us knows which types should be put, so we arrive at a compromise: </p><br><pre> <code class="python hljs">function grad(fit, Œ¥) <span class="hljs-comment"><span class="hljs-comment"># –≤—ã—á–∏—Å–ª—è–µ—Ç –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞ ndimes = length(fit) g = zeros(ndimes) for i = 1:ndimes fit[i] += Œ¥ Fr = fun(fit) fit[i] -= Œ¥ fit[i] -= Œ¥ Fl = fun(fit) fit[i] += Œ¥ g[i] = 0.5(Fr - Fl)/Œ¥ end modg = sqrt( sum(x -&gt; x*x, g) ) g /= modg end @benchmark ofGradient() BenchmarkTools.Trial: memory estimate: 15.38 KiB allocs estimate: 409 -------------- minimum time: 28.026 Œºs (0.00% GC) median time: 30.394 Œºs (0.00% GC) mean time: 33.724 Œºs (6.29% GC) maximum time: 3.736 ms (98.72% GC) -------------- samples: 10000 evals/sample: 1</span></span></code> </pre> <br><p>  And now let him draw: </p><br><pre> <code class="python hljs">function ofGradient(; ndimes = <span class="hljs-number"><span class="hljs-number">2</span></span>, Œµ = <span class="hljs-number"><span class="hljs-number">1e-4</span></span>, st = <span class="hljs-number"><span class="hljs-number">0.9</span></span>, fit = [<span class="hljs-number"><span class="hljs-number">9.9</span></span>, <span class="hljs-number"><span class="hljs-number">9.9</span></span>], low = [<span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>], up = [<span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>]) k = <span class="hljs-number"><span class="hljs-number">0</span></span> x = [] y = [] push!(x, fit[<span class="hljs-number"><span class="hljs-number">1</span></span>]) push!(y, fit[<span class="hljs-number"><span class="hljs-number">2</span></span>]) plotter(contour, low = low, up = up) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> st &gt; Œµ g = grad(fit, <span class="hljs-number"><span class="hljs-number">0.01</span></span>) fung = fun(fit) fit -= st*g <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> fun(fit) &gt;= fung st *= <span class="hljs-number"><span class="hljs-number">0.5</span></span> fit += st*g end k += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">#println(k, " ", fit) push!(x, fit[1]) push!(y, fit[2]) end plot!(x, y, w = 3, legend = false, marker = :rect ) title!("Age = $kf(x,y) = $(fun(fit))") println(fun(fit)) end ofGradient()</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/3g/4e/lo/3g4eloq6pgjwfdw4yoovacooi3i.png"></p><br><p>  And now let's test on Ackley's functions: </p><br><pre> <code class="python hljs">ekly(x) = <span class="hljs-number"><span class="hljs-number">-20</span></span>exp(<span class="hljs-number"><span class="hljs-number">-0.2</span></span>sqrt(<span class="hljs-number"><span class="hljs-number">0.5</span></span>(x[<span class="hljs-number"><span class="hljs-number">1</span></span>]*x[<span class="hljs-number"><span class="hljs-number">1</span></span>]+x[<span class="hljs-number"><span class="hljs-number">2</span></span>]*x[<span class="hljs-number"><span class="hljs-number">2</span></span>]))) - exp(<span class="hljs-number"><span class="hljs-number">0.5</span></span>(cospi(<span class="hljs-number"><span class="hljs-number">2</span></span>x[<span class="hljs-number"><span class="hljs-number">1</span></span>])+cospi(<span class="hljs-number"><span class="hljs-number">2</span></span>x[<span class="hljs-number"><span class="hljs-number">2</span></span>]))) + <span class="hljs-number"><span class="hljs-number">20</span></span> + ‚ÑØ <span class="hljs-comment"><span class="hljs-comment"># f(0,0) = 0, x_i ‚àà [-5,5] fun = ekly ofGradient(fit = [4.3, 4.9], st = 0.1, low = [3 4.5], up = [4.5 5.4] )</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/in/49/nj/in49njxvjmk1pldjwflc6x5dhzc.png"></p><br><p>  Dropped to a local minimum.  Let's take more steps: </p><br><pre> <code class="python hljs">ofGradient(fit = [<span class="hljs-number"><span class="hljs-number">4.3</span></span>, <span class="hljs-number"><span class="hljs-number">4.9</span></span>], st = <span class="hljs-number"><span class="hljs-number">0.9</span></span>, low = [<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4.5</span></span>], up = [<span class="hljs-number"><span class="hljs-number">4.5</span></span> <span class="hljs-number"><span class="hljs-number">5.4</span></span>] )</code> </pre> <br><p><img src="https://habrastorage.org/webt/1u/wu/rn/1uwurnti-yqnz_x75wfk6fxhahs.png"></p><br><pre> <code class="python hljs">ofGradient(fit = [<span class="hljs-number"><span class="hljs-number">4.3</span></span>, <span class="hljs-number"><span class="hljs-number">4.9</span></span>], st = <span class="hljs-number"><span class="hljs-number">1.9</span></span>, low = [<span class="hljs-number"><span class="hljs-number">-5.2</span></span> <span class="hljs-number"><span class="hljs-number">-2.2</span></span>], up = [<span class="hljs-number"><span class="hljs-number">8.1</span></span> <span class="hljs-number"><span class="hljs-number">7.1</span></span>] )</code> </pre> <br><p><img src="https://habrastorage.org/webt/lw/21/fn/lw21fnq0hmobp49moqmytvcdjbe.png"></p><br><p>  ‚Ä¶ And a bit more: </p><br><pre> <code class="python hljs">ofGradient(fit = [<span class="hljs-number"><span class="hljs-number">4.3</span></span>, <span class="hljs-number"><span class="hljs-number">4.9</span></span>], st = <span class="hljs-number"><span class="hljs-number">8.9</span></span>, low = [<span class="hljs-number"><span class="hljs-number">-5.2</span></span> <span class="hljs-number"><span class="hljs-number">-2.2</span></span>], up = [<span class="hljs-number"><span class="hljs-number">8.1</span></span> <span class="hljs-number"><span class="hljs-number">7.1</span></span>] )</code> </pre> <br><p><img src="https://habrastorage.org/webt/ah/pj/1s/ahpj1swejdx7srnqo5jh7s0af9w.png"><br>  Fine!  And now something with a ravine, for example the Rosenbrock function: </p><br><pre> <code class="python hljs">rosenbrok(x) = <span class="hljs-number"><span class="hljs-number">100</span></span>(x[<span class="hljs-number"><span class="hljs-number">2</span></span>]-x[<span class="hljs-number"><span class="hljs-number">1</span></span>]*x[<span class="hljs-number"><span class="hljs-number">1</span></span>])^<span class="hljs-number"><span class="hljs-number">2</span></span> + (x[<span class="hljs-number"><span class="hljs-number">1</span></span>]<span class="hljs-number"><span class="hljs-number">-1</span></span>)^<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-comment"><span class="hljs-comment"># f(0,0) = 0, x_i ‚àà [-5,5] fun = rosenbrok plotter(surface, low = [-2 -1.5], up = [2 1.5])</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/rn/mo/wj/rnmowjiuky7rayeoaw410fh1jem.png"></p><br><pre> <code class="python hljs">ofGradient(fit = [<span class="hljs-number"><span class="hljs-number">2.3</span></span>, <span class="hljs-number"><span class="hljs-number">2.2</span></span>], st = <span class="hljs-number"><span class="hljs-number">9.9</span></span>, low = [<span class="hljs-number"><span class="hljs-number">-5.2</span></span> <span class="hljs-number"><span class="hljs-number">-5.2</span></span>], up = [<span class="hljs-number"><span class="hljs-number">8.1</span></span> <span class="hljs-number"><span class="hljs-number">7.1</span></span>] )</code> </pre> <br><p><img src="https://habrastorage.org/webt/hd/fm/d3/hdfmd3vr0zammghj39u5o-3nu-y.png"></p><br><pre> <code class="python hljs">ofGradient(fit = [<span class="hljs-number"><span class="hljs-number">2.3</span></span>, <span class="hljs-number"><span class="hljs-number">2.2</span></span>], st = <span class="hljs-number"><span class="hljs-number">0.9</span></span>, low = [<span class="hljs-number"><span class="hljs-number">-5.2</span></span> <span class="hljs-number"><span class="hljs-number">-5.2</span></span>], up = [<span class="hljs-number"><span class="hljs-number">8.1</span></span> <span class="hljs-number"><span class="hljs-number">7.1</span></span>] )</code> </pre> <br><p><img src="https://habrastorage.org/webt/rp/eu/mf/rpeumfpmjhvxjo-5k0cm1fjtnyq.png"><br>  Moral: gradients do not like the slopes. </p><br><h2 id="simpleks-metod">  Simplex method </h2><br><p>  The Nelder ‚Äì Mead method, also known as the deformable polyhedron method and the simplex method, is an unconditional optimization method for a function of several variables that does not use the derivative (or more precisely, gradients) function, and therefore is easily applicable to non-smooth and / or noisy functions. </p><br><p>  The essence of the method lies in the sequential movement and deformation of the simplex around the extremum point. </p><br><p>  The method finds a local extremum and can ‚Äúget stuck‚Äù in one of them.  If you still need to find a global extremum, you can try to choose another initial simplex. </p><br><p>  Secondary functions: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#—Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ —Å—Ç–æ–ª–±—Ü–æ–≤ –º–∞—Ç—Ä–∏—Ü—ã –≤—ã—Å—Ç—Ä–∞–∏–≤–∞–Ω–∏–µ–º —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –ø–æ—Å–ª–µ–¥–Ω–µ–π —Å—Ç—Ä–æ–∫–∏ –≤ –ø–æ—Ä—è–¥–∫–µ –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—è function sortcoord(Mx) N = size(Mx,2) f = [fun(Mx[:,i]) for i in 1:N] # –∑–Ω–∞—á–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ –≤ –≤–µ—Ä—à–∏–Ω–∞—Ö Mx[:, sortperm(f)] #Return a permutation vector I that puts v[I] in sorted order. end # –ù–æ—Ä–º–∞ –º–∞—Ç—Ä–∏—Ü—ã function normx(Mx) m = size(Mx,2) D = zeros(m-1,m) vecl(x) = sqrt( sum(u -&gt; u*u, x) )# –¥–ª–∏–Ω–∞ –≤–µ–∫—Ç–æ—Ä–∞ for i = 1:m, j = i+1:m D[i,j] = vecl(Mx[:,i] - Mx[:,j]) # —Å—á–∏—Ç–∞–µ—Ç –¥–ª–∏–Ω—É —Ä–∞–∑–Ω–æ—Å—Ç–∏ —Å—Ç–æ–ª–±—Ü–æ–≤ end D sqrt(maximum(D)) end function simplexplot(xy, low, up) for i = 1:length(xy) if i%11 == 0 low *= 0.05 up *= 0.05 end Xs = range(low[1], stop = up[1], length = 80) Ys = range(low[2], stop = up[2], length = 80) Zs = [ fun([xy]) for y in Ys, x in Xs ] contour(Xs, Ys, Zs) xaxis!( low[1]:(up[1]-low[1])*0.2:up[1] ) yaxis!( low[2]:(up[2]-low[2])*0.2:up[2] ) plot!(xy[i][1,:], xy[i][2,:], w = 3, legend = false, marker = :circle ) title!("Age = $if(x,y) = $(fun(xy[i][:,1]))") savefig("$fun $i.png") end end</span></span></code> </pre> <br><p>  And the simplex method itself: </p><br><pre> <code class="python hljs">function ofNelderMid(; ndimes = <span class="hljs-number"><span class="hljs-number">2</span></span>, Œµ = <span class="hljs-number"><span class="hljs-number">1e-4</span></span>, fit = [<span class="hljs-number"><span class="hljs-number">.1</span></span>, <span class="hljs-number"><span class="hljs-number">.1</span></span>], low = [<span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>], up = [<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>]) vecl(v) = sqrt( sum(x -&gt; x*x, v) ) k = <span class="hljs-number"><span class="hljs-number">0</span></span> N = ndimes dz = zeros(N, N+<span class="hljs-number"><span class="hljs-number">1</span></span>) Xx = zeros(N, N+<span class="hljs-number"><span class="hljs-number">1</span></span>) coords = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>:N+<span class="hljs-number"><span class="hljs-number">1</span></span> Xx[:,i] = fit end <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>:N dz[i,i] = <span class="hljs-number"><span class="hljs-number">0.5</span></span>*vecl(fit) end Xx += dz p = normx(Xx) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> p &gt; Œµ k += <span class="hljs-number"><span class="hljs-number">1</span></span> Xx = sortcoord(Xx) Xo = [ sum(Xx[i,<span class="hljs-number"><span class="hljs-number">1</span></span>:N])/N <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>:N ] <span class="hljs-comment"><span class="hljs-comment"># —Å—Ä–µ–¥–Ω–µ–µ —ç–ª-—Ç–æ–≤ i-–π —Å—Ç—Ä–æ–∫–∏ Ro = 2Xo - Xx[:,N+1] FR = fun(Ro) if FR &gt; fun(Xx[:,N+1]) for i = 2:N+1 Xx[:,i] = 0.5(Xx[:,1] + Xx[:,i]) end else if FR &lt; fun(Xx[:,1]) Eo = Xo + 2(Xo - Xx[:,N+1]) if FR &gt; fun(Eo) Xx[:,N+1] = Eo else Xx[:,N+1] = Ro end else if FR &lt;= fun(Xx[:,N]) Xx[:,N+1] = Ro else Co = Xo + 0.5(Xo - Xx[:,N+1]) if FR &gt; fun(Co) Xx[:,N+1] = Co else Xx[:,N+1] = Ro end end end end #println(k, " ", p, " ", Xx[:,1]) push!(coords, [Xx[:,1:3] Xx[:,1] ]) p = normx(Xx) end #while #simplexplot(coords, low, up) fit = Xx[:,1] end ofNelderMid(fit = [-9, -2], low = [-2 2], up = [-8 8])</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/td/1q/e6/td1qe6h4ykk4snlgxikunbmxrbc.gif"></p><br><p>  And for dessert, some beech ... for example, the function of Bukin <br><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="44.393ex" height="2.901ex" viewBox="0 -935.7 19113.5 1249" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/440070/&amp;xid=17259,1500004,15700022,15700186,15700190,15700248&amp;usg=ALkJrhieNM4_OyQka-h5RCbFTtSzeRbJnw#MJMATHI-66" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/440070/&amp;xid=17259,1500004,15700022,15700186,15700190,15700248&amp;usg=ALkJrhieNM4_OyQka-h5RCbFTtSzeRbJnw#MJMAIN-28" x="550" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/440070/&amp;xid=17259,1500004,15700022,15700186,15700190,15700248&amp;usg=ALkJrhieNM4_OyQka-h5RCbFTtSzeRbJnw#MJMATHI-78" x="940" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/440070/&amp;xid=17259,1500004,15700022,15700186,15700190,15700248&amp;usg=ALkJrhieNM4_OyQka-h5RCbFTtSzeRbJnw#MJMAIN-2C" x="1512" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/440070/&amp;xid=17259,1500004,15700022,15700186,15700190,15700248&amp;usg=ALkJrhieNM4_OyQka-h5RCbFTtSzeRbJnw#MJMATHI-79" x="1957" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/440070/&amp;xid=17259,1500004,15700022,15700186,15700190,15700248&amp;usg=ALkJrhieNM4_OyQka-h5RCbFTtSzeRbJnw#MJMAIN-29" x="2455" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/440070/&amp;xid=17259,1500004,15700022,15700186,15700190,15700248&amp;usg=ALkJrhieNM4_OyQka-h5RCbFTtSzeRbJnw#MJMAIN-3D" x="3122" y="0"></use><g transform="translate(4178,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/440070/&amp;xid=17259,1500004,15700022,15700186,15700190,15700248&amp;usg=ALkJrhieNM4_OyQka-h5RCbFTtSzeRbJnw#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/440070/&amp;xid=17259,1500004,15700022,15700186,15700190,15700248&amp;usg=ALkJrhieNM4_OyQka-h5RCbFTtSzeRbJnw#MJMAIN-30" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/440070/&amp;xid=17259,1500004,15700022,15700186,15700190,15700248&amp;usg=ALkJrhieNM4_OyQka-h5RCbFTtSzeRbJnw#MJMAIN-30" x="1001" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/440070/&amp;xid=17259,1500004,15700022,15700186,15700190,15700248&amp;usg=ALkJrhieNM4_OyQka-h5RCbFTtSzeRbJnw#MJMATHI-73" x="5930" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/440070/&amp;xid=17259,1500004,15700022,15700186,15700190,15700248&amp;usg=ALkJrhieNM4_OyQka-h5RCbFTtSzeRbJnw#MJMATHI-71" x="6399" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/440070/&amp;xid=17259,1500004,15700022,15700186,15700190,15700248&amp;usg=ALkJrhieNM4_OyQka-h5RCbFTtSzeRbJnw#MJMATHI-72" x="6860" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/440070/&amp;xid=17259,1500004,15700022,15700186,15700190,15700248&amp;usg=ALkJrhieNM4_OyQka-h5RCbFTtSzeRbJnw#MJMATHI-74" x="7311" y="0"></use><g transform="translate(7673,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/440070/&amp;xid=17259,1500004,15700022,15700186,15700190,15700248&amp;usg=ALkJrhieNM4_OyQka-h5RCbFTtSzeRbJnw#MJMAIN-7C" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/440070/&amp;xid=17259,1500004,15700022,15700186,15700190,15700248&amp;usg=ALkJrhieNM4_OyQka-h5RCbFTtSzeRbJnw#MJMATHI-79" x="278" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/440070/&amp;xid=17259,1500004,15700022,15700186,15700190,15700248&amp;usg=ALkJrhieNM4_OyQka-h5RCbFTtSzeRbJnw#MJMAIN-2212" x="998" y="0"></use><g transform="translate(1998,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/440070/&amp;xid=17259,1500004,15700022,15700186,15700190,15700248&amp;usg=ALkJrhieNM4_OyQka-h5RCbFTtSzeRbJnw#MJMAIN-30"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/440070/&amp;xid=17259,1500004,15700022,15700186,15700190,15700248&amp;usg=ALkJrhieNM4_OyQka-h5RCbFTtSzeRbJnw#MJMAIN-2E" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/440070/&amp;xid=17259,1500004,15700022,15700186,15700190,15700248&amp;usg=ALkJrhieNM4_OyQka-h5RCbFTtSzeRbJnw#MJMAIN-30" x="779" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/440070/&amp;xid=17259,1500004,15700022,15700186,15700190,15700248&amp;usg=ALkJrhieNM4_OyQka-h5RCbFTtSzeRbJnw#MJMAIN-31" x="1279" y="0"></use></g><g transform="translate(3778,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/440070/&amp;xid=17259,1500004,15700022,15700186,15700190,15700248&amp;usg=ALkJrhieNM4_OyQka-h5RCbFTtSzeRbJnw#MJMATHI-78" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/440070/&amp;xid=17259,1500004,15700022,15700186,15700190,15700248&amp;usg=ALkJrhieNM4_OyQka-h5RCbFTtSzeRbJnw#MJMAIN-32" x="809" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/440070/&amp;xid=17259,1500004,15700022,15700186,15700190,15700248&amp;usg=ALkJrhieNM4_OyQka-h5RCbFTtSzeRbJnw#MJMAIN-7C" x="4805" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/440070/&amp;xid=17259,1500004,15700022,15700186,15700190,15700248&amp;usg=ALkJrhieNM4_OyQka-h5RCbFTtSzeRbJnw#MJMAIN-2B" x="12979" y="0"></use><g transform="translate(13980,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/440070/&amp;xid=17259,1500004,15700022,15700186,15700190,15700248&amp;usg=ALkJrhieNM4_OyQka-h5RCbFTtSzeRbJnw#MJMAIN-30"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/440070/&amp;xid=17259,1500004,15700022,15700186,15700190,15700248&amp;usg=ALkJrhieNM4_OyQka-h5RCbFTtSzeRbJnw#MJMAIN-2E" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/440070/&amp;xid=17259,1500004,15700022,15700186,15700190,15700248&amp;usg=ALkJrhieNM4_OyQka-h5RCbFTtSzeRbJnw#MJMAIN-30" x="779" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/440070/&amp;xid=17259,1500004,15700022,15700186,15700190,15700248&amp;usg=ALkJrhieNM4_OyQka-h5RCbFTtSzeRbJnw#MJMAIN-31" x="1279" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/440070/&amp;xid=17259,1500004,15700022,15700186,15700190,15700248&amp;usg=ALkJrhieNM4_OyQka-h5RCbFTtSzeRbJnw#MJMAIN-7C" x="15760" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/440070/&amp;xid=17259,1500004,15700022,15700186,15700190,15700248&amp;usg=ALkJrhieNM4_OyQka-h5RCbFTtSzeRbJnw#MJMATHI-78" x="16038" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/440070/&amp;xid=17259,1500004,15700022,15700186,15700190,15700248&amp;usg=ALkJrhieNM4_OyQka-h5RCbFTtSzeRbJnw#MJMAIN-2B" x="16833" y="0"></use><g transform="translate(17833,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/440070/&amp;xid=17259,1500004,15700022,15700186,15700190,15700248&amp;usg=ALkJrhieNM4_OyQka-h5RCbFTtSzeRbJnw#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/440070/&amp;xid=17259,1500004,15700022,15700186,15700190,15700248&amp;usg=ALkJrhieNM4_OyQka-h5RCbFTtSzeRbJnw#MJMAIN-30" x="500" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/440070/&amp;xid=17259,1500004,15700022,15700186,15700190,15700248&amp;usg=ALkJrhieNM4_OyQka-h5RCbFTtSzeRbJnw#MJMAIN-7C" x="18834" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> f (x, y) = 100 \ sqrt {| y-0.01x ^ 2 |} + 0.01 | x + 10 | </script></p><br><pre> <code class="python hljs">bukin6(x) = <span class="hljs-number"><span class="hljs-number">100</span></span>sqrt(abs(x[<span class="hljs-number"><span class="hljs-number">2</span></span>]<span class="hljs-number"><span class="hljs-number">-0.01</span></span>x[<span class="hljs-number"><span class="hljs-number">1</span></span>]*x[<span class="hljs-number"><span class="hljs-number">1</span></span>])) + <span class="hljs-number"><span class="hljs-number">0.01</span></span>abs(x[<span class="hljs-number"><span class="hljs-number">1</span></span>]+<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-comment"><span class="hljs-comment"># f(-10,1) = 0, x_i ‚àà [-15,-5; -3,3] fun = bukin6 ofNelderMid(fit = [-10, -2], low = [-3 -7], up = [-8 -4.5])</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/i2/fx/hb/i2fxhbbd0mtly2pnw9et4ojecfy.gif"></p><br><p>  The local minimum is nothing, the main thing is to choose the starting simplex correctly, so for myself I found a favorite. </p><br><p>  Bonus  Methods of Nelder-Meade, the fastest descent and coordinate descent in C ++ </p><br><div class="spoiler">  <b class="spoiler_title">Alarm!</b>  <b class="spoiler_title">550 lines of code!</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * File: main.cpp * Author: User * * Created on 3 —Å–µ–Ω—Ç—è–±—Ä—è 2017 –≥., 21:22 */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;math.h&gt; using namespace std; typedef double D; class Model { public: D *fit; D ps; Model(); DI(); }; Model :: Model() { ps = 1; fit = new D[3]; fit[0]=1.3; fit[1]=1.; fit[2]=2.; } D Model :: I() // rosenbrock { return 100*(fit[1]-fit[0]*fit[0]) * (fit[1]-fit[0]*fit[0]) + (1-fit[0])*(1-fit[0]); } class Methods : public Model { public: void ofDescent(); void Newton(int i); void SPI(int i); //sequential parabolic interpolation void Cutters(int i); void Interval(D *ab, D st, int i); void Gold_section(int i); void ofGradient(); void Grad(int N, D *g, D delta); void Srt(D **X, int N); void ofNelder_Mid(); D Nor(D **X, int N); }; void Methods :: ofDescent()//–º–µ—Ç–æ–¥ –ø–æ–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–Ω–æ–≥–æ —Å–ø—É—Å–∫–∞ { int i, j=0; D *z = new D[3]; D sumx, sumz; sumx = sumz = 0; do { sumx = sumz = 0; for(i=0; i&lt;3; i++) z[i] = fit[i]; for(i=0; i&lt;2; i++) { //Cutters(i); //SPI(i); Newton(i); //Gold_section(i); sumx += fit[i]; sumz += z[i]; } j++; //if(j%1000==0) cout &lt;&lt; j &lt;&lt; " " &lt;&lt; fit[0] &lt;&lt; " " &lt;&lt; fit[1] &lt;&lt; " " &lt;&lt; fit[2] &lt;&lt; " " &lt;&lt; fit[3] &lt;&lt; endl; //cout &lt;&lt; sumz &lt;&lt; " " &lt;&lt; sumx &lt;&lt; endl; } while(fabs(sumz - sumx) &gt; 1e-6); delete[]z; } void Methods :: SPI(int i) { int k = 2; D f0, f1, f2; D v0, v1, v2; D s0, s1, s2; D *X = new D[300]; X[0] = fit[i] + 0.01; X[1] = fit[i]; X[2] = fit[i] - 0.01; while(fabs(X[k] - X[k-1]) &gt; 1e-3) { fit[i] = X[k]; f0 = I(); fit[i] = X[k-1]; f1 = I(); fit[i] = X[k-2]; f2 = I(); v0 = X[k-1] - X[k-2]; v1 = X[k ] - X[k-2]; v2 = X[k ] - X[k-1]; s0 = X[k-1]*X[k-1] - X[k-2]*X[k-2]; s1 = X[k ]*X[k ] - X[k-2]*X[k-2]; s2 = X[k ]*X[k ] - X[k-1]*X[k-1]; X[k+1] = 0.5*(f2*s2 - f1*s1 + f0*s0) / (f2*v2 - f1*v1 + f0*v0); k++; cout &lt;&lt; k &lt;&lt; " " &lt;&lt; X[k] &lt;&lt; endl; } fit[i] = X[k]; delete[]X; } void Methods :: Newton(int i) { D dt, T, It; int k=0; while(fabs(T-fit[i]) &gt; 1e-3) { It = I(); T = fit[i]; fit[i] += 0.01; dt = I(); fit[i] -= 0.01; fit[i] -= It*0.001 / (dt - It); cout &lt;&lt; k &lt;&lt; " " &lt;&lt; fit[i] &lt;&lt; endl; k++; } } void Methods :: Cutters(int i) { D Tn, Tnm, Tnp, It, Itm; int j=0; Tn = 0.15; Tnm = 2.65;//otrezok Itm = I(); //cout &lt;&lt; Tnm &lt;&lt; " " &lt;&lt; Tn &lt;&lt; endl; while(fabs(Tn-Tnm) &gt; 1e-6) { fit[i] = Tn; It = I(); Tnp = Tn - It * (Tn-Tnm) / (It-Itm); cout &lt;&lt; j+1 &lt;&lt; " " &lt;&lt; Tnp &lt;&lt; endl; Itm = It; Tnm = Tn; Tn = Tnp; j++; } fit[i] = Tnp; } void Methods :: Interval(D *ab, D st, int i) { D Fa, Fdx, d, c, Fb, fitbox = fit[i]; ab[0] = fit[i]; Fa = I(); fit[i] -= st; Fdx = I(); fit[i] += st; if(Fdx &lt; Fa) st = -st; fit[i] += st; ab[1] = fit[i]; Fb = I(); while(Fb &lt; Fa) { d = ab[0]; ab[0] = ab[1]; Fa = Fb; fit[i] += st; ab[1] = fit[i]; Fb = I(); cout &lt;&lt; Fb &lt;&lt; " " &lt;&lt; Fa &lt;&lt; endl; } if(st&lt;0) { c = ab[1]; ab[1] = d; d = c; } ab[0] = d; fit[i] = fitbox; } void Methods :: Gold_section(int i) { D Fa, Fb, al, be; D *ab = new D[2]; D st = 0.5; D e = 0.5*(sqrt(5) - 1); Interval(ab, st, i); al = e*ab[0] + (1-e)*ab[1]; be = e*ab[1] + (1-e)*ab[0]; fit[i] = al; Fa = I(); fit[i] = be; Fb = I(); while(fabs(ab[1]-ab[0]) &gt; e) { if(Fa &lt; Fb) { ab[1] = be; be = al; Fb = Fa; al = e*ab[0] + (1-e)*ab[1]; fit[i] = al; Fa = I(); } if(Fa &gt; Fb) { ab[0] = al; al = be; Fa = Fb; be = e*ab[1] + (1-e)*ab[0]; fit[i] = be; Fb = I(); } cout &lt;&lt; ab[0] &lt;&lt; " " &lt;&lt; ab[1] &lt;&lt; endl; } fit[i] = 0.5*(ab[0] + ab[1]); cout &lt;&lt; ab[0] &lt;&lt; " " &lt;&lt; ab[1] &lt;&lt; endl; } void Methods :: Grad(int N, D *g, D delta)//–≤–µ–∫—Ç–æ—Ä –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞ { int n; D Fr, Fl, modG=0; for(n=0; n&lt;N; n++) { fit[n] += delta; Fr = I(); fit[n] -= delta; fit[n] -= delta; Fl = I(); fit[n] += delta; g[n] = (Fr - Fl)*0.5/delta; modG += g[n]*g[n]; } modG = sqrt(modG); for(n=0; n&lt;N; n++) g[n] /= modG; g[N] = I(); } void Methods :: ofGradient() { int n, j=0; D Fun, st, eps; const int N = 2; D *g = new D[N+1]; st = 0.1; eps = 0.000001; while(st &gt; eps) { Grad(N,g,0.0001); for(n=0; n&lt;N; n++) fit[n] -= st*g[n]; Fun = I(); if(Fun &gt;= g[N]) { st /= 2.; for(n=0; n&lt;N; n++) fit[n] += st*g[n]; } j++; cout &lt;&lt; j &lt;&lt; " " &lt;&lt; fit[0]/ps &lt;&lt; " " &lt;&lt; fit[1]/ps &lt;&lt; " " &lt;&lt; fit[2]/ps&lt;&lt; endl; } } void Methods :: ofNelder_Mid() { int i, j, k; D modz = 0., p, eps = 1e-3; D FR, FN, F0, FE, FNm1, FC; const int N = 2; D *Co = new D[N]; D *Eo = new D[N]; D *Ro = new D[N]; D *Xo = new D[N]; D **Xx = new D*[N]; D **dz = new D*[N]; for(i=0;i&lt;N;i++) { dz[i] = new D[N]; Xx[i] = new D[N+1]; } for(i=0;i&lt;N;i++) for(j=0;j&lt;N;j++) if(i^j) dz[i][j] = 0; else dz[i][j] = 1; for(i=0;i&lt;N;i++) Xx[i][N] = fit[i]; for(i=0;i&lt;N;i++) modz += fit[i]*fit[i]; modz = sqrt(modz); for(i=0;i&lt;N;i++) dz[i][i] = 0.5*modz; for(i=0;i&lt;N;i++) for(j=0;j&lt;N;j++) Xx[i][j] = fit[i] + dz[i][j]; k = 0; p = Nor(Xx, N); while(p &gt; eps) { k++; Srt(Xx, N); for(i=0;i&lt;N;i++) Xo[i] = 0.; for(i=0;i&lt;N;i++) for(j=0;j&lt;N;j++) Xo[i] += Xx[i][j]; for(i=0;i&lt;N;i++) Xo[i] /= N; for(i=0;i&lt;N;i++) Ro[i] = Xo[i] + (Xo[i]-Xx[i][N]); for(i=0;i&lt;N;i++) fit[i] = Ro[i]; FR = I(); for(i=0;i&lt;N;i++) fit[i] = Xx[i][N]; FN = I(); if(FR &gt; FN) { for(i=0;i&lt;N;i++) for(j=1;j&lt;=N;j++) Xx[i][j] = 0.5*(Xx[i][0] + Xx[i][j]); } else { for(i=0;i&lt;N;i++) fit[i] = Xx[i][0]; F0 = I(); if(FR &lt; F0) { for(i=0;i&lt;N;i++) Eo[i] = Xo[i] +2*(Xo[i] - Xx[i][N]); for(i=0;i&lt;N;i++) fit[i] = Eo[i]; FE = I(); if(FE &lt; FR) for(i=0;i&lt;N;i++) Xx[i][N] = Eo[i]; else for(i=0;i&lt;N;i++) Xx[i][N] = Ro[i]; } else { for(i=0;i&lt;N;i++) fit[i] = Xx[i][N-1]; FNm1 = I(); if(FR &lt;= FNm1) for(i=0;i&lt;N;i++) Xx[i][N] = Ro[i]; else { for(i=0;i&lt;N;i++) Co[i] = Xo[i] +0.5*(Xo[i] - Xx[i][N]); for(i=0;i&lt;N;i++) fit[i] = Co[i]; FC = I(); if(FC &lt; FR) for(i=0;i&lt;N;i++) Xx[i][N] = Co[i]; else for(i=0;i&lt;N;i++) Xx[i][N] = Ro[i]; } } } for(i=0;i&lt;N;i++) cout &lt;&lt; Xx[i][0] &lt;&lt; " "; cout &lt;&lt; k &lt;&lt; " " &lt;&lt; p &lt;&lt; endl; p = Nor(Xx, N); if(p &lt; eps) break; } for(i=0;i&lt;N;i++) fit[i] = Xx[i][0]; /*for(i=0;i&lt;N;i++) { for(j=0;j&lt;N+1;j++) cout &lt;&lt; Xx[i][j] &lt;&lt; " "; cout &lt;&lt; endl; }*/ delete[]Co; delete[]Xo; delete[]Ro; delete[]Eo; for(i=0;i&lt;N;i++) { delete[]dz[i]; delete[]Xx[i]; } } //–≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –Ω–æ—Ä–º—É –≤–µ–∫—Ç–æ—Ä–∞ D Methods :: Nor(D **X, int N) { int i, j, k; D norm, xij, pn = 0.; for(i=0;i&lt;N;i++) for(j=i+1;j&lt;=N;j++) { xij = 0.; for(k=0;k&lt;N;k++) xij += ( (X[k][i]-X[k][j])*(X[k][i]-X[k][j]) ); pn = sqrt(xij);//—Å—á–∏—Ç–∞–µ—Ç –¥–ª–∏–Ω—É —Ä–∞–∑–Ω–æ—Å—Ç–∏ —Å—Ç–æ–ª–±—Ü–æ–≤ if(norm &gt; pn) norm = pn;//–∏—â–µ—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –¥–ª–∏–Ω—É } return sqrt(norm); } //—Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –≤–µ—Ä—à–∏–Ω —Å–∏–º–ø–ª–µ–∫—Å–∞ void Methods :: Srt(D **X, int N) { int i, j, k; D temp; D *f = new D[N+1]; D *box = new D[N]; D **y = new D*[N+1]; for(i=0;i&lt;N+1;i++)//–¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è –ø–∞–º—è—Ç—å y[i] = new D[N+1]; for(i=0;i&lt;N;i++) box[i] = fit[i];//—Å—Ç–∞—Ä—ã–µ —Ç–∞—É –≤ –∫–æ—Ä–æ–±–∫—É for(i=0;i&lt;=N;i++) { for(j=0;j&lt;N;j++) fit[j] = X[j][i]; f[i] = I();//–∑–Ω–∞—á–µ–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–∏ –≤ –≤–µ—Ä—à–∏–Ω–∞—Ö —Å–∏–º–ø–ª–µ–∫—Å–∞ } for(i=0;i&lt;N;i++) fit[i] = box[i];//–≤—ã–∫–ª–∞–¥—ã–≤–∞–µ—Ç —Ç–∞—É –∏–∑ –∫–æ—Ä–æ–±–∫–∏ for(i=0;i&lt;N;i++) for(j=0;j&lt;=N;j++) y[i][j] = X[i][j]; for(i=0;i&lt;=N;i++) y[N][i] = f[i];//stack(X, f) //–°–æ—Ä—Ç–∏—Ä—É–µ—Ç —Å—Ç–æ–ª–±—Ü—ã –º–∞—Ç—Ä–∏—Ü—ã —Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, //—á—Ç–æ–±—ã —Ä–∞—Å–ø–æ–ª–æ–∂–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç—ã –≤ —Å—Ç—Ä–æ–∫–µ N –≤ –ø–æ—Ä—è–¥–∫–µ –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—è for(i=1;i&lt;=N;i++) for(j=0;j&lt;=Ni;j++) if(y[N][j] &gt;= y[N][j+1]) for(k=0;k&lt;=N;k++) { temp = y[k][j]; y[k][j] = y[k][j+1]; y[k][j+1] = temp; } //submatrix –≤—ã—Ä–µ–∑–∞–µ—Ç –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ for(i=0;i&lt;N;i++) for(j=0;j&lt;=N;j++) X[i][j] = y[i][j]; /* for(i=0;i&lt;=N;i++) { for(j=0;j&lt;=N;j++) cout &lt;&lt; y[i][j] &lt;&lt; " "; cout &lt;&lt; endl; } */ for(i=0;i&lt;N+1;i++) delete[]y[i]; delete[]box; delete[]f; } int main() { Methods method; //method.ofDescent(); //method.ofGradient(); method.ofNelder_Mid(); return 0; }</span></span></span></span></code> </pre></div></div><br><p>  It's enough for today.  The next step will be logical to try something from the global optimization, type more test functions, and then examine the packages with built-in methods. </p></div><p>Source: <a href="https://habr.com/ru/post/440070/">https://habr.com/ru/post/440070/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>