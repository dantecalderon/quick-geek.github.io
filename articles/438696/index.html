<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Swift compiler device. Part 3</title>
  <meta name="description" content="We continue to study the Swift compiler. This part is dedicated to Swift Intermediate Language. 


 If you have not seen the previous ones, I recommen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Swift compiler device. Part 3</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/w6/d3/5f/w6d35fpnglkxq8suebz-fhsl2de.png"><br><p>  We continue to study the Swift compiler.  This part is dedicated to Swift Intermediate Language. </p><br><p>  If you have not seen the previous ones, I recommend to follow the link and read: </p><br><ul><li>  <a href="https://habr.com/ru/company/e-Legion/blog/438204/">General overview of components</a> . </li><li>  <a href="https://habr.com/ru/company/e-Legion/blog/438664/">Parsing the source file</a> . <a name="habracut"></a></li></ul><br><h1 id="silgen">  Silgen </h1><br><p>  The next step is to convert typed AST to raw SIL.  Swift Intermediate Language (SIL) is an intermediate representation specially created for Swift.  A description of all instructions can be found in the <a href="">documentation</a> . </p><br><p>  SIL has an SSA form.  Static Single Assignment (SSA) is a representation of a code in which each variable is assigned a value only once.  It is created from ordinary code by adding additional variables.  For example, using a numeric suffix that indicates the version of the variable after each assignment. </p><br><p>  Thanks to this form it is easier for the compiler to optimize the code.  Below is an example in pseudocode.  Obviously, the first line is unnecessary: </p><br><pre><code class="plaintext hljs">a = 1 a = 2 b = a</code> </pre> <br><p>  But this is only for us.  To teach the compiler to define it, it would be necessary to write non-trivial algorithms.  But using SSA is much easier.  Now, even for a simple compiler, it will be obvious that the value of the <strong>a1</strong> variable is not used, and this line can be deleted: </p><br><pre> <code class="plaintext hljs">a1 = 1 a2 = 2 b1 = a2</code> </pre> <br><p>  SIL allows you to apply specific optimizations and checks to the Swift code that would be difficult or impossible to implement at the AST stage. </p><br><h3 id="ispolzovanie-generatora-sil">  Using SIL Generator </h3><br><p>  To generate SIL, the <strong>-emit-silgen</strong> flag is used: </p><br><pre> <code class="plaintext hljs">swiftc -emit-silgen main.swift</code> </pre> <br><p>  The result of the command: </p><br><pre> <code class="plaintext hljs">sil_stage raw import Builtin import Swift import SwiftShims let x: Int // x sil_global hidden [let] @$S4main1xSivp : $Int // main sil @main : $@convention(c) (Int32, UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;) -&gt; Int32 { bb0(%0 : $Int32, %1 : $UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;): alloc_global @$S4main1xSivp // id: %2 %3 = global_addr @$S4main1xSivp : $*Int // user: %8 %4 = metatype $@thin Int.Type // user: %7 %5 = integer_literal $Builtin.Int2048, 16 // user: %7 // function_ref Int.init(_builtinIntegerLiteral:) %6 = function_ref @$SSi22_builtinIntegerLiteralSiBi2048__tcfC : $@convention(method) (Builtin.Int2048, @thin Int.Type) -&gt; Int // user: %7 %7 = apply %6(%5, %4) : $@convention(method) (Builtin.Int2048, @thin Int.Type) -&gt; Int // user: %8 store %7 to [trivial] %3 : $*Int // id: %8 %9 = integer_literal $Builtin.Int32, 0 // user: %10 %10 = struct $Int32 (%9 : $Builtin.Int32) // user: %11 return %10 : $Int32 // id: %11 } // end sil function 'main' // Int.init(_builtinIntegerLiteral:) sil [transparent] [serialized] @$SSi22_builtinIntegerLiteralSiBi2048__tcfC : $@convention(method) (Builtin.Int2048, @thin Int.Type) -&gt; Int</code> </pre> <br><p>  SIL, like LLVM IR, can be output as source code.  You can find in it that at this stage Swift import of Builtin, Swift and SwiftShims modules was added. </p><br><p>  Despite the fact that you can write code in Swift directly in the global scope, SILGen generates the main function - the entry point to the program.  All code was located inside it, except for declaring a constant, since it is global and should be accessible everywhere. </p><br><p>  Most of the lines have a similar structure.  On the left is a pseudo-register, which stores the result of the instruction.  Then - the instruction itself and its parameters, and at the end - a comment indicating the register for which calculation this register will be used. </p><br><p>  For example, this line creates an integer literal of type Int2048 and a value of 16. This literal is saved in the fifth register and will be used to calculate the value of the seventh: </p><br><pre> <code class="plaintext hljs">%5 = integer_literal $Builtin.Int2048, 16 // user: %7</code> </pre> <br><p>  The function declaration begins with the keyword sil.  Further the name with prefix @, calling convention, parameters, type of return value and function code is indicated.  For the initializer <strong>Int.init (_builtinIntegerLiteral :)</strong> it is, of course, not specified, since this function is from another module, and it needs only to be declared, but not defined.  The dollar symbol indicates the start of the type indication: </p><br><pre> <code class="plaintext hljs">// Int.init(_builtinIntegerLiteral:) sil [transparent] [serialized] @$SSi22_builtinIntegerLiteralSiBi2048__tcfC : $@convention(method) (Builtin.Int2048, @thin Int.Type) -&gt; Int</code> </pre> <br><p>  <a href="https://en.wikipedia.org/wiki/Calling_convention">Calling convention</a> points out how to properly call a function.  This is necessary to generate machine code.  A detailed description of these principles is beyond the scope of the article. </p><br><p>  The name of initializers, like the names of structures, classes, methods, protocols, are distorted (name mangling).  This solves several problems at once. </p><br><p>  First, it allows you to use the same name in different modules and nested entities.  For example, for the first <strong>fff</strong> method, the name <strong>S4main3AAAV3fffSiyF is used</strong> , and for the second <strong>method, S4main3BBV3fffSiyF</strong> is <strong>used</strong> : </p><br><pre> <code class="plaintext hljs">struct AAA { func fff() -&gt; Int { return 8 } } struct BBB { func fff() -&gt; Int { return 8 } }</code> </pre> <br><p>  <strong>S</strong> means Swift, 4 is the number of characters in the module name, and 3 in the class name.  In the initializer, the literal <strong>Si</strong> denotes the standard type Swift.Int. </p><br><p>  Secondly, names and types of function arguments are added to the name.  This allows overloading.  For example, for the first method, <strong>S4main3AAAV3fff3iiiS2i_tF is</strong> generated, and for the second method, <strong>S4main3AAAV3fff3dddSiSd_tF</strong> is <strong>generated</strong> : </p><br><pre> <code class="plaintext hljs">struct AAA { func fff(iii internalName: Int) -&gt; Int { return 8 } func fff(ddd internalName: Double) -&gt; Int { return 8 } }</code> </pre> <br><p>  After the parameter names, the type of the return value is indicated, followed by the parameter types.  However, their internal names are not specified.  Unfortunately, there is no documentation for name mangling in Swift, and its implementation may change at any time. </p><br><p>  The function name is followed by its definition.  It consists of one or more basic block.  The base unit is a sequence of instructions with one entry point, one exit point, which does not contain branch instructions or conditions for early exit. </p><br><p>  The main function has one base unit that accepts all parameters passed to the function and contains all its code, since there are no branches in it: </p><br><pre> <code class="plaintext hljs">bb0(%0 : $Int32, %1 : $UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;):</code> </pre> <br><p>  We can assume that each field of view, bounded by curly brackets, is a separate base unit.  Suppose the code contains a branch: </p><br><pre> <code class="plaintext hljs">// before if 2 &gt; 5 { // true } else { // false } // after</code> </pre> <br><p>  In this case, at least 4 basic blocks will be generated for: </p><br><ul><li>  code to branch, </li><li>  the case where the expression is true </li><li>  the case where the expression is false, </li><li>  code after branching. </li></ul><br><p>  <strong>cond_br</strong> is an instruction for conditional <strong>branching</strong> .  If the value of the pseudo-register% 14 is true, then the transition to the <strong>bb1</strong> block is <strong>performed</strong> .  If not, then in <strong>bb2</strong> .  br is an unconditional jump that triggers the execution of the specified base unit: </p><br><pre> <code class="plaintext hljs">// before cond_br %14, bb1, bb2 // id: %15 bb1: // true br bb3 // id: %21 bb2: // Preds: bb0 // false br bb3 // id: %27 bb3: // Preds: bb2 bb1 // after</code> </pre> <br><p>  Source: </p><br><ul><li>  <a href="https://github.com/apple/swift/tree/master/lib/SILGen">SILGen Implementation files</a> , </li><li>  <a href="https://github.com/apple/swift/tree/master/include/swift/SIL">SIL Header files</a> , </li><li>  <a href="https://github.com/apple/swift/tree/master/lib/SIL">SIL Implementation files</a> , </li><li>  <a href="">SIL Documentation</a> . </li></ul><br><h1 id="sil-guaranteed-transformations">  SIL guaranteed transformations </h1><br><p>  The raw intermediate representation, which was obtained at the previous stage, is analyzed for correctness and transformed into canonical: functions marked transparent are <a href="https://en.wikipedia.org/wiki/Inline_expansion">inline</a> (the function call is replaced by its body), the values ‚Äã‚Äãof constant expressions are calculated, the functions that return values ‚Äã‚Äãare calculated do it in all branches of code, and so on. </p><br><p>  These conversions are mandatory and are performed even if code optimization is disabled. </p><br><h3 id="generaciya-kanonichnogo-sil">  Generating canonical SIL </h3><br><p>  To generate the canonical SIL, the <strong>-emit-sil</strong> flag is used: </p><br><pre> <code class="plaintext hljs">swiftc -emit-sil main.swift</code> </pre> <br><p>  The result of the command: </p><br><pre> <code class="plaintext hljs">sil_stage canonical import Builtin import Swift import SwiftShims let x: Int // x sil_global hidden [let] @$S4main1xSivp : $Int // main sil @main : $@convention(c) (Int32, UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;) -&gt; Int32 { bb0(%0 : $Int32, %1 : $UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;): alloc_global @$S4main1xSivp // id: %2 %3 = global_addr @$S4main1xSivp : $*Int // user: %6 %4 = integer_literal $Builtin.Int64, 16 // user: %5 %5 = struct $Int (%4 : $Builtin.Int64) // user: %6 store %5 to %3 : $*Int // id: %6 %7 = integer_literal $Builtin.Int32, 0 // user: %8 %8 = struct $Int32 (%7 : $Builtin.Int32) // user: %9 return %8 : $Int32 // id: %9 } // end sil function 'main' // Int.init(_builtinIntegerLiteral:) sil public_external [transparent] [serialized] @$SSi22_builtinIntegerLiteralSiBi2048__tcfC : $@convention(method) (Builtin.Int2048, @thin Int.Type) -&gt; Int { // %0 // user: %2 bb0(%0 : $Builtin.Int2048, %1 : $@thin Int.Type): %2 = builtin "s_to_s_checked_trunc_Int2048_Int64"(%0 : $Builtin.Int2048) : $(Builtin.Int64, Builtin.Int1) // user: %3 %3 = tuple_extract %2 : $(Builtin.Int64, Builtin.Int1), 0 // user: %4 %4 = struct $Int (%3 : $Builtin.Int64) // user: %5 return %4 : $Int // id: %5 } // end sil function '$SSi22_builtinIntegerLiteralSiBi2048__tcfC'</code> </pre> <br><p>  In this simple example, there are few changes.  To see the real work of the optimizer, you need to complicate the code a bit.  For example, add addition: </p><br><pre> <code class="plaintext hljs">let x = 16 + 8</code> </pre> <br><p>  In his raw SIL, you can find the addition of these literals: </p><br><pre> <code class="plaintext hljs">%13 = function_ref @$SSi1poiyS2i_SitFZ : $@convention(method) (Int, Int, @thin Int.Type) -&gt; Int // user: %14 %14 = apply %13(%8, %12, %4) : $@convention(method) (Int, Int, @thin Int.Type) -&gt; Int // user: %15</code> </pre> <br><p>  And in the canonical it is no longer.  Instead, the constant value 24 is used: </p><br><pre> <code class="plaintext hljs">%4 = integer_literal $Builtin.Int64, 24 // user: %5</code> </pre> <br><p>  Source: </p><br><ul><li>  <a href="https://github.com/apple/swift/tree/master/lib/SILOptimizer/Mandatory">SIL Optimizer Mandatory</a> </li></ul><br><h1 id="sil-optimization">  SIL optimization </h1><br><p>  Additional Swift-specific transformations are applied if optimization is enabled.  Among them, <a href="https://en.wikipedia.org/wiki/Generic_programming">specialization of generics</a> (optimization of a generic code for a specific type of parameter), <a href="https://marcofoco.com/the-power-of-devirtualization">devirtualization</a> (replacement of dynamic calls with static calls), inlayning, <a href="">optimization of ARC,</a> and much more.  The explanation of these techniques does not fit into the already overgrown article. </p><br><p>  Source: </p><br><ul><li>  <a href="https://github.com/apple/swift/tree/master/include/swift/SILOptimizer">SIL Optimizer Headers</a> </li><li>  <a href="https://github.com/apple/swift/tree/master/lib/SILOptimizer">SIL Optimizer Implementation files</a> </li></ul><br><p>  Since SIL is a Swift feature, I did not show examples of implementation this time.  We will return to the parenthesis compiler in the next section, when we will be engaged in the generation of LLVM IR. </p></div><p>Source: <a href="https://habr.com/ru/post/438696/">https://habr.com/ru/post/438696/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>