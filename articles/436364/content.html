<div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/sm/5p/or/sm5porzvybv5m_8ngvmgicgmeui.jpeg"><br><br>  Hi, Habr!  My name is Timur Shagiakhmetov, I am a PHP developer at <a href="https://tech.badoo.com/ru/">Badoo</a> . <br><br>  Application performance is one of the most important quality criteria for a programmer.  In questions of optimization of PHP applications the profiler is the assistant. <br><br>  Recently, we <a href="https://habr.com/company/badoo/blog/430722/">talked</a> about what tools we use for profiling.  Let me remind you: one of the tools for analyzing performance, when it is unclear which parts of the code most influenced the increase in response time, is <a href="http://php.net/xhprof">XHProf</a> .  This is an extension for PHP, which allows you to profile the code on the combat server and subsequently improve it. <br><br>  But I would also like to have a history of performance changes, so that you can track what and when it affected its deterioration, right?  About a year ago, we developed <a href="https://github.com/badoo/liveprof-ui">Liveprof for this</a> - a tool for automatic profiling of all requests with an interface for analyzing changes in application performance. <br><br>  Our tool allows you to analyze the change in the performance of any part of the code, to find the places where it fell most heavily.  At the same time, it is not necessary to specifically include it and wait for statistics to accumulate, it is always active and collects data for a certain percentage of all requests. <br><br>  In this article I will talk about the details of the implementation and features of the use of this tool. <br><a name="habracut"></a><br><h2>  Little about XHProf </h2><br>  First, a few words about the capabilities of XHProf itself.  This is a PHP profiler written in C as an extension.  It was developed on Facebook and made public.  It has several forks ( <a href="https://github.com/FriendsOfPHP/uprofiler">uprofiler</a> , <a href="https://github.com/tideways/php-profiler-extension">Tideways</a> ), fully compatible at the level of the output data format. <br><br>  XHProf places timers around all function / method calls.  Its use is associated with some overhead.  But they are not so big and allow you to use it in production. <br><br>  The result of XHProf is an array of elements in the following format: <br><br><pre><code class="php hljs">$data = [ <span class="hljs-string"><span class="hljs-string">'parentMethodName==&gt;childMethodName'</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">'ct'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">'wt'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-string"><span class="hljs-string">'cpu'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-string"><span class="hljs-string">'mu'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">528</span></span> <span class="hljs-string"><span class="hljs-string">'pmu'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ] ];</code> </pre> <br>  where <br><br>  <code><b>parentMethodName</b></code> and <code><b>childMethodName</b></code> are the parent and child methods, respectively; <br>  <code><b>ct</b></code> - the number of calls in the context of the request; <br>  <code><b>wt</b></code> is the request execution time (consists of the time spent by the processor and the waiting time for input / output or another service response); <br>  <code><b>cpu</b></code> - time spent by the processor to process the request; <br>  <code><b>mu</b></code> - change in memory consumption after calling the method; <br>  <code><b>pmu</b></code> - change in peak memory consumption after a method call. <br><br>  Some other options are also possible. <br><br>  XHProf also contains tools for visualizing the results thus obtained.  For each profiling operation, we obtain a table with a set of parameters for each method. <br><br>  For example, <br><br><div class="spoiler">  <b class="spoiler_title">bubble sort result</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArrayGenerator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRandomArray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(int $count)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ $array = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i &lt; $count; $i++) { $array[] = rand(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $array; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BubbleSorter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;$array)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ $len = count($array); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i &lt; $len ; $i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($j = <span class="hljs-number"><span class="hljs-number">0</span></span>; $j &lt; $len - $i - <span class="hljs-number"><span class="hljs-number">1</span></span>; $j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($array[$j] &gt; $array[$j + <span class="hljs-number"><span class="hljs-number">1</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;swap($array[$j], $array[$j + <span class="hljs-number"><span class="hljs-number">1</span></span>]); } } } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;$a, &amp;$b)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ $tmp = $a; $a = $b; $b = $tmp; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isSorted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $array)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function"> </span></span>{ $len = count($array); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i &lt; $len - <span class="hljs-number"><span class="hljs-number">1</span></span>; $i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($array[$i] &gt; $array[$i + <span class="hljs-number"><span class="hljs-number">1</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArrayPrinter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $array, string $delimiter = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">' '</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> implode($delimiter, $array) . PHP_EOL; } } xhprof_enable(); $n = <span class="hljs-number"><span class="hljs-number">10</span></span>; $arrayGenerator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \ArrayGenerator(); $array = $arrayGenerator-&gt;getRandomArray($n); $sorter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BubbleSorter(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$sorter-&gt;isSorted($array)) { $sorter-&gt;sort($array); } $printer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \ArrayPrinter(); $printer-&gt;print($array); $xhprof_data = xhprof_disable();</code> </pre><br></div></div><br><img src="https://habrastorage.org/webt/ip/cw/vi/ipcwviocimg7kjon1memwwziho8.png"><br><br>  You can go inside each method to find out which methods how many resources are used. <br><br>  You can also look at the call graph with the most demanding methods highlighted: <br><br><img src="https://habrastorage.org/webt/zq/yw/pl/zqywplc0eibbdxdotsr3f0bed_o.png"><br><br>  XHProf is useful for analyzing the performance of each request manually.  But it is also important for us to see the whole picture.  You need to understand how performance has changed over time.  For this purpose, a tool was developed that profiles queries automatically and allows you to analyze them in the web interface. <br><br><h2>  Liveprof: aggregate results and store history </h2><br>  How to get profiling history? <br><br>  First you need to configure the automatic launch of the profiler and save the results.  Productivity is not constant, and from start to start it fluctuates.  To avoid the influence of such fluctuations, we use the averaged data of several queries.  As a result, we get aggregated results for each query, for example, minimum, maximum, average, and 95th percentile.  It helps to find heavy things that may not be called for every request. <br><br>  Our tool has both advantages and some limitations. <br><br><h3>  What can aggregator: </h3><br><ol><li>  Automatic profiling of every Nth query. <br></li><li>  Daily aggregation of collected profiles. <br></li><li>  Ability to view graphs of changes in each parameter measured by the profiler.  For example, wt, cpu, mu, pmu, described above. <br></li><li>  View the performance change of any method for a certain interval. <br></li><li>  <a href="http://www.brendangregg.com/flamegraphs.html">Flamegraph</a> built on the latest aggregated data. <br></li><li>  Find queries that called a specific method. <br></li></ol><br><h3>  Limitations: </h3><br><ol><li>  Since our tool is aggregating, it is impossible to know the performance of a single query (for example, the slowest one) - the results are averaged over the last 24 hours.  But this is enough to assess the overall performance dynamics.  If a query has subsided in execution speed, the average value, the 95th percentile, and the maximum execution time will change. <br></li><li>  It is impossible to unequivocally restore the full call stack, since XHProf returns only unique parent-child pairs with the sum of the values ​​of resources expended. <br></li><li>  Query time error due to XHProf overhead.  The difference is not so big, but it must be taken into account when measuring the query execution time. <br></li></ol><br><h3>  How to use profiler </h3><br><ol><li>  First, you need to connect the profiler to the site or script.  The most convenient way to use the <a href="https://github.com/badoo/liveprof">tool is to automatically launch the profiler</a> : <br><br><pre> <code class="plaintext hljs">php composer.phar require badoo/liveprof # Run a script to configure database LIVE_PROFILER_CONNECTION_URL=mysql://db_user:db_password@db_mysql:3306/Profiler?charset=utf8 php vendor/badoo/liveprof/bin/install.php</code> </pre><br>  It supports PHP versions starting from 5.4, and its use involves minimal overhead, which allows it to be used in combat environments.  The tool automatically determines which profiler extension to use: <a href="http://php.net/xhprof">XHProf</a> , <a href="https://github.com/FriendsOfPHP/uprofiler">uprofiler</a> or <a href="https://github.com/tideways/php-profiler-extension">Tideways</a> .  At startup, you need to specify the parameters for connecting to the database and profiling settings. <br><br>  An example of using in code with default settings: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">'vendor/autoload.php'</span></span>; \Badoo\LiveProfiler\LiveProfiler::getInstance()-&gt;start(); <span class="hljs-comment"><span class="hljs-comment">// Code is here</span></span></code> </pre> <br>  Profiling results are saved to the database.  Once a day there is an aggregation process.  To do this, select all records for a specific query of the day and calculate the aggregated functions for each of the parameters.  Aggregation functions can be extended or redefined. <br><br>  The following are now available: <br><br><ul><li>  at least one day; </li><li>  maximum per day; </li><li>  average value per day; </li><li>  95th percentile per day. </li></ul><br></li><li>  The aggregator <a href="https://github.com/badoo/liveprof-ui">web client is</a> used to set up aggregation and view the results.  The easiest way to install it is in the docker container: <br><br><pre> <code class="php hljs">git <span class="hljs-keyword"><span class="hljs-keyword">clone</span></span> https:<span class="hljs-comment"><span class="hljs-comment">//github.com/badoo/liveprof-ui.git cd liveprof-ui docker-compose up web</span></span></code> </pre> </li><li>  Before the first start, you need to configure the database connection parameters, the list of fields and the used aggregated functions in the src / config / services.yaml configuration file.  Then run the installation script: <br><br><pre> <code class="php hljs">docker-compose exec web bash install.sh</code> </pre> </li><li>  It is necessary to register automatically running scripts of aggregation and cleaning of old data in crones: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment"># script aggregates all profiles for previous day, add it if you don't use a queue for aggregation jobs (parameter aggregator.use_jobs_in_aggregation=false) 0 2 * * * docker-compose -f %PATH_TO_PROJECT%/docker-compose.yml run --rm --entrypoint '/usr/local/bin/php /app/bin/cli.php cron:aggregate-all-profiles' web # script removes old aggregated data, by default &gt; 200 days 0 1 * * * docker-compose -f %PATH_TO_PROJECT%/docker-compose.yml run --rm --entrypoint '/usr/local/bin/php /app/bin/cli.php cron:remove-old-profiles' web 200</span></span></code> </pre> <br></li><li>  To fill in the test data, you can run the script: <br><br><pre> <code class="php hljs">docker-compose exec web php /app/bin/cli.php example:a-week-degradation</code> </pre> </li></ol><br><h2>  Interface description </h2><br>  The web interface is available at: 127.0.0.1:8000. <br><br>  By default, a page opens with a list of aggregated queries.  It makes it easy to find a query of interest, sort all queries by any of the parameters, and also re-aggregate a specific query to see the latest results: <br><br><img src="https://habrastorage.org/webt/qj/-d/6b/qj-d6bj1095huwhvqmzdwim1g6k.png"><br><br>  The page with a list of methods and graphs of performance changes is the most used when working with the tool.  Allows you to go through the call stack, watch the consumption of each parameter, as well as graphs of performance changes over a certain interval: <br><br><img src="https://habrastorage.org/webt/-6/ag/u4/-6agu45zuu1qs77tckpkngabjwq.png"><br><br>  <i>A page with a full list of methods invoked allows you to quickly find the method of interest and view graphs by going to the page with graphs:</i> <br><br><img src="https://habrastorage.org/webt/nj/g-/f_/njg-f_48jsuo8mcmlxuq1ukxj_4.png"><br>  <i>The <a href="http://www.brendangregg.com/flamegraphs.html">flame graph page of the</a> last aggregated query allows you to visually identify the most difficult parts.</i> <br><br>  Using XHProf imposes some limitations on the accuracy of the result.  This is due to the fact that the profiler does not return a full tree of calls, but only parent-child pairs.  Moreover, if some pair of methods was called from different places of the application, then as a result we get the sum of the time spent.  For a flamegraph, you need to have a full call tree.  When such a tree is restored, the parameter values ​​are normalized taking into account the time spent by the parents. <br><br><img src="https://habrastorage.org/webt/vp/lp/xr/vplpxry-gjd-lq774gg3ji9cooo.png"><br>  <i>A page with a list of methods that have become slower during the selected interval.</i> <br><br>  Also for each method, you can see which of the child calls affected the most performance.  For example, in the screenshot below, you can see that the <code>ServiceApi::getAvailableServices()</code> method is <code>ServiceApi::getAvailableServices()</code> 116 ms slower.  The reason for this was the addition of a call to <code>ServiceApi::getGifts()</code> (56 ms change) and an increase in the number of calls to the <code>ServiceApi::getConfigForList()</code> method from 1 to 5 (another 50 ms): <br><br> <a href=""><img src="https://habrastorage.org/webt/rv/mc/dd/rvmcddru-ay4x9cb45xsvey_tka.png"></a> <br><br>  If it is not known in advance which query has the most noticeable performance change, then a page with a list of methods that have begun to work more slowly without reference to a specific query will help: <br><br><img src="https://habrastorage.org/webt/-6/0b/3s/-60b3svwq_rg9z7wbzmzmpriapc.png"><br>  <i>A page with a search for queries that called a specific method.</i> <br><br>  It allows you to compare execution time in different requests.  Also useful in searching for unused code: <br><br><img src="https://habrastorage.org/webt/hq/du/lv/hqdulvav1asbj9nczgowuk1mvak.png"><br><br><h3>  Customization options </h3><br>  The tool has wide possibilities for customization: <br><br><ul><li>  You can add your own aggregation functions that calculate a certain value based on the transferred array of parameter values; <br></li><li>  You can change the database to store profiles and aggregated results (SQLite, MySQL and PostgreSQL are now supported, but you can also use others from the list available for <a href="https://www.doctrine-project.org/projects/doctrine-dbal/en/2.8/reference/configuration.html">Doctrine DBAL</a> ); <br></li><li>  You can override either the database connection manager or implement your own data retrieval methods; <br></li><li>  You can use the web interface both as a standalone project, and within any framework (for example, the control panel of the site).  Example: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">profileListAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{      &lt;i&gt;<span class="hljs-comment"><span class="hljs-comment">//Some custom logic before&lt;/i&gt;   $this-&gt;checkPermissions();   $App = new \Badoo\LiveProfilerUI\LiveProfilerUI();   $Page = $App-&gt;getPage('profile_method_list_page');   return $Page-&gt;setData($data)-&gt;render(); }</span></span></code> </pre> </li></ul><br><h2>  Conclusion </h2><br>  I hope our tool will be useful to other developers.  It will provide an opportunity to check the performance of any part of the code without using additional timers.  It will also facilitate the optimization process, because now you can see what has affected the application performance over time. <br><br>  It is available on GitHub: <a href="https://github.com/badoo/liveprof/">github.com/badoo/liveprof</a> , the web interface is <a href="https://github.com/badoo/liveprof-ui/">github.com/badoo/liveprof-ui</a> . <br><br>  The tool is in active development and may contain some errors.  I hope that with the participation of the community he will become even better.  Plans to add support for other profilers besides XHProf, as well as expand the list of supported databases. <br><br>  Send us feedback and questions on use to <a href="https://t.me/badoo_php_meetup">Telegram</a> , bugs and pull requests - straight to <a href="http://github.com/badoo/liveprof">GitHub</a> .  We welcome comments and suggestions! <br><br>  Special thanks to <a href="https://habr.com/users/PhoenixMSTU/">Grigory</a> for the idea and the first implementation. </div>