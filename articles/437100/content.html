<div class="post__text post__text-html js-mediator-article">  The first part of the translation is <a href="https://habr.com/ru/post/422573/">here</a> .  In this part we will talk about the effect of sharpness, average brightness, phases of the moon and atmospheric phenomena during the rain. <br><br><h2>  Part 6. Sharpen </h2><br>  In this section, we take a closer look at another post-processing effect from The Witcher 3 - Sharpen. <br><br>  Sharpening makes the output image a little clearer.  This effect is known to us from Photoshop and other graphic editors. <br><br>  In The Witcher 3, sharpening has two options: low and high.  I will tell about the difference between them below, but for now let's take a look at the screenshots: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/285/1fc/6bc/2851fc6bc19e39660e0307f2775b0322.png" alt="image"></div><br>  <i>Option "Low" - to</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc2/cd4/4cd/dc2cd44cd83306f2c08bbf7f87831d8c.png" alt="image"></div><br>  <i>“Low” option - after</i> <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aad/807/2aa/aad8072aa3977f32549856c0be24206b.png"></div><br>  <i>Option "High" - to</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b87/3ce/0f3/b873ce0f320a785f4fb4bc83e9a696f5.png"></div><br>  <i>Option “High” - after</i> <br><br>  If you want to take a look at more detailed (interactive) comparisons, then look at the <a href="https://www.geforce.com/whats-new/guides/the-witcher-3-wild-hunt-graphics-performance-and-tweaking-guide">section in the Nvidia The Witcher 3 manual</a> .  As you can see, the effect is especially noticeable on grass and foliage. <br><br>  In this part of the post we will study the frame from the very beginning of the game: I chose it intentionally, because here we see the relief (the long distance of drawing) and the dome of the sky. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/898/e97/895/898e9789593705231157a07ebcf34f5e.png"></div><br>  From the point of view of input data, sharpening requires a color buffer <b>t0</b> (LDR after tone correction and lens flares) and a depth buffer <b>t1</b> . <br><br>  Let's examine the pixel shader assembler code: <br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb3[3], immediateIndexed <br> dcl_constantbuffer cb12[23], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t1 <br> dcl_input_ps_siv v0.xy, position <br> dcl_output o0.xyzw <br> dcl_temps 7 <br> 0: ftoi r0.xy, v0.xyxx <br> 1: mov r0.zw, l(0, 0, 0, 0) <br> 2: ld_indexable(texture2d)(float,float,float,float) r0.x, r0.xyzw, t1.xyzw <br> 3: mad r0.x, r0.x, cb12[22].x, cb12[22].y <br> 4: mad r0.y, r0.x, cb12[21].x, cb12[21].y <br> 5: max r0.y, r0.y, l(0.000100) <br> 6: div r0.y, l(1.000000, 1.000000, 1.000000, 1.000000), r0.y <br> 7: mad_sat r0.y, r0.y, cb3[1].z, cb3[1].w <br> 8: add r0.z, -cb3[1].x, cb3[1].y <br> 9: mad r0.y, r0.y, r0.z, cb3[1].x <br> 10: add r0.y, r0.y, l(1.000000) <br> 11: ge r0.x, r0.x, l(1.000000) <br> 12: movc r0.x, r0.x, l(0), l(1.000000) <br> 13: mul r0.z, r0.x, r0.y <br> 14: round_z r1.xy, v0.xyxx <br> 15: add r1.xy, r1.xyxx, l(0.500000, 0.500000, 0.000000, 0.000000) <br> 16: div r1.xy, r1.xyxx, cb3[0].zwzz <br> 17: sample_l(texture2d)(float,float,float,float) r2.xyz, r1.xyxx, t0.xyzw, s0, l(0) <br> 18: lt r0.z, l(0), r0.z <br> 19: if_nz r0.z <br> 20: div r3.xy, l(0.500000, 0.500000, 0.000000, 0.000000), cb3[0].zwzz <br> 21: add r0.zw, r1.xxxy, -r3.xxxy <br> 22: sample_l(texture2d)(float,float,float,float) r4.xyz, r0.zwzz, t0.xyzw, s0, l(0) <br> 23: mov r3.zw, -r3.xxxy <br> 24: add r5.xyzw, r1.xyxy, r3.zyxw <br> 25: sample_l(texture2d)(float,float,float,float) r6.xyz, r5.xyxx, t0.xyzw, s0, l(0) <br> 26: add r4.xyz, r4.xyzx, r6.xyzx <br> 27: sample_l(texture2d)(float,float,float,float) r5.xyz, r5.zwzz, t0.xyzw, s0, l(0) <br> 28: add r4.xyz, r4.xyzx, r5.xyzx <br> 29: add r0.zw, r1.xxxy, r3.xxxy <br> 30: sample_l(texture2d)(float,float,float,float) r1.xyz, r0.zwzz, t0.xyzw, s0, l(0) <br> 31: add r1.xyz, r1.xyzx, r4.xyzx <br> 32: mul r3.xyz, r1.xyzx, l(0.250000, 0.250000, 0.250000, 0.000000) <br> 33: mad r1.xyz, -r1.xyzx, l(0.250000, 0.250000, 0.250000, 0.000000), r2.xyzx <br> 34: max r0.z, abs(r1.z), abs(r1.y) <br> 35: max r0.z, r0.z, abs(r1.x) <br> 36: mad_sat r0.z, r0.z, cb3[2].x, cb3[2].y <br> 37: mad r0.x, r0.y, r0.x, l(-1.000000) <br> 38: mad r0.x, r0.z, r0.x, l(1.000000) <br> 39: dp3 r0.y, l(0.212600, 0.715200, 0.072200, 0.000000), r2.xyzx <br> 40: dp3 r0.z, l(0.212600, 0.715200, 0.072200, 0.000000), r3.xyzx <br> 41: max r0.w, r0.y, l(0.000100) <br> 42: div r1.xyz, r2.xyzx, r0.wwww <br> 43: add r0.y, -r0.z, r0.y <br> 44: mad r0.x, r0.x, r0.y, r0.z <br> 45: max r0.x, r0.x, l(0) <br> 46: mul r2.xyz, r0.xxxx, r1.xyzx <br> 47: endif <br> 48: mov o0.xyz, r2.xyzx <br> 49: mov o0.w, l(1.000000) <br> 50: ret</code> <br> <br>  50 lines of assembler code look like a feasible task.  Let's get to its solution. <br><br><h3>  Sharpen value generation </h3><br>  The first stage is to load ( <a href="https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/dx-graphics-hlsl-to-load">Load</a> ) the depth buffer (line 1).  It is worth noting that the "Witcher 3" uses an inverted depth (1.0 - close, 0.0 - far).  As you may know, the hardware depth is tied nonlinearly (see <a href="https://developer.nvidia.com/content/depth-precision-visualized">this article for details</a> ). <br><br>  Lines 3-6 perform a very interesting way of binding this hardware depth [1.0 - 0.0] to the values ​​[near-far] (we set them at the MatrixPerspectiveFov stage).  Consider the values ​​from the constant buffer: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/636/345/52a/63634552ae9daf03f14305c118cccc25.png"></div><br>  Having a “close” value of 0.2, and a “far” value of 5000, we can calculate the values ​​of cb12_v21.xy as follows: <br><br> <code>cb12_v21.y = 1.0 / near <br> cb12_v21.x = - (1.0 / near) + (1.0 / near) * (near / far)</code> <br> <br>  This code fragment is quite common in TW3 shaders, so I think this is just a function. <br><br>  After obtaining the “depth of visibility pyramid” line 7 uses scale / distortion to create an interpolation coefficient (here we use <a href="https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/dx-graphics-hlsl-saturate">saturate</a> to limit the values ​​to [0-1]). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e89/efd/571/e89efd5711cb2aa1a3c544e9deda9321.png"></div><br>  cb3_v1.xy and cb3_v2.xy is the brightness of the sharpening effect at near and far distances.  Let's call them "sharpenNear" and "sharpenFar".  And this is the only difference between the “Low” and “High” options of this effect in The Witcher 3. <br><br>  Now it is time to use the resulting coefficient.  Lines 8-9 just perform <code>lerp(sharpenNear, sharpenFar, interpolationCoeff)</code> .  What is it for?  Due to this we get different brightness near Geralt and far from it.  Take a look: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/646/233/515/6462335151728759f236b58f14b894dd.png"></div><br>  Perhaps this is barely noticeable, but here we interpolate, based on the distance, the brightness of the sharpen next to the player (2.177151) and the brightness of the effect very far (1.91303).  After this calculation, we add to the brightness 1.0 (line 10).  Why do you need it?  Suppose that the operation lerp shown above gave us 0.0.  After adding 1.0, we naturally get 1.0, and this value will not affect the pixel when performing sharpening.  Read more about this below. <br><br>  While adding sharpness, we do not want to affect the sky.  This can be achieved by adding a simple conditional check: <br><br> <code>// Не выполнять sharpen для неба <br> float fSkyboxTest = (fDepth &gt;= 1.0) ? 0 : 1;</code> <br> <br>  In The Witcher 3, the pixel depth of the sky is 1.0, so we use it to get a kind of “binary filter” (interesting fact: in this case, <a href="https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/dx-graphics-hlsl-step">step</a> will not work properly). <br><br>  Now we can multiply the interpolated brightness by the “sky filter”: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63c/ed1/f50/63ced1f5036d9ee63cfe54de6a501bc1.png"></div><br>  This multiplication is performed in line 13. <br><br>  Shader code example: <br><br> <code>// Вычисление финального значения sharpen <br> float fSharpenAmount = fSharpenIntensity * fSkyboxTest;</code> <br> <br><h3>  Pixel Sampling Center </h3><br>  In <a href="https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/dx-graphics-hlsl-semantics">SV_Position</a> there is an aspect that will be important here: an <a href="http://www.asawicki.info/news_1516_half-pixel_offset_in_directx_11.html">offset of half a pixel</a> .  It turns out that this pixel in the upper left corner (0, 0) has coordinates not (0, 0) from the point of view of SV_Position.xy, but (0.5, 0.5).  Wow! <br><br>  Here we want to take a sample in the center of the pixel, so let's look at lines 14-16.  You can write them on HLSL: <br><br> <code>// Сэмплируем центр пикселя. <br> // Избавляемся от "половинопиксельного" смещения в SV_Position.xy. <br> float2 uvCenter = trunc( Input.Position.xy ); <br> <br> // Прибавляем половину пикселя, чтобы мы сэмплировали именно центр пикселя <br> uvCenter += float2(0.5, 0.5); <br> uvCenter /= g_Viewport.xy</code> <br> <br>  And later, we sample the color input texture from texcoords uvCenter.  Do not worry, the result of the sampling will be the same as in the “normal” method (SV_Position.xy / ViewportSize.xy). <br><br><h3>  To sharpen or not to sharpen </h3><br>  The decision about whether to use sharpen depends on fSharpenAmount. <br><br> <code>// Получаем значение текущего пикселя <br> float3 colorCenter = TexColorBuffer.SampleLevel( samplerLinearClamp, uvCenter, 0 ).rgb; <br> <br> // Финальный результат <br> float3 finalColor = colorCenter; <br> <br> if ( fSharpenAmount &gt; 0 ) <br> { <br> // здесь выполняем sharpening... <br> } <br> <br> return float4( finalColor, 1 );</code> <br> <br><h3>  Sharpen </h3><br>  It's time to look at the insides of the algorithm itself. <br><br>  In essence, it performs the following actions: <br><br>  - samples four times the input color texture at the corners of the pixel, <br><br>  - adds samples and calculates the average value, <br><br>  - calculates the difference between "center" and "cornerAverage", <br><br>  - finds the maximum absolute component of the difference, <br><br>  - adjusts max.  abs  component using scale + bias values <br><br>  - determines the effect size using max.  abs  component, <br><br>  - calculates the brightness value (luma) for "centerColor" and "averageColor", <br><br>  - divides the colorCenter into its luma, <br><br>  - calculates a new, interpolated luma value based on the magnitude of the effect, <br><br>  - multiplies the colorCenter by the new value of luma. <br><br>  Quite a lot of work, and it was difficult for me to figure it out, because I never experimented with sharpness filters. <br><br>  Let's start with the sampling pattern.  As you can see in the assembly code, four texture reads are performed. <br><br>  It would be best to show this with a pixel image as an example (the artist’s skill level is <i>an expert</i> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e3/d46/5fa/5e3d465fadc0bccd551256c40c6e5368.png"></div><br>  All reads in the shader use bilinear sampling (D3D11_FILTER_MIN_MAG_LINEAR_MIP_POINT). <br><br>  The offset from the center to each of the angles is (± 0.5, ± 0.5), depending on the angle. <br><br>  See how it can be implemented on HLSL?  Let's get a look: <br><br> <code>float2 uvCorner; <br> float2 uvOffset = float2( 0.5, 0.5 ) / g_Viewport.xy; // remember about division! <br> <br> float3 colorCorners = 0; <br> <br> // Верхний левый угол <br> // -0,5, -0.5 <br> uvCorner = uvCenter - uvOffset; <br> colorCorners += TexColorBuffer.SampleLevel( samplerLinearClamp, uvCorner, 0 ).rgb; <br> <br> // Верхний правый угол <br> // +0.5, -0.5 <br> uvCorner = uvCenter + float2(uvOffset.x, -uvOffset.y); <br> colorCorners += TexColorBuffer.SampleLevel( samplerLinearClamp, uvCorner, 0 ).rgb; <br> <br> // Нижний левый угол <br> // -0.5, +0.5 <br> uvCorner = uvCenter + float2(-uvOffset.x, uvOffset.y); <br> colorCorners += TexColorBuffer.SampleLevel( samplerLinearClamp, uvCorner, 0 ).rgb; <br> <br> // Нижний правый угол <br> // +0.5, +0.5 <br> uvCorner = uvCenter + uvOffset; <br> colorCorners += TexColorBuffer.SampleLevel( samplerLinearClamp, uvCorner, 0 ).rgb;</code> <br> <br>  So now all four samples are summarized in the variable “colorCorners”.  Let's follow these steps: <br><br> <code>// Вычисляем среднее четырёх углов <br> float3 averageColorCorners = colorCorners / 4.0; <br> <br> // Вычисляем разность цветов <br> float3 diffColor = colorCenter - averageColorCorners; <br> <br> // Находим макс. абс. RGB-компонент разности <br> float fDiffColorMaxComponent = max( abs(diffColor.x), max( abs(diffColor.y), abs(diffColor.z) ) ); <br> <br> // Корректируем этот коэффициент <br> float fDiffColorMaxComponentScaled = saturate( fDiffColorMaxComponent * sharpenLumScale + sharpenLumBias ); <br> <br> // Вычисляем необходимую величину резкости пикселя. <br> // Заметьте здесь "1.0" - именно поэтому мы прибавили в fSharpenIntensity значение 1.0. <br> float fPixelSharpenAmount = lerp(1.0, fSharpenAmount, fDiffColorMaxComponentScaled); <br> <br> // Вычисляем яркость "центра" пикселя и яркость среднего значения. <br> float lumaCenter = dot( LUMINANCE_RGB, finalColor ); <br> float lumaCornersAverage = dot( LUMINANCE_RGB, averageColorCorners ); <br> <br> // делим "centerColor" на его яркость <br> float3 fColorBalanced = colorCenter / max( lumaCenter, 1e-4 ); <br> <br> // Вычисляем новую яркость <br> float fPixelLuminance = lerp(lumaCornersAverage, lumaCenter, fPixelSharpenAmount); <br> <br> // Вычисляем цвет на выходе <br> finalColor = fColorBalanced * max(fPixelLuminance, 0.0); <br> } <br> <br> return float4(finalColor, 1.0);</code> <br> <br>  Edge recognition is performed by calculating max.  abs  the difference component.  Smart move!  See his visualization: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa9/a26/44a/aa9a2644a16b1b79c6213f7d4effe068.jpg"></div><br>  <i>Visualization of the maximum absolute difference component.</i> <br><br>  Fine.  Ready HLSL-shader posted <a href="https://drive.google.com/file/d/1TVMbNldvFS5vbt1gsKPSXlqJijiaDPtt/view%3Fusp%3Dsharing">here</a> .  Sorry for the pretty bad formatting.  You can use my <a href="https://astralcode.blogspot.com/2018/11/few-words-about-hlslexplorer.html">HLSLexplorer</a> program and experiment with the code. <br><br>  I am happy to say that the above code creates the same assembler code as in the game! <br><br>  To summarize: The Witcher 3's sharpness shader is very well written (note that fPixelSharpenAmount is greater than 1.0! That's interesting ...).  In addition, the main way to change the brightness of the effect is the brightness of near / far objects.  In this game, they are not constants;  I collected a few examples of the values: <br><br>  Skellige: <br><br><table><tbody><tr><th></th><th>  sharpenNear </th><th>  sharpenFar </th><th>  sharpenDistanceScale </th><th>  sharpenDistanceBias </th><th>  sharpenLumScale </th><th>  sharpenLumBias </th></tr><tr><td>  <b>low</b> </td></tr></tbody><tbody><tr><td>  <b>high</b> </td><td>  2.0 </td><td>  1.8 </td><td>  0.025 <br></td><td>  -0.25 <br></td><td>  -13.33333 <br></td><td>  1.33333 </td></tr></tbody></table><br>  Kaer Morhen: <br><br><table><tbody><tr><th></th><th>  sharpenNear <br></th><th>  sharpenFar <br></th><th>  sharpenDistanceScale <br></th><th>  sharpenDistanceBias <br></th><th>  sharpenLumScale <br></th><th>  sharpenLumBias <br></th></tr><tr><td>  low <br></td><td>  0.57751 <br></td><td>  0.31303 <br></td><td>  0.06665 <br></td><td>  -0.33256 <br></td><td>  -1.0 <br></td><td>  2.0 <br></td></tr><tr><td>  high <br></td><td>  2.17751 <br></td><td>  1.91303 <br></td><td>  0.06665 <br></td><td>  -0.33256 <br></td><td>  -1.0 <br></td><td>  2.0 </td></tr></tbody></table><br><h2>  Part 7. Average brightness </h2><br>  The operation of calculating the average brightness of the current frame can be found in almost any modern video game.  This value is often used later for the effect of eye adaptation and tonal correction (see the <a href="https://habr.com/ru/post/422573/">previous part of the</a> post).  In simple solutions, a brightness calculation is used for, say, a texture of 512 <sup>2</sup> in size, then its mip-level calculation and application of the latter.  This usually works, but it severely limits the possibilities.  More complex solutions use computational shaders that perform, for example, <a href="https://software.intel.com/en-us/articles/compute-shader-hdr-and-bloom">parallel reduction</a> . <br><br>  Let's find out how the CD Projekt Red team solved this problem in The Witcher 3.  In the previous part, I have already investigated the tonal correction and adaptation of the eye, so the only remaining piece of the puzzle remained the average brightness. <br><br>  To begin with, the calculation of the average brightness of The Witcher 3 consists of two passes.  For clarity, I decided to break them into separate parts, and first we will consider the first pass - “brightness distribution” (calculation of the brightness histogram). <br><br><h3>  Brightness distribution </h3><br>  These two passes are fairly easy to find in any frame analyzer.  These are proceeding calls to <a href="https://docs.microsoft.com/en-us/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-dispatch">Dispatch</a> right before the eye adapts: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7de/5fb/09c/7de5fb09ce00453f14262f9e2b1bae30.png"></div><br>  Let's look at the input for this pass.  He needs two textures: <br><br>  1) HDR-buffer color, the scale of which is reduced to 1/4 x 1/4 (for example, from 1920x1080 to 480x270), <br><br>  2) Full screen depth buffer <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/021/38b/795/02138b795946d192f553eadc20d34366.png"></div><br>  <i>HDR color buffer with 1/4 x 1/4 resolution.</i>  <i>Note the tricky trick - this buffer is part of a larger buffer.</i>  <i>Reusing buffers is good practice.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e3/62d/c97/0e362dc97908f75db564cff0f46b1e7e.png"></div><br>  <i>Full screen depth buffer</i> <br><br>  Why scale down the color buffer?  I think it's all about performance. <br><br>  As for the output of this pass, it is a structured buffer.  256 elements of 4 bytes each. <br><br>  Here, shaders have no debug information, so suppose that this is just a buffer of unsigned int values. <br><br>  Important: the first stage of the calculation of the average brightness causes <a href="https://docs.microsoft.com/en-us/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-clearunorderedaccessviewuint">ClearUnorderedAccessViewUint</a> to reset all the elements of the structured buffer. <br><br>  Let's examine the assembler code of the computational shader (this is the first computational shader for our entire analysis!) <br><br> <code>cs_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb0[3], immediateIndexed <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t1 <br> dcl_uav_structured u0, 4 <br> dcl_input vThreadGroupID.x <br> dcl_input vThreadIDInGroup.x <br> dcl_temps 6 <br> dcl_tgsm_structured g0, 4, 256 <br> dcl_thread_group 64, 1, 1 <br> 0: store_structured g0.x, vThreadIDInGroup.x, l(0), l(0) <br> 1: iadd r0.xyz, vThreadIDInGroup.xxxx, l(64, 128, 192, 0) <br> 2: store_structured g0.x, r0.x, l(0), l(0) <br> 3: store_structured g0.x, r0.y, l(0), l(0) <br> 4: store_structured g0.x, r0.z, l(0), l(0) <br> 5: sync_g_t <br> 6: ftoi r1.x, cb0[2].z <br> 7: mov r2.y, vThreadGroupID.x <br> 8: mov r2.zw, l(0, 0, 0, 0) <br> 9: mov r3.zw, l(0, 0, 0, 0) <br> 10: mov r4.yw, l(0, 0, 0, 0) <br> 11: mov r1.y, l(0) <br> 12: loop <br> 13: utof r1.z, r1.y <br> 14: ge r1.z, r1.z, cb0[0].x <br> 15: breakc_nz r1.z <br> 16: iadd r2.x, r1.y, vThreadIDInGroup.x <br> 17: utof r1.z, r2.x <br> 18: lt r1.z, r1.z, cb0[0].x <br> 19: if_nz r1.z <br> 20: ld_indexable(texture2d)(float,float,float,float) r5.xyz, r2.xyzw, t0.xyzw <br> 21: dp3 r1.z, r5.xyzx, l(0.212600, 0.715200, 0.072200, 0.000000) <br> 22: imul null, r3.xy, r1.xxxx, r2.xyxx <br> 23: ld_indexable(texture2d)(float,float,float,float) r1.w, r3.xyzw, t1.yzwx <br> 24: eq r1.w, r1.w, cb0[2].w <br> 25: and r1.w, r1.w, cb0[2].y <br> 26: add r2.x, -r1.z, cb0[2].x <br> 27: mad r1.z, r1.w, r2.x, r1.z <br> 28: add r1.z, r1.z, l(1.000000) <br> 29: log r1.z, r1.z <br> 30: mul r1.z, r1.z, l(88.722839) <br> 31: ftou r1.z, r1.z <br> 32: umin r4.x, r1.z, l(255) <br> 33: atomic_iadd g0, r4.xyxx, l(1) <br> 34: endif <br> 35: iadd r1.y, r1.y, l(64) <br> 36: endloop <br> 37: sync_g_t <br> 38: ld_structured r1.x, vThreadIDInGroup.x, l(0), g0.xxxx <br> 39: mov r4.z, vThreadIDInGroup.x <br> 40: atomic_iadd u0, r4.zwzz, r1.x <br> 41: ld_structured r1.x, r0.x, l(0), g0.xxxx <br> 42: mov r0.w, l(0) <br> 43: atomic_iadd u0, r0.xwxx, r1.x <br> 44: ld_structured r0.x, r0.y, l(0), g0.xxxx <br> 45: atomic_iadd u0, r0.ywyy, r0.x <br> 46: ld_structured r0.x, r0.z, l(0), g0.xxxx <br> 47: atomic_iadd u0, r0.zwzz, r0.x <br> 48: ret</code> <br> <br>  And the buffer of constants: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c14/805/dc6/c14805dc6b7ffd431d9307cc46dcba0d.png"></div><br>  We already know that the first input is the HDR color buffer.  With FullHD, its resolution is 480x270.  Let's look at the Dispatch call. <br><br>  Dispatch (270, 1, 1) - this means that we run 270 groups of threads.  Simply put, we run one thread group for each row of the color buffer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e9a/a97/7e3/e9aa977e3f9a60104fe9a66d797a27cc.png"></div><br>  <i>Each thread group executes one line of HDR buffer of colors.</i> <br><br>  Now that we have this context, let's try to figure out what the shader is doing. <br><br>  Each thread group has 64 threads in the X direction (dcl_thread_group 64, 1, 1), as well as shared memory, 256 elements with 4 bytes each (dcl_tgsm_structured g0, 4, 256). <br><br>  Note that in the shader we use <a href="https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/sv-groupthreadid">SV_GroupThreadID</a> (vThreadIDInGroup.x) [0-63] and <a href="https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/sv-groupid">SV_GroupID</a> (vThreadGroupID.x) [0-269]. <br><br>  1) We begin by assigning zero values ​​to all elements of shared memory.  Since the total memory contains 256 elements and 64 threads per group, this can be conveniently done using a simple loop: <br><br> <code>// Первый шаг - присвоение всем общим данным нулевых значений. <br> // Так как в каждой группе потоков есть 64 потока, каждый из них может с помощью простого смещения обнулить 4 элемента. <br> [unroll] for (uint idx=0; idx &lt; 4; idx++) <br> { <br> const uint offset = threadID + idx*64; <br> shared_data[ offset ] = 0; <br> }</code> <br> <br>  2) After that we set a barrier using <a href="https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/groupmemorybarrierwithgroupsync">GroupMemoryBarrierWithGroupSync</a> (sync_g_t).  We do this to ensure that all the threads in the shared memory of the groups are reset to zero before proceeding to the next stage. <br><br>  3) Now we are performing a loop that can be roughly written like this: <br><br> <code>// cb0_v0.x - это ширина буфера цветов уменьшенного масштаба. Для 1920x1080 она равна 1920/4 = 480; <br> float ViewportSizeX = cb0_v0.x; <br> [loop] for ( uint PositionX = 0; PositionX &lt; ViewportSizeX; PositionX += 64 ) <br> { <br> ...</code> <br> <br>  This is a simple for loop with an increment of 64 (did you already understand why?). <br><br>  The next step is the calculation of the position of the loaded pixel. <br><br>  Let's think about it. <br><br>  For the Y coordinate, we can use SV_GroupID.x, because we launched 270 thread groups. <br><br>  For the X coordinate, we ... can take advantage of the current group flow!  Let's try to do it. <br><br>  Since there are 64 streams in each group, this solution will bypass all the pixels. <br><br>  Consider a group of threads (0, 0, 0). <br><br>  - The stream (0, 0, 0) will process the pixels (0, 0), (64, 0), (128, 0), (192, 0), (256, 0), (320, 0), (384, 0), (448, 0). <br><br>  - The stream (1, 0, 0) will process the pixels (1, 0), (65, 0), (129, 0), (193, 0), (257, 0), (321, 0), (385, 0), (449, 0) ... <br><br>  - The stream (63, 0, 0) will process the pixels (63, 0), (127, 0), (191, 0), (255, 0), (319, 0), (383, 0), (447, 0) <br><br>  Thus, all pixels will be processed. <br><br>  We also need to ensure that we do not load pixels from outside the color buffer: <br><br> <code>// Мы попиксельно перемещаемся вдоль оси X. Значение Y равно GroupID. <br> uint CurrentPixelPositionX = PositionX + threadID; <br> uint CurrentPixelPositionY = groupID; <br> if ( CurrentPixelPositionX &lt; ViewportSizeX ) <br> { <br> // HDR-буфер цветов. <br> // Вычисляем позицию HDR-буфера цветов в экранном пространстве, загружаем его и вычисляем яркость. <br> uint2 colorPos = uint2(CurrentPixelPositionX, CurrentPixelPositionY); <br> float3 color = texture0.Load( int3(colorPos, 0) ).rgb; <br> float luma = dot(color, LUMA_RGB);</code> <br> <br>  Do you see?  It's pretty simple! <br><br>  I also calculated the brightness (line 21 of the assembler code). <br><br>  Great, we've already calculated the brightness from the color pixel.  The next step is to load (not sampling!) The corresponding depth value. <br><br>  But here we have a problem, because we have connected a full resolution depth buffer.  What to do with it? <br><br>  It is surprisingly simple - just multiply the colorPos by some constant (cb0_v2.z).  We reduced the HDR buffer color by a factor of four.  so the value will be 4! <br><br> <code>const int iDepthTextureScale = (int) cb0_v2.z; <br> uint2 depthPos = iDepthTextureScale * colorPos; <br> float depth = texture1.Load( int3(depthPos, 0) ).x;</code> <br> <br>  So far everything is great!  But ... we reached lines 24-25 ... <br><br> <code>24: eq r2.x, r2.x, cb0[2].w <br> 25: and r2.x, r2.x, cb0[2].y</code> <br> <br>  So.  First, we have a <a href="https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/eq--sm4---asm-">comparison of equality</a> with a floating point, its result is written in r2.x, and immediately after that comes ... what?  Bitwise <a href="https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/and--sm4---asm-">And</a> ??  Seriously?  For floating point values?  What the heck??? <br><br>  <b>Problem 'eq + and'</b> <br><br>  Let me just say that for me it was the hardest part of the shader.  I even tried strange combinations asint / asfloat ... <br><br>  And if you use a slightly different approach?  Let's just do the usual float-float comparison in HLSL. <br><br> <code>float DummyPS() : SV_Target0 <br> { <br> float test = (cb0_v0.x == cb0_v0.y); <br> return test; <br> }</code> <br> <br>  And this is what output in assembly code looks like: <br><br> <code>0: eq r0.x, cb0[0].y, cb0[0].x <br> 1: and o0.x, r0.x, l(0x3f800000) <br> 2: ret</code> <br> <br>  Interesting, right?  I did not expect to see here "and". <br><br>  0x3f800000 is just 1.0f ... It makes sense, because if we get a success, the comparison is 1.0 and 0.0 otherwise. <br><br>  What if we "replace" 1.0 with some other value?  For example: <br><br> <code>float DummyPS() : SV_Target0 <br> { <br> float test = (cb0_v0.x == cb0_v0.y) ? cb0_v0.z : 0.0; <br> return test; <br> }</code> <br> <br>  We get the following result: <br><br> <code>0: eq r0.x, cb0[0].y, cb0[0].x <br> 1: and o0.x, r0.x, cb0[0].z <br> 2: ret</code> <br> <br>  Ha!  It worked.  This is just the magic of the HLSL compiler.  Note: if we replace 0.0 with something else, then we simply get movc. <br><br>  Let's return to the computational shader.  The next step is to check if the depth is equal to the value of cb0_v2.w.  It is always 0.0 - in other words, we check whether the pixel is in the far plane (in the sky).  If yes, then we assign some value to this coefficient, approximately 0.5 (I checked on several frames). <br><br>  This calculated coefficient is used to interpolate between the brightness of the color and the brightness of the "sky" (the value of cb0_v2.x, which is often about 0.0).  I assume that it is necessary to control the importance of the sky in calculating the average brightness.  Usually the importance decreases.  Very clever idea. <br><br> <code>// Проверяем, лежит ли пиксель на дальней плоскости (в небе). Если да, то мы можем указать, как он будет <br> // смешиваться с нашими значениями. <br> float value = (depth == cb0_v2.w) ? cb0_v2.y : 0.0; <br> <br> // Если 'value' равно 0.0, то эта lerp просто даёт нам 'luma'. Однако если 'value' отличается <br> // (часто около 0.50), то вычисленное luma имеет гораздо меньший вес. (cb0_v2.x обычно близко к 0.0). <br> float lumaOk = lerp( luma, cb0_v2.x, value );</code> <br> <br>  Since we have lumaOk, the next step is to calculate its natural logarithm to create a good distribution.  But wait, say, lumaOk is 0.0.  We know that the value of log (0) is undefined, so we add 1.0, because log (1) = 0.0. <br><br>  After that, we scale the calculated logarithm by 128 to distribute it to 256 cells.  Very clever! <br><br>  And it is from here that this value is taken 88.722839.  This is <code>128 * натуральный логарифм (2)</code> . <br><br>  This is just the way HLSL calculates logarithms. <br><br>  In the HLSL assembly code, there is only one function that calculates logarithms: <a href="https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/log--sm4---asm-">log</a> , and it has base 2. <br><br> <code>// Предположим, что lumaOk равно 0.0. <br> // log(0) имеет значение undefined <br> // log(1) = 0. <br> // вычисляем натуральный логарифм яркости <br> lumaOk = log(lumaOk + 1.0); <br> <br> // Масштабируем логарифм яркости на 128 <br> lumaOk *= 128;</code> <br> <br>  Finally, we calculate the cell index from the log-distributed brightness and add 1 to the corresponding cell in the shared memory. <br><br> <code>// Вычисляем правильный индекс. Значение имеет формат Uint, поэтому в массиве 256 элементов, <br> // нужно убедиться, что мы не вышли за границы. <br> uint uLuma = (uint) lumaOk; <br> uLuma = min(uLuma, 255); <br> <br> // Прибавляем 1 к соответствующему значению яркости. <br> InterlockedAdd( shared_data[uLuma], 1 );</code> <br> <br>  The next step is to install the barrier again to ensure that all the pixels in the row were processed. <br><br>  And the final step is to add values ​​from shared memory to a structured buffer.  This is done in the same way, through a simple loop: <br><br> <code>// Ждём, пока обработаются все пиксели в строке <br> GroupMemoryBarrierWithGroupSync(); <br> <br> // Прибавление вычисленных значений в структурированный буфер. <br> [unroll] for (uint idx = 0; idx &lt; 4; idx++) <br> { <br> const uint offset = threadID + idx*64; <br> <br> uint data = shared_data[offset]; <br> InterlockedAdd( g_buffer[offset], data ); <br> }</code> <br> <br>  After all 64 streams in a stream group fill the common data, each stream adds 4 values ​​to the output buffer. <br><br>  Consider an output buffer.  Let's think about it.  The sum of all values ​​in the buffer is equal to the total number of pixels!  (at 480x270 = 129 600).  That is, we know how many pixels have a specific brightness value. <br><br>  If you have little understanding of computational shaders (like me), then at first it may not be clear, so read the post a few more times, take paper and a pencil, and try to understand the concepts on which this technique is built. <br><br>  That's all!  That is how "The Witcher 3" calculates the brightness histogram.  Personally, I have learned a lot when writing this part.  Congratulations to the guys from Projekt Red CD with excellent work! <br><br>  If you are interested in a full HLSL shader, then it is posted <a href="https://pastebin.com/8tgrw1bi">here</a> .  I always strive to get as close as possible to the game assembly code and I am absolutely happy that I succeeded again! <br><br><h2>  Average brightness calculation </h2><br>  This is the second part of the analysis of average brightness calculations in “The Witcher 3: Wild Hunt”. <br><br>  Before we fight another computational shader, let's briefly repeat what happened in the last part: we worked with an HDR color buffer with a scale reduced to 1 / 4x1 / 4.  After the first pass, we got a histogram of brightness (structured buffer of 256 unsigned integer values).  We calculated the logarithm for the brightness of each pixel, distributed it to 256 cells and increased the corresponding value of the structured buffer by 1 per pixel.  Due to this, the total sum of all values ​​in these 256 cells is equal to the number of pixels. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c3/89c/d16/3c389cd16ec2eed7617dcf9334429c6e.png"></div><br>  <i>An example of the output of the first pass.</i>  <i>Here are 256 elements.</i> <br><br>  For example, our fullscreen buffer is 1920x1080.  After zooming out, the first pass used a 480x270 buffer.  The sum of all 256 values ​​in the buffer will be equal to 480 * 270 = 129 600. <br><br>  After this brief introduction, we are ready to proceed to the next stage: to calculations. <br><br>  This time only one thread group is used (Dispatch (1, 1, 1)). <br><br>  Let's take a look at the compiler shader assembly code: <br><br> <code>cs_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb0[1], immediateIndexed <br> dcl_uav_structured u0, 4 <br> dcl_uav_typed_texture2d (float,float,float,float) u1 <br> dcl_input vThreadIDInGroup.x <br> dcl_temps 4 <br> dcl_tgsm_structured g0, 4, 256 <br> dcl_thread_group 64, 1, 1 <br> 0: ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r0.x, vThreadIDInGroup.x, l(0), u0.xxxx <br> 1: store_structured g0.x, vThreadIDInGroup.x, l(0), r0.x <br> 2: iadd r0.xyz, vThreadIDInGroup.xxxx, l(64, 128, 192, 0) <br> 3: ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r0.w, r0.x, l(0), u0.xxxx <br> 4: store_structured g0.x, r0.x, l(0), r0.w <br> 5: ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r0.x, r0.y, l(0), u0.xxxx <br> 6: store_structured g0.x, r0.y, l(0), r0.x <br> 7: ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r0.x, r0.z, l(0), u0.xxxx <br> 8: store_structured g0.x, r0.z, l(0), r0.x <br> 9: sync_g_t <br> 10: if_z vThreadIDInGroup.x <br> 11: mul r0.x, cb0[0].y, cb0[0].x <br> 12: ftou r0.x, r0.x <br> 13: utof r0.y, r0.x <br> 14: mul r0.yz, r0.yyyy, cb0[0].zzwz <br> 15: ftoi r0.yz, r0.yyzy <br> 16: iadd r0.x, r0.x, l(-1) <br> 17: imax r0.y, r0.y, l(0) <br> 18: imin r0.y, r0.x, r0.y <br> 19: imax r0.z, r0.y, r0.z <br> 20: imin r0.x, r0.x, r0.z <br> 21: mov r1.z, l(-1) <br> 22: mov r2.xyz, l(0, 0, 0, 0) <br> 23: loop <br> 24: breakc_nz r2.x <br> 25: ld_structured r0.z, r2.z, l(0), g0.xxxx <br> 26: iadd r3.x, r0.z, r2.y <br> 27: ilt r0.z, r0.y, r3.x <br> 28: iadd r3.y, r2.z, l(1) <br> 29: mov r1.xy, r2.yzyy <br> 30: mov r3.z, r2.x <br> 31: movc r2.xyz, r0.zzzz, r1.zxyz, r3.zxyz <br> 32: endloop <br> 33: mov r0.w, l(-1) <br> 34: mov r1.yz, r2.yyzy <br> 35: mov r1.xw, l(0, 0, 0, 0) <br> 36: loop <br> 37: breakc_nz r1.x <br> 38: ld_structured r2.x, r1.z, l(0), g0.xxxx <br> 39: iadd r1.y, r1.y, r2.x <br> 40: utof r2.x, r2.x <br> 41: utof r2.w, r1.z <br> 42: add r2.w, r2.w, l(0.500000) <br> 43: mul r2.w, r2.w, l(0.011271) <br> 44: exp r2.w, r2.w <br> 45: add r2.w, r2.w, l(-1.000000) <br> 46: mad r3.z, r2.x, r2.w, r1.w <br> 47: ilt r2.x, r0.x, r1.y <br> 48: iadd r2.w, -r2.y, r1.y <br> 49: itof r2.w, r2.w <br> 50: div r0.z, r3.z, r2.w <br> 51: iadd r3.y, r1.z, l(1) <br> 52: mov r0.y, r1.z <br> 53: mov r3.w, r1.x <br> 54: movc r1.xzw, r2.xxxx, r0.wwyz, r3.wwyz <br> 55: endloop <br> 56: store_uav_typed u1.xyzw, l(0, 0, 0, 0), r1.wwww <br> 57: endif <br> 58: ret</code> <br> <br>  There is one constant buffer: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbe/13a/0ab/bbe13a0abe0d79f47b0a59d33d51ab9c.png"></div><br>  Briefly take a look at the assembler code: two UAVs are attached (u0: input buffer from the first part and u1: output texture of 1x1 format R32_FLOAT).  We also see that there are 64 streams per group and 256 elements of 4-byte shared group memory. <br><br>  Let's start by filling the shared memory with data from the input buffer.  We have 64 threads, so we have to do almost the same thing as before. <br><br>  To be absolutely sure that all data is loaded for further processing, after that we put a barrier. <br><br> <code>// Первый этап - заполнение всех общих данных данными из предыдущего этапа. <br> // Так как в каждой группе потоков по 64 потока, каждый может заполнить 4 элемента в одном потоке <br> // с помощью простого смещения. <br> [unroll] for (uint idx=0; idx &lt; 4; idx++) <br> { <br> const uint offset = threadID + idx*64; <br> shared_data[ offset ] = g_buffer[offset]; <br> } <br> // Здесь мы устанавливаем барьер, то есть блокируем выполнение всех потоков группы, пока не будет завершён <br> // весь общий доступ групп и все потоки в группе не достигнут этого вызова. <br> GroupMemoryBarrierWithGroupSync();</code> <br> <br>  All calculations are performed only in one thread, all others are used simply to load values ​​from the buffer into the common memory. <br><br>  The “computational” flow has index 0. Why?  Theoretically, we can use any stream from the interval [0-63], but thanks to a comparison with 0, we can avoid additional integer-integer comparison ( <a href="https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/ieq--sm4---asm-">ieq</a> instructions). <br><br>  The algorithm is based on specifying the interval of pixels that will be taken into account in the operation. <br><br>  In line 11, we multiply the width * height to get the total number of pixels and multiply them by two numbers from the interval [0.0f-1.0f], denoting the beginning and end of the interval.  Further restrictions are used to ensure that <code>0 &lt;= Start &lt;= End &lt;= totalPixels - 1</code> : <br><br> <code>// Выполняем вычисления только для потока с индексом 0. <br> [branch] if (threadID == 0) <br> { <br> // Общее количество пикселей в буфере с уменьшенным масштабом <br> uint totalPixels = cb0_v0.x * cb0_v0.y; <br> <br> // Интервал пикселей (или, если конкретнее, интервал яркости на экране), <br> // который мы хотим задействовать в вычислении средней яркости. <br> int pixelsToConsiderStart = totalPixels * cb0_v0.z; <br> int pixelsToConsiderEnd = totalPixels * cb0_v0.w; <br> <br> int pixelsMinusOne = totalPixels - 1; <br> <br> pixelsToConsiderStart = clamp( pixelsToConsiderStart, 0, pixelsMinusOne ); <br> pixelsToConsiderEnd = clamp( pixelsToConsiderEnd, pixelsToConsiderStart, pixelsMinusOne );</code> <br> <br>  As you can see, there are two cycles below.  The problem with them (or with their assembly code) is that there are strange conditional jumps at the ends of the cycles.  It was very difficult for me to recreate them.  Also take a look at line 21. Why is there a -1?  I will explain this below. <br><br>  The task of the first cycle is to drop <i>pixelsToConsiderStart</i> and give us the buffer cell index, in which pixel <i>pixelsToConsiderStart</i> +1 is present (as well as the number of all pixels in the previous cells). <br><br>  Suppose that <i>pixelsToConsiderStart is</i> approximately equal to 30000, and in the buffer there are 37000 pixels in the “zero” cell (this happens in a game at night).  Therefore, we want to start analyzing the brightness at about pixel 30001, which is present in the “zero” cell.  In this case, we immediately exit the loop, getting the initial index '0' and zero dropped pixels. <br><br>  Look at the HLSL code: <br><br> <code>// Количество уже обработанных пикселей <br> int numProcessedPixels = 0; <br> <br> // Ячейка яркости [0-255] <br> int lumaValue = 0; <br> <br> // Надо ли продолжать выполнение цикла <br> bool bExitLoop = false; <br> <br> // Задача первого цикла - отбросить "pixelsToConsiderStart" пикселей. <br> // Мы сохраняем количество отброшенных пикселей из предыдущих ячеек и lumaValue, чтобы использовать их в следующем цикле. <br> [loop] <br> while (!bExitLoop) <br> { <br> // Получаем количество пикселей с заданным значением яркости. <br> uint numPixels = shared_data[lumaValue]; <br> <br> // Проверяем, сколько пикселей должно быть с lumaValue <br> int tempSum = numProcessedPixels + numPixels; <br> <br> // Если больше, чем pixelsToConsiderStart, то выходим из цикла. <br> // Следовательно, мы начнём вычисление яркости из lumaValue. <br> // Проще говоря, pixelsToConsiderStart - это количество "затемнённых" пикселей, которые нужно отбросить, прежде чем начинать вычисления. <br> [flatten] <br> if (tempSum &gt; pixelsToConsiderStart) <br> { <br> bExitLoop = true; <br> } <br> else <br> { <br> numProcessedPixels = tempSum; <br> lumaValue++; <br> } <br> }</code> <br> <br>  The mysterious number "-1" from line 21 of the assembler code is associated with a boolean condition for executing a loop (I discovered this almost by accident). <br><br>  Having obtained the number of pixels from the <i>lumaValue</i> cells and the <i>lumaValue</i> itself, we can proceed to the second cycle. <br><br>  The task of the second cycle is the calculation of the effect of pixels and average brightness. <br><br>  We start with <i>lumaValue</i> , calculated in the first loop. <br><br> <code>float finalAvgLuminance = 0.0f; <br> <br> // Количество отброшенных в первом цикле пикселей <br> uint numProcessedPixelStart = numProcessedPixels; <br> <br> // Задача этого цикла - вычисление влияния пикселей и средней яркости. <br> // Мы начинаем с точки, вычисленной в предыдущем цикле, сохраняя количество отброшенных пикселей и начальную позицию lumaValue. <br> // Декодируем значение яркости из интервала [0-255], умножаем его на количество пикселей, имеющих это значение яркости, и суммируем их, пока не дойдём <br> // до обработки пикселей pixelsToConsiderEnd. <br> // После этого мы делим общее влияние на количество проанализированных пикселей. <br> bExitLoop = false; <br> [loop] <br> while (!bExitLoop) <br> { <br> // Получаем количество пикселей с заданным значением яркости. <br> uint numPixels = shared_data[lumaValue]; <br> <br> // Прибавляем ко всем обработанным пикселям <br> numProcessedPixels += numPixels; <br> <br> // Текущее обрабатываемое значение яркости, распределённое в интервале [0-255] (uint) <br> uint encodedLumaUint = lumaValue; <br> <br> // Количество пикселей с текущим обрабатываемым значением яркости <br> float numberOfPixelsWithCurrentLuma = numPixels; <br> <br> // Текущее обрабатываемое значение яркости, закодированное в интервале [0-255] (float) <br> float encodedLumaFloat = encodedLumaUint;</code> <br> <br>  At this stage, we obtained the brightness value encoded in the interval [0.0f-255.f]. <br><br>  The decoding process is quite simple - you need to reverse the calculations of the encoding stage. <br><br>  Briefly repeat the coding process: <br><br> <code>float luma = dot( hdrPixelColor, float3(0.2126, 0.7152, 0.0722) ); <br> ... <br> float outLuma; <br> <br> // так как log(0) равен undef, а log(1) = 0 <br> outLuma = luma + 1.0; <br> <br> // распределяем логарифмически <br> outLuma = log( outLuma ); <br> <br> // масштабируем на 128, что означает log(1) * 128 = 0, log(2,71828) * 128 = 128, log(7,38905) * 128 = 256 <br> outLuma = outLuma * 128 <br> <br> // преобразуем в uint <br> uint outLumaUint = min( (uint) outLuma, 255);</code> <br> <br>  To decode the brightness, we reverse the encoding process, like this: <br><br> <code>// начинаем с прибавления 0.5f (мы не хотим, чтобы получился нулевой результат) <br> float fDecodedLuma = encodedLumaFloat + 0.5; <br> <br> // и декоридуем яркость: <br> <br> // Делим на 128 <br> fDecodedLuma /= 128.0; <br> <br> // exp(x), что отменяет log(x) <br> fDecodedLuma = exp(fDecodedLuma); <br> <br> // Вычитаем 1.0 <br> fDecodedLuma -= 1.0;</code> <br> <br>  Then we calculate the distribution, multiplying the number of pixels with a given brightness by the decoded brightness, and adding them together until we reach the processing <i>pixelsToConsiderEnd</i> pixels. <br><br>  After that, we divide the total effect by the number of pixels analyzed. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is the rest of the loop (and the shader): The </font><font style="vertical-align: inherit;">full shader is posted </font><a href="https://pastebin.com/U6zqMrcP"><font style="vertical-align: inherit;">here</font></a><font style="vertical-align: inherit;"> . It is fully compatible with my </font><a href="https://astralcode.blogspot.com/2018/11/few-words-about-hlslexplorer.html"><font style="vertical-align: inherit;">HLSLexplorer</font></a><font style="vertical-align: inherit;"> program </font><font style="vertical-align: inherit;">, without which I could not effectively recreate the calculation of the average brightness in The Witcher 3 (and all the other effects too!). </font><font style="vertical-align: inherit;">In conclusion, a few thoughts. From the point of view of calculating the average brightness, this shader was difficult to recreate. The main reasons are: </font><font style="vertical-align: inherit;">1) Strange "deferred" checks on the execution of the cycle, it took much longer than I expected earlier. </font><font style="vertical-align: inherit;">2) Problems with debugging this computational shader in RenderDoc (v. 1.2).</font></font><br><br> <code>// Вычисляем влияние этой яркости <br> float fCurrentLumaContribution = numberOfPixelsWithCurrentLuma * fDecodedLuma; <br> <br> // (Временное) влияние от всех предыдущих проходов и текущего. <br> float tempTotalContribution = fCurrentLumaContribution + finalAvgLuminance; <br> <br> <br> [flatten] <br> if (numProcessedPixels &gt; pixelsToConsiderEnd ) <br> { <br> // чтобы выйти из цикла <br> bExitLoop = true; <br> <br> // Мы уже обработали все нужные пиксели, поэтому выполняем здесь окончательное деление. <br> // Количество всех обработанных пикселей для выбранного пользователем начала <br> int diff = numProcessedPixels - numProcessedPixelStart; <br> <br> // Вычисляем окончательную среднюю яркость <br> finalAvgLuminance = tempTotalContribution / float(diff); <br> } <br> else <br> { <br> // Передаём текущее влияние дальше и увеличиваем lumaValue <br> finalAvgLuminance = tempTotalContribution; <br> lumaValue++; <br> } <br> } <br> <br> // Сохраняем среднюю яркость <br> g_avgLuminance[uint2(0,0)] = finalAvgLuminance;</code> <br> <br><font style="vertical-align: inherit;"></font><a href="https://pastebin.com/U6zqMrcP"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://astralcode.blogspot.com/2018/11/few-words-about-hlslexplorer.html"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The “ld_structured_indexable” operations are not fully supported, although the reading result from the index 0 gives the correct value, all the others return zeroes, because of which the cycles continue indefinitely. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although I was not able to achieve the same assembler code as in the original (see the screenshot below for differences), with the help of RenderDoc I was able to inject this shader into the pipeline - and the results were the same!</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de1/a0e/74f/de1a0e74f0f6619994d1edc9621d148d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The result of the battle. </font><font style="vertical-align: inherit;">On the left - my shader, on the right - the original assembly code.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Part 8. The moon and its phases </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the eighth part of the article, I explore the Moon's shader from The Witcher 3 (and more specifically from the Blood and Wine extension). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The moon is an important element of the night sky, and it can be quite difficult to make it believable, but for me walking at night in TW3 became a real pleasure. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Just look at this scene!</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53f/099/b6c/53f099b6ccfcef0eeb0755ced73894b9.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before we take on the pixel shader, I’ll say a few words about the nuances of rendering. Geometrically, the Moon is just a sphere (see below), which has texture coordinates, normal vectors, and tangent vectors. The vertex shader calculates the position in world space, as well as the normalized normal vectors, tangents and tangents to two points (using the vector product) multiplied by the world matrix. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To ensure that the moon completely lies on a distant plane, the MinDepth and MaxDepth fields of the D3D11_VIEWPORT structure </font></font><a href="https://docs.microsoft.com/en-us/windows/desktop/api/d3d11/ns-d3d11-d3d11_viewport"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> set to 0.0 (the same trick used for the dome of the sky). The moon is rendered immediately after the sky.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f5/999/ec7/6f5999ec7ca1176dfac370f60820d97f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The sphere used to draw the moon.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Well, everything, I think you can proceed. </font><font style="vertical-align: inherit;">Let's take a look at the pixel shader: The </font><font style="vertical-align: inherit;">main reason that I chose the shader from “Blood and Wine” is simple - it’s shorter. </font><font style="vertical-align: inherit;">First we calculate the offset for texture sampling. </font><font style="vertical-align: inherit;">cb0 [0] .w is used as an X-axis offset. With this simple trick, we can simulate the rotation of the moon around its axis.</font></font><br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb0[1], immediateIndexed <br> dcl_constantbuffer cb2[3], immediateIndexed <br> dcl_constantbuffer cb12[267], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_input_ps linear v1.w <br> dcl_input_ps linear v2.xyzw <br> dcl_input_ps linear v3.xy <br> dcl_input_ps linear v4.xy <br> dcl_output o0.xyzw <br> dcl_temps 3 <br> 0: mov r0.x, -cb0[0].w <br> 1: mov r0.y, l(0) <br> 2: add r0.xy, r0.xyxx, v2.xyxx <br> 3: sample_indexable(texture2d)(float,float,float,float) r0.xyzw, r0.xyxx, t0.xyzw, s0 <br> 4: add r0.xyz, r0.xyzx, l(-0.500000, -0.500000, -0.500000, 0.000000) <br> 5: log r0.w, r0.w <br> 6: mul r0.w, r0.w, l(2.200000) <br> 7: exp r0.w, r0.w <br> 8: add r0.xyz, r0.xyzx, r0.xyzx <br> 9: dp3 r1.x, r0.xyzx, r0.xyzx <br> 10: rsq r1.x, r1.x <br> 11: mul r0.xyz, r0.xyzx, r1.xxxx <br> 12: mul r1.xy, r0.yyyy, v3.xyxx <br> 13: mad r0.xy, v4.xyxx, r0.xxxx, r1.xyxx <br> 14: mad r0.xy, v2.zwzz, r0.zzzz, r0.xyxx <br> 15: mad r0.z, cb0[0].y, l(0.033864), cb0[0].w <br> 16: mul r0.z, r0.z, l(6.283185) <br> 17: sincos r1.x, r2.x, r0.z <br> 18: mov r2.y, r1.x <br> 19: dp2_sat r0.x, r0.xyxx, r2.xyxx <br> 20: mul r0.xyz, r0.xxxx, cb12[266].xyzx <br> 21: mul r0.xyz, r0.xyzx, r0.wwww <br> 22: mul r0.xyz, r0.xyzx, cb2[2].xyzx <br> 23: add_sat r0.w, -v1.w, l(1.000000) <br> 24: mul r0.w, r0.w, cb2[2].w <br> 25: mul o0.xyz, r0.wwww, r0.xyzx <br> 26: mov o0.w, l(0) <br> 27: ret</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc2/ddb/c02/fc2ddbc0262d27002f70d837a623c366.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Examples of values ​​from the buffer of constants</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> One texture (1024x512) is attached as input. </font><font style="vertical-align: inherit;">The normal map is encoded in the RGB channels, and the color of the moon's surface is encoded in the alpha channel. </font><font style="vertical-align: inherit;">Clever!</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/392/733/1a1/3927331a17867d712e667c36a0ee6641.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The alpha channel of the texture is the color of the surface of the moon.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c64/542/d70/c64542d70a7e3b58aa9426f12e8880d7.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texture RGB channels are a normal map.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Having the correct texture coordinates, we will sample the RGBA channels. We need to unpack the normal map and perform a gamma correction of the surface color. Currently, the HLSL shader can be written like this, for example: </font><font style="vertical-align: inherit;">The next step is to bind the normals, but only in the XY components. (In The Witcher 3, the Z axis is pointing up, and the entire Z-channel of the texture is 1.0). We can do it this way: </font><font style="vertical-align: inherit;">Now it’s time for my favorite part of this shader. </font><font style="vertical-align: inherit;">Take another </font><font style="vertical-align: inherit;">look at lines 15-16: </font><font style="vertical-align: inherit;">What is this mysterious 0.033864? At first it seems that there is no point in it, but if we calculate the inverse of it, we will get approximately 29.53, which is equal to the duration of the </font><a href="https://en.wikipedia.org/wiki/Lunar_month"><font style="vertical-align: inherit;">synodic month.</font></a></font><br><br> <code>float4 MoonPS(in InputStruct IN) : SV_Target0 <br> { <br> // Смещения Texcoords <br> float2 uvOffsets = float2(-cb0_v0.w, 0.0); <br> <br> // Готовые texcoords <br> float2 uv = IN.param2.xy + uvOffsets; <br> <br> // Сэмплирование текстуры <br> float4 sampledTexture = texture0.Sample( sampler0, uv); <br> <br> // Цвет поверхности Луны - выполняем гамма-коррекцию <br> float moonColorTex = pow(sampledTexture.a, 2.2 ); <br> <br> // Распаковываем нормали из интервала [0,1] в интервал [-1,1]. <br> // Примечание: sampledTexture.xyz * 2.0 - 1.0 работает аналогичным образом <br> float3 sampledNormal = normalize((sampledTexture.xyz - 0.5) * 2);</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>// Векторы касательного пространства <br> float3 Tangent = IN.param4.xyz; <br> float3 Normal = float3(IN.param2.zw, IN.param3.w); <br> float3 Bitangent = IN.param3.xyz; <br> <br> // Матрица TBN <br> float3x3 TBN = float3x3(Tangent, Bitangent, Normal); <br> <br> // Вычисление вектора нормали XY <br> // Ужимаем матрицу TBN во float3x2: 3 строки, 2 столбца <br> float2 vNormal = mul(sampledNormal, (float3x2)TBN).xy;</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>15: mad r0.z, cb0[0].y, l(0.033864), cb0[0].w <br> 16: mul r0.z, r0.z, l(6.283185)</code> <br> <br><font style="vertical-align: inherit;"></font><a href="https://en.wikipedia.org/wiki/Lunar_month"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the day! </font><font style="vertical-align: inherit;">This is what I call attention to detail! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can reliably assume that cb0 [0] .y is the number of days that have passed during the gameplay. </font><font style="vertical-align: inherit;">Here, an additional deviation is used, which is used as an offset along the X axis of the texture. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Having received this coefficient, we multiply it by 2 * Pi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then, using sincos, we compute another 2d vector. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The calculation of the scalar product between the normal vector and the "lunar" vector simulates one phase of the moon. </font><font style="vertical-align: inherit;">Look at the screenshots with different phases of the moon:</font></font><br><br> <code>// Лунная фаза. <br> // Мы вычисляем days/29.53 + bias. <br> float phase = cb0_v0.y * (1.0 / SYNODIC_MONTH_LENGTH) + cb0_v0.w; <br> <br> // Умножаем на 2*PI. Таким образом, 29.53 будет равно полному периоду <br> // для функций sin/cos. <br> phase *= TWOPI; <br> <br> // Вычисляем синус и косинус лунной фазы. <br> float outSin = 0.0; <br> float outCos = 0.0; <br> sincos(phase, outSin, outCos); <br> <br> // Вычисляем лунную фазу <br> float lunarPhase = saturate( dot(vNormal, float2(outCos, outSin)) );</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c54/e7f/648/c54e7f6488b10d402a7f4b45e61d455d.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/899/133/edc/899133edc0c04c67ffb4987748e908b7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The final stage is a series of multiplication operations to calculate the final color. </font><font style="vertical-align: inherit;">Perhaps you do not understand why this shader sends the alpha value 0.0 to the output. </font><font style="vertical-align: inherit;">This is because the moon is rendered with blending turned on:</font></font><br><br> <code>// Выполняем серию операций умножения для вычисления окончательного цвета. <br> <br> // cb12_v266.xyz используется, чтобы усилить свечение и цвет Луны. <br> // например (1.54, 2.82, 4.13) <br> float3 moonSurfaceGlowColor = cb12_v266.xyz; <br> <br> float3 moonColor = lunarPhase * moonSurfaceGlowColor; <br> moonColor = moonColorTex * moonColor; <br> <br> // cb_v2.xyz - это, вероятно, фильтр, например (1.0, 1.0, 1.0) <br> moonColor *= cb2_v2.xyz; <br> <br> // Не совсем понимаю, что делает этот фрагмент, возможно. это какое-то значение непрозрачности горизонта. <br> // Как бы то ни было, он имеет не такое большое влияние на окончательный цвет, <br> // как параметры выше. <br> float paramHorizon = saturate(1.0 - IN.param1.w); <br> paramHorizon *= cb2_v2.w; <br> <br> moonColor *= paramHorizon; <br> <br> // Выводим окончательный цвет с нулевым значением альфы <br> return float4(moonColor, 0.0);</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d9/549/32c/2d954932c188bcdcdd0a156796b85da7.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This approach allows you to get the color of the background (sky), if this shader returns black. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you are interested in a complete shader, you can take it </font></font><a href="https://pastebin.com/NTqC8sSu"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">It has large constant buffers and it should already be ready for injection into RenderDoc instead of the original shader (just rename “MoonPS” to “EditedShaderPS”). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One last thing: I wanted to share the results with you: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the left, my shader, on the right, the original shader from the game. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The difference is minimal and does not affect the results.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff8/c4a/8fa/ff8c4a8fa103b9592941c965ad060729.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As you can see, this shader was pretty easy to recreate. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Part 9. G-buffer </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this part, I’ll cover some of the details of the gbuffer in The Witcher 3. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We’ll assume that you know the basics of deferred shading. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A brief repetition: the idea of ​​postponing is not to calculate all the finished lighting and shading at once, but to divide the calculations into two steps. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the first (geometry pass) we fill the GBuffer with surface data (position, normals, specular color, etc ...), and in the second (illumination pass) we combine everything and calculate the illumination. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deferred shading is a very popular approach because it allows you to calculate techniques such as </font></font><a href="https://software.intel.com/en-us/articles/deferred-rendering-for-current-and-future-rendering-pipelines"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tile deferred shading</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in a single full-screen pass </font><font style="vertical-align: inherit;">, which greatly improves performance.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simply put, GBuffer is a set of textures with geometry properties. </font><font style="vertical-align: inherit;">It is very important to create the right structure for it. </font><font style="vertical-align: inherit;">As an example from real life, you can explore </font></font><a href="https://www.slideshare.net/TiagoAlexSousa/rendering-technologies-from-crysis-3-gdc-2013"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crysis 3 rendering technologies</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After this brief introduction, let's look at an example of a frame from The Witcher 3: Blood and Wine:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c3/6f5/537/2c36f5537e82217c31d0f5f682b17b6c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One of the many hotels in Tussent</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The main GBuffer consists of three full-screen render target format DXGI_FORMAT_R8G8B8A8_UNORM and depth buffer + stencil format DXGI_FORMAT_D24_UNORM_S8_UINT. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here are their screenshots:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/309/dec/857/309dec857a7839f41984b44ff82516ab.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Render Target 0 - RGB channels, surface color</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16c/44c/b90/16c44cb90b067cb420d921e101319bb0.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Render Target 0 - alpha channel. </font><font style="vertical-align: inherit;">Honestly, I have no idea what this information is.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de9/f1a/cf3/de9f1acf36c9f9e18ec6f4a9708ede11.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Render Target 1 - RGB channels. </font><font style="vertical-align: inherit;">Here we write the normal vectors in the interval [0-1].</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a5/a60/1e8/0a5a601e893d88a619b94f1ed7d21ae2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Render Target 1 - alpha channel. </font><font style="vertical-align: inherit;">It looks like reflectivity!</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7fa/8f5/d61/7fa8f5d61cfc903b764eec1e9b46c431.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Render Target 2 - RGB channels. </font><font style="vertical-align: inherit;">Looks like a specular color! </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this scene, the alpha channel is black (but later it is used).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7e/27d/dab/e7e27ddab2102174b3f63bb9037e28a0.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depth buffer </font><font style="vertical-align: inherit;">Notice that the inverted depth is used here.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4e/77d/daa/e4e77ddaa01705381f956410f546fdf4.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stencil buffer used to mark a certain type of pixel (for example, skin, vegetation, etc.)</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This is not the whole GBuffer. </font><font style="vertical-align: inherit;">The lighting pass also uses lighting probes and other buffers, but I will not consider them in this article. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before proceeding to the "main" part of the post, I will give general observations:</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> General observations </font></font></h3><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1) The only buffer to be cleared is the depth / stencil buffer.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If you analyze the above-mentioned textures in a good frame analyzer, then you will be a little surprised, because the “Clear” call is not used for them, with the exception of Depth / Stencil. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, in reality, RenderTarget1 looks like this (note the “blurry” pixels on the far plane):</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22a/16a/3a7/22a16a3a7df971c2d1609f15e254cd06.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is a simple and smart optimization. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Important lesson: </font><font style="vertical-align: inherit;">you need to waste resources </font><font style="vertical-align: inherit;">on calls to </font></font><a href="https://docs.microsoft.com/en-us/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-clearrendertargetview"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ClearRenderTargetView</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , so use them only when necessary. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2) Inverted depth - it is cool</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font></font><a href="https://outerra.blogspot.com/2012/11/maximizing-depth-buffer-range-and.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">many </font></font></a> <a href="https://developer.nvidia.com/content/depth-precision-visualized"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">articles </font></font></a> <a href="https://nlguillemot.wordpress.com/2016/12/07/reversed-z-in-opengl/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">already </font></font></a> <a href="http://dev.theomader.com/depth-precision/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">written</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> about the accuracy of the depth buffer with floating point. Witcher 3 uses reversed-z. This is a natural choice for such an open-world game and long-distance rendering. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It will be easy to switch to DirectX: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Clear the depth buffer with the entry “0”, not “1”. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the traditional approach, the remote value “1” was used to clean the depth buffer. After the reversal of the depth, the new "long-range" value became 0, so you need to change everything.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Swap the near and far boundaries when calculating the projection matrix </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c) Change the depth check from “less” to “more” </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For OpenGL, a little more work needs to be done (see the articles mentioned above), but it's worth it. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3) Do not keep a position in the world</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Yes, everything is so simple. </font><font style="vertical-align: inherit;">In the aisle of the lighting position in the world recreate from the depths.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixel shader </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this part, I wanted to show exactly the pixel shader that supplies surface data to GBuffer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So now we already know how to store color, normals and specular. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, everything is not as simple as you might think. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The problem with the pixel shader is that it has many options. </font><font style="vertical-align: inherit;">They differ in the number of textures transferred to them and the number of parameters used from the buffer of constants (probably from the buffer of constants describing the material). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For analysis, I decided to use this beautiful barrel:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/262/635/aa0/262635aa0a42dde5353586c867bc91d1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our heroic barrel! </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Please welcome textures:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e4/fde/9bb/9e4fde9bbe2ebcc3c1088eff5e3ea40d.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So we have albedo, normal map and specular color. Pretty standard case. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before we begin, a few words about the geometry input data: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geometry is transmitted with position, texcoords, normal buffers, and tangents. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The vertex shader displays </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at least</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> texcoords, normalized tangent / normal / tangent two-point vectors, previously multiplied by the world matrix. For more complex materials (for example, with two diffuse maps or two normal maps), the vertex shader can output other data, but I wanted to show a simple example here. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pixel shader in assembler code: The </font><font style="vertical-align: inherit;">shader consists of several stages. I will describe each major part of this shader separately.</font></font><br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb4[3], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_sampler s13, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t1 <br> dcl_resource_texture2d (float,float,float,float) t2 <br> dcl_resource_texture2d (float,float,float,float) t13 <br> dcl_input_ps linear v0.zw <br> dcl_input_ps linear v1.xyzw <br> dcl_input_ps linear v2.xyz <br> dcl_input_ps linear v3.xyz <br> dcl_input_ps_sgv v4.x, isfrontface <br> dcl_output o0.xyzw <br> dcl_output o1.xyzw <br> dcl_output o2.xyzw <br> dcl_temps 3 <br> 0: sample_indexable(texture2d)(float,float,float,float) r0.xyzw, v1.xyxx, t1.xyzw, s0 <br> 1: sample_indexable(texture2d)(float,float,float,float) r1.xyz, v1.xyxx, t0.xyzw, s0 <br> 2: add r1.w, r1.y, r1.x <br> 3: add r1.w, r1.z, r1.w <br> 4: mul r2.x, r1.w, l(0.333300) <br> 5: add r2.y, l(-1.000000), cb4[1].x <br> 6: mul r2.y, r2.y, l(0.500000) <br> 7: mov_sat r2.z, r2.y <br> 8: mad r1.w, r1.w, l(-0.666600), l(1.000000) <br> 9: mad r1.w, r2.z, r1.w, r2.x <br> 10: mul r2.xzw, r1.xxyz, cb4[0].xxyz <br> 11: mul_sat r2.xzw, r2.xxzw, l(1.500000, 0.000000, 1.500000, 1.500000) <br> 12: mul_sat r1.w, abs(r2.y), r1.w <br> 13: add r2.xyz, -r1.xyzx, r2.xzwx <br> 14: mad r1.xyz, r1.wwww, r2.xyzx, r1.xyzx <br> 15: max r1.w, r1.z, r1.y <br> 16: max r1.w, r1.w, r1.x <br> 17: lt r1.w, l(0.220000), r1.w <br> 18: movc r1.w, r1.w, l(-0.300000), l(-0.150000) <br> 19: mad r1.w, v0.z, r1.w, l(1.000000) <br> 20: mul o0.xyz, r1.wwww, r1.xyzx <br> 21: add r0.xyz, r0.xyzx, l(-0.500000, -0.500000, -0.500000, 0.000000) <br> 22: add r0.xyz, r0.xyzx, r0.xyzx <br> 23: mov r1.x, v0.w <br> 24: mov r1.yz, v1.zzwz <br> 25: mul r1.xyz, r0.yyyy, r1.xyzx <br> 26: mad r1.xyz, v3.xyzx, r0.xxxx, r1.xyzx <br> 27: mad r0.xyz, v2.xyzx, r0.zzzz, r1.xyzx <br> 28: uge r1.x, l(0), v4.x <br> 29: if_nz r1.x <br> 30: dp3 r1.x, v2.xyzx, r0.xyzx <br> 31: mul r1.xyz, r1.xxxx, v2.xyzx <br> 32: mad r0.xyz, -r1.xyzx, l(2.000000, 2.000000, 2.000000, 0.000000), r0.xyzx <br> 33: endif <br> 34: sample_indexable(texture2d)(float,float,float,float) r1.xyz, v1.xyxx, t2.xyzw, s0 <br> 35: max r1.w, r1.z, r1.y <br> 36: max r1.w, r1.w, r1.x <br> 37: lt r1.w, l(0.200000), r1.w <br> 38: movc r2.xyz, r1.wwww, r1.xyzx, l(0.120000, 0.120000, 0.120000, 0.000000) <br> 39: add r2.xyz, -r1.xyzx, r2.xyzx <br> 40: mad o2.xyz, v0.zzzz, r2.xyzx, r1.xyzx <br> 41: lt r1.x, r0.w, l(0.330000) <br> 42: mul r1.y, r0.w, l(0.950000) <br> 43: movc r1.x, r1.x, r1.y, l(0.330000) <br> 44: add r1.x, -r0.w, r1.x <br> 45: mad o1.w, v0.z, r1.x, r0.w <br> 46: dp3 r0.w, r0.xyzx, r0.xyzx <br> 47: rsq r0.w, r0.w <br> 48: mul r0.xyz, r0.wwww, r0.xyzx <br> 49: max r0.w, abs(r0.y), abs(r0.x) <br> 50: max r0.w, r0.w, abs(r0.z) <br> 51: lt r1.xy, abs(r0.zyzz), r0.wwww <br> 52: movc r1.yz, r1.yyyy, abs(r0.zzyz), abs(r0.zzxz) <br> 53: movc r1.xy, r1.xxxx, r1.yzyy, abs(r0.yxyy) <br> 54: lt r1.z, r1.y, r1.x <br> 55: movc r1.xy, r1.zzzz, r1.xyxx, r1.yxyy <br> 56: div r1.z, r1.y, r1.x <br> 57: div r0.xyz, r0.xyzx, r0.wwww <br> 58: sample_l(texture2d)(float,float,float,float) r0.w, r1.xzxx, t13.yzwx, s13, l(0) <br> 59: mul r0.xyz, r0.wwww, r0.xyzx <br> 60: mad o1.xyz, r0.xyzx, l(0.500000, 0.500000, 0.500000, 0.000000), l(0.500000, 0.500000, 0.500000, 0.000000) <br> 61: mov o0.w, cb4[2].x <br> 62: mov o2.w, l(0) <br> 63: ret</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> But first, as usual - a screenshot with the values ​​from the buffer of constants: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e94/24c/abb/e9424cabbd31630a47b7489e0e32c6af.jpg"></div><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Albedo </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We start with complex things. </font><font style="vertical-align: inherit;">This is not just </font></font><strike><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“OutputColor.rgb = Texture.Sample (uv) .rgb”</font></font></strike> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After sampling the RGB texture of the color (line 1), the next 14 lines are what I call the “saturation reduction buffer”. </font><font style="vertical-align: inherit;">Let me show the HLSL code: </font><font style="vertical-align: inherit;">For most objects, this code does nothing but return the original color from the texture. </font><font style="vertical-align: inherit;">This is achieved by the corresponding values ​​of "material cbuffer". </font><font style="vertical-align: inherit;">cb4_v1.x is set to 1.0, which returns a mask of 0.0, and returns the input color from the </font><i><font style="vertical-align: inherit;">lerp</font></i><font style="vertical-align: inherit;"> instruction </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">However, there are some exceptions. </font><font style="vertical-align: inherit;">The highest </font><i><font style="vertical-align: inherit;">desaturationFactor</font></i><font style="vertical-align: inherit;"> I </font><i><font style="vertical-align: inherit;">found</font></i><font style="vertical-align: inherit;"> is 4.0 (it is never less than 1.0), and </font><i><font style="vertical-align: inherit;">desaturatedColor</font></i></font><br><br> <code>float3 albedoColorFilter( in float3 color, in float desaturationFactor, in float3 desaturationValue ) <br> { <br> float sumColorComponents = color.r + color.g + color.b; <br> <br> float averageColorComponentValue = 0.3333 * sumColorComponents; <br> float oneMinusAverageColorComponentValue = 1.0 - averageColorComponentValue; <br> <br> float factor = 0.5 * (desaturationFactor - 1.0); <br> <br> float avgColorComponent = lerp(averageColorComponentValue, oneMinusAverageColorComponentValue, saturate(factor)); <br> float3 desaturatedColor = saturate(color * desaturationValue * 1.5); <br> <br> float mask = saturate( avgColorComponent * abs(factor) ); <br> <br> float3 finalColor = lerp( color, desaturatedColor, mask ); <br> return finalColor; <br> }</code> <br> <br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">depends on the material. </font><font style="vertical-align: inherit;">It can be something like (0.2, 0.3, 0.4); </font><font style="vertical-align: inherit;">there are no strict rules. </font><font style="vertical-align: inherit;">Of course, I could not refrain from implementing this in my own DX11 framework, and here are the results, where all values ​​of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desaturatedColor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are equal to float3 (0.25, 0.3, 0.45)</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/12f/184/2d9/12f1842d9d272fc057f35bc73439c4c1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desaturationFactor = 1.0 (no effect)</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/03c/ead/3a3/03cead3a3d5a713e051e7d863d99ecb0.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desaturationFactor = 2.0</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/caf/c81/992/cafc81992ebb70914c1e9d6605b8ba17.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desaturationFactor = 3.0</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f37/193/7fb/f371937fb39f94a887410a951f9eb628.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desaturationFactor = 4.0</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I’m sure it’s just the application of material parameters, but not the end of the part with albedo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lines 15-20 add the final touches: </font><font style="vertical-align: inherit;">v0.z is the output from the vertex shader, and they are zero. </font><font style="vertical-align: inherit;">Do not forget about this, because v0.z will be used a couple of times later. </font><font style="vertical-align: inherit;">It seems that this is some kind of coefficient, and the whole code looks like a slight darkening of albedo, but since v0.z is 0, the color remains the same. </font><font style="vertical-align: inherit;">HLSL: </font><font style="vertical-align: inherit;">As for RT0.a, then, as we see, it is taken from the buffer of material constants, but since the shader does not have debugging information, it is difficult to say what it is. </font><font style="vertical-align: inherit;">Possible translucency? </font><font style="vertical-align: inherit;">We are done with the first render target!</font></font><br><br> <code>15: max r1.w, r1.z, r1.y <br> 16: max r1.w, r1.w, r1.x <br> 17: lt r1.w, l(0.220000), r1.w <br> 18: movc r1.w, r1.w, l(-0.300000), l(-0.150000) <br> 19: mad r1.w, v0.z, r1.w, l(1.000000) <br> 20: mul o0.xyz, r1.wwww, r1.xyzx</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <code>/* ALBEDO */ <br> // опциональный фильтр снижения насыщенности (?) <br> float3 albedoColor = albedoColorFilter( colorTex, cb4_v1.x, cb4_v0.rgb ); <br> float albedoMaxComponent = getMaxComponent( albedoColor ); <br> <br> // Понятия не имею, что это <br> // В большинстве случаев вершинный шейдер выводит "paramZ" со значением 0 <br> float paramZ = Input.out0.z; // помните, чаще всего это 0 <br> <br> // Заметьте, что 0.70 и 0.85 отсутствуют в ассемблерном коде вывода <br> // Так как я хотел использовать здесь lerp, мне пришлось настроить их вручную. <br> float param = (albedoMaxComponent &gt; 0.22) ? 0.70 : 0.85; <br> float mulParam = lerp(1, param, paramZ); <br> <br> // Вывод <br> pout.RT0.rgb = albedoColor * mulParam; <br> pout.RT0.a = cb4_v2.x;</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Normals </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's start by unpacking the normal map, and then, as usual, we will bind the normals: </font><font style="vertical-align: inherit;">So far, nothing surprising. </font><i><font style="vertical-align: inherit;">Look at lines 28-33:</font></i><font style="vertical-align: inherit;"> We can roughly write them as follows: </font><font style="vertical-align: inherit;">Not sure if it is the right way to write. </font><font style="vertical-align: inherit;">If you know what this mathematical operation is, let me know. </font><font style="vertical-align: inherit;">We see that the pixel shader uses SV_IsFrontFace.</font></font><br><br> <code>/* НОРМАЛИ */ <br> float3 sampledNormal = ((normalTex.xyz - 0.5) * 2); <br> <br> // Данные для создания матрицы TBN <br> float3 Tangent = Input.TangentW.xyz; <br> float3 Normal = Input.NormalW.xyz; <br> float3 Bitangent; <br> Bitangent.x = Input.out0.w; <br> Bitangent.yz = Input.out1.zw; <br> <br> // в реальном сценарии это насыщение удаляется; это хак, для того, чтобы умножение normal-tbn <br> // давало в ассемблерном коде инструкции 'mad' вместо кучи 'mov' <br> Bitangent = saturate(Bitangent); <br> <br> float3x3 TBN = float3x3(Tangent, Bitangent, Normal); <br> float3 normal = mul( sampledNormal, TBN );</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <i><font style="vertical-align: inherit;"></font></i> <br><br> <code>28: uge r1.x, l(0), v4.x <br> 29: if_nz r1.x <br> 30: dp3 r1.x, v2.xyzx, r0.xyzx <br> 31: mul r1.xyz, r1.xxxx, v2.xyzx <br> 32: mad r0.xyz, -r1.xyzx, l(2.000000, 2.000000, 2.000000, 0.000000), r0.xyzx <br> 33: endif</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>[branch] if (bIsFrontFace &lt;= 0) <br> { <br> float cosTheta = dot(Input.NormalW, normal); <br> float3 invNormal = cosTheta * Input.NormalW; <br> normal = normal - 2*invNormal; <br> }</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br>  What it is?<font style="vertical-align: inherit;"></font><a href="https://docs.microsoft.com/en-us/windows/desktop/direct3dhlsl/dx-graphics-hlsl-semantics"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comes to help </font><font style="vertical-align: inherit;">(I wanted to write “msdn”, but ...):</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Determines whether the triangle is looking into the camera. </font><font style="vertical-align: inherit;">For lines and points, IsFrontFace is true. </font><font style="vertical-align: inherit;">Exceptions are the lines drawn from triangles (wireframe mode), which set IsFrontFace in a way similar to rasterizing a triangle in solid mode. </font><font style="vertical-align: inherit;">Writing to it can be done by a geometry shader, and reading from it can be done by a pixel shader.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I wanted to check it out by myself. </font><font style="vertical-align: inherit;">And in fact, the effect is noticeable only in wireframe mode. </font><font style="vertical-align: inherit;">I suppose this code fragment is needed to correctly calculate the normals (and hence the lighting) in wireframe mode. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is a comparison: both colors of the frame of the finished scene with this enabled / disabled trick, as well as the texture normals of gbuffer [0-1] with the enabled / disabled trick:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/598/46b/81b/59846b81b8b9ed57f0441f29e22e6656.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scene color without stunt</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/590/7e1/a97/5907e1a978e58b6fa362ef2e4b6187a8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Color scene with a gimmick</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/745/09a/c0e/74509ac0e56fa639ec4ae2d70a39be44.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normals [0-1] without stunt</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db8/2f8/622/db82f86223182135807d316fe479ff08.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normals [0-1] with a stunt.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Have you noticed that each render target in GBuffer has the format R8G8B8A8_UNORM? This means that there are 256 possible values ​​per component. Is this enough to store normals? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Storing high-quality normals with enough bytes in Gbuffer is a well-known problem, but fortunately there are a </font></font><a href="https://aras-p.info/texts/CompactNormalStorage.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lot of </font></font></a> <a href="https://knarkowicz.wordpress.com/2014/04/16/octahedron-normal-vector-encoding/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">different </font></font></a> <a href="http://hacksoflife.blogspot.com/2011/02/g-buffer-normals-revisited.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">materials</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to </font></font><a href="http://c0de517e.blogspot.com/2015/01/notes-on-g-buffer-normal-encodings.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">learn from</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhaps some of you already know which technique is used here. It must be said that in the whole passage of geometry there is one additional texture attached to slot 13 ...:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab1/e4a/0bf/ab1e4a0bf128bfed8837d3cd081748f8.jpg"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ha! </font><font style="vertical-align: inherit;">The Witcher 3 uses a technique called " </font></font><a href="http://advances.realtimerendering.com/s2010/Kaplanyan-CryEngine3(SIGGRAPH%25202010%2520Advanced%2520RealTime%2520Rendering%2520Course).pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Best Fit Normals</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". </font><font style="vertical-align: inherit;">Here I will not explain it in detail (see the presentation). </font><font style="vertical-align: inherit;">It was invented by Crytek around 2009-2010, and since CryEngine is open source, BFN is also </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">open source</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BFN gives the normal texture a “grainy” look. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After scaling the normals with BFN, we recode them from the interval [-1; 1] to [0, 1].</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Specular </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's start with line 34, and sample the specular texture: </font><font style="vertical-align: inherit;">As you can see, here we have the “dimming” filter familiar to us from Albedo: </font><font style="vertical-align: inherit;">Calculate the component with max. </font><font style="vertical-align: inherit;">value, and then we calculate the “darkened” color and interpolate it with the original specular color, taking the parameter from the vertex shader ... which is 0, so at the output we get the color from the texture. </font><font style="vertical-align: inherit;">HLSL:</font></font><br><br> <code>34: sample_indexable(texture2d)(float,float,float,float) r1.xyz, v1.xyxx, t2.xyzw, s0 <br> 35: max r1.w, r1.z, r1.y <br> 36: max r1.w, r1.w, r1.x <br> 37: lt r1.w, l(0.200000), r1.w <br> 38: movc r2.xyz, r1.wwww, r1.xyzx, l(0.120000, 0.120000, 0.120000, 0.000000) <br> 39: add r2.xyz, -r1.xyzx, r2.xyzx <br> 40: mad o2.xyz, v0.zzzz, r2.xyzx, r1.xyzx</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <code>/* SPECULAR */ <br> float3 specularTex = texture2.Sample( samplerAnisoWrap, Texcoords ).rgb; <br> <br> // Тот же алгоритм, что и в Albedo. Вычисляем макс. компонент, сравниваем его с <br> // каким-то пороговым значением и при необходимости вычисляем значение "минимума". <br> // Так как в анализируемой сцене paramZ имеет значение 0, окончательным результатом будет <br> //значение из текстуры. <br> float specularMaxComponent = getMaxComponent( specularTex ); <br> float3 specB = (specularMaxComponent &gt; 0.2) ? specularTex : float3(0.12, 0.12, 0.12); <br> float3 finalSpec = lerp(specularTex, specB, paramZ); <br> pout.RT2.xyz = finalSpec;</code> <br> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reflectivity </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I have no idea if this name is appropriate for this parameter, because I don’t know how it affects the lighting passage. </font><font style="vertical-align: inherit;">The fact is that the alpha channel of the input normal map contains additional data:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d2/9e5/bd1/5d29e5bd1cb4888593139c38630e3f8e.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alpha channel texture "normal maps". </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assembler code: </font><font style="vertical-align: inherit;">Say hello to our old friend - v0.z! </font><font style="vertical-align: inherit;">Its meaning is similar to albedo and specular:</font></font><br><br> <code>41: lt r1.x, r0.w, l(0.330000) <br> 42: mul r1.y, r0.w, l(0.950000) <br> 43: movc r1.x, r1.x, r1.y, l(0.330000) <br> 44: add r1.x, -r0.w, r1.x <br> 45: mad o1.w, v0.z, r1.x, r0.w</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>/* REFLECTIVITY */ <br> float reflectivity = normalTex.a; <br> float reflectivity2 = (reflectivity &lt; 0.33) ? (reflectivity * 0.95) : 0.33; <br> <br> float finalReflectivity = lerp(reflectivity, reflectivity2, paramZ); <br> pout.RT1.a = finalReflectivity;</code> <br> <br>  Fine!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is the end of the analysis of the first variant of the pixel shader. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is a comparison of my shader (left) with the original (right):</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c1/f18/47b/2c1f1847b5ceef3cd0e2f8dfba45d2a6.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> These differences do not affect the calculations, so my work here is finished. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixel Shader: Albedo + Normals Option </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I decided to show another option, now only with albedo maps and normals, without a specular texture. The assembler code is slightly longer: </font><font style="vertical-align: inherit;">The difference between this and the previous versions is as follows: </font><font style="vertical-align: inherit;">a) </font><b><font style="vertical-align: inherit;">lines 1, 19</font></b><font style="vertical-align: inherit;"> : the interpolation parameter v0.z is multiplied by cb4 [0] .x from the constant buffer, but this product is used only for the interpolation albedo in line 19. For other outputs, the “normal” value of v0.z is used. </font><font style="vertical-align: inherit;">b) </font><b><font style="vertical-align: inherit;">lines 54-55</font></b><font style="vertical-align: inherit;"> : o2.w is now set, provided that (cb4 [7] .x&gt; 0.0) </font><font style="vertical-align: inherit;">We already recognize this pattern “some comparison - AND” from the calculation of the brightness histogram. It can be written like this: </font><font style="vertical-align: inherit;">c) </font><b><font style="vertical-align: inherit;">lines 34-42</font></b><font style="vertical-align: inherit;"> : a completely different specular calculation.</font></font><br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb4[8], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_sampler s13, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t1 <br> dcl_resource_texture2d (float,float,float,float) t13 <br> dcl_input_ps linear v0.zw <br> dcl_input_ps linear v1.xyzw <br> dcl_input_ps linear v2.xyz <br> dcl_input_ps linear v3.xyz <br> dcl_input_ps_sgv v4.x, isfrontface <br> dcl_output o0.xyzw <br> dcl_output o1.xyzw <br> dcl_output o2.xyzw <br> dcl_temps 4 <br> 0: mul r0.x, v0.z, cb4[0].x <br> 1: sample_indexable(texture2d)(float,float,float,float) r1.xyzw, v1.xyxx, t1.xyzw, s0 <br> 2: sample_indexable(texture2d)(float,float,float,float) r0.yzw, v1.xyxx, t0.wxyz, s0 <br> 3: add r2.x, r0.z, r0.y <br> 4: add r2.x, r0.w, r2.x <br> 5: add r2.z, l(-1.000000), cb4[2].x <br> 6: mul r2.yz, r2.xxzx, l(0.000000, 0.333300, 0.500000, 0.000000) <br> 7: mov_sat r2.w, r2.z <br> 8: mad r2.x, r2.x, l(-0.666600), l(1.000000) <br> 9: mad r2.x, r2.w, r2.x, r2.y <br> 10: mul r3.xyz, r0.yzwy, cb4[1].xyzx <br> 11: mul_sat r3.xyz, r3.xyzx, l(1.500000, 1.500000, 1.500000, 0.000000) <br> 12: mul_sat r2.x, abs(r2.z), r2.x <br> 13: add r2.yzw, -r0.yyzw, r3.xxyz <br> 14: mad r0.yzw, r2.xxxx, r2.yyzw, r0.yyzw <br> 15: max r2.x, r0.w, r0.z <br> 16: max r2.x, r0.y, r2.x <br> 17: lt r2.x, l(0.220000), r2.x <br> 18: movc r2.x, r2.x, l(-0.300000), l(-0.150000) <br> 19: mad r0.x, r0.x, r2.x, l(1.000000) <br> 20: mul o0.xyz, r0.xxxx, r0.yzwy <br> 21: add r0.xyz, r1.xyzx, l(-0.500000, -0.500000, -0.500000, 0.000000) <br> 22: add r0.xyz, r0.xyzx, r0.xyzx <br> 23: mov r1.x, v0.w <br> 24: mov r1.yz, v1.zzwz <br> 25: mul r1.xyz, r0.yyyy, r1.xyzx <br> 26: mad r0.xyw, v3.xyxz, r0.xxxx, r1.xyxz <br> 27: mad r0.xyz, v2.xyzx, r0.zzzz, r0.xywx <br> 28: uge r0.w, l(0), v4.x <br> 29: if_nz r0.w <br> 30: dp3 r0.w, v2.xyzx, r0.xyzx <br> 31: mul r1.xyz, r0.wwww, v2.xyzx <br> 32: mad r0.xyz, -r1.xyzx, l(2.000000, 2.000000, 2.000000, 0.000000), r0.xyzx <br> 33: endif <br> 34: add r0.w, -r1.w, l(1.000000) <br> 35: log r1.xyz, cb4[3].xyzx <br> 36: mul r1.xyz, r1.xyzx, l(2.200000, 2.200000, 2.200000, 0.000000) <br> 37: exp r1.xyz, r1.xyzx <br> 38: mad r0.w, r0.w, cb4[4].x, cb4[5].x <br> 39: mul_sat r1.xyz, r0.wwww, r1.xyzx <br> 40: log r1.xyz, r1.xyzx <br> 41: mul r1.xyz, r1.xyzx, l(0.454545, 0.454545, 0.454545, 0.000000) <br> 42: exp r1.xyz, r1.xyzx <br> 43: max r0.w, r1.z, r1.y <br> 44: max r0.w, r0.w, r1.x <br> 45: lt r0.w, l(0.200000), r0.w <br> 46: movc r2.xyz, r0.wwww, r1.xyzx, l(0.120000, 0.120000, 0.120000, 0.000000) <br> 47: add r2.xyz, -r1.xyzx, r2.xyzx <br> 48: mad o2.xyz, v0.zzzz, r2.xyzx, r1.xyzx <br> 49: lt r0.w, r1.w, l(0.330000) <br> 50: mul r1.x, r1.w, l(0.950000) <br> 51: movc r0.w, r0.w, r1.x, l(0.330000) <br> 52: add r0.w, -r1.w, r0.w <br> 53: mad o1.w, v0.z, r0.w, r1.w <br> 54: lt r0.w, l(0), cb4[7].x <br> 55: and o2.w, r0.w, l(0.064706) <br> 56: dp3 r0.w, r0.xyzx, r0.xyzx <br> 57: rsq r0.w, r0.w <br> 58: mul r0.xyz, r0.wwww, r0.xyzx <br> 59: max r0.w, abs(r0.y), abs(r0.x) <br> 60: max r0.w, r0.w, abs(r0.z) <br> 61: lt r1.xy, abs(r0.zyzz), r0.wwww <br> 62: movc r1.yz, r1.yyyy, abs(r0.zzyz), abs(r0.zzxz) <br> 63: movc r1.xy, r1.xxxx, r1.yzyy, abs(r0.yxyy) <br> 64: lt r1.z, r1.y, r1.x <br> 65: movc r1.xy, r1.zzzz, r1.xyxx, r1.yxyy <br> 66: div r1.z, r1.y, r1.x <br> 67: div r0.xyz, r0.xyzx, r0.wwww <br> 68: sample_l(texture2d)(float,float,float,float) r0.w, r1.xzxx, t13.yzwx, s13, l(0) <br> 69: mul r0.xyz, r0.wwww, r0.xyzx <br> 70: mad o1.xyz, r0.xyzx, l(0.500000, 0.500000, 0.500000, 0.000000), l(0.500000, 0.500000, 0.500000, 0.000000) <br> 71: mov o0.w, cb4[6].x <br> 72: ret</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <code>pout.RT2.w = (cb4_v7.x &gt; 0.0) ? (16.5/255.0) : 0.0;</code> <br> <br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is no specular texture here. </font><font style="vertical-align: inherit;">Let's take a look at the assembly code responsible for this part: </font><font style="vertical-align: inherit;">Notice what we used here (1 is the reflected ability). </font><font style="vertical-align: inherit;">Fortunately, in HLSL it is quite simple to write: </font><font style="vertical-align: inherit;">I will add that in this variant the buffer of constants with these materials is slightly more. </font><font style="vertical-align: inherit;">Here, these additional values ​​are used to emulate a specular color. </font><font style="vertical-align: inherit;">The rest of the shader is the same as in the previous version. </font><font style="vertical-align: inherit;">72 lines of assembly code is too much to display in WinMerge, so take my word for it: my code is almost the same as in the original. </font><font style="vertical-align: inherit;">Or you can download my </font><a href="https://astralcode.blogspot.com/2018/11/few-words-about-hlslexplorer.html"><font style="vertical-align: inherit;">HLSLexplorer</font></a><font style="vertical-align: inherit;"> and see for yourself!</font></font><br><br> <code>34: add r0.w, -r1.w, l(1.000000) <br> 35: log r1.xyz, cb4[3].xyzx <br> 36: mul r1.xyz, r1.xyzx, l(2.200000, 2.200000, 2.200000, 0.000000) <br> 37: exp r1.xyz, r1.xyzx <br> 38: mad r0.w, r0.w, cb4[4].x, cb4[5].x <br> 39: mul_sat r1.xyz, r0.wwww, r1.xyzx <br> 40: log r1.xyz, r1.xyzx <br> 41: mul r1.xyz, r1.xyzx, l(0.454545, 0.454545, 0.454545, 0.000000) <br> 42: exp r1.xyz, r1.xyzx</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>float oneMinusReflectivity = 1.0 - normalTex.a; <br> float3 specularTex = pow(cb4_v3.rgb, 2.2); <br> oneMinusReflectivity = oneMinusReflectivity * cb4_v4.x + cb4_v5.x; <br> specularTex = saturate(specularTex * oneMinusReflectivity); <br> specularTex = pow(specularTex, 1.0/2.2); <br> <br> // продолжение как в первом варианте... <br> float specularMaxComponent = getMaxComponent( specularTex ); <br> ...</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><a href="https://astralcode.blogspot.com/2018/11/few-words-about-hlslexplorer.html"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Summarize </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... and if you have read this far, then you may want to go a bit more deeply. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What seems simple in real life is often not so, and data transfer to the gbuffer The Witcher 3 is no exception. </font><font style="vertical-align: inherit;">I showed you only the simplest versions of pixel shaders responsible for it, and also cited general observations that relate to deferred shadowing in general. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For the most patient, there are two options for pixel shaders in pastebin: </font></font><br><br> <a href="https://pastebin.com/VtAabHKK"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Option 1 - with a specular texture </font></font></a> <br><br> <a href="https://pastebin.com/khWQwpgv"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Option 2 - without a specular texture</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Part 10. Curtains of rain in the distance </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this part, we will look at a wonderful atmospheric effect, which I like very much - the distant </font><font style="vertical-align: inherit;">rain / light </font></font><a href="https://en.wikipedia.org/wiki/Precipitation_shaft"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">curtains</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> near the horizon. </font><font style="vertical-align: inherit;">In the game they are easiest to meet on the Skellige Islands.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/VXt4PEEqV2k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Personally, I really like this atmospheric phenomenon and was curious how the graphics programmers CD Projekt Red implemented it. </font><font style="vertical-align: inherit;">Let's figure it out! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here are two screenshots before and after applying rain curtains:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9a/62a/eb6/a9a62aeb6050efd2404f9d352fc89d33.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before the rain curtains</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9aa/e43/fcf/9aae43fcf34413a4810778e101b8a209.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After the rain curtains</font></font></i> <br><br><h3>  Geometry </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First we will focus on geometry. </font><font style="vertical-align: inherit;">The idea is to use a small cylinder:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc4/df3/add/fc4df3addf2524bc18f91c46a42fcd6a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A cylinder in a local space</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> From the point of view of its position in a local space, it is small enough - its position is in the interval (0.0 - 1.0). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The input scheme for this render call looks like this ...</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c1d/a35/c00/c1da35c0080225e7a47d8010c42aeab8.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following is important to us here: Texcoords and Instance_Transform. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texcoords are wrapped quite simply: U of the upper and lower bases are in the interval [0.02777 - 1.02734]. V on the bottom base is 1.0, and on the top base 0.0. As you can see, you can quite simply create this mesh, even procedurally. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After receiving this small cylinder in local space, we multiply it by the world matrix provided for each instance of the INSTANCE_TRANSFORM input element. Let's check the values ​​of this matrix:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e88/791/17e/e8879117edb6f1dd9b53d3e7334a22df.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/adf/fb8/697/adffb8697a86ac86b935a00d6ae23dda.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/608/599/f6c/608599f6cf3930889c92df1a256991af.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Looks pretty scary, right? </font><font style="vertical-align: inherit;">But do not worry, we will analyze this matrix and see what it hides! </font><font style="vertical-align: inherit;">The results are very interesting: </font><font style="vertical-align: inherit;">It is important to know the position of the camera in this particular frame: (-116.5338, 234.8695, 2.09) </font><font style="vertical-align: inherit;">As you can see, we scaled the cylinder to make it quite large in global space (in TW3, the Z axis is up), moved it relative to the camera position and turned. </font><font style="vertical-align: inherit;">Here is what the cylinder looks like after the vertex shader transforms:</font></font><br><br> <code>XMMATRIX mat( -227.7472, 159.8043, 374.0736, -116.4951, <br> -194.7577, -173.3836, -494.4982, 238.6908, <br> -14.16466, -185.4743, 784.564, -1.45565, <br> 0.0, 0.0, 0.0, 1.0 ); <br> <br> mat = XMMatrixTranspose( mat ); <br> <br> XMVECTOR vScale; <br> XMVECTOR vRotateQuat; <br> XMVECTOR vTranslation; <br> XMMatrixDecompose( &amp;vScale, &amp;vRotateQuat, &amp;vTranslation, mat ); <br> <br> // Матрица поворота... <br> XMMATRIX matRotate = XMMatrixRotationQuaternion( vRotateQuat );</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>vRotateQuat: (0.0924987569, -0.314900011, 0.883411944, -0.334462732) <br> <br> vScale: (299.999969, 300.000000, 1000.00012) <br> <br> vTranslation: (-116.495102, 238.690796, -1.45564997)</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f60/457/ca6/f60457ca61dd2d15ec3805b387e71def.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cylinder after conversion by vertex shader. </font><font style="vertical-align: inherit;">See how it is located relative to the visibility pyramid.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vertex shader </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The input geometry and the vertex shader are strictly dependent on each other. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's take a closer look at the vertex shader assembler code: </font><font style="vertical-align: inherit;">Along with the simple transfer Texcoords (line 0) and Instance_LOD_Params (line 8), two more elements are needed for output: SV_Position (obviously) and Height (component .z) of the world's position. </font><font style="vertical-align: inherit;">Remember that local space is in the range [0-1]? So, right before applying the world matrix, the vertex shader uses scale and deflection to change the local position. Smart move! </font><font style="vertical-align: inherit;">In this case, scale = float3 (4, 4, 2), and bias = float3 (-2, -2, -1). &lt; </font><font style="vertical-align: inherit;">The pattern that is visible between lines 9 and 28 is the multiplication of two row-major-matrices. </font><font style="vertical-align: inherit;">Let's just look at the finished vertex shader on HLSL:</font></font><br><br> <code>vs_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb1[7], immediateIndexed <br> dcl_constantbuffer cb2[6], immediateIndexed <br> dcl_input v0.xyz <br> dcl_input v1.xy <br> dcl_input v4.xyzw <br> dcl_input v5.xyzw <br> dcl_input v6.xyzw <br> dcl_input v7.xyzw <br> dcl_output o0.xyz <br> dcl_output o1.xyzw <br> dcl_output_siv o2.xyzw, position <br> dcl_temps 2 <br> 0: mov o0.xy, v1.xyxx <br> 1: mul r0.xyzw, v5.xyzw, cb1[6].yyyy <br> 2: mad r0.xyzw, v4.xyzw, cb1[6].xxxx, r0.xyzw <br> 3: mad r0.xyzw, v6.xyzw, cb1[6].zzzz, r0.xyzw <br> 4: mad r0.xyzw, cb1[6].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 5: mad r1.xyz, v0.xyzx, cb2[4].xyzx, cb2[5].xyzx <br> 6: mov r1.w, l(1.000000) <br> 7: dp4 o0.z, r1.xyzw, r0.xyzw <br> 8: mov o1.xyzw, v7.xyzw <br> 9: mul r0.xyzw, v5.xyzw, cb1[0].yyyy <br> 10: mad r0.xyzw, v4.xyzw, cb1[0].xxxx, r0.xyzw <br> 11: mad r0.xyzw, v6.xyzw, cb1[0].zzzz, r0.xyzw <br> 12: mad r0.xyzw, cb1[0].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 13: dp4 o2.x, r1.xyzw, r0.xyzw <br> 14: mul r0.xyzw, v5.xyzw, cb1[1].yyyy <br> 15: mad r0.xyzw, v4.xyzw, cb1[1].xxxx, r0.xyzw <br> 16: mad r0.xyzw, v6.xyzw, cb1[1].zzzz, r0.xyzw <br> 17: mad r0.xyzw, cb1[1].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 18: dp4 o2.y, r1.xyzw, r0.xyzw <br> 19: mul r0.xyzw, v5.xyzw, cb1[2].yyyy <br> 20: mad r0.xyzw, v4.xyzw, cb1[2].xxxx, r0.xyzw <br> 21: mad r0.xyzw, v6.xyzw, cb1[2].zzzz, r0.xyzw <br> 22: mad r0.xyzw, cb1[2].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 23: dp4 o2.z, r1.xyzw, r0.xyzw <br> 24: mul r0.xyzw, v5.xyzw, cb1[3].yyyy <br> 25: mad r0.xyzw, v4.xyzw, cb1[3].xxxx, r0.xyzw <br> 26: mad r0.xyzw, v6.xyzw, cb1[3].zzzz, r0.xyzw <br> 27: mad r0.xyzw, cb1[3].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 28: dp4 o2.w, r1.xyzw, r0.xyzw <br> 29: ret</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <code>cbuffer cbPerFrame : register (b1) <br> { <br> row_major float4x4 g_viewProjMatrix; <br> row_major float4x4 g_rainShaftsViewProjMatrix; <br> } <br> <br> cbuffer cbPerObject : register (b2) <br> { <br> float4x4 g_mtxWorld; <br> float4 g_modelScale; <br> float4 g_modelBias; <br> } <br> <br> struct VS_INPUT <br> { <br> float3 PositionW : POSITION; <br> float2 Texcoord : TEXCOORD; <br> float3 NormalW : NORMAL; <br> float3 TangentW : TANGENT; <br> float4 InstanceTransform0 : INSTANCE_TRANSFORM0; <br> float4 InstanceTransform1 : INSTANCE_TRANSFORM1; <br> float4 InstanceTransform2 : INSTANCE_TRANSFORM2; <br> float4 InstanceLODParams : INSTANCE_LOD_PARAMS; <br> }; <br> <br> struct VS_OUTPUT <br> { <br> float3 TexcoordAndZ : Texcoord0; <br> <br> float4 LODParams : LODParams; <br> float4 PositionH : SV_Position; <br> }; <br> <br> VS_OUTPUT RainShaftsVS( VS_INPUT Input ) <br> { <br> VS_OUTPUT Output = (VS_OUTPUT)0; <br> <br> // простая передача данных <br> Output.TexcoordAndZ.xy = Input.Texcoord; <br> Output.LODParams = Input.InstanceLODParams; <br> <br> // мировое пространство <br> float3 meshScale = g_modelScale.xyz; // float3( 4, 4, 2 ); <br> float3 meshBias = g_modelBias.xyz; // float3( -2, -2, -1 ); <br> float3 PositionL = Input.PositionW * meshScale + meshBias; <br> <br> // Построение вручную матрицы instanceWorld из float4s: <br> float4x4 matInstanceWorld = float4x4(Input.InstanceTransform0, Input.InstanceTransform1, <br> Input.InstanceTransform2 , float4(0, 0, 0, 1) ); <br> <br> // Высота в мировом пространстве (.z) <br> float4x4 matWorldInstanceLod = mul( g_rainShaftsViewProjMatrix, matInstanceWorld ); <br> Output.TexcoordAndZ.z = mul( float4(PositionL, 1.0), transpose(matWorldInstanceLod) ).z; <br> <br> // SV_Posiiton <br> float4x4 matModelViewProjection = mul(g_viewProjMatrix, matInstanceWorld ); <br> Output.PositionH = mul( float4(PositionL, 1.0), transpose(matModelViewProjection) ); <br> <br> return Output; <br> }</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comparison of my shader (left) and original (right): </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef3/4f3/4ed/ef34f34edbc63113a08f47b7cde00df0.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Differences do not affect calculations. </font><font style="vertical-align: inherit;">I performed an injection of my shader into the frame and everything was still fine!</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixel shader </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally! </font><font style="vertical-align: inherit;">First, I’ll show you the input data: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Two textures are used here: the noise texture and the depth buffer:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/83a/558/fc3/83a558fc3c8c7e723eb85308b12657d6.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db5/0da/111/db50da111880f6b934d8bed6b74491e6.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Values ​​from constant buffers: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a12/394/bdc/a12394bdc039e522beeff97b8e41cd80.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/37a/c47/485/37ac47485335960b2efbefc9f315ef14.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e7/e70/38a/4e7e7038a1bc956aadbb695d70b80ded.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ae/775/bc4/7ae775bc4a9388feceaa1ddf8c0a214a.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And pixel shader assembly code: </font></font><br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb0[8], immediateIndexed <br> dcl_constantbuffer cb2[3], immediateIndexed <br> dcl_constantbuffer cb12[23], immediateIndexed <br> dcl_constantbuffer cb4[8], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_sampler s15, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t15 <br> dcl_input_ps linear v0.xyz <br> dcl_input_ps linear v1.w <br> dcl_input_ps_siv v2.xy, position <br> dcl_output o0.xyzw <br> dcl_temps 1 <br> 0: mul r0.xy, cb0[0].xxxx, cb4[5].xyxx <br> 1: mad r0.xy, v0.xyxx, cb4[4].xyxx, r0.xyxx <br> 2: sample_indexable(texture2d)(float,float,float,float) r0.x, r0.xyxx, t0.xyzw, s0 <br> 3: add r0.y, -cb4[2].x, cb4[3].x <br> 4: mad_sat r0.x, r0.x, r0.y, cb4[2].x <br> 5: mul r0.x, r0.x, v0.y <br> 6: mul r0.x, r0.x, v1.w <br> 7: mul r0.x, r0.x, cb4[1].x <br> 8: mul r0.yz, v2.xxyx, cb0[1].zzwz <br> 9: sample_l(texture2d)(float,float,float,float) r0.y, r0.yzyy, t15.yxzw, s15, l(0) <br> 10: mad r0.y, r0.y, cb12[22].x, cb12[22].y <br> 11: mad r0.y, r0.y, cb12[21].x, cb12[21].y <br> 12: max r0.y, r0.y, l(0.000100) <br> 13: div r0.y, l(1.000000, 1.000000, 1.000000, 1.000000), r0.y <br> 14: add r0.y, r0.y, -v0.z <br> 15: mul_sat r0.y, r0.y, cb4[6].x <br> 16: mul_sat r0.x, r0.y, r0.x <br> 17: mad r0.y, cb0[7].y, r0.x, -r0.x <br> 18: mad r0.x, cb4[7].x, r0.y, r0.x <br> 19: mul r0.xyz, r0.xxxx, cb4[0].xyzx <br> 20: log r0.xyz, r0.xyzx <br> 21: mul r0.xyz, r0.xyzx, l(2.200000, 2.200000, 2.200000, 0.000000) <br> 22: exp r0.xyz, r0.xyzx <br> 23: mul r0.xyz, r0.xyzx, cb2[2].xyzx <br> 24: mul o0.xyz, r0.xyzx, cb2[2].wwww <br> 25: mov o0.w, l(0) <br> 26: ret</code> <br> <br>  Wow!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quite a large amount, but in fact everything is not so bad. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is going on here? </font><font style="vertical-align: inherit;">First, we calculate animated UV using the elapsed time from the cbuffer (cb0 [0] .x) and scale / offset. </font><font style="vertical-align: inherit;">These texcoords are used for sampling from the noise texture (line 2). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Having obtained the noise value from the texture, we interpolate between the min / max values ​​(usually 0 and 1). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then we perform multiplications, for example, on the coordinate of the texture V (remember that the coordinate V goes from 1 to 0?) - line 5. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, we calculated the “brightness mask” - it looks like this:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/064/1a8/801/0641a88012fb6ec18797c0b143fb5f27.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note that distant objects (lighthouse, mountains ...) are gone. </font><font style="vertical-align: inherit;">This happened because the cylinder passes the depth test - the cylinder is not in the far plane and is drawn over these objects:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/106/8f5/ffd/1068f5ffde6b0efba2c4894b88d5ddf5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depth test</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We want to simulate the fact that the rain curtain is on (but not necessarily on the far plane). </font><font style="vertical-align: inherit;">To do this, we compute another mask, the “mask of distant objects.” </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is calculated by the following formula: </font></font><br><br> <code>farObjectsMask = saturate( (FrustumDepth - CylinderWorldSpaceHeight) * 0.001 );</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(0.001 is taken from the buffer), which gives us the necessary mask:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/02a/153/9ff02a1534054fb27b370d5cd58e7a75.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(In the part about the Sharpen effect, I have already superficially explained how the depth of the pyramid of visibility is retrieved from the depth buffer.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Personally, it seems to me that this effect could be implemented less costly without calculating the height in global space by multiplying the depth of the pyramid of visibility by a smaller number, 0.0004. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By multiplying both masks, the final is obtained:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c49/fb2/c1e/c49fb2c1e1dd2ee8d38d81c0cccb0daf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After receiving this final mask (line 16), we perform another interpolation, doing almost nothing (at least in the tested case), and then multiply the final mask by the curtain color (line 19), perform gamma correction (line 20 -22) and final multiplications (23-24). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the end, we return a color with zero alpha value. This is done because mixing is enabled on this aisle: </font></font><br><br> <code>FinalColor = SourceColor * 1.0 + (1.0 - SourceAlpha) * DestColor</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you are not quite </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sure </font><font style="vertical-align: inherit;">how mixing works, here’s a brief explanation: </font><font style="vertical-align: inherit;">SourceColor is the output RGB data from the pixel shader, and DestColor is the current RGB color of the pixel in the render target . Since SourceAlpha always equal to 0.0, the above equation reduces to: </font></font><code>FinalColor = SourceColor + DestColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simply put, here we do additive blending. </font><font style="vertical-align: inherit;">If the pixel shader returns (0, 0, 0), then the color will remain the same. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is the ready HLSL code - I think that after the explanation it will be much easier to understand it: </font><font style="vertical-align: inherit;">I can happily say that my pixel shader creates the same assembler code as in the original. </font><font style="vertical-align: inherit;">I hope you enjoyed the article. </font><font style="vertical-align: inherit;">Thanks for reading!</font></font><br><br> <code>struct VS_OUTPUT <br> { <br> float3 TexcoordAndWorldspaceHeight : Texcoord0; <br> float4 LODParams : LODParams; // float4(1,1,1,1) <br> float4 PositionH : SV_Position; <br> }; <br> <br> float getFrustumDepth( in float depth ) <br> { <br> // from [1-0] to [0-1] <br> float d = depth * cb12_v22.x + cb12_v22.y; <br> <br> // special coefficents <br> d = d * cb12_v21.x + cb12_v21.y; <br> <br> // return frustum depth <br> return 1.0 / max(d, 1e-4); <br> } <br> <br> float4 EditedShaderPS( in VS_OUTPUT Input ) : SV_Target0 <br> { <br> // * Input from Vertex Shader <br> float2 InputUV = Input.TexcoordAndWorldspaceHeight.xy; <br> float WorldHeight = Input.TexcoordAndWorldspaceHeight.z; <br> float LODParam = Input.LODParams.w; <br> <br> // * Inputs <br> float elapsedTime = cb0_v0.x; <br> float2 uvAnimation = cb4_v5.xy; <br> float2 uvScale = cb4_v4.xy; <br> float minValue = cb4_v2.x; // 0.0 <br> float maxValue = cb4_v3.x; // 1.0 <br> float3 shaftsColor = cb4_v0.rgb; // RGB( 147, 162, 173 ) <br> <br> float3 finalColorFilter = cb2_v2.rgb; // float3( 1.175, 1.296, 1.342 ); <br> float finalEffectIntensity = cb2_v2.w; <br> <br> float2 invViewportSize = cb0_v1.zw; <br> <br> float depthScale = cb4_v6.x; // 0.001 <br> <br> // sample noise <br> float2 uvOffsets = elapsedTime * uvAnimation; <br> float2 uv = InputUV * uvScale + uvOffsets; <br> float disturb = texture0.Sample( sampler0, uv ).x; <br> <br> // * Intensity mask <br> float intensity = saturate( lerp(minValue, maxValue, disturb) ); <br> intensity *= InputUV.y; // transition from (0, 1) <br> intensity *= LODParam; // usually 1.0 <br> intensity *= cb4_v1.x; // 1.0 <br> <br> // Sample depth <br> float2 ScreenUV = Input.PositionH.xy * invViewportSize; <br> float hardwareDepth = texture15.SampleLevel( sampler15, ScreenUV, 0 ).x; <br> float frustumDepth = getFrustumDepth( hardwareDepth ); <br> <br> <br> // * Calculate mask covering distant objects behind cylinder. <br> <br> // Seems that the input really is world-space height (.z component, see vertex shader) <br> float depth = frustumDepth - WorldHeight; <br> float distantObjectsMask = saturate( depth * depthScale ); <br> <br> // * calculate final mask <br> float finalEffectMask = saturate( intensity * distantObjectsMask ); <br> <br> // cb0_v7.y and cb4_v7.x are set to 1.0 so I didn't bother with naming them :) <br> float paramX = finalEffectMask; <br> float paramY = cb0_v7.y * finalEffectMask; <br> float effectAmount = lerp(paramX, paramY, cb4_v7.x); <br> <br> // color of shafts comes from contant buffer <br> float3 effectColor = effectAmount * shaftsColor; <br> <br> // gamma correction <br> effectColor = pow(effectColor, 2.2); <br> <br> // final multiplications <br> effectColor *= finalColorFilter; <br> effectColor *= finalEffectIntensity; <br> <br> // return with zero alpha 'cause the blending used here is: <br> // SourceColor * 1.0 + (1.0 - SrcAlpha) * DestColor <br> return float4( effectColor, 0.0 ); <br> }</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font></div>