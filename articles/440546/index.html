<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Distributed chat on Node.JS and Redis</title>
  <meta name="description" content="Small question / answer: 


 Who is it for? People who have little or no encounter with distributed systems, and who are interested to see how they ca...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Distributed chat on Node.JS and Redis</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://cs4.pikabu.ru/post_img/2015/10/04/5/1443945163_2102700146.jpg" alt="The result is a bit like a dovemail"></p><br><p>  Small question / answer: </p><br><p>  <em>Who is it for?</em>  People who have little or no encounter with distributed systems, and who are interested to see how they can be built, what patterns and solutions exist. </p><br><p>  <em>Why is this?</em>  It became interesting to myself what and how.  Scooped information from different sources, I decided to lay out in a concentrated form, because in due time I would like to see such work myself.  In essence, this is a textual statement of my personal throwings and thoughts.  Also, there will surely be a lot of corrections in comments from knowledgeable people, in part this is the goal of writing all this in the form of an article. </p><br><h2 id="postanovka-zadachi">  Formulation of the problem </h2><br><p>  How to make a chat?  This should be a trivial task, probably every second backender sawed his own, just like game developers make their tetris / snakes, etc. I took it, but to make it more interesting it should be ready to take over the world so that it could withstand hundreds of billions active users and in general was incredibly cool.  From this comes a clear need for a distributed architecture, because to accommodate all the imaginary number of clients on one machine is not yet possible with the current capacities.  Instead of just sitting and waiting for the appearance of quantum computers, I resolutely took up the study of the topic of distributed systems. </p><br><p>  It is worth noting that quick response is very important, the notorious realtime, because this is a <strong>chat</strong> !  and not mail delivery by pigeons. </p><br><p>  % <em>random joke about russian mail</em> % </p><br><p>  We will use Node.JS, it is ideal for prototyping.  For sockets, take Socket.IO.  Write on TypeScript. </p><br><p>  And so, what do we want: </p><br><ol><li>  So that users can send each other messages </li><li>  Know who is online / offline </li></ol><br><p>  How we want it: </p><a name="habracut"></a><br><h2 id="singl-server">  Single server </h2><br><p>  There is nothing to say especially, immediately to the code.  Declare the message interface: </p><br><pre><code class="plaintext hljs">interface Message{ roomId: string,//–í –∫–∞–∫—É—é –∫–æ–º–Ω–∞—Ç—É –ø–∏—à–µ–º message: string,//–ß—Ç–æ –º—ã —Ç—É–¥–∞ –ø–∏—à–µ–º }</code> </pre> <br><p>  On server: </p><br><pre> <code class="plaintext hljs">io.on('connection', sock=&gt;{ //–ü—Ä–∏—Å–æ–µ–¥–µ–Ω—è–µ–º—Å—è –≤ —É–∫–∞–∑–∞–Ω–Ω—É—é –∫–æ–º–Ω–∞—Ç—É sock.on('join', (roomId:number)=&gt; sock.join(roomId)) //–ü–∏—à–µ–º –≤ —É–∫–∞–∑–∞–Ω–Ω—É—é –∫–æ–º–Ω–∞—Ç—É //–í—Å–µ –∫—Ç–æ –∫ –Ω–µ–π –ø—Ä–∏—Å–æ–µ–¥–µ–Ω–∏–ª—Å—è —Ä–∞–Ω–µ–µ –ø–æ–ª—É—á–∞—Ç —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ sock.on('message', (data:Message)=&gt; io.to(data.roomId).emit('message', data)) })</code> </pre> <br><p>  On the client, something like: </p><br><pre> <code class="plaintext hljs">sock.on('connect', ()=&gt; { const roomId = 'some room' //–ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –∏–∑ –ª—é–±—ã—Ö –∫–æ–º–Ω–∞—Ç sock.on('message', (data:Message)=&gt; console.log(`Message ${data.message} from ${data.roomId}`)) //–ü—Ä–∏—Å–æ–µ–¥–µ–Ω—è–µ–º—Å—è –∫ –æ–¥–Ω–æ–π sock.emit('join', roomId) //–ò –ø–∏—à–µ–º –≤ –Ω–µ–µ sock.emit('message', &lt;Message&gt;{roomId: roomId, message: 'Halo!'}) })</code> </pre> <br><p>  You can work with online status like this: </p><br><pre> <code class="plaintext hljs">io.on('connection', sock=&gt;{ //–ü—Ä–∏ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –ø—Ä–∏—Å–æ–µ–¥–µ–Ω—è–µ–º —Å–æ–∫–µ—Ç –≤ –∫–æ–º–Ω–∞—Ç—É —Å –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è //–í –±—É–¥—É—â–µ–º, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ –±—É–¥–µ—Ç –ø–æ—Å–ª–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é - //–º–æ–∂–Ω–æ –µ–≥–æ —Å–∫–∏–Ω—É—Ç—å –ø—Ä—è–º–æ –≤ –Ω–µ–µ sock.on('auth', (uid:string)=&gt; sock.join(uid)) //–¢–µ–ø–µ—Ä—å, —á—Ç–æ–± —É–∑–Ω–∞—Ç—å –æ–Ω–ª–∞–π–Ω –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å, //–ø—Ä–æ—Å—Ç–æ —Å–º–æ—Ç—Ä–∏–º –µ—Å—Ç—å –ª–∏ –∫—Ç–æ –≤ –∫–æ–º–Ω–∞—Ç–µ —Å –µ–≥–æ –∞–π–¥–∏—à–Ω–∏–∫–æ–º //–∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç sock.on('isOnline', (uid:string, resp)=&gt; resp(io.sockets.clients(uid).length &gt; 0)) })</code> </pre> <br><p>  And on the client: </p><br><pre> <code class="plaintext hljs">sock.on('connect', ()=&gt; { const uid = 'im uid, rly' //–¢–∏–ø–æ –∞–≤—Ç–æ—Ä–∏–∑—É–µ–º—Å—è sock.emit('auth', uid) //–°–º–æ—Ç—Ä–∏–º –≤ –æ–Ω–ª–∞–π–Ω–µ –ª–∏ –º—ã sock.emit('isOnline', uid, (isOnline:boolean)=&gt; console.log(`User online status is ${isOnline}`)) })</code> </pre> <br><blockquote>  Note: the code did not run, I write from memory just for example </blockquote><p>  Just like firewood, dokruchiva syudy real authorization, management of rooms (history of messages, adding / deleting participants) and profit. </p><br><p>  BUT!  We are going to seize the world peace, and therefore not the time to stop, rapidly move on: </p><br><h2 id="nodejs-klaster">  Node.JS Cluster </h2><br><p>  Examples of using Socket.IO on a set of nodes are right <a href="https://socket.io/docs/using-multiple-nodes/">on the official site</a> .  Including there is also about the native Node.JS cluster, which seemed to me inapplicable to my task: it allows us to expand our application throughout the machine, BUT not beyond it, therefore we definitely pass by.  We need to finally go beyond the bounds of one piece of iron! </p><br><h2 id="raspredelyay-i-velosiped">  Distribute and bike </h2><br><p>  How to do it?  Obviously, we need to somehow bind our instances running not only at home in the basement, but also in the neighbor's basement too.  What comes first to mind: we are doing some intermediate link that will serve as a bus between all our nodes: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549140775997.png" alt="1549140775997"></p><br><p>  When a node wants to send a message to another, it makes a request to the Bus, and already it in turn sends it to the right place, everything is simple.  Our network is ready! </p><br><p>  <strong>FIN.</strong> </p><br><p>  ... but isn't everything so simple?) </p><br><p>  With this approach, we run into the performance of this intermediate link, and in general we would like to directly refer to the right nodes, because what can be faster than communicating directly?  So let's move it in this direction! </p><br><p>  What you need first?  Actually, one instance to another.  But how can the first find out about the existence of the second?  We want to have an infinite number of them, arbitrarily pick up / remove!  We need a master server, the address of which is obviously known, everyone connects to it, due to which it knows all the existing nodes on the network and kindly shares this information with everyone. </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549048945334.png" alt="1549048945334"></p><br><p>  T e node rises, tells the master about his awakening, he gives a list of other active nodes, we connect to them and that's it, the network is ready.  Consul or something similar can act as a master, but since we are cycling, the master should be self-made. </p><br><p>  Great, now we have our own skynet!  But the current implementation of the chat in it is no longer suitable.  Let‚Äôs come up with the following requirements: </p><br><ol><li>  When a user sends a message, we need to know to WHOM he sends it, that is, to have access to room members. </li><li>  When we received participants we must deliver them messages. </li><li>  We need to know which user is online now. </li><li>  For convenience, give users the opportunity to subscribe to the online status of other users in order to learn in real time about its change. </li></ol><br><p>  Let's deal with users.  For example, you can make the master know to which node which user is connected to.  The situation is as follows: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549237952673.png" alt="1549237952673"></p><br><p>  Two users are connected to different nodes.  The master knows this, the nodes know what the master knows.  When UserB is authorized, Node2 notifies the Master, which "remembers" that UserB is attached to Node2.  When UserA wants to send a message to UserB, you get the following picture: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549140491881.png" alt="1549140491881"></p><br><p>  In principle, everything works, but I would like to avoid an extra round of trip in the form of polling the master, it would be more economical to immediately go directly to the desired node, because it was for this that everything was started.  This can be done if they tell everyone around them which users are connected to them, each of them becomes a self-sufficient analogue of the master, and the master itself becomes unnecessary, because the list of the "User =&gt; Node" ratio is duplicated for everyone.  When you start a node, it is enough to connect to any already running one, pull off its list yourself and voila, it is also ready for battle. </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549139768940.png" alt="1549139768940"></p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549139882747.png" alt="1549139882747"></p><br><p>  But as a trade off, we get a duplication of the list, which, although it is a ratio of "user id -&gt; [host connections]", but still with a sufficient number of users it will be quite large in memory.  And in general, to cut it yourself - it clearly smacks of the bicycle industry.  The more code - the more potential errors.  Perhaps, we will freeze this option and we will look that already is from ready: </p><br><h2 id="brokery-soobscheniy">  Message brokers </h2><br><p>  An entity that implements the same "Bus", "intermediate" mentioned above.  His task is to receive and deliver messages.  We, as users - we can subscribe to them and send ours.  It's simple. </p><br><p>  There are proven RabbitMQ and Kafka: they only do what they deliver messages - this is their purpose, crammed with all the necessary functionality.  In their world, the message must be delivered, no matter what. </p><br><p>  At the same time, there is Redis and his pub / sub - the same as the aforementioned guys, but more oakish: he just stupidly receives the message and delivers it to the subscriber, without any queues and other overheads.  He absolutely doesn‚Äôt care about the messages themselves, if they disappear, if the subscriber hangs up - he will throw it away and take on something new, as if throwing a hot poker into his hands that he wants to get rid of faster.  Also, if he suddenly falls - all messages will also be lost with him.  In other words, there is no guarantee of any delivery of speech. </p><br><p>  ... and this is what you need! </p><br><p>  Well, really, we do just chat.  Not some critical money service or space mission control center, but ... just a chat.  The risk that the conditional Petya once a year does not receive one message out of a thousand - they can be neglected, if in return we get a performance increase and in the place with it the number of users for the same days, trade off in all its glory.  Moreover, at the same time, you can keep a history of messages in some persistent storage, which means that Petya will see the same missing message by reloading the page / application.  That is why we‚Äôll dwell on Redis pub / sub, to be exact: let's look at the existing adapter for SocketIO, which <a href="https://socket.io/docs/using-multiple-nodes/">is mentioned in the article at the office.</a>  <a href="https://socket.io/docs/using-multiple-nodes/">site</a> . </p><br><p>  So what is it? </p><br><h2 id="redis-adapter">  Redis adapter </h2><br><p>  <a href="https://github.com/socketio/socket.io-redis">https://github.com/socketio/socket.io-redis</a> </p><br><p>  With it, the usual application with a few lines and a minimum number of gestures turns into a real distributed chat!  But how?  <a href="">If you look inside</a> - there is only one file on the floor, hundreds of lines. </p><br><p>  In the case when we issue a message </p><br><pre> <code class="plaintext hljs">io.emit("everyone", "hello")</code> </pre> <br><p>  it feeds into radishes, is transmitted to all other instances of our chat, which in turn will emit it locally on their sockets </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549232309776.png" alt="1549232309776"></p><br><p>  The message will be distributed on all nodes even if we issue to a specific user.  T e each node accepts all messages and already understands whether it needs it. </p><br><p>  Also, there is implemented a simple rpc (remote procedure call), allowing not only to send but also to receive answers.  For example, you can control sockets remotely, such as "who is in the specified room", "order the socket to join the room", and so on. </p><br><p>  What can be done with this?  For example, use the user ID as the name of the room (user id == room id).  When authorizing joining a socket to it, and when we want to send a message to the user - just a helmet into it.  Also, we can find out whether the user is online, by simply looking at whether there are sockets in the specified room. </p><br><p>  In principle, this can be stopped, but, as always, we have little: </p><br><ol><li>  Bottleneck in the form of a single radish instance </li><li>  Redundancy, I would like the nodes to receive only the messages they need </li></ol><br><p>  At the expense of the first item, we look at such a thing as: </p><br><h2 id="redis-cluster">  Redis cluster </h2><br><p>  Connects several radish instances, and then work as a unit.  But how does he do it?  Yes, like this: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549233023980.png" alt="1549233023980"></p><br><p>  ... and we see that the message is duplicated to all members of the cluster.  T e it is not intended to increase performance, but to increase reliability, which is nice and necessary, but for our case it has no value and does not save the situation with a bottleneck, plus in total it is even more resource consumption. </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549231953897.png" alt="1549231953897"></p><br><p>  I am a newbie, I don‚Äôt know much, sometimes I have to go back to vilesopedostroenie, which we will do.  No, let's leave the radish in order not to slip at all, but something needs to be invented with the architecture for the current one is no good. </p><br><h2 id="povorot-ne-tuda">  Wrong turn </h2><br><p>  What do we need?  Increase overall throughput.  For example we will try to stupidly sleep another one instance.  Imagine that socket.io-redis can connect to several, when pushing a message, it chooses a random one, and subscribes to everything.  It turns out like this: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549239818663.png" alt="1549239818663"></p><br><p>  Voila!  In general, the problem is solved, radish is no longer a bottleneck, you can spawn arbitrarily instances!  But they became nodes.  Yes, our chatik instances still digest ALL messages, no matter what they are intended for. </p><br><p>  It can be the other way around: subscribe to one random one, which will reduce the load on the nodes, and push into everything: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549239361416.png" alt="1549239361416"></p><br><p>  We see that it has become the opposite: the nodes feel calmer, but the load on the radish instance has increased.  This, too, is no good.  Need a bit sensitive bicycling. </p><br><p>  In order to pump our system, we leave the socket.io-redis package alone, although it‚Äôs cool, but we need more freedom.  And so, we connect radishes: </p><br><pre> <code class="plaintext hljs">//–û—Ç–¥–µ–ª—å–Ω—ã–µ –∫–∞–Ω–∞–ª—ã –¥–ª—è: const pub = new RedisClient({host: 'localhost', port: 6379})//–ü—É—à–∞ —Å–æ–æ–±—â–µ–Ω–∏–π const sub = new RedisClient({host: 'localhost', port: 6379})//–ü–æ–¥–ø–∏—Å–æ–∫ –Ω–∞ –Ω–∏—Ö //–¢–∞–∫–∂–µ –≤—Å–ø–æ–º–∏–Ω–∞–µ–º —ç—Ç–æ—Ç –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å interface Message{ roomId: string,//–í –∫–∞–∫—É—é –∫–æ–º–Ω–∞—Ç—É –ø–∏—à–µ–º message: string,//–ß—Ç–æ –º—ã —Ç—É–¥–∞ –ø–∏—à–µ–º }</code> </pre> <br><p>  Set up our message system: </p><br><pre> <code class="plaintext hljs">//–û—Ç–ª–∞–≤–ª–∏–≤–∞–µ–º –≤—Å–µ –ø—Ä–∏—Ö–æ–¥—è—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è —Ç—É—Ç sub.on('message', (channel:string, dataRaw:string)=&gt; { const data = &lt;Message&gt;JSON.parse(dataRaw) io.to(data.roomId).emit('message', data)) }) //–ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ –∫–∞–Ω–∞–ª sub.subscribe("messagesChannel") //–ü—Ä–∏—Å–æ–µ–¥–µ–Ω—è–µ–º—Å—è –≤ —É–∫–∞–∑–∞–Ω–Ω—É—é –∫–æ–º–Ω–∞—Ç—É sock.on('join', (roomId:number)=&gt; sock.join(roomId)) //–ü–∏—à–µ–º –≤ –∫–æ–º–Ω–∞—Ç—É sock.on('message', (data:Message)=&gt; { //–ü—É–±–ª–∏–∫—É–µ–º –≤ –∫–∞–Ω–∞–ª pub.publish("messagesChannel", JSON.stringify(data)) })</code> </pre> <br><p>  At the moment it turns out as in socket.io-redis: we listen to all messages.  Now we fix it. </p><br><p>  We organize subscriptions in the following way: we recall the concept with a "user id == room id", and when a user appears, we subscribe to the eponymous channel in radish.  Thus, our nodes will receive only messages intended for them, and not to listen to "the whole broadcast." </p><br><pre> <code class="plaintext hljs">//–û—Ç–ª–∞–≤–ª–∏–≤–∞–µ–º –≤—Å–µ –ø—Ä–∏—Ö–æ–¥—è—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è —Ç—É—Ç sub.on('message', (channel:string, message:string)=&gt; { io.to(channel).emit('message', message)) }) let UID:string|null = null; sock.on('auth', (uid:string)=&gt; { UID = uid //–ö–æ–≥–¥–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∞–≤—Ç–æ—Ä–∏–∑–∏—Ä—É–µ—Ç—Å—è - –ø–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ //–æ–¥–Ω–æ–∏–º–µ–Ω–Ω—ã–π –Ω–∞—à–µ–º—É UID –∫–∞–Ω–∞–ª sub.subscribe(UID) //–ò —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â—É—é –∫–æ–º–Ω–∞—Ç—É sock.join(UID) }) sock.on('writeYourself', (message:string)=&gt; { //–ü–∏—à–µ–º —Å–∞–º–∏ —Å–µ–±–µ, —Ç –µ –ø—É–±–ª–∏–∫—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –∫–∞–Ω–∞–ª –æ–¥–Ω–æ–∏–º–µ–Ω–Ω—ã–π UID if (UID) pub.publish(UID, message) })</code> </pre> <br><p>  Awesome, now we are sure that the nodes receive only messages intended for them, nothing more!  It should be noted, however, that the subscriptions themselves are now much, much more, which means that they will eat the memory of the second yoy, + more subscription / unsubscription operations that are relatively expensive.  But in any case, this gives us some flexibility, it is even possible at this point to stop and reconsider all previous options, taking into account our new property of the nodes in the form of more selective, chaste receiving messages.  For example, nodes can subscribe to one of several radish instances, and when pushing, send a message to all instances: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1550174595491.png" alt="1550174595491"></p><br><p>  ... but, anyway, they still do not give endless extensibility with reasonable overhead, you need to give birth to other options.  At one point, the following scheme came to mind: what if the radish instances were divided into groups, say, A and B, two instances each.  When subscribing, nodes subscribe to one instance from each group, and when pushing, they send a message to all instances of any one random group. </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1550174092066.png" alt="1550174092066"></p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1550174943313.png" alt="1550174943313"></p><br><p>  Thus, we obtain a real structure with an infinite potential of extensibility in real time, the load on an individual node at any point does not depend on the size of the system, because: </p><br><ol><li>  The total bandwidth is divided between groups, i.e. with an increase in users / activity, we simply compare additional groups. </li><li>  Management by users (subscriptions) is divided within the groups themselves, that is, with an increase in users / subscriptions, we simply increase the number of instances within the groups. </li></ol><br><p>  ... and as always there is one "BUT": the more it all becomes, the more resources are needed for the next increase, it seems to me exorbitant trade off. </p><br><p>  In general, if you think about it - the above-mentioned plugs come from ignorance of which node is which user.  Well, after all, indeed, having we had this information, we could have used to push messages right where necessary, without unnecessary duplication.  What have we been trying to do all this time?  They tried to make the system infinitely scalable, while not having a clear addressing mechanism, from which they inevitably dropped either to a dead end or to an unjustified redundancy.  For example, you can recall the master, performing the role of "address book": </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1550233610561.png" alt="1550233610561"></p><br><blockquote>  Something similar tells this dude: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/6G22a5Iooqk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></blockquote><p>  To get the user's location, we perform an additional roundtrip, which is basically OK, but not in our case.  It seems we are digging in the wrong direction, we need something else ... </p><br><h2 id="sila-hesha">  Hash strength </h2><br><p>  There is such a thing as a hash.  It has some finite range of values.  You can get it from any data.  And what if this range is divided between radish instances?  Well, we take the user ID, produce a hash, and depending on the range in which it turned out, we subscribe / push to one specific instance.  T e we do not know in advance where a user exists, but upon receiving his ID, we can say with confidence that he is in the n instance, infa 100. Now the same, but with the code: </p><br><pre> <code class="plaintext hljs">function hash(val:string):number{/**/}//–ù–∞—à–∞ —Ö—ç—à-—Ñ—É–Ω–∫—Ü–∏—è, –≤–æ–∑–≤—Ä–∞—â–∞—é—â–∞—è —á–∏—Å–ª–æ const clients:RedisClient[] = []//–ú–∞—Å—Å–∏–≤ –∫–ª–∏–µ–Ω—Ç–æ–≤ —Ä–µ–¥–∏—Å–∞ const uid = "some uid"//–ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è //–¢–µ–ø–µ—Ä—å, —Ç–∞–∫–æ–π –Ω–µ —Ö–∏—Ç—Ä–æ–π –º–∞–Ω–∏–ø—É–ª—è—Ü–∏–µ–π –º—ã –ø–æ–ª—É—á–∞–µ–º –≤—Å–µ–≥–¥–∞ –æ–¥–∏–Ω –∏ —Ç–æ—Ç –∂–µ //–∫–ª–∏–µ–Ω—Ç –∏–∑ –º–Ω–æ–∂–µ—Å—Ç–≤–∞ –¥–ª—è –¥–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è const selectedClient = clients[hash(uid) % clients.length]</code> </pre> <br><p>  Voila!  Now we do not depend on the number of instances from the word in general, we can scale arbitrarily without overhead!  Well, seriously, this is a brilliant option, the only negative of which is the need to completely restart the system when updating the number of radish instances.  There is such a thing as the <a href="https://4gophers.ru/articles/standartnoe-kolco-basic-hash-ring/">Standard Ring and the Partition Ring</a> that can overcome this, but they are not applicable to the conditions of the messaging system.  Well, I can make the logic of migration of subscriptions between instances possible, but it still costs an additional piece of code of an incomprehensible size, and as we know - the more the code, the more bugs, we don‚Äôt need it, thanks.  And in our case, downtime is quite acceptable tradeoff. </p><br><p>  You can also look at RabbitMQ with its <a href="https://github.com/rabbitmq/rabbitmq-sharding">plugin</a> , which allows you to do the same thing as we do, and + ensures the migration of subscriptions (as I said above - it is tied with functionality from head to toe).  In principle, you can take it and sleep peacefully, but if someone fumbles in his tuning in order to bring the mode to realtime, leaving only the feature with the hash ring. </p><br><p>  <a href="https://github.com/Alster/distributed-nodejs-chat-with-redis">Filled repository on githab.</a> </p><br><p>  It implements the final version to which we came.  In addition, there is an additional logic for working with rooms (dialogues). </p><br><p>  In general, I am pleased and can be rounded. </p><br><h2 id="itogo">  Total </h2><br><p>  You can do anything, but there is such a thing as resources, but they are finite, so you need to wriggle. </p><br><p>  We started with complete ignorance of how distributed systems can work to less tangible specific patterns, and this is good. </p></div><p>Source: <a href="https://habr.com/ru/post/440546/">https://habr.com/ru/post/440546/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>