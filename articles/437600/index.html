<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>opencv4arts: Draw my city, Vincent</title>
  <meta name="description" content="OpenCV is a library with a continuous development history of 20 years. Age, when you start to dig into yourself, look for a destination. Are there pro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>opencv4arts: Draw my city, Vincent</h1><div class="post__text post__text-html js-mediator-article"><p>  OpenCV is a library with a continuous development history of 20 years.  Age, when you start to dig into yourself, look for a destination.  Are there projects based on it that have made someone's life better, someone happier?  Can you do it yourself?  Looking for answers and wanting to discover previously unknown OpenCV modules for myself, I want to build applications that "make beautifully" - so that at first it was "wow" and only then you say "oh yes, this is computer vision." </p><br><p>  The right of the first article received an experiment with the transfer of styles of world artists to photographs.  From the article you will learn what is the heart of the procedure and about the relatively new OpenCV.js - JavaScript version of the OpenCV library. </p><br><p><img src="https://habrastorage.org/webt/bd/gi/zx/bdgizx8meb6hqmshphkkpsonuee.jpeg"></p><a name="habracut"></a><br><h2 id="style-transfer">  Style transfer </h2><br><p>  Forgive me, opponents of machine learning, but the main component in today's article will be a deep convolutional network.  Because it works.  In OpenCV, there is no way to train neural networks, but you can run existing models.  We will use the pre- <a href="https://github.com/junyanz/CycleGAN">trained</a> network <a href="https://github.com/junyanz/CycleGAN">CycleGAN</a> .  The authors, for which they are very grateful, offer a completely free download of networks that convert images of apples into oranges, horses into zebras, satellite images into maps, photos of winter into photos of summer and much more.  Moreover, the network training procedure allows you to have two generator models working in both directions at once.  That is, by teaching the conversion of winter to summer, you will receive a model for drawing winter landscapes in summer photos.  A unique offer that is impossible to refuse. </p><br><p>  In our example, we will take models that turn photos into paintings by artists.  Namely, Vincent Van Gogh, Claude Monet, Paul Cezanne or the whole genre of Japanese engravings Ukiyo-e.  That is, we will have four separate networks at our disposal.  It is worth noting that not only one picture of the artist was used for teaching each, but a whole multitude, thus the authors tried to teach the neural network not to shift the style of one work, but, as it were, to adopt the writing style. </p><br><h2 id="opencvjs">  OpenCV.js </h2><br><p>  OpenCV is a library developed in the C ++ language, while for most of its functionality, it is possible to create automatic wrappers that call native methods.  Officially, Python and Java wrappers are supported.  In addition, there are custom solutions for <a href="https://github.com/hybridgroup/gocv">Go</a> , <a href="https://github.com/php-opencv">PHP</a> .  If you have experience using other languages, it would be great to know which ones, and thanks to whose efforts. </p><br><p> OpenCV.js is a project that received the right to life thanks to the Google Summer of Code program in 2017.  By the way, once the deep learning OpenCV module itself was created and significantly improved in its framework.  Unlike other languages, OpenCV.js at the moment is not a wrapper for native methods in JavaScript, but a complete compilation using Emscripten using LLVM and Clang.  It allows you to make from your C and C ++ applications or a <code>.js</code> library a file that can be run, say, in a browser. </p><br><p>  For example, </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; int main(int argc, char** argv) { std::cout &lt;&lt; "Hello, world!" &lt;&lt; std::endl; return 0; }</span></span></span></span></code> </pre> <br><p>  Compile in <code>asm.js</code> </p><br><pre> <code class="plaintext hljs">emcc main.cpp -s WASM=0 -o main.js</code> </pre> <br><p>  And we load: </p><br><pre> <code class="html hljs xml"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"main.js"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text/javascript"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><blockquote><img src="https://habrastorage.org/webt/pt/pp/bx/ptppbxsjtgxqe48qlfpxho0umaa.png"></blockquote><p>  You can connect OpenCV.js to your project as follows (nightly build): </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://docs.opencv.org/master/opencv.js"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text/javascript"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  An additional library for reading images, working with the camera, etc., which is written manually in JavaScript, may also be useful: </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://docs.opencv.org/master/utils.js"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text/javascript"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h2 id="zagruzka-izobrazheniy">  Loading images </h2><br><p>  Images in OpenCV.js can be read from elements like <code>canvas</code> or <code>img</code> .  This means that downloading the image files directly to them remains the user's task.  For convenience, the auxiliary function <code>addFileInputHandler</code> will automatically load the image into the desired <code>canvas</code> element when selecting a picture from the disk at the touch of a button. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> utils = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Utils(<span class="hljs-string"><span class="hljs-string">''</span></span>); utils.addFileInputHandler(<span class="hljs-string"><span class="hljs-string">'fileInput'</span></span>, <span class="hljs-string"><span class="hljs-string">'canvasInput'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> img = cv.imread(<span class="hljs-string"><span class="hljs-string">'canvasInput'</span></span>);</code> </pre> <br><p>  Where </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"file"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"fileInput"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"file"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">accept</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"image/*"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">canvas</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"canvasInput"</span></span></span><span class="hljs-tag"> &gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">canvas</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  The important point is that <code>img</code> will be a 4-channel RGBA image, which is different from the usual behavior of <code>cv::imread</code> , which creates a BGR image.  This should be taken into account, for example, when porting algorithms from other languages. </p><br><p>  Everything is simple with drawing - just one <code>imshow</code> call with indication of the desired <code>canvas</code> (it expects RGB or RGBA). </p><br><pre> <code class="javascript hljs">cv.imshow(<span class="hljs-string"><span class="hljs-string">"canvasOutput"</span></span>, img);</code> </pre> <br><h3 id="algoritm">  Algorithm </h3><br><p>  The entire image processing algorithm is the launch of a neural network.  Let what happens inside - remains magic, we will only need to prepare the correct input and correctly interpret the prediction (network output). </p><br><p>  The network considered in this example takes as input a four-dimensional tensor with values ‚Äã‚Äãof type <code>float</code> in the interval <code>[-1, 1]</code> .  Each of the dimensions, in order of the rate of change, is an index of the picture, channels, height and width.  This arrangement is called NCHW, and the tensor itself is called a blob (blob, binary large object).  The preprocessing task is to convert an OpenCV image, whose intensity values ‚Äã‚Äãare interleaved, have an interval of <code>[0, 255]</code> type of <code>unsigned char</code> in the NCHW blob with a range of values <code>[-1, 1]</code> . </p><br><p><img src="https://habrastorage.org/webt/bi/yi/yo/biyiyoyp35oyopnpk3zb3yzohzm.jpeg"><br>  <em>a piece of the Nizhny Novgorod Kremlin (as a person sees)</em> </p><br><p><img src="https://habrastorage.org/webt/qq/ju/nf/qqjunf_3hmkujx9ano4ordvwdtc.jpeg"><br>  <em>interleaved view (as stored by opencv)</em> </p><br><p><img src="https://habrastorage.org/webt/cc/z3/ln/ccz3lnfgrpn-tju9bbtk3qvlhdg.jpeg"><br>  <em>planar view (what the network needs)</em> </p><br><p>  As a post-processing, it will be necessary to perform inverse transformations: the network returns an NCHW blob with values ‚Äã‚Äãin the interval <code>[-1, 1]</code> , which need to be repacked into a picture, normalized to <code>[0, 255]</code> and translated into <code>unsigned char</code> . </p><br><p>  Thus, taking into account all the features of reading and writing images of OpenCV.js, we have the following steps: </p><br><pre> <code class="plaintext hljs">imread -&gt; RGBA -&gt; BGR [0, 255] -&gt; NCHW [-1, 1] -&gt; [—Å–µ—Ç—å] [—Å–µ—Ç—å] -&gt; NCHW [-1, 1] -&gt; RGB [0, 255] -&gt; imshow</code> </pre> <br><p>  Looking at the resulting pipeline, there are questions why the network cannot work directly on interleaved RGBA and return interleaved RGB?  Why do we need extra transformations for pixel permutation and normalization?  The answer is that a neural network is a mathematical object that performs transformations on the input data of a specific distribution.  In our case, it was trained to receive data in this form, therefore, to obtain the desired results, it is necessary to reproduce the preprocessing that the authors used in the training. </p><br><h3 id="realizaciya">  Implementation </h3><br><p>  The neural network, which we will run, is stored as a binary file, which must be preloaded into the local file system. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> net; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> url = <span class="hljs-string"><span class="hljs-string">'style_vangogh.t7'</span></span>; utils.createFileFromUrl(<span class="hljs-string"><span class="hljs-string">'style_vangogh.t7'</span></span>, url, () =&gt; { net = cv.readNet(<span class="hljs-string"><span class="hljs-string">'style_vangogh.t7'</span></span>); });</code> </pre> <br><p>  By the way, <code>url</code> is a full link to the file.  In this case, we simply load the file lying next to the current HTML page, but you can replace it with the <a href="">original source</a> (in this case, the download time may be longer). </p><br><p>  Reading images from <code>canvas</code> and converting from RGBA to BGR: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> imgRGBA = cv.imread(<span class="hljs-string"><span class="hljs-string">'canvasInput'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> imgBGR = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> cv.Mat(imgRGBA.rows, imgRGBA.cols, cv.CV_8UC3); cv.cvtColor(imgRGBA, imgBGR, cv.COLOR_RGBA2BGR);</code> </pre> <br><p>  Creating a 4D blob where the <code>blobFromImage</code> function converts to a <code>float</code> data <code>float</code> using normalization constants.  Then - start the network. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> blob = cv.blobFromImage(imgBGR, <span class="hljs-number"><span class="hljs-number">1.0</span></span> / <span class="hljs-number"><span class="hljs-number">127.5</span></span>, <span class="hljs-comment"><span class="hljs-comment">// –º–Ω–æ–∂–∏—Ç–µ–ª—å {width: imgBGR.cols, height: imgBGR.rows}, // —Ä–∞–∑–º–µ—Ä—ã [127.5, 127.5, 127.5, 0]); // –≤—ã—á–∏—Ç–∞–Ω–∏–µ —Å—Ä–µ–¥–Ω–µ–≥–æ net.setInput(blob); var out = net.forward();</span></span></code> </pre> <br><p>  The result obtained is converted back into the image of the desired type and interval of values <code>[0, 255]</code> </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// –ù–æ—Ä–º–∏—Ä–æ–≤–∫–∞ –∑–Ω–∞—á–µ–Ω–∏–π –∏–∑ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞ [-1, 1] –≤ [0, 255] var outNorm = new cv.Mat(); out.convertTo(outNorm, cv.CV_8U, 127.5, 127.5); // –°–æ–∑–¥–∞–Ω–∏–µ interleaved –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–∑ planar –±–ª–æ–±–∞ var outHeight = out.matSize[2]; var outWidth = out.matSize[3]; var planeSize = outHeight * outWidth; var data = outNorm.data; var b = cv.matFromArray(outHeight, outWidth, cv.CV_8UC1, data.slice(0, planeSize)); var g = cv.matFromArray(outHeight, outWidth, cv.CV_8UC1, data.slice(planeSize, 2 * planeSize)); var r = cv.matFromArray(outHeight, outWidth, cv.CV_8UC1, data.slice(2 * planeSize, 3 * planeSize)); var vec = new cv.MatVector(); vec.push_back(r); vec.push_back(g); vec.push_back(b); var rgb = new cv.Mat(); cv.merge(vec, rgb); // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ cv.imshow("canvasOutput", rgb);</span></span></code> </pre> <br><p>  At the moment, OpenCV.js is going in semi-automatic mode.  In the sense that not all modules and methods from them receive the corresponding signatures in JavaScript.  For example, for a dnn module, the list of valid functions is defined as: </p><br><pre> <code class="python hljs">dnn = {<span class="hljs-string"><span class="hljs-string">'dnn_Net'</span></span>: [<span class="hljs-string"><span class="hljs-string">'setInput'</span></span>, <span class="hljs-string"><span class="hljs-string">'forward'</span></span>], <span class="hljs-string"><span class="hljs-string">''</span></span>: [<span class="hljs-string"><span class="hljs-string">'readNetFromCaffe'</span></span>, <span class="hljs-string"><span class="hljs-string">'readNetFromTensorflow'</span></span>, <span class="hljs-string"><span class="hljs-string">'readNetFromTorch'</span></span>, <span class="hljs-string"><span class="hljs-string">'readNetFromDarknet'</span></span>, <span class="hljs-string"><span class="hljs-string">'readNetFromONNX'</span></span>, <span class="hljs-string"><span class="hljs-string">'readNet'</span></span>, <span class="hljs-string"><span class="hljs-string">'blobFromImage'</span></span>]}</code> </pre> <br><p>  The last transformation, which divides the blob into three channels and then mixes them into the picture, in fact, can be done with one method <code>imagesFromBlob</code> , which has not yet been added to the list above.  Perhaps this will be your first contribution to the development of OpenCV?  ;) </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  As a demonstration, I prepared a page on GitHub, where you can test the resulting code: <a href="https://dkurtaev.github.io/opencv4arts">https://dkurtaev.github.io/opencv4arts</a> (Caution! Downloading a network around 22MB, save your traffic. It is also recommended to reload the page for each new image, otherwise the quality subsequent treatments somehow strongly distorted).  Be prepared for a long process of processing or try changing the size of the image, which as a result will be a slider. </p><br><p>  While working on the article and choosing the very image that would become her face, I accidentally found a photo of my friend, which depicts the Kremlin of our city, and then everything came together - I came up with the name of the article and only then I felt that this was what it should be.  I suggest you try the application on the photos of your favorite place and, perhaps, tell about it something interesting in the comments or personal letter. </p><br><p>  From me - a fun fact.  Most residents of Nizhny Novgorod and the Nizhny Novgorod region use the word ‚Äúget out‚Äù in the sense of the word ‚Äúfit‚Äù (to find a free place for themselves).  For example, the question ‚ÄúWill we get out of your car?‚Äù Means ‚ÄúDo we have enough space in your car?‚Äù And not ‚ÄúCan we clean up your car?‚Äù.  When students from other areas come to us for summer internships, we like to tell this fact - many are genuinely surprised. </p><br><h2 id="poleznye-ssylki">  useful links </h2><br><ul><li>  <a href="https://docs.opencv.org/master/d5/d10/tutorial_js_root.html">OpenCV.js documentation</a> </li><li>  <a href="https://people.eecs.berkeley.edu/~taesung_park/CycleGAN/models/">CycleGAN Models</a> </li><li>  <a href="https://github.com/jcjohnson/fast-neural-style">Other style transfer models</a> (different normalization) </li></ul></div><p>Source: <a href="https://habr.com/ru/post/437600/">https://habr.com/ru/post/437600/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>