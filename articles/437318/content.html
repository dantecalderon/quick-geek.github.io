<div class="post__text post__text-html js-mediator-article">  In True Engineering, on one project, there is a need to change the version of PostgreSQL from 9.6 to 11.1. <br><br>  What for?  The database on the project is already 1.5 Tb in volume and is growing.  Performance is one of the basic requirements for the system.  And the data structure itself evolves: new columns are added, existing ones change.  The new version of Postgres has learned to work efficiently with the addition of new columns with default values, so there is no need to fence down custom crutches at the application level.  Even in the new version they added several new ways to partition tables, which is also extremely useful in the conditions of a large amount of data. <br><br>  So, we decided to migrate.  Of course, you can raise in parallel with the old PostgreSQL server version, stop the application, via dump / restore (or pg_upgrade) move the base and restart the application.  This decision didn’t work for us due to the large size of the base; moreover, the application works in combat mode, and there are only a few minutes to downtime. <br><br>  Therefore, we decided to try migration using logical replication in PostgreSQL using a third-party plugin called <a href="https://www.2ndquadrant.com/en/resources/pglogical/">pglogical</a> . <br><br>  In the process of "sampling" we are faced with very fragmentary documentation on this process (and in Russian there is none at all), as well as some pitfalls and unobvious nuances.  In this article, we want to present our experience in the form of a tutorial. <br><br><img src="https://habrastorage.org/webt/cp/i7/oi/cpi7oixtsenmioqdrcyyotgagyk.png"><br><br>  <b>TL; DR</b> <br><br><ul><li>  Everything turned out (not without crutches, about them and the article). </li><li>  You can migrate within the PostgreSQL version from 9.4 to 11.x, from any version to any, down or up. </li><li>  Downtime is equal to the time it takes for your application to reconnect to the new database server (in our case it was a restart of the entire application, but in the wild, obviously, “options are possible”). </li></ul><a name="habracut"></a><br><h3>  Why we didn’t have a “head on” solution </h3><br>  As we have already said, the easiest way out is to pick up the new PostgreSQL server in parallel with the old one, stop the application, move the base via dump / restore (or pg_upgrade) and start the application again.  For small databases, in principle, this is quite a suitable option (or, in general, the volume is unimportant when you have the possibility of downtime of the application while the database is “transfused” from the old server to a new one, no matter how long this time is).  But in our case, the base takes about 1.5 Tb on the disk, and moving it is not a matter of minutes, but several hours.  The application, in turn, works in combat mode, and I really wanted to avoid downtime longer than a couple of minutes. <br><br>  Also, the fact that we use Master-Slave replication and can’t shut down the Slave server from the work process without serious consequences also played against this option.  So, to switch the application from the old version of PostgreSQL to the new one after the migration of the Master server, it would be necessary to prepare a new Slave server before launching the application.  And this is just a few hours of idle time, until a slave is created (although much less than the Master migration). <br><br>  Therefore, we decided to try migration using logical replication in PostgreSQL using a third-party plugin called pglogical. <br><br><h3>  general information </h3><br>  <a href="https://www.2ndquadrant.com/en/resources/pglogical/">pglogical</a> is a logical replication system that uses native Logical Decoding in PostgreSQL and is implemented as a PostgreSQL extension.  Allows you to customize selective replication using a subscription / publication model.  Does not require the creation of triggers in the database or the use of any external tools for replication. <br><br>  The extension works on any version of PostgreSQL starting from 9.4 (since Logical Decoding first appeared in 9.4), and allows migration between any supported PostgreSQL versions in any direction. <br><br>  Configuring replication with pglogical manually is not very trivial, although in principle it is quite possible.  Fortunately, there is a third-party utility <a href="https://github.com/rtshome/pgrepup/">pgrepup</a> to automate the configuration process, which we will use. <br><br><h3>  Memo on free disk space </h3><br>  Since we plan to raise a new version of PostgreSQL on the same servers in parallel with the old one, the disk requirements for the database on the Master and Slave servers double.  It would seem obvious, but ... Just take care of a sufficient amount of free space before running replication, so as not to regret the years spent aimlessly. <br><br>  In our case, database modifications were required, plus the storage format during migration between 9.6 and 11 doesn’t “swell” in favor of the newer version, so the disk space had to be increased by about 2.2 times not by 2.  Praise LVM, this can be done during the migration process on the fly. <br><br>  In general, take care of it. <br><br><h3>  Install PostgreSQL 11 on Master </h3><br><blockquote>  Note: We use Oracle Linux, and all of the following will be sharpened for this distribution.  It is possible that other Linux distributions will require a small modification by the file, but it is unlikely to be significant. </blockquote><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># добавляем репозиторий yum install https://download.postgresql.org/pub/repos/yum/11/redhat/rhel-7-x86_64/pgdg-oraclelinux11-11-2.noarch.rpm # устанавливаем пакеты postgresql11 yum install postgresql11 postgresql11-devel postgresql11-server postgresql11-contrib # инициализируем базу /usr/pgsql-11/bin/postgresql-11-setup initdb</span></span></code> </pre> <br>  The old datadir is located in <b>/var/lib/pgsql/9.6/data</b> , the new one, respectively, is located in <b>/ var / lib / pgsql / 11 / data</b> <br><br>  We copy access settings ( <b>pg_hba.conf</b> ) and server settings ( <b>postgresql.conf</b> ) from 9.6 to 11. <br><br>  To run two PostgreSQL servers on the same machine, in the <b>postgresql.conf</b> 11 version config, change the port to 15432 (port = 15432). <br><br>  Here you need to think hard about what else you need to do in the new version of PostgreSQL specifically in your case, so that it starts with your <b>postgresql.conf</b> (and your application could eventually work with it).  In our case, it was necessary to install the PostgreSQL extensions used by us into the new version.  This is beyond the scope of the article, just make the new PostgreSQL run, work and fully suit you :) <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ставим расширения, тюним конфиги, добавляем shared libraries, whatever... # .... # запускаемся systemctl enable postgresql-11 systemctl start postgresql-11</span></span></code> </pre> <br>  We look in <b>/ var / lib / pgsql / 11 / data / pg_log /</b> .  All is well?  We continue! <br><br><h3>  Install and configure pgrepup </h3><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ставим python yum install python yum install python2-pip # ставим pgrepup pip install pgrepup # создаём конфигурацию pgrepup config</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/zg/xz/9o/zgxz9oct5l-qglkxyeyrqejh4we.png"><br><br>  Nuances: <br><br><ol><li>  As <b>app_owner we</b> specify the user under which the PostgreSQL servers are running. </li><li>  As <b>Database we</b> specify <b>template1</b> . </li><li>  <b>Username</b> and <b>Password</b> - access data for the superuser.  In our case, the <b>pg_hba.conf</b> for the local connections of the <b>postgres</b> user was assigned a <b>trust</b> method, so you can specify an arbitrary password. </li></ol><br><h3>  Configuring Replication </h3><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># запускаем проверку pgrepup check</span></span></code> </pre><br>  We get a list of the output from the set of parameters that must be configured as required. <br><br>  Sample test results: <br><br><img src="https://habrastorage.org/webt/h3/wu/zm/h3wuzmcevo7idf-xlyrz3ae8av8.png"><br><br><img src="https://habrastorage.org/webt/58/zh/bb/58zhbbubdbfvzzgat051bviywqy.png"><br><br>  All verification errors will need to be fixed.  The settings of both servers should be set to <b>wal_level = LOGICAL</b> (for Logical Decoding to work), the necessary settings for the replication engine (the number of slots and <b>wal_senders</b> ).  The pgrepup utility hints are informative enough, there should be no questions on most of the items. <br><br>  We make all the necessary settings that pgrepup asks for. <br><br>  In both <b>pg_hba.conf</b> files, we add permissions for the user who will replicate, all at the pgrepup prompt: <br><br><pre> <code class="bash hljs">host replication pgrepup_replication 127.0.0.1/32 md5 host all pgrepup_replication 127.0.0.1/32 md5</code> </pre> <br><h3>  Add Primary Keys </h3><br>  In order for replication to work, a Primary Key must be defined in all tables. <br><br>  In our case, PK was not everywhere, so at the time of replication it is necessary to add it, and after the replication is over, if you wish, delete it. <br><br>  The list of tables without PK, among other things, gives <code>pgrepup check</code> .  For all tables from this list, you need to add the primary key in any way acceptable to you.  In our case, it was something like: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> %s <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> temporary_pk <span class="hljs-type"><span class="hljs-type">BIGSERIAL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span></code> </pre> <br>  The pgrepup utility has a built-in command for performing this operation ( <code>pgrepup fix</code> ), and using it even implies that, with successful replication, these temporary columns will be automatically deleted.  But, unfortunately, this functionality is so non-illusory and magically buggy on large bases, that we decided not to use it, but to do this operation manually as we are comfortable. <br><br><h3>  Install pglogical extension </h3><br>  Installation instructions for the extension can be read <a href="https://www.2ndquadrant.com/en/resources/pglogical/pglogical-installation-instructions/">here</a> .  The extension must be installed in both servers. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># добавляем репозитории с нужными нам версиями curl https://access.2ndquadrant.com/api/repository/dl/default/release/9.6/rpm | bash curl https://access.2ndquadrant.com/api/repository/dl/default/release/11/rpm | bash # устанавливаем пакеты yum install postgresql96-pglogical postgresql11-pglogical</span></span></code> </pre> <br>  Add the library load to the <b>postgresql.conf of</b> both servers: <br><br><pre> <code class="bash hljs">shared_preload_libraries = <span class="hljs-string"><span class="hljs-string">'pglogical'</span></span></code> </pre> <br><h3>  Install pgl_ddl_deploy extension </h3><br>  This is a helper extension that pgrepup uses for logical replication of the DDL. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># и его придётся собирать вручную git clone https://github.com/enova/pgl_ddl_deploy.git # сборка и установка для старого сервера PATH=/usr/pgsql-9.6/bin/:$PATH USE_PGXS=1 make USE_PGXS=1 make install make clean # сборка и установка для нового сервера PATH=/usr/pgsql-11/bin/:$PATH make CLANG=true make install</span></span></code> </pre> <br>  Add the library load to the <b>postgresql.conf of</b> both servers: <br><br><pre> <code class="bash hljs">shared_preload_libraries = <span class="hljs-string"><span class="hljs-string">'pglogical,pgl_ddl_deploy'</span></span></code> </pre> <br><h3>  Check for changes </h3><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># перезапускаем новый postgresql systemctl restart postgresql-11</span></span></code> </pre> <br>  Now, using <code>pgrepup check</code> you need to make sure that everything with the target server is ok and all comments regarding the target server are completely eliminated. <br><br>  If all is well, you can restart the old server.  Here you need to think about how your application will react to restarting the database server, you should probably stop it first. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># перезапускаем systemctl restart postgresql-9.6 # проверяем pgrepup check</span></span></code> </pre> <br>  Now in the command output, every single item should be marked OK. <br><br>  It would seem that you can run the migration, but ... <br><br><h3>  Rule bugs pgrepup </h3><br>  In the current version of pgrepup there are several bugs that make migration impossible.  Pull request'y sent, but alas, are ignored, so you have to make corrections manually. <br><br>  Go to the pgrepup installation folder (our case is <b>/usr/lib/python2.7/site-packages/pgrepup/commands/</b> ). <br><br>  Do it once.  In each <b>* .py</b> file we add the missing <code>**kwargs</code> in the function description.  A picture is better than a thousand words: <br><br><img src="https://habrastorage.org/webt/l3/zc/uo/l3zcuo2exe8lq_0u3gwv_nq8jty.png"><br><br>  Commit <a href="https://github.com/Slach/pgrepup/commit/fe2146af5d8965a7fd6193669923eb9fbe7eaccc">here</a> . <br><br>  Do two.  In <b>setup.py,</b> we do a search for “sh -c”, two entries, all multi-line shell commands need to be made one-line. <br><br>  Commit <a href="https://github.com/rtshome/pgrepup/pull/16">here</a> . <br><br><h3>  Starting the migration </h3><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># подготовка pgrepup setup</span></span></code> </pre> <br>  With this command, pgrepup prepares both servers for replication start, creates a user, sets up pglogical, transfers the database schema. <br><br><img src="https://habrastorage.org/webt/ww/km/jd/wwkmjdmmpmwyvgbdqyktohnhmmy.png"><br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># запускаем репликацию pgrepup start</span></span></code> </pre> <br>  He said “Let's go!” And waved his hand: <br><br><img src="https://habrastorage.org/webt/3k/xc/_r/3kxc_rgde-t7q6yuhtvwkol5acs.png"><br><br>  Replication started.  The current situation can be seen using the <code>pgrepup status</code> command: <br><br><img src="https://habrastorage.org/webt/ig/gs/wb/iggswbqldii-c6cd5a1y7qyqawu.png"><br><br>  Here we see that two databases have already moved and replication is underway, and one is still in the process of moving.  Now it remains only to drink coffee and wait until the entire volume of the source database is pumped through. <br><br>  Along the way, you can look deeper than the pgrepup facade and see what happens under the hood.  For inquisitive minds, here is a list of requests as a starting point: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_replication_origin_status <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> remote_lsn <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> *,pg_xlog_location_diff(s.sent_location,s.replay_location) byte_lag <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_replication s; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> query <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> application_name=<span class="hljs-string"><span class="hljs-string">'subscription_copy'</span></span></code> </pre> <br>  Having drunk enough coffee (on the test server when writing this article, the migration of ~ 700Gb data lasted for about 24 hours), we finally see the following picture: <br><br><img src="https://habrastorage.org/webt/ep/2e/q2/ep2eq2c_mtywxboftk4ocb0e_1c.png"><br><br>  And that means it's time to cook a new Slave. <br><br><h3>  Install PostgreSQL 11 on Slave </h3><br>  Here everything is simple and according to the textbook, no nuances. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># добавляем репозиторий yum install https://download.postgresql.org/pub/repos/yum/11/redhat/rhel-7-x86_64/pgdg-oraclelinux11-11-2.noarch.rpm # устанавливаем postgresql 11 yum install postgresql11 postgresql11-devel postgresql11-server postgresql11-contrib # переливаем данные с нового мастера su - postgres pg_basebackup -h db-master.hostname -p 15432 -D /var/lib/pgsql/11/data/ -R -P -U replication -X stream -c fast</span></span></code> </pre> <br>  We copy access settings ( <b>pg_hba.conf</b> ) and server settings ( <b>postgresql.conf</b> ) from 9.6 to 11. In the <b>postgresql.conf</b> 11 configuration file, change the port to 15432 (port = 15432) <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># запускаем systemctl enable postgresql-11 systemctl start postgresql-11</span></span></code> </pre> <br><pre> <code class="pgsql hljs"># проверяем статус репликации на Master <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> *,pg_wal_lsn_diff(s.sent_lsn,s.replay_lsn) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> byte_lag <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_replication s; # проверяем статус репликации на Slave <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> now()-pg_last_xact_replay_timestamp();</code> </pre><br><h3>  Subtotals </h3><br>  After all these procedures, we will have such a tricky replication scheme: <br><br><img src="https://habrastorage.org/webt/70/ns/ej/70nsejcslxlccih_yktvesptqjg.png"><br><br>  Here, as a final check (well, in the end, it’s just beautiful), you can do some UPDATE to the 9.6 Master database and see how it replicates to the other three servers. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c0/c42/89e/7c0c4289e8a00b100f58ce751bd9209e.png" alt="image"><br><br><h3>  Switch applications to the new PostgreSQL version </h3><br>  Until now, our application did not suspect anything about the new version of PostgreSQL, it’s time to fix it.  The options for action here are fundamentally dependent on only two things: <br>  will you outweigh the new services on the same ports where the old ones worked, <br>  and whether your application requires a restart when restarting the database server. <br><br>  For the sake of interest, we will answer both questions “yes” and proceed. <br><br>  Stop the application. <br><br><pre> <code class="pgsql hljs"># проверяем, что нет коннектов, например: <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity;</code> </pre> <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># останавливаем логическую репликацию # при этом также произойдёт финальная синхронизация sequences. pgrepup stop</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/cz/hc/2t/czhc2t8k6pjk-6ivvilidj5k9xq.png"><br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># чистим за собой все хвосты pgrepup uninstall</span></span></code> </pre><br><img src="https://habrastorage.org/webt/2w/ud/dq/2wuddqovqbninwwz9rx9fia8psa.png"><br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># на master: # выключаем старый сервис systemctl disable postgresql-9.6 # останавливаем оба сервиса, сначала старый, затем новый. systemctl stop postgresql-9.6 systemctl stop postgresql-11 # на slave: # выключаем старый сервис systemctl disable postgresql-9.6 # останавливаем оба сервиса, сначала старый, затем новый. systemctl stop postgresql-9.6 systemctl stop postgresql-11</span></span></code> </pre> <br>  We return the standard port in the <b>postgresql.conf</b> config of the new version on the Master and Slave. <br><br>  On the new Slave, we also change the port to the standard one in <b>recovery.conf</b> . <br><br>  Along the way, there is an offer out of harm to change the port on the old version that is becoming inactive: <br>  We expose a non-standard port in <b>postgresql.conf of the</b> old version on the Master and Slave. <br>  On the old Slave, we also change the port to non-standard in <b>recovery.conf</b> . <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># запускаем на master systemctl enable postgresql-11 systemctl start postgresql-11 # запускаем на slave: systemctl enable postgresql-11 systemctl start postgresql-11</span></span></code> </pre> <br>  Check the logs. <br><br>  Check replication status on Master. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> *,pg_wal_lsn_diff(s.sent_lsn,s.replay_lsn) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> byte_lag <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_replication s;</code> </pre> <br>  Run the application.  We rejoice half an hour. <br><br>  <b>And finally, useful literature on the topic:</b> <br><br><ul><li>  <a href="https://www.2ndquadrant.com/en/resources/pglogical/">pglogical</a> </li><li>  <a href="https://www.2ndquadrant.com/en/resources/pglogical/pglogical-installation-instructions/">Installation Instructions for pglogical</a> </li><li>  <a href="https://www.2ndquadrant.com/en/resources/pglogical/pglogical-docs/">pglogical docs</a> </li><li>  <a href="https://hunleyd.github.io/posts/Upgrading-PostgreSQL-from-9.4-to-10.3-with-pglogical/">Upgrading PostgreSQL from 9.4 to 10.3 with pglogical</a> </li><li>  <a href="http://gasparin.net/2016/11/pgrepup-upgrade-postgresql-using-logical-replication/">pgrepup - upgrade PostgreSQL using logical replication</a> </li><li>  <a href="https://github.com/rtshome/pgrepup">pgrepup - PostgreSQL REPlicate and UPgrade</a> </li><li>  <a href="https://rosenfeld.herokuapp.com/en/articles/infrastructure/2017-11-10-upgrading-postgresql-from-9-6-to-10-with-minimal-downtime-using-pglogical">Upgrading PostgreSQL from 9.6 to 10 with minimal downtime using pglogical</a> </li></ul><br>  Successes! </div>