<div class="post__text post__text-html js-mediator-article">  Recently, the company <a href="https://www.smartspate.com/">SmartSpate</a> decided to collect questions related to <a href="https://www.javascript.com/">JavaScript</a> , and answer them.  The material, the translation of which we publish, contains a little more than two dozen questions about JavaScript and answers to them.  The range of topics covered here is quite wide.  In particular, these are features of the language, problems encountered by programmers when writing JS code, work in the browser and in the Node.js environment. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/436454/"><img src="https://habrastorage.org/getpro/habr/post_images/d8e/a96/0ab/d8ea960ab0540026291d5d0f5cf83712.png"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Question number 1.</font>  <font color="#3AC1EF">Prototype Inheritance</font> </h2><br>  I was used to the "classic" classes, but decided to learn JavaScript.  I had a problem with understanding the prototype model.  If possible, explain, in the form of templates, the possibilities for creating "classes" in JavaScript, tell us about the closed and open methods and properties of classes.  I understand that a lot has been written about this already, and the fact that JavaScript methods and properties of objects, by default, are publicly available, but I would like to understand all this.  How does prototype inheritance work in JavaScript? <br><br><h3>  <font color="#3AC1EF">▍ Answer</font> </h3><br>  Classical inheritance is very similar to how people inherit the genes of their ancestors.  People have some common basic capabilities, like walking and talking.  In addition, each person has some peculiarities.  People cannot change what can be called their "class", but they can, within certain limits, change their own "properties".  At the same time, grandmothers, grandfathers, mothers and fathers cannot influence the genes of children or grandchildren in the course of their life.  So everything is arranged on Earth, but let's imagine another planet on which the mechanisms of inheritance work in a special way.  For example, some organisms capable of mutations use the mechanisms of "telepathic inheritance" there.  This is reflected in the fact that they can change the genetic information of their own descendants in the process of their life. <br><br>  Consider the example of inheritance on this strange planet.  The Father object inherits the genes from the Grandfather object, and the Son object inherits the genetic information from the Father.  Every inhabitant of this planet can freely mutate and change the genes of descendants.  For example, the “Grandpa” skin has a green color.  This sign is inherited by "Father" and "Son".  Suddenly, "Grandpa" decides that he is tired of green.  Now he wants to be blue and changes his skin color (in terms of JS, he changes the prototype of his class), telepathically transmitting this mutation to Father and Son.  After that, “Father”, believing that “Grandfather” was out of his mind, decides to change his genes so that he becomes green again (that is, he changes his own prototype).  These changes are "telepathically" transmitted to the "Son".  As a result, both the “Father” and the “Son” have green skin again.  In this case, "Grandfather" still remains blue.  Now, whatever he does with his color, it will not affect anyone else.  And all this is due to the fact that the “Father” explicitly asked the color of his skin in his “prototype”, and the “Son” inherits this color.  Then “Son” thinks like this: “I’ll become black.  And let my descendants inherit color from my father. ”  To do this, it changes its own property (and not its prototype property) in such a way that its property would affect its color, but not affect its descendants.  Express all this in the form of code: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Grandfather = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}; <span class="hljs-comment"><span class="hljs-comment">// Конструктор Grandfather Grandfather.prototype.color = 'green'; var Father = function () {}; // Конструктор Father Father.prototype = new Grandfather (); // Это - простой, но не самый лучший пример прототипного наследования var Son = function () {}; // Конструктор Son Son.prototype = new Father (); // Son является наследником Father var u = new Grandfather (); // Экземпляр класса Grandfather var f = new Father (); // Экземпляр класса Father var s = new Son (); // Экземпляр класса Son // Изначально все зелёного цвета console.log ([u.color, f.color, s.color]); // ["green", "green", "green"] // Объект Grandfather решает перекраситься и поменять цвет своих потомков Grandfather.prototype.color = 'blue'; console.log ([u.color, f.color, s.color]); // ["blue", "blue", "blue"] // Объект Father решает вернуть всё как было - и для себя, и для своих потомков Father.prototype.color = 'green'; // Хотя он может поступить и так: // Grandfather.prototype.color = 'green'; console.log ([u.color, f.color, s.color]); // ["blue", "green", "green"] // Теперь, что бы ни делалось с прототипом объекта Grandfather в плане изменения свойства color, на потомках это не отразится Grandfather.prototype.color = 'blue'; console.log ([u.color, f.color, s.color]); // ["blue", "green", "green"] // Объект Son, решив перекраситься, но не брать пример с объекта Grandfather, меняет собственное свойство s.color = 'black'; // Изменение собственного свойства не затрагивает цепочку прототипов console.log ([u.color, f.color, s.color]); // ["blue", "green", "black"] var SonsSon = function () {}; // Конструктор SonsSon - потомка класса Son SonsSon.prototype = new Son (); // Наследование var ss = new SonsSon (); // Экземпляр класса SonsSon // Сын сына наследует цвет от отца своего отца console.log ([u.color, f.color, s.color, ss.color]); // ["blue", "green", "black", "green"]</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Question number 2.</font>  <font color="#3AC1EF">Creating objects</font> </h2><br>  If you create new instances of objects using the <code>new</code> keyword, how can you protect against errors?  Here is how I usually work: <br><br><ol><li>  I always compose the names of the constructor functions so that they begin with a capital letter. </li><li>  I check the correctness of the operation performed with the help of the <code>this instanceof Function_Name</code> construction (I try not to use the construction of <code>this instanceof arguments.callee</code> for performance reasons). </li><li>  This approach is similar to the previous one, but the comparison is made with the <code>window</code> , since I don’t like to hard-code the entity names in the code and don’t need to write code for environments other than the browser. </li></ol><br>  What is the most convenient model for creating objects? <br><br><h3>  <font color="#3AC1EF">▍ Answer</font> </h3><br>  It is best, both ideologically and based on the familiarity of this method, to create objects using the keyword <code>new</code> .  In this case, the constructor functions must be given names beginning with a capital letter. <br><br>  I prefer to stick to the rules and not perform additional checks on <code>this</code> in constructors.  If the constructor is called without <code>new</code> and work begins in the global scope, this can be compared with "self-deception".  In this case, I in no way recommend to handle situations in constructors in which they are invoked without the <code>new</code> keyword.  For example, it might look like this: if the constructor is called without <code>new</code> , then, all the same, a new object is created and returned.  This approach is ideologically incorrect and leads to errors. <br>  Here is an example of working with the designer. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Obj = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-string"><span class="hljs-string">"use strict"</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.pew = <span class="hljs-number"><span class="hljs-number">100</span></span>; }; <span class="hljs-comment"><span class="hljs-comment">// Правильно let o = new Obj(); o.pew++; console.log(o.pew); //101 // Неправильно. Возникает ошибка Obj (); // TypeError: this is undefined</span></span></code> </pre> <br>  It is better not to use the <code>new</code> keyword for factory methods and for cases when there is no need for a constructor, when it is more convenient to create an object using an object literal.  Say, the constructor code shown in the following example is clearly redundant: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Не очень хороший подход. var Obj = function () {    if (! (this instanceof Obj)) {        return new Obj ();    }    this.pew = 100; };</span></span></code> </pre> <br>  If, even for creating a small object, a constructor is still needed, it is better to do this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Obj = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{    <span class="hljs-string"><span class="hljs-string">"use strict"</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.pew = <span class="hljs-number"><span class="hljs-number">100</span></span>; };</code> </pre> <br>  Here, as was shown above, due to the fact that the constructor is working in strict mode, if you call it without <code>new</code> an error will occur. <br><br><h2>  <font color="#3AC1EF">Question number 3.</font>  <font color="#3AC1EF">Interception of mouse clicks</font> </h2><br>  How do I use JavaScript tools to find out which mouse button is pressed? <br><br><h3>  <font color="#3AC1EF">▍ Answer</font> </h3><br>  When you click on the mouse button, <code>mousedown</code> and <code>mouseup</code> events are generated.  In this case, the <code>click</code> event generates only the left mouse button.  In the event handler, you need to check the code found in the <code>event.button</code> property to find out exactly which button is pressed (0 - left, 1 - middle, 2 - right).  However, in IE, everything looks different.  Consider an example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> button = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById (<span class="hljs-string"><span class="hljs-string">'button'</span></span>),              <span class="hljs-comment"><span class="hljs-comment">// 0 1 2    buttonMap = ['Left', 'Middle', 'Right'],    handler = function (event) {        event = event || window.event;        alert (buttonMap [event.button] + 'id:' + event.button);    }; if (button.addEventListener) {     button.addEventListener ('mousedown', handler, false); } else {     // IE 0 1 2 3 4     buttonMap = ['???', 'Left', 'Right', '???', 'Middle'];     button.attachEvent ('onmousedown', handler); }</span></span></code> </pre> <br>  The jQuery library takes this feature of IE into account, so when using it in any browser, it is enough to check the value of the <code>event.which</code> property instead of messing with <code>event.button</code> : <br><br><pre> <code class="javascript hljs">$(<span class="hljs-string"><span class="hljs-string">'button'</span></span>).mousedown(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{   alert([<span class="hljs-string"><span class="hljs-string">'Left'</span></span>, <span class="hljs-string"><span class="hljs-string">'Middle'</span></span>, <span class="hljs-string"><span class="hljs-string">'Right'</span></span>][event.which]); });</code> </pre> <br><h2>  <font color="#3AC1EF">Question number 4.</font>  <font color="#3AC1EF">Intercept keystrokes</font> </h2><br>  Is it possible to intercept, by means of JavaScript, pressing the arrow keys (in particular, pressing the Down and Up keys), making it so that, after clicking on them, the browser does not scroll through the page?  If this is possible - what are the features of implementing this in different browsers?  Suppose a page is displayed on a page that does not fit entirely on the screen.  Navigation through the cells of this table must be organized using the arrow keys, and it is required that the browser does not scroll the page when pressing such keys. <br><br><h3>  <font color="#3AC1EF">▍ Answer</font> </h3><br>  In order to implement something similar, first of all, you need to disable the standard response of the system to control actions.  For example, the arrow keys and mouse wheel scroll the page, right-click on the page to <code>form.submit()</code> context menu, when you click on the <code>submit</code> button, the <code>form.submit()</code> function is <code>form.submit()</code> , when you click on the input field, it receives input focus, when you click on the link, the browser loads page to which she leads. <br><br>  This can be done <a href="https://stackoverflow.com/questions/8916620/disable-arrow-key-scrolling-in-users-browser">in different ways</a> .  For example - so: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">"keydown"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-comment"><span class="hljs-comment">// Коды клавиш-стрелок   if([37, 38, 39, 40].indexOf(e.keyCode) &gt; -1) {       e.preventDefault();   } }, false);</span></span></code> </pre> <br>  The page after this will not normally respond to key presses. <br>  There is one important thing to note.  Call the <code>preventDefault()</code> method before the default action is executed.  For example, if, when clicking on a field, it is required that it would not receive the input focus, you need to hang the corresponding handler on the event that is in the chain of events before the default action.  In our case, this is a <code>mousedown</code> event: <br><br><pre> <code class="javascript hljs">$(<span class="hljs-string"><span class="hljs-string">'input'</span></span>).bind (<span class="hljs-string"><span class="hljs-string">'mousedown'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{   event.preventDefault();   <span class="hljs-comment"><span class="hljs-comment">// или   return false; });</span></span></code> </pre> <br>  When you click on the input field, the following events occur - in the sequence in which they are shown here: <br><br><ol><li> <code>mousedown</code> </li> <li>  <code>focus</code> (before that, another object that loses focus will trigger the <code>blur</code> event) </li><li> <code>mouseup</code> </li> <li> <code>click</code> </li> </ol><br>  If we try to prevent an element from receiving an input focus, then using event handlers for this purpose, beginning with the event handler <code>focus</code> will not help us with this. <br><br><h2>  <font color="#3AC1EF">Question number 5.</font>  <font color="#3AC1EF">Stop GIF animation and ESC key</font> </h2><br>  How to deal with the problem of stopping GIF-animation when you press the ESC key? <br><br><h3>  <font color="#3AC1EF">▍ Answer</font> </h3><br>  Here you can use the same approach that we considered above.  In some browsers, pressing the ESC key stops GIF animation and page loading.  This is their standard behavior, and in order for them not to behave this way, we, as before, come in handy for the <code>preventDefault()</code> event method.  The key code ESC - 27. <br><br><h2>  <font color="#3AC1EF">Question number 6.</font>  <font color="#3AC1EF">Parentheses in IIFE</font> </h2><br>  How does the construction in the form of two parentheses, used to declare an immediately called functional expression (IIFE, Immediately Invoked Function Expression)? <br><br><h3>  <font color="#3AC1EF">▍ Answer</font> </h3><br>  The brackets in this situation allow the parser to understand that there is a function in front of them that needs to be executed.  But he also needs to understand what these brackets are - a grouping operator, or a construct indicating the need to call a function.  For example, if we use two brackets as shown below, we will <code>SyntaxError</code> a <code>SyntaxError</code> error: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// код }()</span></span></code> </pre> <br>  This happens due to the fact that the function does not have a name (in function declarations, you need to specify their names). <br><br>  Let's try to rewrite this code, giving the function a name: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// код }()</span></span></code> </pre> <br>  Now that the function has a name, this construction, theoretically, should look quite normal from the point of view of the system.  But the error does not disappear, though now it relates to the grouping operator, within which there is no expression.  Notice that in this case, the function declaration is followed by a grouping operator, and not a sequence of parentheses, indicating to the system that it is necessary to call the prefixing function. <br><br>  Often IIFE make out so: <br><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-comment"><span class="hljs-comment">// код })()</span></span></code> </pre> <br>  But there are other ways, the essence of which is to somehow indicate to the parser that what is in front of it is the functional expression that needs to be executed: <br><br><pre> <code class="javascript hljs">!<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// код }(); +function () { // код }(); [function() { // код }()]; var a = function () { // код }();</span></span></code> </pre> <br>  IIFE are widely used in JavaScript programming.  For example, this construct is used in jQuery.  With its help, you can create a circuit.  In fact, we are talking about the fact that, using IIFE, the programmer can execute some code in the local scope.  This helps to protect the global scope from pollution, allows you to optimize access to global variables.  Such designs are well minified. <br><br><h2>  <font color="#3AC1EF">Question number 7.</font>  <font color="#3AC1EF">Pass code in response to requests</font> </h2><br>  The server, in the process of AJAX interaction with the client, in the response body, sends the client a string <code>alert ('Boom !!!');</code>  .  The client accepts the response and executes this code using the <code>eval()</code> function.  How it's called?  After all, what is contained in the response of the server is not JSON, not XML and not HTML.  What can you say about the execution on the client of the code that comes from the server as the body of an answer to a certain request? <br><br><h3>  <font color="#3AC1EF">▍ Answer</font> </h3><br>  In fact, there is no special name for such a scheme of interaction between the client and the server.  And this is a system interaction scheme, which is strongly discouraged.  This is as bad as storing PHP code in a database and then executing it using the appropriate language methods.  Even if one does not take into account ideological considerations, one can say that such an architecture turns out to be extremely inflexible, therefore, if the project where it is used needs to be changed as it evolves, it will not be easy to do.  Here we see an example of a bad system architecture, when data is mixed with code and interface elements.  In order to change something in such a system, you first need to understand the intricacies of its intricate architecture, and then, after completing the changes, again “confuse” everything.  I'm not talking about code reuse. <br><br>  To simplify the support of the code, it is necessary to strive for the separation of system parts as much as possible and to reduce the number of interdependencies of these parts.  In order to provide weak connectivity of parts of the system, that is, to make it so that a fragment of the application can be extracted from it, or replaced with another, with the least complexity, event mechanisms or special architectural solutions, such as MVC, can be applied. <br><br><h2>  <font color="#3AC1EF">Question number 8.</font>  <font color="#3AC1EF">Performing heavy operations in the main thread</font> </h2><br>  How to organize the execution of some resource-intensive commands in JavaScript and not hang the whole script? <br><br><h3>  <font color="#3AC1EF">▍ Answer</font> </h3><br>  JavaScript is a single-threaded language.  In the same thread, the code of the web pages is executed and the DOM tree is converted.  Timers work there too.  Every time you perform some resource-intensive operations (cycles, calls to "heavy" functions), this leads to a slowdown of the user interface or even its complete blocking.  If the operations performed do not have a particularly large load on the system, then their effect on the interface will be so insignificant that users simply will not notice.  In order to make heavy calculations out of the main thread, JavaScript introduced the concept of web workers. <br><br>  If the use of workers is not possible, then it is necessary to optimize cycles and "heavy" functions.  In the book "JavaScript.  Performance Optimization ”Nicholas Zakas says that the user will not notice anything if the UI thread is blocked for 100 ms or less. <br><br>  From this idea, we can conclude that resource-intensive calculations can be divided into fragments, the execution of which takes a maximum of 100 ms, after which the main stream must be freed. <br><br>  Here is a sample code from the above book: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timedProcessArray</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">items, process, callback</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> todo = items.concat();   <span class="hljs-comment"><span class="hljs-comment">//создаём клон   setTimeout(function () {       var start = +new Date();       do {           process(todo.shift());       } while (todo.length &gt; 0 &amp;&amp; (+new Date() - start &lt; 50));       if (todo.length &gt; 0){           setTimeout(arguments.callee, 25);       } else {           callback(items);       }   }, 25); } function saveDocument(id) {   var tasks = [openDocument, writeText, closeDocument, updateUI];   timedProcessArray(tasks, [id], function(){       alert("Save completed!");   }); }</span></span></code> </pre> <br>  The <code>timedProcessArray()</code> function blocks the main thread for 25 ms, performs a sequence of actions, then releases it for 25 ms, after which this process is repeated. <br><br><h2>  <font color="#3AC1EF">Question number 9.</font>  <font color="#3AC1EF">Browser resizing information</font> </h2><br>  Can I somehow find out that the user has completed resizing the browser window? <br><br><h3>  <font color="#3AC1EF">▍ Answer</font> </h3><br>  There is no special event that allows you to find out.  But you can find out if the user is resizing the window using the <code>onresize</code> event.  This method, however, is not very accurate. <br><br>  Here is an outline of the code aimed at solving this problem. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> time = <span class="hljs-number"><span class="hljs-number">0</span></span>,   timerId,   TIME_ADMISSION = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 0.1 с function onresizeend () {   console.log('onresizeend'); }; function resizeWatcher () {   if (+new Date - time &gt;= TIME_ADMISSION) {       onresizeend();       if (timerId) {           window.clearInterval(timerId);           timerId = null;       }   } }; $(window).resize(function () {   if (!timerId) {       timerId = window.setInterval(resizeWatcher, 25);   }   time = +new Date; });</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Question number 10.</font>  <font color="#3AC1EF">Opening new windows and browser tabs</font> </h2><br>  How, using the <code>window.open()</code> method, open a new browser window, not a new tab? <br><br><h3>  <font color="#3AC1EF">▍ Answer</font> </h3><br>  How exactly the <code>window.open()</code> method behaves depends on the browser.  Opera always opens new tabs (although they look like windows), Safari always opens windows (although this behavior can be changed).  The behavior of Chrome, Firefox and Internet Explorer can be controlled. <br><br>  So, if an additional parameter (window position <code>window.open()</code> passed to the <code>window.open()</code> method, a new window will be opened: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.open(<span class="hljs-string"><span class="hljs-string">'http://www.google.com'</span></span>, <span class="hljs-string"><span class="hljs-string">'_blank'</span></span>, <span class="hljs-string"><span class="hljs-string">'toolbar=0,location=0,menubar=0'</span></span>);</code> </pre> <br>  If only a link is passed to this method, then a new browser tab will open: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.open(<span class="hljs-string"><span class="hljs-string">'http://www.google.com'</span></span>);</code> </pre> <br>  Often you need to open a new browser tab.  This can cause problems in the Safari browser.  By default (it depends on the settings) the browser, when you call <code>window.open()</code> , opens a new window.  But if you click on the link, while pressing the <code>Ctrl + Shift/Meta + Shift</code> keys, a new tab will open (regardless of the settings).  In the following example, we will simulate a <code>click</code> event that is triggered when the <code>Ctrl + Shift/Meta + Shift</code> keys are pressed: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">safariOpenWindowInNewTab</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">href</span></span></span><span class="hljs-function">) </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> event = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createEvent (<span class="hljs-string"><span class="hljs-string">'MouseEvents'</span></span>),        mac = (navigator.userAgent.indexOf (<span class="hljs-string"><span class="hljs-string">'Macintosh'</span></span>)&gt; = <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// выполнить Ctrl + Shift + LeftClick / Meta + Shift + LeftClick (фокус)    // создаём собственное событие    event.initMouseEvent (        / * type * / "click",        / * canBubble * / true        / * cancelable * / true,        / * view * / window,        / * detail * / 0,        / * screenX, screenY, clientX, clientY * / 0, 0, 0, 0,        / * ctrlKey * /! mac,        / * altKey * / false,        / * shiftKey * / true        / * metaKey * / mac,        / * button * / 0,        / * relatedTarget * / null    ); // создаём ссылку в памяти и, используя наше событие, открываем её в новой вкладке    $ ('&lt;a/&gt;', {'href': href, 'target': '_blank'}) [0] .dispatchEvent (event); }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Question number 11.</font>  <font color="#3AC1EF">Deep copying of objects</font> </h2><br>  How to effectively organize deep copying of objects? <br><br><h3>  <font color="#3AC1EF">▍ Answer</font> </h3><br>  If the object that you want to create a copy of (let's call it <code>oldObject</code> ) does not change, then it will be most effective to do it through its prototype (this is done very quickly): <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">object</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">o</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">F</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}   F.prototype = o;   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> F(); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newObject = object(oldObject);</code> </pre> <br>  If you really need to perform an object cloning operation, then the fastest will be recursively, having optimized this process, to go over its properties.  This is probably the fastest algorithm for creating deep copies of objects: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cloner = {   <span class="hljs-attr"><span class="hljs-attr">_clone</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_clone</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>) {           <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> out = [];           <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, len = obj.length; i &lt; len; i++) {               <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = obj[i];               out[i] = (value !== <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> value === <span class="hljs-string"><span class="hljs-string">"object"</span></span>) ? _clone(value) : value;           }       } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {           <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> out = {};           <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> obj) {               <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj.hasOwnProperty(key)) {                   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = obj[key];                   out[key] = (value !== <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> value === <span class="hljs-string"><span class="hljs-string">"object"</span></span>) ? _clone(value) : value;               }           }       }       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> out;   }, <span class="hljs-attr"><span class="hljs-attr">clone</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">it</span></span></span><span class="hljs-function">) </span></span>{       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._clone({       <span class="hljs-attr"><span class="hljs-attr">it</span></span>: it       }).it;   } }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newObject = cloner.clone(oldObject);</code> </pre> <br>  If you use jQuery, then you can resort to the following constructions: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Мелкое копирование var newObject = jQuery.extend ({}, oldObject); // Глубокое копирование var newObject = jQuery.extend (true, {}, oldObject);</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Question number 12.</font>  <font color="#3AC1EF">Destructors in javascript</font> </h2><br>  How to create something like destructor in JavaScript?  How to manage the life cycle of objects? <br><br><h3>  <font color="#3AC1EF">▍ Answer</font> </h3><br>  In JavaScript, the object will be removed from memory after the last link to it disappears: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = {<span class="hljs-attr"><span class="hljs-attr">z</span></span>: <span class="hljs-string"><span class="hljs-string">'z'</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = a; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = a; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> az; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> a; <span class="hljs-comment"><span class="hljs-comment">// Мы удалили ссылку a console.log (b, c); // Объект, теперь пустой, никуда не делся</span></span></code> </pre> <br>  Using something like “destructor” in JavaScript leads only to clearing the contents of an object, but not to deleting it from memory. <br><br><h2>  <font color="#3AC1EF">Question number 13.</font>  <font color="#3AC1EF">Binary data processing</font> </h2><br>  Is it possible to handle binary data in JavaScript?  And if so, how? <br><br><h3>  <font color="#3AC1EF">▍ Answer</font> </h3><br>  If you need to work with binary data in a JavaScript application, you can try using the <a href="http://jsfromhell.com/classes/binary-parser">Binary Parser</a> library.  But its code is real hell.  In ES6 + there is a sentence regarding the type of <code>StructType</code> (this is the same thing that is represented in C ++ with a composite type of this <code>struct</code> ).  This data type is needed to simplify working with binary data.  Working with him might look something like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Point2D = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StructType({ <span class="hljs-attr"><span class="hljs-attr">x</span></span>: uint32, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: uint32 }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Color = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StructType({ <span class="hljs-attr"><span class="hljs-attr">r</span></span>: uint8, <span class="hljs-attr"><span class="hljs-attr">g</span></span>: uint8, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: uint8 }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Pixel = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StructType({ <span class="hljs-attr"><span class="hljs-attr">point</span></span>: Point2D, <span class="hljs-attr"><span class="hljs-attr">color</span></span>: Color }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Triangle = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayType(Pixel, <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> t = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Triangle([{ <span class="hljs-attr"><span class="hljs-attr">point</span></span>: { <span class="hljs-attr"><span class="hljs-attr">x</span></span>:  <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }, <span class="hljs-attr"><span class="hljs-attr">color</span></span>: { <span class="hljs-attr"><span class="hljs-attr">r</span></span>: <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-attr"><span class="hljs-attr">g</span></span>: <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">255</span></span> } },                     { <span class="hljs-attr"><span class="hljs-attr">point</span></span>: { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span> }, <span class="hljs-attr"><span class="hljs-attr">color</span></span>: { <span class="hljs-attr"><span class="hljs-attr">r</span></span>: <span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-attr"><span class="hljs-attr">g</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>,   <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } },                     { <span class="hljs-attr"><span class="hljs-attr">point</span></span>: { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }, <span class="hljs-attr"><span class="hljs-attr">color</span></span>: { <span class="hljs-attr"><span class="hljs-attr">r</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>,   <span class="hljs-attr"><span class="hljs-attr">g</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">128</span></span> } }]);</code> </pre> <br><h2>  <font color="#3AC1EF">Question number 14.</font>  <font color="#3AC1EF">Change variables in one function from another function</font> </h2><br>  How to change variables in one function from another function? <br><h3>  <font color="#3AC1EF">▍ Answer</font> </h3><br>  Here you can apply several approaches: <br><br><ol><li>  You can use the reference to the context of the function of interest (the <code>primer()</code> function in the following example) in the <code>smth()</code> function. <br></li><li>  You can pass a function created in the context of the <code>primer()</code> function to the <code>smth()</code> function. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> primer = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a, b, c, d, e = {}; smth (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{        a = <span class="hljs-number"><span class="hljs-number">1</span></span>;        b = <span class="hljs-number"><span class="hljs-number">2</span></span>;        c = <span class="hljs-number"><span class="hljs-number">3</span></span>;        d = <span class="hljs-number"><span class="hljs-number">4</span></span>;    }, e); alert ([a, b, c, d, e.pewpew]); }, smth = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback, e</span></span></span><span class="hljs-function">) </span></span>{    callback ();    e.pewpew = <span class="hljs-string"><span class="hljs-string">"pewpew"</span></span>; }; primer ();</code> </pre> </li><li>  Previously (to Firefox 3.6), the context could be reached using the <code>__parent__</code> property, but this feature was removed in Firefox 4. </li></ol><br><h2>  <font color="#3AC1EF">Question number 15.</font>  <font color="#3AC1EF">Work with functions</font> </h2><br>  Tell us how you can call functions in JavaScript. <br><h3>  <font color="#3AC1EF">▍ Answer</font> </h3><br>  I suppose there is no need to talk about how to call functions, methods, and constructors during normal work with them.  Let's talk about how to use the <code>call()</code> and <code>apply()</code> methods. <br><br><h4>  Using call () to set up an object constructor </h4><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Вспомогательная функция function extend (newObj, oldObj) {   function F () {};   F.prototype = oldObj.prototype;   newObj.prototype = new F ();   return newObj }; var Obj = function () {   this.obj_var = 100; }; Obj.prototype.obj_proto_var = 101; var NewObj = function () {   Obj.call (this); // Вызываем конструктор Obj и получаем собственное свойство obj_var   this.new_obj_var = 102; }; extend (NewObj, Obj) NewObj.prototype.new_obj_proto_var = 103; new NewObj (); // {new_obj_proto_var: 103, new_obj_var: 102, obj_proto_var: 101, obj_var: 100}</span></span></code> </pre> <br><h4>  Converting mass-like objects into arrays </h4><br>  Massive objects are similar to JavaScript arrays, but they are not.  In particular, this is expressed in the fact that such objects do not have methods of ordinary arrays.  Among such objects, for example, the <code>arguments</code> object of traditional functions and the results of the <a href="https://developer.mozilla.org/ru/docs/Web/API/Element/getElementsByTagName">getElementsByTagName ()</a> method can be noted. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// document.getElementsByTagName ("div") возвращает нечто, похожее на массив, но им не являющееся, что, в частности, не даёт нам возможность пользоваться методами массивов document.getElementsByTagName ("div"). forEach (function (elem) {    // ... }); // TypeError: document.getElementsByTagName ("div"). forEach is not a function // Переходим к массиву Array.prototype.slice.call(document.getElementsByTagName("div")).forEach (function (elem) {   // OK }); // Похожие вещи можно делать и со строками console.log(Array.prototype.slice.call ('pewpew')) // ["p", "e", "w", "p", "e", "w"] // В IE8 это работает иначе</span></span></code> </pre> <br><h4>  Creating wrapper objects </h4><br> Эта методика применения <code>call()</code> и <code>apply()</code> позволяет создавать объекты-обёртки. Предположим, нам нужно создать функцию-обёртку <code>foo()</code> , которая вызывает функцию <code>bar()</code> в специфическом контексте с произвольным числом аргументов. <br><br> При использовании традиционного подхода это будет выглядеть так: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>)} <span class="hljs-comment"><span class="hljs-comment">// foo (context, arg1, arg2, ...) function foo () {    var context = arguments [0];    var args = Array.prototype.slice.call (arguments, 1); // массив с аргументами для bar    bar.apply (context, args); }</span></span></code> </pre> <br> То же самое с применением конструкции <code>Function.call.apply()</code> можно переписать гораздо короче: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>.call.apply(bar, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); }</code> </pre> <br> Здесь, благодаря использованию <code>Function.call.apply()</code> , аргументы, переданные <code>foo()</code> , передаются <code>bar</code> . <br><br><h2> <font color="#3AC1EF">Вопрос №16. Передача контекста выполнения функции</font> </h2><br> Как передать контекст, в котором выполняется одна функция, другой функции? <br><br><h3> <font color="#3AC1EF">▍Ответ</font> </h3><br> Это невозможно. Раньше, в версиях Firefox до 3.6, контекст можно было получить через свойство <code>__parent__</code> , но потом эту возможность убрали. <br><br><h2> <font color="#3AC1EF">Вопрос №17. Работа с глобальным объектом</font> </h2><br> Расскажите о том, как работать с глобальным объектом в том случае, если он не передаётся напрямую, если не используется <code>eval()</code> и применяется строгий режим? <br><br><h3> <font color="#3AC1EF">▍Ответ</font> </h3><br> Если соблюдены все три этих условия, то доступ к глобальному объекту получить нельзя. Если же от них отступить, то можно рассмотреть следующие варианты: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// 1: Использование eval() (function () {    "use strict";    var globalObject = (0, eval) ("this"); // Волшебство :)    return globalObject; } ()); // 2: Передача глобального объекта (function (global) {    // ... } (window)); // 3: Работа без использования строгого режима (function () {    return this; } ()); // 4: Выполняя этот код в глобальном контексте мы получим ссылку на глобальный объект, в противном случае это работать не будет. // Это - наиболее адекватный вариант "use strict"; (function (global) {    // global }) (this);</span></span></code> </pre> <br><h2> <font color="#3AC1EF">Вопрос №18. Перезапуск событий</font> </h2><br> Можно ли, средствами JavaScript, перезапустить событие после того, как оно было перехвачено? <br><br><h3> <font color="#3AC1EF">▍Ответ</font> </h3><br> Объект события в JavaScript не несёт какой-либо «полезной нагрузки». Он лишь содержит дескриптор события. Но соответствующую ссылку на подобный объект можно передать обработчику события. Например, это может выглядеть так: <br><br><pre> <code class="javascript hljs">$(<span class="hljs-string"><span class="hljs-string">'#smth'</span></span>).click(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSmthClick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smth) {       <span class="hljs-comment"><span class="hljs-comment">// Пишем обработчик       event.handlerFunction = onSmthClick;       event.handlerContext = this;       // Передаём объект       // Теперь otherObjectSetSomeEvent может использовать event.handlerFunction и вызывать обработчик       otherObjectSetSomeEvent(event);   } else {       // Делаем что-то ещё   } });</span></span></code> </pre> <br> Но это — не самое удачное решение, так как код получается запутанным. Лучше переписать этот пример следующим образом, разделив обработчик на 2 части: <br><br><pre> <code class="javascript hljs">$(<span class="hljs-string"><span class="hljs-string">'#smth'</span></span>). click (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler1</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smth) {       <span class="hljs-comment"><span class="hljs-comment">// Передаём объект       leftObjectSetSomeEvent(event, function handler2 (e) {           // Делаем что-то с событием e       });   } else {       // Делаем что-то ещё   } }); function leftObjectSetSomeEvent(event, callback) {   callback (event);   // Работаем с событием }</span></span></code> </pre> <br><h2> <font color="#3AC1EF">Вопрос №19. Универсальный обработчик событий мыши</font> </h2><br> Как в JavaScript перехватывать щелчки мышью по любым элементам страницы? Например — для того, чтобы написать универсальный обработчик событий. <br><br><h3> <font color="#3AC1EF">▍Ответ</font> </h3><br> Нужно прикрепить обработчик события <code>click</code> к самому «нижнему» объекту в дереве DOM. В результате все подобные события достигнут этого объекта (правда, так будет только в том случае, если их никто не перехватит). <br><br><pre> <code class="plaintext hljs">// jQuery $(window).bind ('click', function (e) {   console.log ('Clicked on', e.target); }); // Можно ввести ограничения с использованием делегирования $('#pewpew').delegate ('*', 'click', function(e) {   console.log('Clicked on', e.target); }); // Можно ограничить целевые объекты $('#pewpew').delegate('.pewpew', 'click', function (e) {   console.log ('Clicked on element with .pewpew class name'); });</code> </pre> <br><h2> <font color="#3AC1EF">Вопрос №20. XHR-запросы</font> </h2><br> Как выполнять XHR-запросы без использования jQuery? <br><br><h3> <font color="#3AC1EF">▍Ответ</font> </h3><br> Вот решение, которое не отличается кросс-браузерными возможностями: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xhr</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">m, u, c, x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">with</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest) onreadystatechange = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{   readyState ^ <span class="hljs-number"><span class="hljs-number">4</span></span> || c(x.target) }, open(m, u), send(с) }</code> </pre> <br> Вот кросс-браузерный вариант: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xhr</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">m, u, c, x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">with</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.XMLHttpRequest || ActiveXObject)(<span class="hljs-string"><span class="hljs-string">"Microsoft.XMLHTTP"</span></span>)) onreadystatechange = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{   readyState ^ <span class="hljs-number"><span class="hljs-number">4</span></span> || c(x) }, open(m, u), send(с) }</code> </pre> <br> Вот как этим пользоваться: <br><br><pre> <code class="javascript hljs">xhr(<span class="hljs-string"><span class="hljs-string">'get'</span></span>, <span class="hljs-string"><span class="hljs-string">'//google.com/favicon.ico'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">xhr</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.dir(xhr) });</code> </pre> <br><h2> <font color="#3AC1EF">Вопрос №21. Оптимизация вывода веб-страниц</font> </h2><br> Как минимизировать число операций пересчёта геометрии элементов (reflow) и перерисовки (repaint) при работе с веб-страницами? <br><br><h3> <font color="#3AC1EF">▍Ответ</font> </h3><br><ol><li> Если браузер поддерживает функцию <code>requestAnimationFrame()</code> , то следует использовать именно её, а не <code>setInterval()</code> или <code>setTimeout()</code> . Браузеры могут оптимизировать анимации, происходящие одновременно, уменьшая число операций пересчёта геометрии и перерисовки до одной, что, в свою очередь, ведёт к повышению точности анимации. Например, на некоей странице JavaScript-анимации могут быть синхронизированы с CSS-переходами или с SVG-анимациями. Кроме того, если анимация выполняется на странице, которая открыта в невидимой вкладке браузера, браузер не будет её перерисовывать, что приведёт к снижению нагрузки на процессор, видеокарту, память. На мобильных устройствах это, кроме того, означает экономию заряда аккумулятора. </li><li> Избегайте использования на страницах большого количества float-элементов (для уменьшения операций по пересчёту геометрии элементов). </li><li> Как можно реже модифицируйте дерево DOM. Формируйте то, что вам нужно, в памяти, после чего обновляйте DOM лишь один раз (это тоже приведёт к снижению числа операций по пересчёту геометрии). </li><li> Если нужно изменить несколько свойств объектов — меняйте их все за один раз. Это минимизирует число операций пересчёта геометрии объектов и число операций перерисовки (для современных браузеров, правда, это неактуально).  Here is an example: <br><br><pre> <code class="plaintext hljs">// Не меняйте свойства по одному element.style.left = "150px;"; // ... element.style.color = "green"; // Меняйте свойства, которые надо модифицировать, за один раз element.setAttribute ('style', 'color: green; left: 150px');</code> </pre> </li><li> Выполняйте анимацию перетаскивания объектов только для элементов с абсолютным позиционированием (это ведёт к снижению числа операций по пересчёту геометрии). <br></li><li> Прежде чем изменить группу элементов — скройте их ( <code>style.display = "none"</code> ). Это уменьшает число операций по пересчёту геометрии элементов, но неактуально для современных браузеров. <br></li></ol><br> Вот ещё несколько рекомендаций, касающихся оптимизации веб-страниц, которые не относятся к пересчёту геометрии элементов и к перерисовке. Надо отметить, что они, в современных браузерах, могут и не дать особенно заметного эффекта, так как эти браузеры хорошо оптимизированы. <br><br><ol><li> Используйте делегирование событий. </li><li> Кэшируйте ссылки на DOM-элементы (выбор элемента — наиболее ресурсозатратная операция). </li><li> Используйте для быстрого поиска элементов функцию <code>Document.querySelectorAll()</code> и свойство <code>firstElementChild</code> . </li><li> Помните о том, что функция <code>document.getElementsByTagName()</code> возвращает живую коллекцию элементов (такая коллекция, при добавлении нового элемента в дерево DOM, обновляется автоматически). </li></ol><br><h2> <font color="#3AC1EF">Вопрос №22. Работа с процессами в Node.js</font> </h2><br> Следует ли в среде Node.js, в высоконагруженных проектах, создавать новые процессы для обработки каждого нового запроса? <br><br><h3> <font color="#3AC1EF">▍Ответ</font> </h3><br> Поступать так категорически не рекомендуется, так как при таком подходе мы создадим слишком большую дополнительную нагрузку на систему (это будет похоже на работу PHP и Apache). Речь идёт о необходимости выделения памяти для нового процесса, о затратах времени на создание форка процесса, на инициализацию процесса и так далее. Платформа Node.js очень хорошо умеет распределять нагрузку и загружает одно процессорное ядро в своём цикле обработки событий — в главном потоке приложения. Лучше всего, когда на одно ядро приходится один форк процесса, причём управлять процессами лучше всего с помощью стандартного модуля <a href="https://nodejs.org/api/cluster.html">cluster</a> . При использовании этого модуля используется концепция главного процесса (master) и процессов-воркеров (worker). При этом надо отметить, что вполне оправдано использование дополнительных процессов для обработки тяжёлых запросов. <br><br><h2> <font color="#3AC1EF">Вопрос №23. Метод runInNewContext() в Node.js</font> </h2><br> Расскажите об использовании метода <code>runInNewContext()</code> в Node.js. <br><br><h3> <font color="#3AC1EF">▍Ответ</font> </h3><br> Я вижу лишь один вариант применения этой технологии. Он заключается в выполнение чужого, потенциально небезопасного кода (именно так поступает Node.js-хостинг Nodester). Если в чём-то подобном сильной нужды нет, то я категорически не рекомендую пользоваться <code>runInNewContext()</code> . Фактически, речь идёт о совершенно ненужной «обёртке», которая не пригодится в разумно спроектированном приложении. При этом на работу с этой «обёрткой» тратятся серьёзные системные ресурсы, кроме того, использование <code>runInNewContext()</code> может плохо сказаться на поддержке кода приложения. <br><br><h2> <font color="#3AC1EF">Итоги</font> </h2><br> В этом материале мы рассмотрели некоторые вопросы о JavaScript и ответы на них. Надеемся, вы нашли здесь что-то такое, что вам пригодится. <br><br> <b>Уважаемые читатели!</b> Какие вопросы, по-настоящему вас беспокоящие, вы задали бы тому, кто очень хорошо разбирается в JavaScript и в технологиях, имеющих отношение к этому языку? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div>