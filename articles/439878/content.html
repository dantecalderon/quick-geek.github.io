<div class="post__text post__text-html js-mediator-article">  The goal is to create a new highly loaded startup in modern conditions.  Architecture creation will be considered on the example of <a href="https://github.com/rumatakira/billingolang">Billingolang</a> - a universal billing project, general purpose, written in golang.  The project includes access via API, website, integration into accounting systems, reports and graphics. <br><br>  Initially, single-threaded systems were opened.  I had to choose between Erlang, Golang and Rust.  Golang was chosen as the main programming language because it is difficult to find Erlang programmers, although sustainability and hot-swappable code went to Erlang plus.  Rust, in spite of the formal lack of a race condition, is still more suitable not for writing applications, but for drivers and operating systems. <br><br>  Messaging between components of the system occurs not on the classic <a href="https://www.rabbitmq.com/getstarted.html">RabbitMQ</a> , but on <a href="https://www.nats.io/documentation/streaming/nats-streaming-intro/">NATS</a> - the latter showed benchmarks on the server that is currently used, 1M messages (+ 360K during clustering) per second against 40K for the hare.  Yes, and it is clustered faster and easier than RabbitMQ. <br><br>  Database: <a href="https://dev.mysql.com/doc/refman/8.0/en/mysql-innodb-cluster-userguide.html">MySQL InnoDB Сluster 7.6</a> (MySQL server 8.0).  Smartly make up and debug the community using the <a href="https://www.mysql.com/products/workbench/">MySQL Workbench</a> tool. <br><a name="habracut"></a><br>  API - written in <a href="https://swagger.io/">Swagger</a> (OpenAPI 2.0).  This avoids errors by different programmers, generates clean well-documented code and API documentation.  Unfortunately, Swagger uses <a href="https://github.com/gorilla/mux">gorilla / mux</a> by default for <a href="https://github.com/gorilla/mux">rooting</a> , but after generating the entire API, the routing will be redone to <a href="https://github.com/kataras/muxie">kataras / muxie</a> - it is twice as fast. <br><br>  Frontend: among the available frameworks: Iris, Beego and Revel - Revel is selected.  Slower than Iris, but everything is out of the box, including integration with graphics.  The main load will still be borne by the API. <br><br>  Scaling: all system components are assembled in LXC containers, as long as they are preceded by a <a href="http://www.haproxy.org/">HAProxy</a> balancer.  The idea of ​​scaling comes down to the fact that as the clients grow, they gradually move to more powerful servers while preserving the structure of containers, and later spread the container to separate servers, replacing HAProxy with NATS.  In addition to the classic hardware scaling, there is always the possibility to increase the amount of goroutine inside the containers handling requests to the API and the site.  Although this process, as practice has shown, has logical limitations. <br><br>  In general, the main idea of ​​the article and my deep conviction is that the initial architecture of highly loaded projects, in modern conditions, is pointless to build on single-threaded systems, despite their years of developed infrastructure and the availability of a large number of available programmers.  And the entire design of the project must be created initially by laying an easy transfer to a more powerful and distributed equipment.  This will allow in the future to easily find a balance between scaling the hardware and the code without multiplying the cost. <br><br>  The usual and most common mistake of new startups is a poor initial design of the architecture.  According to the principle - “we will quickly start writing, and then we'll figure it out.”  As a rule, later - this leads to the collapse of the project. <br><br>  As they say - "90% of success is training."  Do not be afraid to spend money initially on creating a competent, well-thought-out architecture - it will pay off a hundredfold. <br><br>  Good luck! </div>