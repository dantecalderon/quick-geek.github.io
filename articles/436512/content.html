<div class="post__text post__text-html js-mediator-article"><p>  Hi, Habr!  After plenty of rest after the long holidays, we are again ready to do you good by all available means.  There is always something to tell colleagues from the IT department, and today we are sharing with you the report by Alexander Prizov, Yandex.Money system administrator, from the JavaJam meeting. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/QpVS4mf4SJs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><blockquote>  How we built feedback flow to detect problem releases using Graphite and Moira.  We will tell you how to collect and analyze metrics about the number of errors in the application. </blockquote><a name="habracut"></a><br><p>  - Hello everyone, my name is Alexander Prizov, I work in the department of automation of operation in Yandex.Money, and today I will tell you about how we collect, process, analyze information about our system. </p><br><p>  You, probably, might have a question why the report is called The Second Way.  Everything is quite simple.  The basis of DevOps is a series of principles, which, arbitrarily, are divided into three groups. </p><br><p>  <strong>The first path</strong> is the flow principle.  <strong>The second path</strong> includes the principle of feedback.  <strong>The third way</strong> is continuous learning and experimentation. </p><br><p>  As a rule, in terms of the development and operation of software products, feedback means telemetry, which we collect about our system, and the most common case is the collection and processing of metrics. </p><br><p>  Why do we need these metrics?  With the help of metrics, we get feedback from the system and we can know what state our system is in, if everything is going well, how our changes have affected its work, and whether some kind of intervention is needed to solve certain problems. </p><br><h2 id="kakie-metriki-mysobiraem">  What metrics do we collect? </h2><br><p>  We collect metrics from three levels. </p><br><p>  <em>The business level</em> includes indicators that are interesting from the point of view of any business problems.  For example, we can get answers to questions such as how many users are registered with us, how often users log in to our system, how many active users are in our mobile application. </p><br><p>  The next level is <em>the application level</em> .  The metrics of this level are most often viewed by developers, because these indicators give an answer to the question of how well our application works, how quickly it processes requests, whether there is a drop in performance.  This includes the response time, the number of requests, the length of the queue, and much more. </p><br><p>  And finally, the <em>level of infrastructure</em> .  Here everything is clear.  Using these metrics, we can estimate the amount of resources consumed, how to predict them, and identify problems related to infrastructure. </p><br><p>  Now Iâ€™ll briefly describe how we send, process, and store these metrics.  Next to the application we have a metrics collector.  In our case, this is the Heka service, which listens on the UDP port and waits for the metrics in the StatsD format. </p><br><p>  The StatsD format looks like this: <br><img src="https://habrastorage.org/webt/le/81/nz/le81nz05apfzg1z55ruxwhaue_q.png"></p><br><p>  That is, we define the name of the metric, indicate the value of this metric, this is 1, 26, and so on, and indicate its type.  In total, StatsD has about four or five types.  If you are suddenly interested, you can see in detail the <a href="">description of these types</a> . </p><br><p><img src="https://habrastorage.org/webt/fn/vl/ma/fnvlma7zzczcko8ucurdce7dhew.png"></p><br><p>  After the application has sent the Heka data, the metrics are aggregated over time.  In our case, it is 30 seconds, after which Heka sends data to carbon-c-relay, which performs the filtering, routing, modification of metrics function, which, in turn, sends metrics to our storage, we use clickhouse (yes, it does not slow down ), as well as in Moira.  If anyone does not know, this is a service that allows you to configure certain triggers for metrics.  I will talk about Moira a little later.  So, we looked at what metrics we collect, how we send and process them.  And the next logical step is the analysis of these metrics. </p><br><h2 id="kak-myanaliziruem-metriki">  How do we analyze metrics? </h2><br><p>  I will give a real situation where the analysis of metrics has given us tangible results.  As an example, take our release process.  In general, it includes the following steps. </p><br><p><img src="https://habrastorage.org/webt/ob/my/pb/obmypbobncrdmgxutbxbetxom3o.png"></p><br><p>  The release is deployed to the canary host.  It accounts for about five percent of user traffic.  After the release to the canary host is completed, we notify the release manager that he should check if everything is fine with the release.  And he should give a reaction, react to this release and press the button with the decision about whether this release should be rolled further, or it should be rolled back. </p><br><p>  It is not difficult to guess that there is a significant drawback in this scheme, namely, that we expect the reaction of the responsible person.  If the person in charge is currently unable to react quickly for some reason, then if we have a release with bugs, then for some time five percent of the traffic comes to the problem node.  If the release is all right, then we simply spend time waiting, and thus slow down the release process. </p><br><blockquote>  No bugs - we slow down the release process <br>  With bugs - users affect </blockquote><p>  With an understanding of this problem, we decided to find out whether it is possible to automate the process of deciding whether a release is problematic or not. </p><br><p>  We, of course, turned to our developers to understand how the release check is performed.  It turned out, and it seems quite logical that the main indicator that the release is problematic, is the increase in the number of errors in the logs of this application. <br></p><br><p>  What did the developers do?  They opened Kibana, sampled the ERROR level of the application block, and in case they saw the lists, they thought that something was wrong with the application.  It is worth mentioning that the logs of our application are stored in Elastic, and it seems that everything looks quite simple.  We have logs in Elastic, we only need to form a request in Elastic, make a selection and understand, based on this data, whether the release is problematic or not.  But this solution seemed to us not very good. </p><br><h2 id="pochemu-neelastic">  Why not Elastic? </h2><br><p>  First of all, we were concerned that we could not promptly receive data from Elastic.  There are such cases, for example, during load testing, when we have a large flow of data, and the cluster can not cope, and, ultimately, there is a delay in sending logs of about 10-15 minutes. </p><br><p>  There were also secondary reasons, for example, the lack of a uniform name for indexes.  This had to be taken into account in the automation tool.  As well as applications on different platforms could have a different format of logs. </p><br><p>  We thought, why not try to make some metrics on the basis of which we can decide whether the release is problematic or not.  At the same time, we did not want to burden our developers to make changes to the code base.  And, as it seems to us, we found a rather elegant solution by adding an additional appender to log4j. </p><br><p>  <strong>What it looks like</strong> </p><br><pre><code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Configuration</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">status</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"warn"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"${sys:application.name}"</span></span></span><span class="hljs-tag"> &gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Properties</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"logsCountStatsDFormat"</span></span></span><span class="hljs-tag">&gt;</span></span>app_name.logs.%level:1|c<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Property</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Properties</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Appenders</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Socket</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"STATSD"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">host</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"127.0.0.1"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">port</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"8125"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">protocol</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"UDP"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PatternLayout</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">pattern</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"${logsCountStatsDFormat}"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Socket</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Appenders</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Loggers</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Root</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">level</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"INFO"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">AppenderRef</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ref</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"STATSD"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Root</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Loggers</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Configuration</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  First we define the format of the metric that we send.  The following describes an additional appender that sends entries in the format that we have indicated above to port 8125 via UDP, that is, to Heka.  What does this give us?  Log4j for each record in the log sends a Counter type metric, with a given record level of ERROR, INFO, WARN, and so on. </p><br><p>  However, we quickly realized that sending metrics to each record in the logs can create quite a significant load, and we wrote a library that aggregates the metrics for a certain time and sends the already aggregated metric to the Heka service.  Actually, we add this appender to loggers, and using this approach, we now know how much our application writes breakdown logs by levels, we have a unified name for metrics, regardless of which platform is used.  We can easily understand how many errors are in the application log.  And finally, we were able to automate the process of making a decision about a problem release. </p><br><h2 id="avtomatizaciya">  Automation </h2><br><p><img src="https://habrastorage.org/webt/ip/6j/ek/ip6jekzqqxrfswkbbwuvagplgqe.png"></p><br><p>  Instead of a manual check after release, we wait five minutes, after which we collect data on the number of entries in the application logs.  After we run the script, which, based on two samples, before the release and after, decides whether the release is problematic.  Thus, we have reduced the amount of time we spend on making a decision to five minutes. </p><br><p>  Apart from the fact that information about the number of errors in the logs is useful during the release, a pleasant bonus for us was that it is also useful during the operation.  So, for example, we can visualize the number of errors in the logs in Grafana and fix anomalous bursts in the application logs. </p><br><p><img src="https://habrastorage.org/webt/gy/16/mc/gy16mcxb5mwvi10zwrb8mbwnlwk.png"></p><br><p>  It uses a fairly simple mathematical model.  The green line is the number of errors in the application logs.  Dark red is the median multiplied by the coefficient of sensitivity.  In the case where the number of errors in the logs crosses the median, we trigger a trigger, when triggered, a notification is sent through Moira. </p><br><p><img src="https://habrastorage.org/webt/qz/eb/3o/qzeb3oasmipjyjyeapvo6vb7ody.png"></p><br><p>  As I promised, I will tell you a little about Moira, how it works.  We define the target metrics we want to observe.  This is the number of errors and the moving median, as well as the conditions under which this trigger will work, that is, when the number of errors in the logs exceeds the median multiplied by the sensitivity coefficient.  When the trigger is triggered, the developer receives a notification that an anomalous surge of errors has been detected in the application, and some action should be taken. </p><br><p><img src="https://habrastorage.org/webt/o7/da/bm/o7dabmq35xnknjkgkkxbjd6o2ak.png"></p><br><p>  What do we have in the end?  We have developed a general mechanism for all our backend-applications, which allow us to obtain information about the number of records in the logs of a given level.  Also, using the metrics about the number of errors in the application logs, we were able to automate the process of deciding whether a release is problematic or not.  They also wrote a library for log4j, which you can use if you want to try the approach I described.  Link to the library below. </p><br><p>  On this I have, perhaps, everything.  Thank. </p><br><h3 id="poleznye-ssylki">  useful links </h3><br><p>  <a href="http://github.com/yandex-money-tech/log4j-count-appender">Log4j-count-appender</a> <br>  <a href="https://moira.readthedocs.io/en/latest/">Moira</a> </p></div>