<div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/_8/cc/h0/_8cch0_nvkzgoi2u1vailg4oiio.png"></p><br><p>  <em>The topic of the article is quite focused, but it may be useful to those who are developing their own data warehouses and are thinking about integration with the Spring Framework.</em> </p><br><h3 id="predposylki">  Prerequisites </h3><br><p>  Developers usually do not like to change their habits (often, the list of habits includes frameworks).  When I started working with <a href="https://www.cuba-platform.com/">CUBA</a> , I did not have to learn too much of everything new, it was possible almost immediately to get actively involved in the work on the project.  But there was one thing that I had to sit on a bit longer - it was work with data. </p><a name="habracut"></a><br><p>  In Spring there are several libraries that can be used to work with the database, one of the most popular is <a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/">spring-data-jpa</a> , which in most cases makes it possible not to write SQL or JPQL.  You just need to create a special interface with methods that are named in a <a href="https://docs.spring.io/spring-data/data-commons/docs/current/reference/html/">special way,</a> and Spring will generate and perform for you the rest of the work on retrieving data from the database and creating instances of entity objects. </p><br><p>  Below is an interface with a method for counting customers with a given last name. </p><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomerRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrudRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Customer</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Long</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countByLastName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String lastName)</span></span></span></span>; }</code> </pre> <br><p>  This interface can be directly used in Spring services without creating any implementation, which greatly speeds up the work. </p><br><p>  CUBA has an API for working with data, which includes various functionality, such as partially loaded entities, or a clever security system with access control to entity attributes and rows in database tables.  But this API is a little different from what Spring Data or JPA / Hibernate developers are used to. </p><br><p>  Why is there no JPA repositories in CUBA and can I add them? </p><br><h3 id="rabota-s-dannymi-v-cuba">  Work with data in CUBA </h3><br><p>  CUBA has three main classes responsible for working with data: DataStore, EntityManager and DataManager. </p><br><p>  <a href="https://doc.cuba-platform.com/manual-latest/data_store.html">DataStore</a> is a high-level abstraction for any data storage: database, file system or cloud storage.  This API allows you to perform basic operations on data.  In most cases, developers do not need to work with the DataStore directly, except when developing their own storage, or if you need some very special access to the data in the storage. </p><br><p>  <a href="https://doc.cuba-platform.com/manual-latest/entityManager.html">EntityManager</a> - a copy of the well-known JPA EntityManager.  Unlike the standard implementation, it has special methods for working with <a href="https://doc.cuba-platform.com/manual-latest/views.html">CUBA views</a> , for "soft" (logical) deletion of data, as well as for working with <a href="https://doc.cuba-platform.com/manual-latest/query.html">queries in CUBA</a> .  As in the case of DataStore, in 90% of projects, the usual developer will not have to deal with the EntityManager, except in cases when you need to perform some queries to bypass the data access restriction system. </p><br><p>  DataManager is the main class for working with data in CUBA.  Provides an API for data manipulation and supports data access control, including access to attributes and row-level constraints.  DataManager implicitly modifies all queries that are executed in CUBA.  For example, it can exclude table fields to which the current user does not have access from the <code>select</code> statement and add <code>where</code> clauses to exclude table rows from the selection.  And it makes life much easier for developers, because you don’t have to think about how to write queries correctly, taking into account access rights, CUBA does this automatically based on data from the database service tables. </p><br><p>  Below is a diagram of the interaction of CUBA components that participate in data sampling through DataManager. </p><br><p><img src="https://habrastorage.org/webt/vy/e7/e1/vye7e1axlvkzuky3raw6an4ttl0.png"></p><br><p>  Using DataManager, you can relatively easily load entities and whole hierarchies of entities using CUBA views.  In its simplest form, the query looks like this: </p><br><pre> <code class="java hljs">dataManager.load(Customer.class).list();</code> </pre> <br><p>  As already mentioned, DataManager will filter out "logically deleted" records, remove forbidden attributes from the request, and also open and close the transaction automatically. </p><br><p>  But, when it comes to queries, it is more complicated, then JPQL has to be written in CUBA. </p><br><p>  For example, if you need to count clients with a given last name, as in the example from the previous section, you need to write something like this code: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Long </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countByLastName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String lastName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dataManager .loadValue(<span class="hljs-string"><span class="hljs-string">"select count(c) from sample$Customer c where c.lastName = :lastName"</span></span>, Long.class) .parameter(<span class="hljs-string"><span class="hljs-string">"lastName"</span></span>, lastName) .one(); }</code> </pre> <br><p>  or this: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Long </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countByLastName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String lastName)</span></span></span><span class="hljs-function"> </span></span>{ LoadContext&lt;Customer&gt; loadContext = LoadContext.create(Customer.class); loadContext .setQueryString(<span class="hljs-string"><span class="hljs-string">"select c from sample$Customer c where c.lastName = :lastName"</span></span>) .setParameter(<span class="hljs-string"><span class="hljs-string">"lastName"</span></span>, lastName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dataManager.getCount(loadContext); }</code> </pre> <br><p>  In the CUBA API, you need to pass the JPQL expression as a string (the Criteria API is not yet supported), this is a readable and understandable way to create queries, but debugging such queries can bring many fun minutes.  In addition, JPQL strings are not verified by either the compiler or the Spring Framework during container initialization, which leads to errors only in Runtime. </p><br><p>  Compare this with Spring JPA: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomerRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrudRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Customer</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Long</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countByLastName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String lastName)</span></span></span></span>; }</code> </pre> <br><p>  The code is three times shorter, and no lines.  In addition, the method name <code>countByLastName</code> checked during the Spring initialization of the container.  If a typo is made and you write <code>countByLastNsme</code> , then the application will crash with an error during deployment: </p><br><pre> <code class="plaintext hljs">Caused by: org.springframework.data.mapping.PropertyReferenceException: No property LastNsme found for type Customer!</code> </pre> <br><p>  CUBA is built around the Spring Framework, so you can plug in the spring-data-jpa library to an application written using CUBA, but there is a small problem - access control.  Implementing CrudRepository in Spring uses its EntityManager.  Thus, all queries will be bypassed by the DataManager.  Thus, to use JPA repositories in CUBA, you need to replace all EntityManager calls with DataManager calls and add support for CUBA views. </p><br><p>  Someone might say that spring-data-jpa is such an uncontrollable black box and it is always preferable to write pure JPQL or even SQL.  This is the eternal problem of the balance between convenience and level of abstraction.  Everyone chooses the way that they prefer, but to have an additional way to work with data in the arsenal will never hurt.  And for those who need more control, in Spring <a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/">there is a way to define your own query</a> for JPA methods of repositories. </p><br><h2 id="realizaciya">  Implementation </h2><br><p>  JPA repositories are implemented as a CUBA module, using the <a href="https://docs.spring.io/spring-data/data-commons/docs/current/reference/html/">spring-data-commons</a> library.  We abandoned the idea of ​​modifying spring-data-jpa because the amount of work would be much larger compared to writing our own query generator.  Especially since spring-data-commons does most of the work.  For example, parsing a method name and associating a name with classes and properties is done entirely in this library.  Spring-data-commons contains all the necessary base classes for implementing your own repositories and it takes not so much effort to implement it.  For example, this library is used in <a href="https://docs.spring.io/spring-data/mongodb/docs/current/reference/html/">spring-data-mongodb</a> . </p><br><p>  The most difficult thing was to accurately implement JPQL generation based on a hierarchy of objects — the result of parsing the method name.  But, fortunately, Apache Ignite has already implemented a similar task, so the code was taken from there and slightly adapted for generating JPQL instead of SQL and supporting the <code>delete</code> operator. </p><br><p>  In spring-data-commons, proxying is used to dynamically create interface implementations.  When the context of a CUBA application is initialized, all references to interfaces are replaced with references to proxies published in the context.  When calling an interface method, it is intercepted by the corresponding proxy object.  Then this object generates a JPQL query by the method name, inserts the parameters and sends the query with the parameters in the DataManager for execution.  The following diagram shows a simplified process for the interaction of key components of a module. </p><br><p><img src="https://habrastorage.org/webt/zh/cd/1l/zhcd1lasrsrz4vwcedkgtnsiz2m.png"></p><br><h2 id="ispolzovanie-repozitoriev-v-cuba">  Using repositories in CUBA </h2><br><p>  To use the repositories in CUBA, you just need to connect the module in the project assembly file: </p><br><pre> <code class="plaintext hljs"> appComponent("com.haulmont.addons.cuba.jpa.repositories:cuba-jpa-repositories-global:0.1-SNAPSHOT")</code> </pre> <br><p>  You can use the XML configuration to "enable" repositories: </p><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">beans:beans</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:beans</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:context</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://www.springframework.org/schema/context"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:repositories</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://www.cuba-platform.org/schema/data/jpa"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.cuba-platform.org/schema/data/jpa http://www.cuba-platform.org/schema/data/jpa/cuba-repositories.xsd"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!-- Annotation-based beans --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">context:component-scan</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">base-package</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.company.sample"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">repositories:repositories</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">base-package</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.company.sample.core.repositories"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">beans:beans</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  And you can use the annotations: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableCubaRepositories</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//Configuration here }</span></span></code> </pre> <br><p>  After the repository support is activated, you can create them as usual, for example: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomerRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CubaJpaRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Customer</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UUID</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countByLastName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String lastName)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">List&lt;Customer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByNameIsIn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;String&gt; names)</span></span></span></span>; <span class="hljs-meta"><span class="hljs-meta">@CubaView</span></span>(<span class="hljs-string"><span class="hljs-string">"_minimal"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@JpqlQuery</span></span>(<span class="hljs-string"><span class="hljs-string">"select c from sample$Customer c where c.name like concat(:name, '%')"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;Customer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByNameStartingWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span></span>; }</code> </pre> <br><p>  For each method, you can use annotations: </p><br><ul><li>  <code>@CubaView</code> - to set the CUBA view to be used in DataManager </li><li>  <code>@JpqlQuery</code> - to set the JPQL query to be executed, regardless of the method name. </li></ul><br><p>  This module is used in the CUBA <code>global</code> framework module; therefore, you can use repositories both in the <code>core</code> module and in the <code>web</code> .  The only thing you need to remember is to activate the repositories in the configuration files of both modules. </p><br><p>  An example of using the repository in the CUBA service: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span>(CustomerService.NAME) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomerServiceBean</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CustomerRepository customerRepository; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Date&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCustomersBirthDatesByLastName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> customerRepository.findByNameStartingWith(name) .stream().map(Customer::getBirthDate).collect(Collectors.toList()); } }</code> </pre> <br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>  CUBA is a flexible framework.  If you want to add something to it, then there is no need to fix the kernel yourself or wait for the new version.  I hope that this module will make development with CUBA more efficient and faster.  The first version of the module is available on <a href="https://github.com/cuba-rnd/cuba-jpa-repositories">GitHub</a> , tested on CUBA version 6.10 <br></p></div>