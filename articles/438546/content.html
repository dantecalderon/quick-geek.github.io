<div class="post__text post__text-html js-mediator-article">  Many Node.js developers use modules (only) to create hard dependencies using require (), but there are other approaches with their own advantages and disadvantages.  I will tell about them in this article.  Four approaches will be considered: <br><br><ul><li>  Hard dependencies (require ()) </li><li>  Dependency Injection </li><li>  Service Locators </li><li>  Inventory Dependency Containers (DI Container) </li></ul><a name="habracut"></a><br><h4>  Little about modules </h4><br>  Modules and modular architecture are the foundation of Node.js.  Modules provide encapsulation (hiding implementation details and opening only the interface using module.exports), code reuse, logical code breaking into code.  Almost all Node.js applications consist of a set of modules that must interact in some way.  If it is wrong to connect modules or to let the interaction of modules take place completely, then you can very quickly find that the application begins to “collapse”: code changes in one place lead to breakdowns in another, and unit testing becomes simply impossible.  Ideally, modules should have high <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D1%2586%25D0%25B5%25D0%25BF%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_(%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">coupling</a> , but low <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D1%2586%25D0%25B5%25D0%25BF%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_(%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">coupling</a> . <br><br><h2>  Hard dependencies </h2><br>  Hard dependence of one module on another arises when using require ().  This is an effective, simple and common approach.  For example, we just want to connect the module responsible for interacting with the database: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ourModule.js const db = require('db'); // Работа с базой данных...</span></span></code> </pre> <br><h4>  Pros: </h4><br><ul><li>  Simplicity </li><li>  Visual organization of modules </li><li>  Easy debugging </li></ul><br><h4>  Minuses: </h4><br><ul><li>  Difficulty in reusing a module (for example, if we want to reuse our module, but with a different DB instance) </li><li>  Difficulty for unit testing (you have to create a dummy instance of the database and somehow transfer it to the module) </li></ul><br><h4>  Summary: </h4><br>  The approach is good for small applications or prototypes, as well as for connecting stateless modules: factories, constructors, and feature sets. <br><br><h2>  Dependency Injection </h2><br>  The main idea of ​​dependency injection is to transfer a dependency module from an external component.  Thus, the hard dependency in the module is eliminated and it becomes possible to reuse it in different contexts (for example, with different database instances). <br><br>  Dependency injection can be done by passing dependencies in the constructor argument or by setting the properties of the module, but in practice it is better to use the first method.  Let's apply dependency injection in practice by creating a database instance using a factory and passing it to our module: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ourModule.js module.exports = (db) =&gt; { // Инициализация модуля с переданным экземпляром базы данных... };</span></span></code> </pre> <br>  External module: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dbFactory = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'db'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> OurModule = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./ourModule.js'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dbInstance = dbFactory.createInstance(<span class="hljs-string"><span class="hljs-string">'instance1'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ourModule = OurModule(dbInstance);</code> </pre> <br>  Now we can not only re-use our module, but also easily write a unit test for it: it is enough to create a mock object of the database instance and transfer it to the module. <br><br><h4>  Pros: </h4><br><ul><li>  Ease of writing unit tests </li><li>  Increase in "reusability" of modules </li><li>  Reduced gearing, increased connectivity </li><li>  Shifting responsibility for creating dependencies to a higher level - often this improves the readability of the program, since important dependencies are collected in one place and not spread over modules </li></ul><br><h4>  Minuses: </h4><br><ul><li>  The need for a more thorough design of dependencies: for example, a certain order of initialization of modules must be observed </li><li>  The complexity of managing dependencies, especially when there are many </li><li>  Impaired module code clarity: it is more difficult to write module code when a dependency comes in from the outside, because we cannot directly look at this dependency. </li></ul><br><h4>  Summary: </h4><br>  Dependency injection increases the complexity and size of the application, but instead gives reusability and facilitates testing.  The developer should decide what is more important for him in a particular case - the simplicity of a hard dependency or wider possibilities of dependency injection. <br><br><h2>  Service Locators </h2><br>  The idea is to have a dependency registry, which acts as an intermediary when loading a dependency with any module.  Instead of hard binding, dependencies are requested by the module from the service locator.  Obviously, modules have a new dependency - the service locator itself.  An example of a service locator is the Node.js module system: modules request a dependency using require ().  In the following example, we will create a services locator, register instances of the database and our module in it. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// serviceLocator.js const dependencies = {}; const factories = {}; const serviceLocator = {}; serviceLocator.register = (name, instance) =&gt; { //[2] dependencies[name] = instance; }; serviceLocator.factory = (name, factory) =&gt; { //[1] factories[name] = factory; }; serviceLocator.get = (name) =&gt; { //[3] if(!dependencies[name]) { const factory = factories[name]; dependencies[name] = factory &amp;&amp; factory(serviceLocator); if(!dependencies[name]) { throw new Error('Cannot find module: ' + name); } } return dependencies[name]; };</span></span></code> </pre> <br>  External module: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> serviceLocator = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./serviceLocator.js'</span></span>)(); serviceLocator.register(<span class="hljs-string"><span class="hljs-string">'someParameter'</span></span>, <span class="hljs-string"><span class="hljs-string">'someValue'</span></span>); serviceLocator.factory(<span class="hljs-string"><span class="hljs-string">'db'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'db'</span></span>)); serviceLocator.factory(<span class="hljs-string"><span class="hljs-string">'ourModule'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'ourModule'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ourModule = serviceLocator.get(<span class="hljs-string"><span class="hljs-string">'ourModule'</span></span>);</code> </pre> <br>  Our module: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ourModule.js module.exports = (serviceLocator) =&gt; { const db = serviceLocator.get('db'); const someValue = serviceLocator.get('someParameter'); const ourModule = {}; // Инициализация модуля, работа с БД... return ourModule; };</span></span></code> </pre> <br>  It should be noted that the service locator stores service factories instead of instances, and this makes sense.  We got the advantages of “lazy” initialization, moreover, now we can not care about the order of initialization of modules - all modules will be initialized when it is needed.  Plus, we were able to store parameters in the service locator (see someParameter). <br><br><h4>  Pros: </h4><br><ul><li>  Ease of writing unit tests </li><li>  Module reuse is easier than with hard dependency. </li><li>  Reduced engagement, increased connectivity compared to hard dependency </li><li>  Shifting responsibility for creating dependencies to a higher level </li><li>  There is no need to follow the module initialization order </li></ul><br><h4>  Minuses: </h4><br><ul><li>  Module reuse is more complicated than with dependency injection (due to the additional service locator dependency) </li><li>  Readability: it's even harder to understand what the dependency required by the service locator does </li><li>  Increased engagement compared to dependency injection </li></ul><br><h4>  Summary </h4><br>  In general, the service locator is similar to dependency injection, in some ways it is easier (there is no initialization order), in some cases it is more complicated (less possibility to reuse code). <br><br><h2>  Inventory Dependency Containers (DI Container) </h2><br>  The service locator has a flaw because of which it is rarely used in practice - the dependence of the modules on the locator itself.  Containers of implemented dependencies (DI-containers) are free from this drawback.  In essence, this is the same service locator with an additional function that determines the dependencies of a module before creating its instance.  You can determine the dependencies of a module by parsing and extracting arguments from the module's constructor (in JavaScript, you can cast a function reference to a string using toString ()).  This method is suitable if the development is purely for the server.  If client code is written, then it is often minified and it will be meaningless to extract the argument names.  In this case, the list of dependencies can be transferred by an array of strings (in Angular.js, based on the use of DI-containers, this is the approach that is used).  Implement a DI container using parsing constructor arguments: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fnArgs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'parse-fn-args'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dependencies = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> factories = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> diContainer = {}; diContainer.factory = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, factory</span></span></span><span class="hljs-function">) =&gt;</span></span> { factories[name] = factory; }; diContainer.register = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, dep</span></span></span><span class="hljs-function">) =&gt;</span></span> { dependencies[name] = dep; }; diContainer.get = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!dependencies[name]) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> factory = factories[name]; dependencies[name] = factory &amp;&amp; diContainer.inject(factory); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!dependencies[name]) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Cannot find module: '</span></span> + name); } } diContainer.inject = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">factory</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> args = fnArgs(factory) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dependency</span></span></span><span class="hljs-function"> =&gt;</span></span> diContainer.get(dependency)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> factory.apply(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, args); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dependencies[name]; };</code> </pre> <br>  Compared to the service locator, the inject method has been added, which determines the dependencies of the module before creating its instance.  The code of the external module has not changed: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> diContainer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./diContainer.js'</span></span>)(); diContainer.register(<span class="hljs-string"><span class="hljs-string">'someParameter'</span></span>, <span class="hljs-string"><span class="hljs-string">'someValue'</span></span>); diContainer.factory(<span class="hljs-string"><span class="hljs-string">'db'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'db'</span></span>)); diContainer.factory(<span class="hljs-string"><span class="hljs-string">'ourModule'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'ourModule'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ourModule = diContainer.get(<span class="hljs-string"><span class="hljs-string">'ourModule'</span></span>);</code> </pre> <br>  Our module looks exactly the same as with simple dependency injection: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ourModule.js module.exports = (db) =&gt; { // Инициализация модуля с переданным экземпляром базы данных... };</span></span></code> </pre> <br>  Now our module can be called either using the DI container, or by passing the necessary dependency instances directly to it using simple dependency injection. <br><br><h4>  Pros: </h4><br><ul><li>  Ease of writing unit tests </li><li>  Easy module reuse </li><li>  Reduced engagement, increased module connectivity (especially when compared to a service locator) </li><li>  Shifting responsibility for creating dependencies to a higher level </li><li>  There is no need to follow the module initialization order. </li></ul><br><h4>  The biggest minus: </h4><br><ul><li>  Significant complication of module linking logic </li></ul><br><h4>  Summary </h4><br>  This approach is more difficult to understand and contains a bit more code, but it is worth the time spent on it because of its power and elegance.  In small projects, this approach may be redundant, but it should be considered if a large application is being designed. <br><br><h2>  Conclusion </h2><br>  The main approaches to linking modules in Node.js were considered.  As is usually the case, there is no “silver bullet”, but the developer should be aware of the possible alternatives and choose the most suitable solution for each specific case. <br><br>  The article is based on a chapter from the <a href="https://www.labirint.ru/books/599022/">Node.js Design Patterns</a> book published in 2017.  Unfortunately, many things in the book are already outdated, so I can not 100% recommend it for reading, but some things are still relevant today. </div>