<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How we overclocked the work with the parameters of the configuration of the frontal system</title>
  <meta name="description" content="Hi, Habr! My name is Sergey Lezhnin, I am a senior architect in Sbertech. One of the directions of my work is the Unified Frontal System. In this syst...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>How we overclocked the work with the parameters of the configuration of the frontal system</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr!  My name is Sergey Lezhnin, I am a senior architect in Sbertech.  One of the directions of my work is the Unified Frontal System.  In this system there is a service for managing configuration parameters.  It is used by many users, services and applications, which requires high performance.  In this post I will tell you how this service evolved from the first, simplest, to its current version, and why we eventually deployed the entire architecture 180 degrees. <br><br><img src="https://habrastorage.org/webt/pk/zu/rp/pkzurprn4lbofwkn2dfrayv34di.jpeg"><br><a name="habracut"></a><br>  This is where we started - this is the first implementation of the parameter management service: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9b3/251/771/9b3251771f856c6f1c7234e042c3a2c3.png"><br><br>  The client requests configuration parameters from the service.  The service translates the request to the database, receives the response and returns it to the client.  In parallel, administrators can control the parameters using their own service: add new values, change current ones. <br><br>  The advantage of this approach is one - simplicity.  More disadvantages, even though they are all related: <br><br><ul><li>  frequent access to the repository over the network, <br></li><li>  high competition of access to the database (it is located on one node), <br></li><li>  insufficient performance. <br></li></ul><br>  To undergo load testing, this architecture had to provide a load of no more than that which goes through a direct access to the database.  As a result, the load testing of this circuit failed. <br><br>  Stage two: we decided to cache the data on the service side. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e7c/51d/867/e7c51d8670edf3a14e641c5158c40975.png"><br><br>  Here, the data is initially loaded into the shared cache upon request and returned from the cache upon subsequent requests.  The service administrator not only manages the data, but also marks it in the cache so that it will be updated when changed. <br><br>  So we reduced the number of calls to the repository.  At the same time, data synchronization turned out to be simple, since the administrator service has access to the cache in memory and manages the reset of parameters.  On the other hand, if a network failure occurs, the client will not be able to get the data.  And in general, the logic of obtaining data becomes more complicated: if the data is not in the cache, you need to get it from the database, put it in the cache, and then return it.  It is necessary to develop further. <br><br>  The third stage of development is client-side data caching: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc7/c76/873/cc7c76873ed1f3ea9524e244f04f4e1e.png"><br><br>  The client has a shell for accessing the service (‚Äúclient module‚Äù), which hides the local data cache.  If you do not find the required data in the cache, the service is accessed.  The service requests parameters from the database and returns them.  Compared to the previous scheme, caching management is complicated here.  In order to reset the parameters, the service must inform the customers that a change has occurred in these parameters. <br><br>  In this architecture, we reduce the number of calls to the service and to the database.  Now, if the parameter is already requested, it will return to the client without accessing the network, even if the service or database is not available.  On the other hand, the big minus is that the logic of data exchange with the client becomes complicated, it is necessary to notify him additionally through some service - for example, the message queue.  The client must subscribe to the topic, he receives notification of changes in the parameters, and in his cache, the client must reset them to get new values.  Quite a complicated scheme. <br><br>  Finally, we come to the last stage at the moment.  This helped us the basic principles formulated in Reactive Manifesto. <br><br><ul><li>  Responsive: the system responds as quickly as possible. <br></li><li>  Resilient: the system continues to respond even in the event of a failure. <br></li><li>  Elastic: the system uses resources according to the load. <br></li><li>  Message Driven: provides asynchronous and free messaging between system components. <br></li></ul><br>  The scheme corresponding to this approach turned out to be quite simple: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f1e/302/480/f1e3024800a86896bd690104311ad134.png"><br><br>  The general principle is as follows: the client subscribes to the configuration parameter, and when its values ‚Äã‚Äãchange, the server notifies the client about it.  The scheme above is slightly simplified: it does not reflect that when a client signs up, he needs to initialize and get the initial value.  But then there is the main thing in it: the arrows changed direction.  Previously, the client or cache actively requested the service to change data, and now the service itself transmits data change events, and they are updated from the client. <br><br>  This architecture has several important advantages.  The number of calls to the service and storage is reduced, because the client is not actively requesting it.  In fact, the call for each desired parameter occurs only once, when subscribing to it.  The client then simply receives the stream of changes.  The availability of data increases because the client always has a value ‚Äî it is cached.  On the whole, this parameter exchange scheme is quite simple. <br><br>  The only drawback of such an architecture is uncertainty during initialization of data.  Until the first subscription update was made, the value of the parameter remains undefined.  But this can be solved by setting the client default values ‚Äã‚Äãof the parameters, which are replaced by the actual ones at the first update. <br><br><h2>  Technology selection </h2><br>  Having approved the scheme, we began to search for products for its implementation.  <a href="https://vertx.io/">Choose</a> between <a href="https://vertx.io/">Vertx.io</a> , <a href="https://akka.io/">Akka.io</a> and <a href="http://spring.io/projects/spring-boot">Spring Boot</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f62/9fe/d44/f629fed442892d5b43a6466e73e4c288.png"><br><br>  The table summarizes the characteristics we were interested in.  Vertx and Akka have actors, while Sping Boot has a microservice library that is essentially close to the actors.  Similarly, with reactivity: Spring Boot has its own WebFlux library that implements the same features.  Lightness, we estimated approximately within the table.  As for languages, Vertx is considered polyglot of the three options: it supports both Java, and Scala, and Kotlin, and JavaScript.  Akka has Scala and Java;  Kotlin, probably, can also be used, but there is no direct support.  Spring has Java, Kotlin and Groovy. <br><br>  As a result, Vertx won.  By the way, they talked a lot about him at the JUG conference, and indeed many companies use it.  Here is a screenshot from the developer's site: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cfd/5e1/927/cfd5e19271c2d28809e43208b4566237.png"><br><br>  On Vertx.io, the implementation of our solution is as follows: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f63/ab8/99f/f63ab899fb017bf113925eedce617632.png"><br><br>  We decided to store the parameters not in the database, but in the Git-repository.  We can easily use this relatively slow data source due to the fact that the client does not actively request parameters and the number of hits decreases. <br><br>  A reader (verticle) reads data from a Git repository into the memory of an application to speed up user access to data.  This is important, for example, when subscribing to parameters.  In addition, the reader processes updates ‚Äî rereads and marks data, replaces old data with new ones. <br><br>  Event Bus is a Vertx service that sends events between verticals, as well as outside, through bridges.  Including through the websocket-bridge, which is used in this case.  When parameter change events arrive, the Event Bus sends them to the client. <br><br>  Finally, on the client side, a simple web client is implemented here that subscribes to events (parameter changes) and displays these changes on the pages. <br><br><h2>  How things work </h2><br>  We show how everything works through a web application. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/VaBtM07AN9Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Launch the application page in the browser.  Subscribe to change data by key.  Then we go to the project page in the local GitLab, change the data in JSON format and save it to the repository.  The application displays the corresponding change, which is what we needed. <br><br>  That's all.  You can find the source code of the demo in my <a href="https://github.com/slezhnin/sodium">git repository</a> , and ask questions in the comments. </div><p>Source: <a href="https://habr.com/ru/post/438144/">https://habr.com/ru/post/438144/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>