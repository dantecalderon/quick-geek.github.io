<div class="post__text post__text-html js-mediator-article"><p>  This is the story of integrating the BEM methodology into the React universe.  The material that you read is built on the experience of Yandex developers developing the largest and most loaded service in Russia - Yandex.Search.  We have never before told in such detail and deeply about why we did it this way and not otherwise, what moved us and what we really wanted.  The external person got dry releases and reviews at conferences.  Only on the sidelines could you hear something similar.  As a coauthor, I was indignant because of the paucity of information outside each time I talked about new versions of libraries.  But this time we will share all the details. </p><br><img src="https://habrastorage.org/webt/wb/mt/xc/wbmtxcvurtd6cdv1aomjrtcyfw8.png"><br><p>  Everyone has heard of the BEM methodology.  Underline CSS selectors.  <a href="https://en.bem.info/methodology/key-concepts/">Component approach</a> , which is said, referring to the way of writing CSS-selectors.  But about the CSS in the article will not be a word.  Only JS, only hardcore! </p><a name="habracut"></a><br><p>  To understand why the methodology appeared and what problems Yandex faced then, I recommend that you <a href="https://en.bem.info/methodology/history/">familiarize yourself with the history of</a> BEM. </p><br><h2 id="prolog">  Prologue </h2><br><p> BEM really was born as a salvation from strong connectivity and nesting in CSS.  But dividing the <code>style.css</code> sheet into files for each block, element, or modifier inevitably led to a similar structuring of JavaScript code. </p><br><p>  In 2011, Open Source acquired the <a href="https://github.com/bem/bem-bl/commit/d7face465663ab5e9c77501edbfd2016e90bf75a">first commits of the</a> <a href="https://en.bem.info/technologies/classic/i-bem/"><code>i-bem.js</code></a> , which worked in conjunction with <a href="https://en.bem.info/technologies/classic/bem-xjst/8/"><code>bem-xjst</code></a> templating engine.  Both technologies grew out of <a href="https://en.wikipedia.org/wiki/XSLT">XSLT</a> and served as a popular idea at the time to separate business logic and component presentation.  In the outside world, these were the <a href="https://code.tutsplus.com/tutorials/best-practices-when-working-with-javascript-templates--net-28364">beautiful times of</a> Handlebars and Underscore. </p><br><p>  <code>bem-xjst</code> - another type of template engine.  In order to supplement the knowledge about the architecture of approaches to standardization, I strongly recommend the <a href="https://www.youtube.com/watch%3Fv%3DVwzcEEAfNCs">report of Sergey Berezhnoy</a> .  <code>bem-xjst</code> can try the <code>bem-xjst</code> template engine in the <a href="https://bit.ly/2S3uLIe">online sandbox</a> . </p><br><p>  Due to the specifics of Yandex search services, user interfaces are built according to data.  The search results page is unique for each query. </p><br><p><img src="https://habrastorage.org/webt/6g/af/sc/6gafsczppz4ul8glzeliauwnkjc.png"><br>  <em>Search query by <a href="https://yandex.ru/search/%3Ftext%3D%25D0%25B1%25D0%25BE%25D0%25B5%25D0%25B2%25D0%25B8%25D0%25BA%25D0%25B8%26lr%3D213">reference</a></em> </p><br><p><img src="https://habrastorage.org/webt/ni/z5/nc/niz5ncgv3rlci2jfymornobfvcy.png"><br>  <em>Search query by <a href="https://yandex.ru/search/%3Ftext%3D%25D1%2586%25D0%25B2%25D0%25B5%25D1%2582%2520%25D1%2582%25D0%25B2%25D0%25B8%25D1%2582%25D1%2582%25D0%25B5%25D1%2580%25D0%25B0%26lr%3D213">reference</a></em> </p><br><p><img src="https://habrastorage.org/webt/eb/6q/ws/eb6qws6vwtclkce_jsumewy4jkk.png"><br>  <em>Search query by <a href="https://yandex.ru/search/%3Ftext%3D%25D1%2580%25D0%25B5%25D1%2586%25D0%25B5%25D0%25BF%25D1%2582%2520%25D1%2580%25D0%25BE%25D1%2581%25D1%2582%25D0%25B1%25D0%25B8%25D1%2584%25D0%25B0%26lr%3D213">reference</a></em> </p><br><p>  When the division into a block, an element and a modifier spread to the file system, this allowed us to efficiently collect only the necessary code, in fact, for each page, for every user request.  But how? </p><br><pre> <code class="plaintext hljs">src/components ├── ComponentName │ ├── _modName │ │ ├── ComponentName_modName.tsx — простой модификатор │ │ └── ComponentName_modName_modVal.tsx — модификатор со значением │ ├── ElementName │ │ └── ComponentName-ElementName.tsx — элемент блока ComponentName │ ├── ComponentName.i18n — файлы переводов │ │ ├── ru.ts — словарь для русского языка │ │ ├── en.ts — словарь для английского языка │ │ └── index.ts — словарь используемых языков │ ├── ComponentName.test — файлы тестов │ │ ├── ComponentName.page-object.js — Page Object │ │ ├── ComponentName.hermione.js — функциональный тест │ │ └── ComponentName.test.tsx — unit-тест │ ├── ComponentName.tsx — визуальное представление блока │ ├── ComponentName.scss — визуальные стили │ ├── ComponentName.examples.tsx — примеры компонента для Storybook │ └── README.md — описание компонента</code> </pre> <br><p>  <em>Modern component directory structure</em> </p><br><p>  As in some other companies, in Yandex, interface developers are responsible for the frontend consisting of the client side of the browser and the server side of <code>Node.js</code>  The server part processes the data of a “large” search and imposes templates on them.  Primary data processing converts JSON to <a href="https://ru.bem.info/technologies/classic/bemjson/">BEMJSON</a> , the data structure for <code>bem-xjst</code> template engine.  Template engine bypasses each node of the tree and imposes a template on it.  Since the primary conversion takes place on the server and, due to the division into small entities, the nodes correspond to the files, with templating we push code to the browser that will be used only on the current page. </p><br><p>  Below is the correspondence of BEMJSON nodes to files on the file system. </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { <span class="hljs-attr"><span class="hljs-attr">block</span></span>: <span class="hljs-string"><span class="hljs-string">'Select'</span></span>, <span class="hljs-attr"><span class="hljs-attr">elem</span></span>: <span class="hljs-string"><span class="hljs-string">'Item'</span></span>, <span class="hljs-attr"><span class="hljs-attr">elemMods</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'navigation'</span></span> } };</code> </pre> <br><pre> <code class="plaintext hljs">src/components ├── Select │ ├── Item │ │ _type │ │ ├── Select-Item_type_navigation.js │ │ └── Select-Item_type_navigation.css</code> </pre> <br><p>  The modular system <a href="https://github.com/ymaps/modules"><code>YModules</code></a> was responsible for isolating the JavaScript code components in the browser.  It allows synchronous and asynchronous delivery of modules to the browser.  An example of how components work with <code>YModules</code> and <code>i-bem.js</code> <a href="https://github.com/bem/bem-components">can be found here</a> .  Today, for most developers <a href="https://webpack.js.org/concepts/modules/"><code>модульная система webpack</code></a> and the <a href="https://webpack.js.org/concepts/modules/"><code>модульная система webpack</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import">standard of dynamic imports do this</a> . </p><br><p>  A set of BEM methodology, declarative template engine and JS framework with a modular system allowed to solve any problem.  But over time, the dynamics came to the user interfaces. </p><br><h2 id="novaya-nadezhda">  New Hope </h2><br><p>  In 2013, <a href="https://reactjs.org/">React</a> came to the Open Source.  In fact, Facebook began to use it back in 2011.  James Long in his notes from the <a href="http://2013.jsconf.us/">JS Conf US</a> conference says: </p><br><blockquote>  The last two sessions were a surprise.  <a href="https://reactjs.org/">Facebook React</a> .  I think it is a bad idea.  Essentially, it lets you embed XML in JavaScript to create live reactive user interfaces.  XML.  In javascript. </blockquote><p>  React has changed the approach to designing web applications.  He has become so popular that today he cannot find a developer who would not hear about React.  But the important thing is different: applications have become different, <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D0%25B4%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BD%25D0%25B8%25D1%2587%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25B8%25D0%25BB%25D0%25BE%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">SPA</a> have come to our life. </p><br><p>  It is believed that the developers of Yandex have a special sense of beauty in terms of technology.  Sometimes strange, with which it is difficult to argue, but groundless - never.  When React scored <a href="https://github.com/facebook/react/stargazers">stars on GitHub</a> , many who were familiar with Yandex web technologies insisted: Facebook won, drop your crafts and run everything to rewrite to React before it is too late.  It is important to understand two things. </p><br><p>  First, there was no war.  Companies do not compete to create the best framework on Earth.  If a company starts spending less time (read money) on infrastructure tasks with the same productivity, everyone will benefit from it.  It makes no sense to write frameworks to write frameworks.  The best developers create tools that solve the company's problems in the best way.  Companies, services, goals - all this is different.  Hence the variety of tools. </p><br><p>  Secondly, we were looking for a way to apply React as we would like.  With all the features that our technology gave, as described above. </p><br><p>  Argued that the code using React default fast.  If you think so, then you are deeply mistaken.  The only thing React does is in most cases helping to optimally interact with the DOM. </p><br><p>  Up to version 16, React had a fatal flaw.  It was 10 times slower than <code>bem-xjst</code> on the server.  We could not afford such waste.  The response time for Yandex is one of the key metrics.  Imagine a query with a mulled wine recipe you will receive a response 10 times slower than usual.  You will not be satisfied with an excuse, even if you at least understand something in web development.  What to say about the explanation like "but the developers have become more convenient to communicate with the DOM."  Add to this the ratio of the price of implementation and profit - and you yourself will take the only right decision. </p><br><p>  Fortunately, whether to grief, the developers are strange people.  If something does not work, then this is not a reason to drop everything ... </p><br><h2 id="shivorot-navyvorot">  Inside out </h2><br><p>  We were confident that we could beat the slowness of React.  We already have a fast template engine.  All you need to do is generate HTML on the server using <code>bem-xjst</code> , and on the client, “force” React to accept this markup as your own.  The idea was so simple that nothing foretold failure. </p><br><p>  In versions up to 15 inclusive, React validated the accuracy of the markup through the hash sum — an algorithm that turns any optimization into a pumpkin.  To convince React of the validity of the markup, it was necessary to put an id on each node and calculate the hash sum of all the nodes.  It also meant support for a double set of templates: React for the client and <code>bem-xjst</code> for the server.  Simple speed tests with setting id made it clear that there is no point in continuing. </p><br><p>  The bem <code>bem-xjst</code> is a very undervalued tool.  Look at the <a href="https://www.youtube.com/watch%3Fv%3DskigiSOmkyQ">report of the main maintainer Glory Oliyanchuk</a> and <a href="https://www.youtube.com/watch%3Fv%3DskigiSOmkyQ">see for</a> yourself.  <code>bem-xjst</code> is based on an architecture that allows you to use the same template syntax for different transformations of the source tree.  Very similar to React, isn't it?  This feature today allows tools such as <a href="https://github.com/airbnb/react-sketchapp"><code>react-sketchapp</code></a> . </p><br><p>  Out of the box <code>bem-xjst</code> contains two types of transformations: in HTML and in JSON.  Any prudent developer can write his own template transformation engine for anything.  We taught <code>bem-xjst</code> transform a tree with data into a sequence of calls to <a href="https://github.com/hyperhype/hyperscript">HyperScript functions</a> .  That meant full compatibility with React, and with other implementations of the Virtual DOM algorithm, for example with <a href="https://preactjs.com/">Preact</a> . </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yPV6pcMdezM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <em>A detailed account of the approach to generating calls to HyperScript functions.</em> </p><br><p>  Since React templates assume the coexistence of layout and business logic, we had to bring logic from <code>i-bem.js</code> to our templates that were not intended for this.  For them it was unnatural.  They were going otherwise.  By the way! </p><br><p>  Below is an example from the depths of gluing different worlds in one runtime. </p><br><pre> <code class="javascript hljs">block(<span class="hljs-string"><span class="hljs-string">'select'</span></span>).elem(<span class="hljs-string"><span class="hljs-string">'menu'</span></span>)( def()(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> React = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'react'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Menu = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../components/menu/menu'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MenuItem = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../components/menu-item/menu-item'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _select = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ctx._select; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> selectComponent = _select._select; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> React.createElement.apply(React, [ Menu, { <span class="hljs-attr"><span class="hljs-attr">mix</span></span>: { <span class="hljs-attr"><span class="hljs-attr">block</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.block, <span class="hljs-attr"><span class="hljs-attr">elem</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elem }, <span class="hljs-attr"><span class="hljs-attr">ref</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">menu</span></span></span><span class="hljs-function"> =&gt;</span></span> selectComponent._menu = menu, <span class="hljs-attr"><span class="hljs-attr">size</span></span>: _select.mods.size, <span class="hljs-attr"><span class="hljs-attr">disabled</span></span>: _select.mods.disabled, <span class="hljs-attr"><span class="hljs-attr">mode</span></span>: _select.mods.mode, <span class="hljs-attr"><span class="hljs-attr">content</span></span>: _select.options, <span class="hljs-attr"><span class="hljs-attr">checkedItems</span></span>: _select.bindings.checkedItems, <span class="hljs-attr"><span class="hljs-attr">style</span></span>: _select.bindings.popupMenuWidth, <span class="hljs-attr"><span class="hljs-attr">onKeyDown</span></span>: _select.bindings.onKeyDown, <span class="hljs-attr"><span class="hljs-attr">theme</span></span>: _select.mods.theme, }].concat(_select.options.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">option</span></span></span><span class="hljs-function"> =&gt;</span></span> React.createElement( MenuItem, { <span class="hljs-attr"><span class="hljs-attr">onClick</span></span>: _select.bindings.onOptionCheck, <span class="hljs-attr"><span class="hljs-attr">theme</span></span>: _select.mods.theme, <span class="hljs-attr"><span class="hljs-attr">val</span></span>: option.value, }, option.content) )) ); }) );</code> </pre> <br><p>  Of course, we had our own build.  As you know, the fastest operation is a concatenation of strings.  It has a <code>bem-xjst</code> engine built on it, and an assembly was built on it.  Files of blocks, elements and modifiers lay in daddies, and the assembly only needed to glue the files together in the correct sequence.  With this approach, you can simultaneously glue together JS, CSS and templates, as well as the entities themselves.  That is, if you have four components in a project, there are four cores on a laptop, and the assembly of one component technology takes one second, then the project build will take two seconds.  Here it should become clearer how we manage to push only the necessary code into the browser. </p><br><p>  All this for us did <a href="https://ru.bem.info/toolbox/enb">ENB</a> .  We received the final tree for templating only at runtime, and since the dependency between the components should have arisen a bit earlier in order to assemble the bundles, the little-known <a href="https://ru.bem.info/technologies/classic/deps-spec"><code>deps.js</code></a> technology <a href="https://ru.bem.info/technologies/classic/deps-spec"><code>deps.js</code></a> this function.  It allowed to build a dependency graph between components, after which the builder could glue the code in the desired sequence, bypassing the graph. </p><br><p>  The work in this direction has been stopped by the release of React version 16. The execution speeds of templates on the server have <a href="https://github.com/awinogradov/xjst-benchmarks">become equal</a> .  At the production capacities, the difference became imperceptible. </p><br><p>  Node: <strong>v8.4.0</strong> <br>  Children: <strong>5K</strong> </p><br><table><thead><tr><th>  renderer </th><th>  mean time </th><th>  ops / sec </th></tr></thead><tbody><tr><td>  <strong>preact</strong> v8.2.6 </td><td>  66.235ms </td><td>  15 </td></tr><tr><td>  <strong>bem-xjst</strong> v8.8.4 </td><td>  71.326ms </td><td>  14 </td></tr><tr><td>  <strong>react</strong> v16.1.0 </td><td>  73.966ms </td><td>  14 </td></tr></tbody></table><br><p>  The links below can restore the history of the approach: </p><br><ul><li>  <a href="https://ru.bem.info/forum/961/">https://ru.bem.info/forum/961/</a> </li><li>  <a href="https://github.com/awinogradov/react-bl">https://github.com/awinogradov/react-bl</a> </li><li>  <a href="https://github.com/awinogradov/xjst-ddsl">https://github.com/awinogradov/xjst-ddsl</a> </li><li>  <a href="https://github.com/awinogradov/ddsl-react">https://github.com/awinogradov/ddsl-react</a> </li></ul><br><p>  Have we tried anything else? </p><br><ul><li>  <a href="https://github.com/veged/bem-components-react">https://github.com/veged/bem-components-react</a> - the first approach to the implementation of the methodology in React; </li><li>  <a href="https://github.com/Yeti-or/bem-hazard">https://github.com/Yeti-or/bem-hazard</a> is a similar approach based on the BH template engine.  With BH, by the way, you can play around online; </li><li>  <a href="https://github.com/dfilatov/bem-react">https://github.com/dfilatov/bem-react</a> - creating components via BEMJSON; </li><li>  <a href="https://github.com/rebem">https://github.com/rebem</a> - utilities for working with BEM in the world of React. </li></ul><br><p><img src="https://habrastorage.org/webt/uv/si/wt/uvsiwtsrexhffeuznrqhpxvtjva.png"></p><br><h2 id="motivaciya">  Motivation </h2><br><p>  In the middle of the story it will be useful to talk about what moved us.  It was worth doing it at the beginning, but - whoever remembers the old, will give that eye as a gift.  Why do we need all this?  What can BEM bring, what can't React do?  Questions that almost everyone asks. </p><br><h3 id="dekompoziciya">  Decomposition </h3><br><p>  The functionality of the components from year to year is complicated, and the number of variations increases.  This is expressed by <code>if</code> or <code>switch</code> constructions, as a result, the code base inevitably grows, as a result, the weight of the component and the project using such a component increase.  The main part of the React-component logic is enclosed in the <code>render()</code> method.  To change the functionality of a component, it is necessary to rewrite most of the method, which inevitably leads to an exponential increase in the number of highly specialized components. </p><br><p>  Everyone knows the <a href="https://material-ui.com/">material-ui</a> , <a href="https://developer.microsoft.com/en-us/fabric">fabric-ui</a> and <a href="https://github.com/react-bootstrap/react-bootstrap">react-bootstrap libraries</a> .  In general, all <a href="https://reactjs.org/community/ui-components.html">known libraries</a> with components have the same drawback.  Imagine that you have several projects and all use the same library.  You take the same components, but in different variations: there are selections with checkboxes, there are no, there are blue buttons with an icon, there are red ones without.  The weight of CSS and JS, which brings you the library, in all projects will be the same.  But why?  Component variations are embedded inside the component itself and are supplied with it, whether you like it or not.  For us, this is unacceptable. </p><br><p>  Yandex also has its own library with components - Lego.  Used in ~ 200 services.  Do we want the use of Lego in Search to be the same for Yandex.Health?  You know the answer. </p><br><h3 id="krossplatformennaya-razrabotka">  Cross Platform Development </h3><br><p>  To support multiple platforms, most often create either a separate version for each platform, or one adaptive one. </p><br><p>  Development of individual versions requires additional resources: the more platforms, the more effort.  Support for the synchronous state of product properties in different versions will cause new difficulties. </p><br><p>  The development of an adaptive version complicates the code, increases the weight, reduces the speed of the product with a proper difference between the platforms. </p><br><p>  Do we want our parents / friends / colleagues / children to use desktop versions on mobiles with lower internet speed and lower performance?  You know the answer. </p><br><h3 id="eksperimenty">  Experiments </h3><br><p>  If you are developing projects for a large audience, you must be confident in every change.  A / B experiments are one way to get this confidence. </p><br><p>  Ways to organize code for experiments: </p><br><ul><li>  fork of the project and creation of production service instances; </li><li>  point conditions inside the code base. </li></ul><br><p>  If the project has a lot of lengthy experiments, the codebase branching causes significant costs.  It is necessary to keep up every branch with the experiment: to port the corrected errors and product functionality.  The codebase branch multiplies complicates overlapping experiments. </p><br><p>  Point conditions work more flexibly, but complicate the code base: experimental conditions can affect different parts of a project.  A large number of conditions affects performance by increasing the amount of code for the browser.  We must remove the conditions, make the code basic, or completely remove the failed experiment. </p><br><p>  In Search ~ 100 experiments online in various combinations for different audiences.  You could see it for yourself.  Remember, maybe you noticed the functionality, and after a week it magically disappeared.  Do we want to test product theories at the cost of maintaining hundreds of branches of the active code base of 500,000 lines, which ~ 60 developers change every day?  You know the answer. </p><br><h3 id="globalnye-izmeneniya">  Global change </h3><br><p>  For example, you can create a <code>CustomButton</code> component inherited from <code>Button</code> from a library.  But the inherited <code>CustomButton</code> does not apply to all components from the library containing the <code>Button</code> .  The library may have a <code>Search</code> component built from <code>Input</code> and <code>Button</code> .  In this case, the inherited <code>CustomButton</code> will not appear inside the <code>Search</code> component.  Do we want to manually bypass the entire codebase where <code>Button</code> used? </p><br><p><img src="https://habrastorage.org/webt/po/7j/fg/po7jfgnxrawurvtkoi-3ch2wneu.jpeg"></p><br><h2 id="dolgaya-doroga-v-kompoziciyu">  Long road to composition </h2><br><p>  We decided to change the strategy.  In the previous approach, they took Yandex technology as a basis and tried to make React work on this basis.  New tactics suggested the opposite.  This is how <a href="https://github.com/bem/bem-react">the bem-react-core</a> project appeared. </p><br><blockquote>  Stop!  Why generally React? </blockquote><p>  We saw in it the opportunity to get rid of the explicit initial rendering in HTML and manual support of the state of the JS component later in runtime - in fact, it became possible to merge BEMHMTL templates and JS components into one technology. </p><br><h3 id="v100httpsgithubcombembem-reacttreev100">  <a href="">v1.0.0</a> </h3><br><p>  Initially, we planned to transfer all the best practices and <code>bem-xjst</code> to the library on top of React.  The first thing that catches your eye is the signature, or, if you prefer, the syntax of the component description. </p><br><p>  <em>What have you done, there is the JSX!</em> </p><br><p>  The first version was built on the basis of <a href="https://github.com/dfilatov/inherit">inherit</a> - a library that helps implement classes and inheritance.  As some of you remember, in those very times there were no classes in JavaScript prototypes in JavaScript, there were no <code>super</code> classes.  In general, they are still not there, or rather, these are not the classes that first come to mind.  <code>inherit</code> did everything that classes in the ES2015 standard can do now, and what is considered to be black magic: multiple inheritance and fusion of prototypes instead of rebuilding the chain, which has a positive effect on performance.  You won’t go wrong if you think it’s similar to the <a href="https://nodejs.org/docs/latest/api/util.html">inherits in Node.js</a> , but they work differently. </p><br><p>  Below is an example of the syntax of templates <code>bem-react-core@v1.0.0</code> . </p><br><p>  <strong>App-Header.js</strong> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { decl } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'bem-react-core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> decl({ <span class="hljs-attr"><span class="hljs-attr">block</span></span>: <span class="hljs-string"><span class="hljs-string">'App'</span></span>, <span class="hljs-attr"><span class="hljs-attr">elem</span></span>: <span class="hljs-string"><span class="hljs-string">'Header'</span></span>, <span class="hljs-attr"><span class="hljs-attr">attrs</span></span>: { <span class="hljs-attr"><span class="hljs-attr">role</span></span>: <span class="hljs-string"><span class="hljs-string">'heading'</span></span> }, content() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'я заголовок'</span></span>; } });</code> </pre> <br><p>  <strong>App-Header@desktop.js</strong> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { decl } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'bem-react-core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> decl({ <span class="hljs-attr"><span class="hljs-attr">block</span></span>: <span class="hljs-string"><span class="hljs-string">'App'</span></span>, <span class="hljs-attr"><span class="hljs-attr">elem</span></span>: <span class="hljs-string"><span class="hljs-string">'Header'</span></span>, <span class="hljs-attr"><span class="hljs-attr">tag</span></span>: <span class="hljs-string"><span class="hljs-string">'h1'</span></span>, attrs() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...this.__base(...arguments), <span class="hljs-string"><span class="hljs-string">'aria-level'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }, }, content() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`А </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.__base(...</span></span><span class="hljs-built_in"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-built_in">arguments</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string"> на десктопах превращаюсь в h1`</span></span>; } });</code> </pre> <br><p>  <strong>App-Header@touch.js</strong> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { decl } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'bem-react-core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> decl({ <span class="hljs-attr"><span class="hljs-attr">block</span></span>: <span class="hljs-string"><span class="hljs-string">'App'</span></span>, <span class="hljs-attr"><span class="hljs-attr">elem</span></span>: <span class="hljs-string"><span class="hljs-string">'Header'</span></span>, <span class="hljs-attr"><span class="hljs-attr">tag</span></span>: <span class="hljs-string"><span class="hljs-string">'h2'</span></span>, content() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`А </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.__base(...</span></span><span class="hljs-built_in"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-built_in">arguments</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string"> на тачах`</span></span>; } });</code> </pre> <br><p>  <strong>index.js</strong> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ReactDomServer <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-dom/server'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> AppHeader <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'b:App e:Header'</span></span>; ReactDomServer.renderToStaticMarkup(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">AppHeader</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">);</span></span></code> </pre> <br><p>  <strong>output@desktop.html</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"App-Header"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">role</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"heading"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">aria-level</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1"</span></span></span><span class="hljs-tag">&gt;</span></span>A я заголовок на десктопах превращаюсь в h1<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h2</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  <strong>output@touch.html</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h2</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"App-Header"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">role</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"heading"</span></span></span><span class="hljs-tag">&gt;</span></span>я заголовок на тачах<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h2</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  <em>The device templates of more complex components can be found <a href="https://github.com/bem/bem-react-components">here</a> .</em> </p><br><p>  Since the class is an object, and the most convenient way to work with objects in JavaScript is that the syntax is appropriate.  Later, the <a href="https://github.com/bem/bem-xjst/pull/497">syntax migrated</a> to its mastermind <code>bem-xjst</code> . </p><br><p>  The library was a global repository of object declarations - the results of the execution of the <code>decl</code> function, parts of entities: a block, element, or modifier.  BEM provides a unique naming mechanism and is therefore suitable for creating keys in the repository.  The final React component stuck together at its place of use.  The trick is that <code>decl</code> worked out when importing a module.  This made it possible to indicate which parts of the component are needed in each particular place, using a simple list of imports.  But remember: the components are complex, there are many parts, the list of imports is long, the developers are lazy. </p><br><h4 id="magiya-importov">  Import magic </h4><br><p>  As you can see, the code examples have <code>import AppHeader from 'b:App e:Header'</code> lines. </p><br><p>  <em>You broke the standard!</em>  <em>You can not do it this way!</em>  <em>It just won't work!</em> </p><br><p>  Firstly, the standard of imports does not use terms in the spirit of “in the import line there must be a path to a real-life module”.  Secondly, it is syntactic sugar, which was transformed with the help of Babel.  Third, strange punctuation constructs in imports for webpack <code>import txt from 'raw-loader!./file.txt';</code>  for some reason nobody was embarrassed. <br>  So, our unit is presented in two platforms: <code>desktop</code> , <code>touch</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Hello <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'b:Hello'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Запись будет трансформирована в следующее: var Hello = [ require('path/to/desktop/Hello/Hello.js'), require('path/to/touch/Hello/Hello.js') ][0].applyDecls();</span></span></code> </pre> <br><p> Здесь в коде произойдёт последовательный импорт всех определений компонента <code>Hello</code> , а затем вызов функции <code>applyDecls</code> , которая склеит все декларации блока из глобального хранилища через <code>inherit</code> и создаст новый, уникальный для конкретного места в проекте React-компонент. </p><br><p> Плагин для Babel, выполняющий такое преобразование, можно <a href="https://github.com/bem/babel-plugin-bem-import">найти здесь</a> . А лоадер для webpack, который искал на файловой системе определения компонентов, <a href="https://github.com/bem/webpack-bem-loader">вот здесь</a> . </p><br><p> В итоге, что было хорошо: </p><br><ul><li> краткий, декларативный синтаксис шаблонов, позволяющий доопределять разные части компонента в любом месте проекта; </li><li> нет цепочек прототипов в наследовании; </li><li> уникальный React-компонент для каждого места использования. </li></ul><br><p> А это было плохо: </p><br><ul><li> нет поддержки TypeScript/Flow; </li><li> непривычный для большинства React-разработчиков синтаксис; </li><li> из-за динамической природы импортов невозможно поставлять код в транспилированном виде; </li><li> обязательна специальная настройка сборки на проекте. </li></ul><br><h3 id="v200httpsgithubcombembem-reacttreev200"> <a href="">v2.0.0</a> </h3><br><p> Мы учли опыт использования <code>bem-react-core@v1.0.0</code> в проектах, отзывы и здравый смысл и попробовали снова. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Elem } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'bem-react-core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Button } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../Button'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppHeader</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Elem</span></span></span><span class="hljs-class"> </span></span>{ block = <span class="hljs-string"><span class="hljs-string">'App'</span></span>; elem = <span class="hljs-string"><span class="hljs-string">'Header'</span></span>; tag() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'h2'</span></span>; } content() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Я кнопка</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); } }</code> </pre> <br><p> В качестве синтаксиса описания блоков, элементов и модификаторов выбрали классы. Классы отличаются декларативной записью, встроенной поддержкой наследования, они просто великолепно работают с TypeScript/Flow. Внимательный читатель заметил, что мы отказались от <code>inherit</code> и «своих» импортов, что означало более удобную отладку, но и более длинную цепочку прототипов со всеми вытекающими последствиями для производительности. </p><br><p> Основными задачами были: <br> — отказаться от дополнительных надстроек в виде лоадеров для webpack и плагинов для Babel; <br> — максимально приблизиться к привычному всем языку; <br> — обзавестись нативной поддержкой всех инструментов для отладки, написания и тестирования кода. </p><br><p> Объявление модификаторов мы убрали за всем привычные <a href="https://reactjs.org/docs/higher-order-components.html">HOC</a> , внутри них создавали новый класс относительно базового и доопределяли нужные методы базового класса. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ReactDOM <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-dom'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Block, Elem, withMods } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'bem-react-core'</span></span>; interface IButtonProps { <span class="hljs-attr"><span class="hljs-attr">children</span></span>: string; } interface IModsProps extends IButtonProps { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'link'</span></span> | <span class="hljs-string"><span class="hljs-string">'button'</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// Создание элемента Text class Text extends Elem { block = 'Button'; elem = 'Text'; tag() { return 'span'; } } // Создание блока Button class Button&lt;T extends IModsProps&gt; extends Block&lt;T&gt; { block = 'Button'; tag() { return 'button'; } mods() { return { type: this.props.type }; } content() { return ( &lt;Text&gt;{this.props.children}&lt;/Text&gt; ); } } // Расширение функциональности блока Button, при наличии свойства type со значением link class ButtonLink extends Button&lt;IModsProps&gt; { static mod = ({ type }: any) =&gt; type === 'link'; tag() { return 'a'; } mods() { return { type: this.props.type }; } attrs() { return { href: 'www.yandex.ru' }; } } // Объединение классов Button и ButtonLink const ButtonView = withMods(Button, ButtonLink); ReactDOM.render( &lt;React.Fragment&gt; &lt;ButtonView type='button'&gt;Click me&lt;/ButtonView&gt; &lt;ButtonView type='link'&gt;Click me&lt;/ButtonView&gt; &lt;/React.Fragment&gt;, document.getElementById('root') );</span></span></code> </pre> <br><p> Спустя некоторое время мы нашли архитектурные проблемы в работе модификаторов и целый ряд недостатков, которые невозможно было решить исправлениями. </p><br><p> <code>withMods</code> принимал аргументами базовый класс блока и классы, расширяющие базовый (модификаторы), модификаторы обладали предикатом на входящие пропсы. При отрисовке компонентов, как только срабатывает предикат модификатора, withMods перестраивает цепочку прототипов относительно всех активных модификаторов так, чтобы каждый следующий был наследником предыдущего. Так происходит при каждом изменении пропсов. На первой отрисовке не случается никаких проблем, но, как только начинают включаться модификаторы, базовый блок (его прототип) получает функциональность модификатора. В результате все инстансы на странице будут обладать всей функциональностью модификаторов независимо от входящих пропсов. Кейс может повториться и на второй перерисовке, и на третьей, и на четвёртой — в зависимости от того, когда сработают предикаты модификаторов. </p><br><p> Решения, которые не помогли: </p><br><ul><li> Заворачивать модификаторы в функцию. Так, чтобы на каждый вызов модификатора возвращался новый класс. Частично решает проблему, но несовместимо с TS. Так как из функции модификатора начинает возвращаться класс, который экстендит базовый из внешнего скопа. При компиляции для ES5 TS перестраивает вызовы super не через прототип, а через внешнюю ссылку на базовый класс из константы. Да, TS транспилирует код не по стандартам, а как ему нравится. </li><li> Компилировать в два прохода. TS для ES6 и Babel для ES5. Помогает только на уровне собираемого проекта, поставляемый код в npm-пакетах так обработан не будет. Кроме того, это сильно замедлит сборку и завяжет всех на использование Babel. </li></ul><br><p> Дополнительные трудности: </p><br><ul><li> Невозможно расширить базовые блоки на уровне проекта, который их использует. Например, использовать блоки библиотек на сервисах. Кейс: атрибуты счетчиков на DOM-нодах. Расширить можно только через HOC, а модификаторы применяются только к классу. Всякое использование withMods не закрывало доступ к методам базового класса. </li><li> Все сущности (блок, элемент, модификатор) для правильной генерации классов обязаны быть классами. Тогда как большинство сущностей обладают слабой функциональностью и могут быть выражены через <a href="https://reactjs.org/docs/components-and-props.html">SFC</a> . </li><li> Жирные CSS-модификаторы. Любой CSS-модификатор обязан иметь JS-представление в виде расширения базового класса. Это не проблема само по себе, но было подозрение, что такой подход не снижал нам количество кода в браузере. </li></ul><br><p> Мы были вынуждены прервать разработку v2. </p><br><h2 id="manifest">  Manifesto </h2><br><p> Естественно, это нас не остановило. Мы написали манифест. Следуя ему, можно было решить проблемы, которые мы встретили в версиях 1 и 2. Ниже я перескажу часть из <a href="https://github.com/bem/bem-react/tree/master/docs/ru">этого манифеста</a> . </p><br><p> Основная мысль — работаем через полную композицию. Работу с CSS-классами и модификаторы выражаем через HOC, а переопределение кода по платформам и экспериментам — через <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D0%25BD%25D0%25B5%25D0%25B4%25D1%2580%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25B7%25D0%25B0%25D0%25B2%25D0%25B8%25D1%2581%25D0%25B8%25D0%25BC%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8">dependency injection</a> . </p><br><p> Необходимое и достаточное от БЭМ в React: </p><br><ul><li> работа с CSS-классами. </li><li> декларативное разделение кода по <a href="https://ru.bem.info/methodology/key-concepts/">модификаторам</a> и <a href="https://ru.bem.info/methodology/redefinition-levels/">уровням переопределения</a> (платформам, экспериментам); </li></ul><br><p> Модификатор более не сможет влиять на внутреннее устройство компонента. Дополнительная функциональность должна быть выражена через управляющие компоненты сверху. А сами компоненты могут быть выражены как <code>React.ComponentType</code> по необходимости без базовых БЭМ-компонентов. Подключение модификаторов не отличается от подключения любых других HOC и работает через любой compose и в любом порядке. </p><br><p> Модификатор определяет истинность предиката и добавит дополнительный класс через пропсы к базовому классу. </p><br><p> Переопределение компонентов и их составляющих выражается через dependency injection, которое реализуется на базе <a href="https://reactjs.org/docs/context.html"><code>React.ContextAPI</code></a> и множественных реестров компонентов. Каждый компонент волен регистрировать свои зависимости в реестре и позволять переопределять их сверху, что напрямую не заложено в работу стандартного контекста, но реализуется иным способом вычисления нового значения контекста. По умолчанию зависимости можно переопределять по контексту вниз, что есть стандартный механизм работы контекста. В итоге DI — это HOC, который провайдит реестры в контекст. Реестры могут работать в режимах проваливания и всплытия зависимостей. Это позволяет переопределять что угодно, где угодно, на любом уровне вложенности простым дописыванием компонентов в реестр. </p><br><p> То, что у нас получилось, уже можно увидеть в продакшене на странице результатов Поиска. Мы уместили всё, что нам было необходимо от БЭМ, в библиотеку из 4 пакетов, общим весом в <code>1.5Kb</code> . </p><br><p> На этом историческая часть заканчивается. Спасибо тем, кто дочитал до конца. В следующей статье я расскажу, как мы работаем с React в Яндекс.Поиске сегодня. </p></div>