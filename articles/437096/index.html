<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>UDB. What is it? Part 4. Datapath ALU</title>
  <meta name="description" content="As promised last time, we begin a detailed analysis of the Arithmetic Logical Unit (ALU). 

 Previous articles of the cycle: 

 UDB. What is it? Part ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>UDB. What is it? Part 4. Datapath ALU</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/eo/rg/-9/eorg-9l3xk6ssggrb7cvbsxkvyo.jpeg"><br><br>  As promised last time, we begin a detailed analysis of the Arithmetic Logical Unit (ALU). <br><a name="habracut"></a><br>  Previous articles of the cycle: <br><br>  <a href="https://habr.com/post/432764/">UDB.</a>  <a href="https://habr.com/post/432764/">What is it?</a>  <a href="https://habr.com/post/432764/">Part 1. Introduction.</a>  <a href="https://habr.com/post/432764/">Pld.</a> <br>  <a href="https://habr.com/post/433018/">UDB.</a>  <a href="https://habr.com/post/433018/">What is it?</a>  <a href="https://habr.com/post/433018/">Part 2. Datapath</a> <br>  <a href="https://habr.com/ru/post/434706/">UDB.</a>  <a href="https://habr.com/ru/post/434706/">What is it?</a>  <a href="https://habr.com/ru/post/434706/">Part 3. Datapath FIFO.</a> <br><br><h2>  21.3.2.4 Datapath ALU </h2><br>  The ALU core consists of three independent 8-bit programmable functions: an arithmetic / logic block, a shift register block, and a mask overlay block. <br><br><h3>  Arithmetic and logical operations </h3><br>  The ALU functions that are dynamically selected using the configuration RAM are shown in the table below. <br><br>  Table 21-8.  ALU functions. <br><table><tbody><tr><th>  Func [2: 0] </th><th>  Function </th><th>  Operation </th></tr><tr><td>  000 </td><td>  Pass </td><td>  srca </td></tr><tr><td>  001 </td><td>  INC </td><td>  ++ srca </td></tr><tr><td>  010 </td><td>  DEC </td><td>  --srca </td></tr><tr><td>  011 </td><td>  ADD </td><td>  srca + srcb </td></tr><tr><td>  100 </td><td>  SUB </td><td>  srca - srcb </td></tr><tr><td>  101 </td><td>  XOR </td><td>  srca ^ srcb </td></tr><tr><td>  110 </td><td>  AND </td><td>  srca &amp; srcb </td></tr><tr><td>  111 </td><td>  OR </td><td>  srca |  srcb </td></tr></tbody></table><br><h3>  Transfer Input (Carry in) </h3><br>  Carry in is used in arithmetic operations.  As shown in Table 21-9, for some functions, there are default carry in values. <br><br>  Table 21-9.  Functions Carry In. <br><table><tbody><tr><th>  Functions </th><th>  Operation </th><th>  The default implementation of Carry In </th></tr><tr><td>  INC </td><td>  ++ srca </td><td>  srca + 00h + ci, where ci is 1 </td></tr><tr><td>  DEC </td><td>  --srca </td><td>  srca + ffh + ci, where ci is 0 </td></tr><tr><td>  ADD </td><td>  srca + srcb </td><td>  srca + srcb + ci, where ci is 0 </td></tr><tr><td>  SUB </td><td>  srca - srcb </td><td>  srca + ~ srcb + ci, where ci is 1 </td></tr></tbody></table><br>  In addition to these standard arithmetic applications, there are three more options for using the transfer.  The CI SELA and CI SELB bits define the use of the carry in input for each clock cycle.  Dynamic configuration RAM selects configuration A or B in each tick.  The parameters are shown in table 21-10. <br><br>  Table 21-10.  Additional features Carry In. <br><table><tbody><tr><th>  CI SEL A <br>  CI SEL B </th><th>  Mode <br>  carry </th><th>  Description </th></tr><tr><td>  00 </td><td>  Default <br>  (Default) </td><td>  Default arithmetic mode <br>  described in table 21-9. </td></tr><tr><td>  01 </td><td>  Snap fit <br>  (Registered) </td><td>  Carry flag which is <br>  the result of the transfer from the previous cycle. <br>  This mode is used to implement <br>  addition operations with transfer and subtraction <br>  with occupation. </td></tr><tr><td>  ten </td><td>  Forwarding <br>  (Routed) </td><td>  Transfer is generated elsewhere. <br>  and is forwarded to this input.  This mode <br>  can be used to implement <br>  managed counters. </td></tr><tr><td>  eleven </td><td>  Chaining <br>  (Chained) </td><td>  The transfer is placed in the chain after <br>  previous datapath.  This mode can <br>  use to implement single-cycle <br>  higher bit operations, <br>  which use two or more <br>  Datapath. </td></tr></tbody></table><br>  If forwarding is used, it is used in a number of functions, as shown in Table 21-11.  Note that for the functions of decrement and subtraction of a unit, the active level of transfer is low (inverse). <br><br>  Table 21-11.  Functions traced Carry In. <br><table><tbody><tr><th>  Function </th><th>  Polarity Carry In </th><th>  Carry In is active </th><th>  Carry In is inactive </th></tr><tr><td>  INC </td><td>  Straight </td><td>  ++ srca </td><td>  srca </td></tr><tr><td>  DEC </td><td>  Inverse </td><td>  --srca </td><td>  srca </td></tr><tr><td>  ADD </td><td>  Straight </td><td>  (srca + srcb) +1 </td><td>  srca + srcb </td></tr><tr><td>  SUB </td><td>  Inverse </td><td>  (srca - srcb) -1 </td><td>  (srca - srcb) </td></tr></tbody></table><br><h3>  Carry Out </h3><br>  Carry out is an optional Datapath output based on a statically defined high bit.  The value can be transferred via a chain to the transfer input to a higher block.  Note that in the case of the decrement and subtraction functions, carry out is inverted. <br><br>  Table 21-12.  Functions Carry Out. <br><table><tbody><tr><th>  Function </th><th>  Polarity Carry Out </th><th>  Carry Out is active </th><th>  Carry Out is inactive </th></tr><tr><td>  INC </td><td>  Straight </td><td>  ++ srca == 0 </td><td>  srca </td></tr><tr><td>  DEC </td><td>  Inverse </td><td>  --srca == -1 </td><td>  srca </td></tr><tr><td>  ADD </td><td>  Straight </td><td>  srca + srcb&gt; 255 </td><td>  srca + srcb </td></tr><tr><td>  SUB </td><td>  Inverse </td><td>  srca - srcb &lt;0 </td><td>  (srca - srcb) </td></tr></tbody></table><br><h3>  Transfer structure </h3><br>  The <b>carry in</b> parameters and to select the high-order bit, to generate <b>carry out,</b> are shown in Figure 21-15.  The snap-in <b>carry out</b> values ‚Äã‚Äãcan be used as <b>carry in</b> for subsequent arithmetic operations.  This feature can be used to implement functions of higher resolution using cycles. <br><br><img src="https://habrastorage.org/webt/7d/pi/ge/7dpigep6_umk1m5ddhzldjw2y70.png"><br><br>  <i>Figure 21-15.</i>  <i>Transfer operation</i> <br><br><h3>  Shift operation </h3><br>  The shift operation occurs independently of the work of the ALU, according to Table 21-13. <br><br>  Table 21-13.  The functions of the shift operation. <br><table><tbody><tr><th>  Shift [1: 0] </th><th>  Function </th></tr><tr><td>  00 </td><td>  Pass (Pass) </td></tr><tr><td>  01 </td><td>  Shift Left (Shift Left) </td></tr><tr><td>  ten </td><td>  Shift Right (Shift Right) </td></tr><tr><td>  eleven </td><td>  Nibble Swap (Nibble Swap) </td></tr></tbody></table><br>  The output value of the shift operation is issued with Datapath.  Setting the outputs for the shift to the right ( <b>sor</b> ) and to the left ( <b>sol_msb</b> ) is performed by the same bits.  The static configuration bit (SHIFT SEL in the CFG15 register) determines which shift output is used as the Datapath output.  In the absence of a shift, the signals <b>sor</b> and <b>sol_msb are</b> defined as LSB and MSB ALU functions, respectively. <br><br>  The SI SELA and SI SELB configuration bits define the data shift for the specified operation.  Dynamic configuration RAM selects configuration A or B for each clock cycle.  The moved data is used only when shifting left and right, this input is not used when skipping and rearranging nibbls.  Selected values ‚Äã‚Äãand use cases refer to both the right shift and the left shift and are shown in Table 21-14. <br><br>  Table 21-14.  Shift in functions <br><table><tbody><tr><th>  SI SEL A <br>  SI SEL B </th><th>  A source <br>  retractable <br>  data </th><th>  Description </th></tr><tr><td>  00 </td><td>  Default / Arithmetic <br>  (Default / Arithmetic) </td><td>  The default value of the DEFSI bit <br>  (constant 1 or 0).  However, if the MSB SI is cocked, <br>  then the source is the value of the selected <br>  the most significant bit of the ALU (only for shifts to the right). </td></tr><tr><td>  01 </td><td>  Snap <br>  (Registered) </td><td>  The input value for the shift is given <br>  current snapped output value <br>  shift (from the previous cycle).  Operation <br>  left shift uses last value <br>  left shift.  The right shift operation uses <br>  the last output value of the shift to the right. </td></tr><tr><td>  ten </td><td>  Forwarding <br>  (Routed) </td><td>  Shift Input Received <br>  from the outside, through the trace resources (input SI). </td></tr><tr><td>  eleven </td><td>  Chaining <br>  (Chained) </td><td>  For input left shift <br>  forwarded from the output of the right block <br>  Datapath in the chain for input shift <br>  right - from the left. </td></tr></tbody></table><br>  The output for the left shift is taken from the bit set as the highest.  When shifted to the right, the input data pushes, starting at the selected highest (MSB) position.  The output data, even when shifted to the left, even if shifted to the right, snaps into place and can be used on the next clock cycle.  This feature can be used to implement a higher-resolution shift in multiple cycles. <br><br><img src="https://habrastorage.org/webt/_j/tw/tt/_jtwtt93bth4kzax0j2hhps9h1i.png"><br><br>  <i>Figure 21-16.</i>  <i>Shift operation</i> <br><br>  It is worth noting that the isolated bits of the MSB are still shifted.  In the example shown, bit 7 is still shifted by the value of sil when shifted to the right, and bit 5 is shifted to bit 4 when shifted to the left.  The output (right or left) bit of the isolated group will be lost. <br><br><h3>  ALU mask overlay operation </h3><br>  The 8-bit masking register in the static space of the UDB configuration registers defines the mask mapping operation.  In this operation, a mask (AND operation) is applied to the ALU output with the value of this register.  A typical use of the ALU mask overlay operation is the implementation of autonomous timers and counters with a resolution that is a multiple of a power of two. <br><br><h2>  21.3.2.5.  Datapath Inputs and Multiplexing (Datapath Inputs and Multiplexing) </h2><br>  As shown in Table 21-15, each Datapath has 9 inputs, including 6 inputs from channel tracing.  These include addresses of the configuration of RAM, FIFO, control signals load data registers, as well as the shift and transfer of data inputs. <br><br>  Table 24-15.  Inputs Datapath. <br><table><tbody><tr><th>  entrance </th><th>  Description </th></tr><tr><td>  RAD2 <br>  RAD1 <br>  RAD0 </td><td>  Asynchronous address in dynamic configuration RAM.  Addresses <br>  eight user-programmable 16-bit words.  Every word <br>  contains the Datapath control bits for the current loop.  Sequence <br>  instructions can be determined by these address inputs. </td></tr><tr><td>  F0LD <br>  F1LD </td><td>  If cocked in this cycle, data is loaded into the selected FIFO. <br>  from the battery A0 or A1, or the output from the ALU.  Source is selected <br>  using the Fx INSEL [1: 0] configuration bits.  This input is sensitive to drops. <br>  It is sampled at the Datapath clock;  when a transition is detected <br>  from ‚Äú0‚Äù to ‚Äú1‚Äù, loading occurs on the next clock edge. </td></tr><tr><td>  D0LD <br>  D1LD </td><td>  If cocked in this loop, the Dx register is loaded from <br>  associated FIFO Fx.  This input is sensitive to drops.  It is sampled. <br>  Datapath clocked;  upon detection of a transition from "0" to "1", loading <br>  occurs on the next clock edge. </td></tr><tr><td>  SI </td><td>  This is a data entry value that can be used to shift <br>  right or left. </td></tr><tr><td>  CI </td><td>  This transfer value is used if the control signal <br>  carry equals "routed carry". <br></td></tr></tbody></table><br>  As shown in Figure 21-17, each input has a 6-in-1 multiplexer, therefore all inputs are interchangeable.  Inputs are processed in two ways: either by level or by differential.  The address in the dynamic configuration memory, as well as the offset and data values ‚Äã‚Äãare level sensitive.  FIFO and data register load signals are sensitive to ramps. <br><br><img src="https://habrastorage.org/webt/gw/g5/ab/gwg5abdshe85xjtx11i7gm_cxzm.png"><br><br>  <i>Figure 21-17.</i>  <i>Datapath input signals.</i> <br><br>  In the next article we will move on to a review of useful things. </div><p>Source: <a href="https://habr.com/ru/post/437096/">https://habr.com/ru/post/437096/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>