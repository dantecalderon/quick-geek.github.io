<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The book "Python. Express course. 3rd ed. "</title>
  <meta name="description" content="Hi, Habrozhiteli! This book is intended for people who already have experience in one or more programming languages ‚Äã‚Äãand want to learn the basics of ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>The book "Python. Express course. 3rd ed. "</h1><div class="post__text post__text-html js-mediator-article"> <a href="https://habr.com/ru/company/piter/blog/437050/"><img src="https://habrastorage.org/webt/sv/bp/53/svbp53i5ti4wyewcggfithv859w.jpeg" align="left" alt="image"></a>  Hi, Habrozhiteli!  This book is intended for people who already have experience in one or more programming languages ‚Äã‚Äãand want to learn the basics of Python 3 as quickly and simply as possible. It is assumed that the reader is already familiar with control structures, OOP, file handling, exception handling, etc. The book is also useful to users of earlier versions of Python, who need a compact reference for Python 3.1. <br><br>  We offer you to read the passage "Processing data files" <br><a name="habracut"></a><br><h3>  How to use the book </h3><br>  Part 1 provides general information about Python.  You will learn how to download and install Python on your system.  It also provides a general overview of the language, which will be useful primarily for experienced programmers who want to get a high-level view of Python. <br><br>  Part 2 contains the main material of the book.  It discusses the ingredients needed to gain practical skills in using Python as a general-purpose programming language.  The material of the chapters was designed so that readers who are just starting to learn Python can move forward consistently, learning the key points of the language.  In this part there are also more complex sections, so that you can then go back and find all the necessary information about a certain structure or topic in one place. <br><br>  Part 3 introduces the advanced features of Python ‚Äî elements of the language that are not absolutely necessary, but will certainly come in handy for any serious Python programmer. <br><br>  Part 4 focuses on specialized topics that go beyond simple language syntax.  You can read these chapters or skip them depending on your needs. <br><br>  For beginners, Python programmers are encouraged to start with Chapter 3 in order to create a general impression, and then go on to the interesting chapters in part 2. Enter interactive examples to consolidate the concepts immediately.  You can also go beyond the examples given in the text and look for answers to any questions that remain unclear.  This approach will increase learning speed and deepen understanding.  If you are not familiar with OOP or are not required for your application, you can skip most of Chapter 15. <br><br>  Readers who are already familiar with Python should also begin with Chapter 3. It contains a good introductory overview and a description of the differences between Python 3 and more familiar versions.  It can also be used to evaluate whether you are ready to proceed to the more complex chapters of parts 3 and 4 of this book. <br><br>  Perhaps some readers who have no experience with Python but have sufficient experience in other programming languages ‚Äã‚Äãwill be able to get most of the information they need by reading Chapter 3 and reviewing the modules of the standard Python library (Chapter 19) and the Python library reference manual in the Python documentation . <br><br><h3>  Excerpt  Processing data files </h3><br>  Most of the data is distributed in text files.  This can be either unstructured text (for example, a collection of messages or a collection of literary texts), or more structured data, in which each line is a record, and the fields are separated by a special separator character ‚Äî a comma, tab, or a vertical bar (|).  Text files can be huge;  a data set may occupy dozens or even hundreds of files, and the data contained in it may be incomplete or distorted.  With such a variety, you almost inevitably face the task of reading and using data from text files.  This chapter presents the basic strategies for solving this problem in Python. <br><br><h3>  21.1.  Introducing ETL </h3><br>  The need to extract data from files, parse them, convert to a convenient format, and then do something appeared almost simultaneously with data files.  Moreover, there is even a standard term for this process: ETL (Extract-Transform-Load, i.e. ‚Äúextract-transform-load‚Äù).  By extraction is meant the process of reading a data source and parsing it if necessary.  Conversion can involve cleaning and normalizing data, as well as merging, splitting and reorganizing the records contained in them.  Finally, loading means saving the converted data in a new location (in another file or database).  This chapter discusses the basics of implementing ETL in Python, starting with text data files and ending with saving converted data to other files.  More structured data files are discussed in Chapter 22, and storing information in a database in Chapter 23. <br><br><h3>  21.2.  Reading text files </h3><br>  The first part of ETL, extraction, involves opening a file and reading its contents.  At first glance, it sounds simple, but even here problems may arise - for example, file size.  If the file is too large to fit in memory, the code should be structured so that it works with smaller segments of the file (possibly, on a single line). <br><br><h3>  21.2.1.  Text encoding: ASCII, Unicode, and others </h3><br>  Another possible problem is with the encoding.  This chapter is about working with text files, and in fact a large proportion of data transmitted in the real world is stored in text files.  However, the exact nature of the text may vary depending on the application, on the user and, of course, on the country. <br><br>  Sometimes the text carries information in ASCII encoding, which includes 128 characters, only 95 of which belong to the category of printed characters.  Fortunately, ASCII is the ‚Äúleast common multiple‚Äù of most data transfer situations.  On the other hand, it can not cope with the difficulties of numerous alphabets and writing systems existing in the world.  Reading ASCII files will almost certainly lead to the fact that when reading unsupported characters, be it German √º, Portuguese √ß, or almost any character from a language other than English, problems will start and errors will appear. <br><br>  These errors occur because ASCII uses 7-bit values, while bytes in a typical file consist of 8 bits, which makes it possible to represent 256 possible values ‚Äã‚Äãinstead of 128 for 7-bit values.  These additional codes are usually used to store additional values ‚Äã‚Äã- from extended punctuation marks (such as the middle and short dashes) to various marks (trademark, copyright mark and degree sign) and versions of alphabetic characters with accents.  There was always one problem: when reading a text file, you could run into a character that went beyond the ASCII range of 128 characters and could not be sure which character was encoded.  Suppose you encounter a symbol with code 214. What is it?  The division sign, the letter √ñ or something else?  Without the source code that created this file, it is impossible to find out. <br><br><h3>  Unicode and UTF-8 </h3><br>  To eliminate this ambiguity, you can use Unicode.  The Unicode encoding, called UTF-8, supports basic ASCII characters without any changes, but also allows for a virtually unlimited set of other characters and characters from the Unicode standard.  Due to its flexibility, UTF-8 is used in more than 85% of the web pages that existed at the time of this writing.  This means that when reading text files, it is best to use UTF-8.  If the files contain only ASCII characters, they will be read correctly, but you also get insurance in case other characters are encoded in UTF-8.  Fortunately, the Python 3 string data type is by default designed for Unicode support. <br><br>  Even with Unicode, there are situations when there are values ‚Äã‚Äãin the text that cannot be decoded successfully.  The open function in Python receives an additional errors parameter, which determines how to deal with encoding errors when reading or writing files.  The default value is 'strict', with which an error is triggered whenever an encoding error is detected.  Other useful values ‚Äã‚Äãare 'ignore' (skip the character that caused the error);  'replace' (the character is replaced by a special marker - usually?);  'backslashreplace' (the character is replaced with the escape sequence with \) and 'surrogateescape' (the violator character is converted to a private Unicode code point when read and back to the original byte sequence when writing).  The choice of processing or resolution of coding errors depends on the specific situation. <br><br>  Consider a brief example of a file containing an invalid UTF-8 character, and see how this character is processed in different modes.  First write the file using bytes and binary mode: <br><br><pre><code class="plaintext hljs">&gt;&gt;&gt; open('test.txt', 'wb').write(bytes([65, 66, 67, 255, 192,193]))</code> </pre> <br>  As a result of the command, a file is created from the characters ‚ÄúABC‚Äù, followed by three non-ASCII characters, which can be displayed differently depending on the encoding method used.  If you use vim to view the file, the result will look like this: <br><br><pre> <code class="plaintext hljs">ABC√ø√Ä√Å ~</code> </pre> <br><br>  When the file is created, try reading it in the default error mode of 'strict': <br><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; x = open('test.txt').read() Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "/usr/local/lib/python3.6/codecs.py", line 321, in decode (result, consumed) = self._buffer_decode(data, self.errors, final) UnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 3: invalid start byte</code> </pre> <br><br>  The fourth byte with a value of 255 is not a valid UTF-8 character in this position, so an exception is thrown in the 'strict' mode.  And now let's see how other error handling modes deal with the same file, without forgetting that the last three characters trigger an error: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rg/k8/kr/rgk8krlwwnpj47drpjqe8cp_pii.png" alt="image"></div><br>  If you want the problem characters to simply disappear, use the 'ignore' mode.  The 'replace' mode only marks positions of invalid characters, while other modes attempt to save invalid characters in different ways without interpretation. <br><br><h3>  21.2.2.  Unstructured text </h3><br>  Unstructured text files are the easiest to read, but they also create the most problems with extracting information.  The processing of unstructured text can vary in the widest limits, depending on both the nature of the text and what you are going to do with it, so that any detailed discussion of text processing is beyond the scope of the book.  However, a brief example will help demonstrate some basic problems and will lay the foundation for discussing files with structured text data. <br><br>  One of the simplest problems is choosing the basic logical unit in the file.  If you use a compilation of thousands of Twitter messages, a Moby Dick text, or a news collection, they need to be broken down into blocks somehow.  In the case of tweets, each block can fit on one line, and reading and processing each line of the file is organized quite simply. <br><br>  In the case of Moby Dick and even a separate news item, the problem becomes more complicated.  Of course, the text of the novel and even the text of the news is usually undesirable to consider as a single unit.  In this case, you need to decide which blocks you need, and then work out a strategy for dividing the file into blocks.  You may prefer to process the text in paragraphs.  In this case, you should determine how the breakdown of the text into paragraphs in the file is organized, and write the code accordingly.  If the paragraphs coincide with the lines of the text file, it will be easy to do.  However, often a single paragraph of a text file may consist of several lines in a text file, and you will have to work hard. <br><br>  Now consider a couple of examples. <br><br><blockquote>  Call me Ishmael.  Some years ago - never mind how long long-- <br>  and nothing particular <br>  I thought I would sail about a little <br>  and see the watery part of the world.  It is a way i have <br>  off the spleen and regulating the circulation. <br>  Whenever I find myself growing grim about the mouth; <br>  whenever it is a damp, drizzly  whenever I <br>  find myself involuntarily pausing before coffin warehouses, <br>  I meet; <br>  get up and down, <br>  that it requires a strong moral rule to prevent me from <br>  deliberately stepping into the street, and methodically knocking <br>  I love you <br>  as soon as i can.  This is my substitute for pistol and ball. <br>  With a philosophical flourish of Cato throws himself upon his sword; <br>  I quietly take to the ship.  There is nothing surprising in this. <br>  Hen <br>  or other, cherish very close to the same feelings towards <br>  the ocean with me. <br><br>  Manhattoes, belted round by wharves <br>  Indian coral reefs - commerce surrounds it with its surf. <br>  Right and left, the streets take you waterward.  Its extreme downtown <br>  where is the battery <br>  by breezes, which were out of sight of land. <br>  Look at the crowds of water-gazers there. </blockquote><br>  In this example (with the beginning of the ‚ÄúMoby Dick‚Äù text), the lines are broken down more or less as they would be paginated, and paragraphs are denoted by a single blank line.  If you want to process each paragraph as a whole, you need to split the text into empty lines.  Fortunately, this problem is easily solved by the split () method.  Each newline character in the text is represented by the "\ n" combination.  Naturally, the last line of the text of each paragraph ends with a newline, and if the next line of text is empty, then immediately followed by the second newline: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lu/a1/qi/lua1qir3kpemtstjg37nvrzwws8.png" alt="image"></div><br>  Splitting text into paragraphs is a very simple step in the process of unstructured text processing.  It may also be necessary to perform additional text normalization before further processing.  Suppose you want to calculate the frequency of occurrence of each word in a text file.  If you just split the file by pass, you will get a list of words in the file, but it will not be so easy to count the entries, because This, this, this.  and this will not be considered the same word.  In order for this code to work properly, you must normalize the text by removing the punctuation marks and converting the entire text to one register before processing.  In the above text example, the code for building a normalized word list might look like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kz/ld/4z/kzld4zqrc9gggdkevqpurtln9z4.png" alt="image"></div><br><h3>  21.2.3.  Unstructured Delimited Files </h3><br>  Unstructured files are easy to read, but the lack of structure is also a disadvantage.  It is often more convenient to define some structure for a file in order to simplify the selection of individual values.  In the simplest version, the file is divided into lines, and one information element is stored in each line.  For example, it may be a list of file names to process, a list of names of people, or a series of temperature readings from a remote sensor.  In such cases, the data analysis is organized very simply: you read the string and, if necessary, convert it to the desired type.  This is all that is needed for the file to be ready for use. <br><br>  However, the situation is not so simple.  Often you want to group several interrelated data elements, and your code must read them together.  Usually, for this, interrelated data is placed in one line and separated by a special character.  In this case, when reading each line of the file, special characters are used to split the data into fields and store the field values ‚Äã‚Äãin variables for further processing. <br><br>  The following file contains temperature data in a delimited format: <br><br><pre> <code class="plaintext hljs">State|Month Day, Year Code|Avg Daily Max Air Temperature (F)|Record Count for Daily Max Air Temp (F) Illinois|1979/01/01|17.48|994 Illinois|1979/01/02|4.64|994 Illinois|1979/01/03|11.05|994 Illinois|1979/01/04|9.51|994 Illinois|1979/05/15|68.42|994 Illinois|1979/05/16|70.29|994 Illinois|1979/05/17|75.34|994 Illinois|1979/05/18|79.13|994 Illinois|1979/05/19|74.94|994</code> </pre> <br>  The data in the file is separated by a vertical bar (|).  In this example, they consist of four fields: state, date of observation, average maximum temperature, and number of stations supplying data.  Other standard delimiters are tab and comma.  Perhaps the comma is used most often, but the delimiter can be any character that will not occur in values ‚Äã‚Äã(more on that later).  Separating data with commas is so common that this format is often called CSV (Comma-Separated Values, that is, data separated by commas), and files of this type are provided with the .csv extension as an indication of the format. <br><br>  Whatever character is used as a delimiter, if you know what kind of character it is, you can write your own Python code to split the string into fields and return them as a list.  In the previous case, you can use the split () method to convert a string to a list of values: <br><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; line = "Illinois|1979/01/01|17.48|994" &gt;&gt;&gt; print(line.split("|")) ['Illinois', '1979/01/01', '17.48', '994']</code> </pre> <br>  This technique is very easy to implement, but all values ‚Äã‚Äãare stored in string form, and this can be inconvenient for further processing. <br><br><h3>  21.2.4.  Csv module </h3><br>  If you often have to process data files with delimiters, it is worth a closer look at the csv module and its capabilities.  When I was asked to name my favorite module from the standard Python library, I often called the module csv - not because it looks spectacular (this is not so), but because it probably saved me more time and saved me from my potential errors more often than any other module. <br>  The csv module is a perfect example of the battery-packaged Python philosophy.  Although you can perfectly write your own code for reading delimited files (moreover, it is not that difficult), it is much easier and more reliable to use the Python module.  The csv module has been tested and optimized, and it provides a number of possibilities that you would hardly have realized on your own, but which are nonetheless quite convenient and time-saving. <br><br>  Take a look at the previous data and decide how you would read it with the csv module.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The data parsing code should read each line and remove the terminating new line character, and then split the line into characters | </font><font style="vertical-align: inherit;">and append the list of values ‚Äã‚Äãto the general list of strings. </font><font style="vertical-align: inherit;">The solution might look something like this:</font></font><br><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; results = [] &gt;&gt;&gt; for line in open("temp_data_pipes_00a.txt"): ... fields = line.strip().split("|") ... results.append(fields) ... &gt;&gt;&gt; results [['State', 'Month Day, Year Code', 'Avg Daily Max Air Temperature (F)', 'Record Count for Daily Max Air Temp (F)'], ['Illinois', '1979/01/01', '17.48', '994'], ['Illinois', '1979/01/02', '4.64', '994'], ['Illinois', '1979/01/03', '11.05', '994'], ['Illinois', '1979/01/04', '9.51', '994'], ['Illinois', '1979/05/15', '68.42', '994'], ['Illinois', '1979/ 05/16', '70.29', '994'], ['Illinois', '1979/05/17', '75.34', '994'], ['Illinois', '1979/05/18', '79.13', '994'], ['Illinois', '1979/05/19', '74.94', '994']]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If you want to do the same with the csv module, the code might look something like this: </font></font><br><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; import csv &gt;&gt;&gt; results = [fields for fields in csv.reader(open("temp_data_pipes_00a.txt", newline=''), delimiter="|")] &gt;&gt;&gt; results [['State', 'Month Day, Year Code', 'Avg Daily Max Air Temperature (F)', 'Record Count for Daily Max Air Temp (F)'], ['Illinois', '1979/01/01', '17.48', '994'], ['Illinois', '1979/01/02', '4.64', '994'], ['Illinois', '1979/01/03', '11.05', '994'], ['Illinois', '1979/01/04', '9.51', '994'], ['Illinois', '1979/05/15', '68.42', '994'], ['Illinois', '1979/ 05/16', '70.29', '994'], ['Illinois', '1979/05/17', '75.34', '994'], ['Illinois', '1979/05/18', '79.13', '994'], ['Illinois', '1979/05/19', '74.94', '994']]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this simple case, the gain in comparison with the independent implementation of the solution is not so great. However, the code is two lines shorter and a little clearer, and you don‚Äôt need to worry about clipping new characters. The real advantage is manifested when you are faced with more complex cases. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The data in this example is real, but in reality it has been simplified and cleaned up. The real data from the source will be more complex. Real data contains more fields, some fields will be enclosed in quotes, while others will not, and the first field may be empty. The original is separated by tabs, but for purposes of demonstration, I quote them separated by commas:</font></font><br><br><pre> <code class="plaintext hljs">"Notes","State","State Code","Month Day, Year","Month Day, Year Code",Avg Daily Max Air Temperature (F),Record Count for Daily Max Air Temp (F),Min Temp for Daily Max Air Temp (F),Max Temp for Daily Max Air Temp (F),Avg Daily Max Heat Index (F),Record Count for Daily Max Heat Index (F),Min for Daily Max Heat Index (F),Max for Daily Max Heat Index (F),Daily Max Heat Index (F) % Coverage ,"Illinois","17","Jan 01, 1979","1979/01/ 01",17.48,994,6.00,30.50,Missing,0,Missing,Missing,0.00% ,"Illinois","17","Jan 02, 1979","1979/01/02",4.64,994,- 6.40,15.80,Missing,0,Missing,Missing,0.00% ,"Illinois","17","Jan 03, 1979","1979/01/03",11.05,994,- 0.70,24.70,Missing,0,Missing,Missing,0.00% ,"Illinois","17","Jan 04, 1979","1979/01/ 04",9.51,994,0.20,27.60,Missing,0,Missing,Missing,0.00% ,"Illinois","17","May 15, 1979","1979/05/ 15",68.42,994,61.00,75.10,Missing,0,Missing,Missing,0.00% ,"Illinois","17","May 16, 1979","1979/05/ 16",70.29,994,63.40,73.50,Missing,0,Missing,Missing,0.00% ,"Illinois","17","May 17, 1979","1979/05/ 17",75.34,994,64.00,80.50,82.60,2,82.40,82.80,0.20% ,"Illinois","17","May 18, 1979","1979/05/ 18",79.13,994,75.50,82.10,81.42,349,80.20,83.40,35.11% ,"Illinois","17","May 19, 1979","1979/05/ 19",74.94,994,66.90,83.10,82.87,78,81.60,85.20,7.85%</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Please note: some fields include commas. According to the rules in such cases, the field is enclosed in quotes to indicate that its contents are not intended for parsing and searching for delimiters. In practice (as in this case), often only part of the field is enclosed in quotation marks, especially those whose values ‚Äã‚Äãmay contain a separator. However (as again in this example), some fields are quoted even when they are unlikely to contain a separator.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In such cases, homegrown solutions become too cumbersome. </font><font style="vertical-align: inherit;">Now, just splitting a string by a delimiter character no longer works; </font><font style="vertical-align: inherit;">you need to ensure that when searching used only those delimiters that are not inside the lines. </font><font style="vertical-align: inherit;">In addition, you must remove the quotes, which can be in an arbitrary position or not located anywhere. </font><font style="vertical-align: inherit;">With the csv module you don‚Äôt have to change your code at all. </font><font style="vertical-align: inherit;">Moreover, since the comma is considered the default delimiter, it does not even need to be specified:</font></font><br><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; results2 = [fields for fields in csv.reader(open("temp_data_01.csv", newline=''))] &gt;&gt;&gt; results2 [['Notes', 'State', 'State Code', 'Month Day, Year', 'Month Day, Year Code', 'Avg Daily Max Air Temperature (F)', 'Record Count for Daily Max Air Temp (F)', 'Min Temp for Daily Max Air Temp (F)', 'Max Temp for Daily Max Air Temp (F)', 'Avg Daily Min Air Temperature (F)', 'Record Count for Daily Min Air Temp (F)', 'Min Temp for Daily Min Air Temp (F)', 'Max Temp for Daily Min Air Temp (F)', 'Avg Daily Max Heat Index (F)', 'Record Count for Daily Max Heat Index (F)', 'Min for Daily Max Heat Index (F)', 'Max for Daily Max Heat Index (F)', 'Daily Max Heat Index (F) % Coverage'], ['', 'Illinois', '17', 'Jan 01, 1979', '1979/01/01', '17.48', '994', '6.00', '30.50', '2.89', '994', '-13.60', '15.80', 'Missing', '0', 'Missing', 'Missing', '0.00%'], ['', 'Illinois', '17', 'Jan 02, 1979', '1979/01/02', '4.64', '994', '-6.40', '15.80', '-9.03', '994', '-23.60', '6.60', 'Missing', '0', 'Missing', 'Missing', '0.00%'], ['', 'Illinois', '17', 'Jan 03, 1979', '1979/01/03', '11.05', '994', '- 0.70', '24.70', '-2.17', '994', '-18.30', '12.90', 'Missing', '0', 'Missing', 'Missing', '0.00%'], ['', 'Illinois', '17', 'Jan 04, 1979', '1979/01/04', '9.51', '994', '0.20', '27.60', '-0.43', '994', '-16.30', '16.30', 'Missing', '0', 'Missing', 'Missing', '0.00%'], ['', 'Illinois', '17', 'May 15, 1979', '1979/05/15', '68.42', '994', '61.00', '75.10', '51.30', '994', '43.30', '57.00', 'Missing', '0', 'Missing', 'Missing', '0.00%'], ['', 'Illinois', '17', 'May 16, 1979', '1979/05/ 16', '70.29', '994', '63.40', '73.50', '48.09', '994', '41.10', '53.00', 'Missing', '0', 'Missing', 'Missing', '0.00%'], ['', 'Illinois', '17', 'May 17, 1979', '1979/05/17', '75.34', '994', '64.00', '80.50', '50.84', '994', '44.30', '55.70', '82.60', '2', '82.40', '82.80', '0.20%'], ['', 'Illinois', '17', 'May 18, 1979', '1979/05/18', '79.13', '994', '75.50', '82.10', '55.68', '994', '50.00', '61.10', '81.42', '349', '80.20', '83.40', '35.11%'], ['', 'Illinois', '17', 'May 19, 1979', '1979/05/19', '74.94', '994', '66.90', '83.10', '58.59', '994', '50.90', '63.20', '82.87', '78', '81.60', '85.20', '7.85%']]</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬ªMore information about the book can be found on </font></font><a href="https://www.piter.com/product/python-ekspress-kurs-3-e-izd"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the publisher's website.</font></font></a> <br>  ¬ª <a href="https://storage.piter.com/upload/contents/978544610908/978544610908_X.pdf">Table of Contents</a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬ª </font></font><a href="https://storage.piter.com/upload/contents/978544610908/978544610908_p.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragment</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For Habrozhiteley 20% discount coupon - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python</font></font></b> </div><p>Source: <a href="https://habr.com/ru/post/437050/">https://habr.com/ru/post/437050/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>