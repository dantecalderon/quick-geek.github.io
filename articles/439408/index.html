<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pseudo Lens Flare</title>
  <meta name="description" content="Hi, Habr! I present to you the translation of the article ‚ÄúPseudo Lens Flare‚Äù by John Chapman. 



 Lens flare (lens flare) is a photographic artifact...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Pseudo Lens Flare</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr!  I present to you the translation of the article <a href="http://john-chapman-graphics.blogspot.com/2013/02/pseudo-lens-flare.html">‚ÄúPseudo Lens Flare‚Äù</a> by John Chapman. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/905/ced/087/905ced087e506e2a67793bb663eb43f9.png" alt="image"><br><br>  <b>Lens flare</b> (lens flare) is a photographic artifact that occurs when light is scattered and refracted in a lens system.  Although it is an artifact, there are many reasons for using <b>lens flare</b> in computer graphics: <br><br><ul><li>  it increases the perceived brightness and visible dynamic range of the image. </li><li>  <b>lens flare is</b> often found in photographs, so its absence can be evident </li><li>  he may play an important role in style or drama, or may be part of the gameplay in games (imagine glare that blinds the player) </li></ul><br>  Traditionally, <b>lens flare</b> in realtime has been implemented using sprite-based technologies.  Although sprites give easily controlled and very realistic results, they should be placed explicitly and require occlusion data for correct display.  Here I will describe a simple and relatively cheap screen space effect that creates a pseudo <b>lens flare</b> from the input color buffer.  It is not based on physics, so the result is slightly different from photorealistic, but it can be used in combination with (or as a substitute) for traditional sprite-based effects. <br><a name="habracut"></a><br><h2>  Algorithm </h2><br>  Consists of 4 stages: <br><br><ol><li>  Downsample / threshold. </li><li>  Generation of elements <b>flare</b> . </li><li>  Blur. </li><li>  Upscale / blend with original image. </li></ol><br><h3>  1. Downsample / Threshold </h3><br>  <b>Downsampling</b> (reduced resolution) - optimization to reduce the cost of subsequent stages.  In addition, we want to select a subset of the brightest pixels of the original image.  Using <b>scale / bias</b> (scale / offset) provides a flexible way to achieve this: <br><br><pre><code class="cpp hljs">uniform sampler2D uInputTex; uniform vec4 uScale; uniform vec4 uBias; noperspective in vec2 vTexcoord; out vec4 fResult; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ fResult = max(vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>), texture(uInputTex, vTexcoord) + uBias) * uScale; }</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/35d/775/c6d/35d775c6d8258a1485f52cb92b6430e5.jpg" alt="image"><br><br>  The <b>scale / bias</b> adjustment is the main way to adjust the effect;  the best settings will depend on the dynamic range of the color buffer, as well as how thin you want to see the result.  Due to the fact that the technique is an approximation, subtlety is more likely to look better. <br><br><h3>  2. Generation of elements flare </h3><br>  <b>Lens flare</b> elements tend to rotate about the center of the image.  By simulating this effect, we can expand the result of the previous stage horizontally / vertically.  This is easy to do at the stage of generating elements, expanding the texture coordinates: <br><br><pre> <code class="cpp hljs">vec2 texcoord = -vTexcoords + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>);</code> </pre><br>  It is not necessary to do this;  element generation works fine with this, and without it.  However, the result of changing the texture coordinates helps to visually separate the <b>lens flare</b> effect from the original image. <br><br><h4>  Ghosts </h4><br>  ‚Äú <b>Ghosts</b> ‚Äù (ghosts) are repetitive highlights that reflect bright areas in the color buffer, turning around the center of the image.  The approach I chose to generate is to get a vector from the current pixel to the center of the screen, and then make several samples along this vector. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/305/a06/097/305a06097b4e8ea7917a3635eb28f308.jpg" alt="image"><br><br><pre> <code class="cpp hljs">uniform sampler2D uInputTex; uniform <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> uGhosts; <span class="hljs-comment"><span class="hljs-comment">// number of ghost samples uniform float uGhostDispersal; // dispersion factor noperspective in vec2 vTexcoord; out vec4 fResult; void main() { vec2 texcoord = -vTexcoord + vec2(1.0); vec2 texelSize = 1.0 / vec2(textureSize(uInputTex, 0)); // ghost vector to image centre: vec2 ghostVec = (vec2(0.5) - texcoord) * uGhostDispersal; // sample ghosts: vec4 result = vec4(0.0); for (int i = 0; i &lt; uGhosts; ++i) { vec2 offset = fract(texcoord + ghostVec * float(i)); result += texture(uInputTex, offset); } fResult = result; }</span></span></code> </pre><br>  Notice that I use <i>fract ()</i> to ensure that the texture coordinates are wrapped around;  equivalent you can use wrap mode <i>GL_REPEAT</i> for the texture. <br><br>  Here is the result: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/204/502/804/204502804fdf82167d0748821d8bac72.jpg" alt="image"><br><br>  You can improve the result by allowing only bright areas closer to the center of the image to generate ghosts.  We can achieve this by adding weights that will decrease from the center for samples: <br><br><pre> <code class="cpp hljs">vec4 result = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; uGhosts; ++i) { vec2 offset = fract(texcoord + ghostVec * <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(i)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> weight = length(vec2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>) - offset) / length(vec2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>)); weight = <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - weight, <span class="hljs-number"><span class="hljs-number">10.0</span></span>); result += texture(uInputTex, offset) * weight; }</code> </pre><br>  The weight function is as simple as possible - linear.  The reason why we calculate the weight inside the loop is that bright areas in the center of the input image can ‚Äúcast‚Äù ghosts onto the borders, but bright areas on the borders cannot cast ghosts into the center. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0bd/c83/d61/0bdc83d61fc9195c6578bd37145d3aed.jpg" alt="image"><br><br>  The final improvement is a radial change in the color of the ghost, in accordance with the 1D texture: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/591/5c9/199/5915c9199899554fd2b545a9e882c5cc.jpg" alt="image"><br><br>  It is applied after the cycle to affect the final color of the ghost: <br><br><pre> <code class="cpp hljs">result *= texture(uLensColor, length(vec2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>) - texcoord) / length(vec2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>)));</code> </pre><br><h4>  HALOS (halos) </h4><br>  If we take the vector to the center of the image, as in the calculation of <b>ghost</b> , but fix the length of the vector, we will get another effect: the original image is deformed radially: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7d/280/b54/c7d280b54391cc3507c3f3c5cd713078.jpg" alt="image"><br>  We can use this to create a ‚Äúhalo‚Äù by multiplying the weight by a sample, thereby limiting the contribution of the deformed image to a ring, the radius of which is controlled by <b>uHaloWidth</b> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// sample halo: vec2 haloVec = normalize(ghostVec) * uHaloWidth; float weight = length(vec2(0.5) - fract(texcoord + haloVec)) / length(vec2(0.5)); weight = pow(1.0 - weight, 5.0); result += texture(uInputTex, texcoord + haloVec) * weight;</span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/bad/cdb/40a/badcdb40a06b62ba0732b8fa54fe2f88.jpg" alt="image"><br><br><h4>  CHROMATIC DISTORTION (color distortion) </h4><br>  Some glare on the lenses have color distortion caused by the variation of light refractions at different wavelengths.  We can simulate this by creating a function that selects the red, green, and blue channels separately with slightly different offsets along the sample vector: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">textureDistorted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( in sampler2D tex, in vec2 texcoord, in vec2 direction, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">// direction of distortion in vec3 distortion // per-channel distortion factor ) { return vec3( texture(tex, texcoord + direction * distortion.r).r, texture(tex, texcoord + direction * distortion.g).g, texture(tex, texcoord + direction * distortion.b).b ); }</span></span></span></span></span></span></code> </pre><br>  It can be used as a direct replacement for calling <b>texture ()</b> in the previous listing.  I calculate the <b>direction</b> and <b>distortion</b> as follows: <br><br><pre> <code class="cpp hljs">vec2 texelSize = <span class="hljs-number"><span class="hljs-number">1.0</span></span> / vec2(textureSize(uInputTex, <span class="hljs-number"><span class="hljs-number">0</span></span>)); vec3 distortion = vec3(-texelSize.x * uDistortion, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, texelSize.x * uDistortion); vec3 direction = normalize(ghostVec);</code> </pre><br>  Although the sampling function is simple, it costs x3 texture samples, although they should all be cache-friendly, unless you specify a giant value for <b>uDistortion</b> . <br><br>  With the generation of elements all.  Here is the result: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2a8/fea/9e7/2a8fea9e783d8b254d2c738fc3362a45.jpg" alt="image"><br><br><h3>  3. Blur </h3><br>  Without blur, <b>lens flare</b> elements (in particular, ghosts), as a rule, preserve the appearance of the image.  By adding blur to the <b>lens flare</b> elements, we weaken the high frequencies and thereby reduce the contrast with the input image, which helps us sell the effect. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/93f/bad/099/93fbad09987037e5d1fd5aa29441bc5c.jpg" alt="image"><br><br>  I will not tell you how to make a blur;  This can be read on various Internet resources (Gaussian blur). <br><br><h3>  4. Upscale / blending with original image </h3><br>  So, we have our <b>lens flare</b> elements, well blurred.  How can we combine them with the original original image?  There are several important considerations regarding the entire render pipeline: <br><br><ul><li>  Any subsequent <b>motion blur</b> or <b>depth of field</b> must be applied before combining with the <b>lens flare</b> , so the <b>lens flare</b> elements will not participate in these effects. </li><li>  <b>Lens flare</b> should be applied before any <b>tonemapping</b> .  This has a physical meaning, since <b>tonemapping</b> simulates film / CMOS response to incoming light, of which <b>lens flare is a part</b> . </li></ul><br>  With this in mind, there are a couple of things that we can do at this stage to improve the result: <br><br><h4>  LENS DIRT </h4><br>  First, you need to modify the elements of <b>lens flare</b> using a ‚Äúdirty‚Äù texture in full resolution (which is widely used in Battlefield 3): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6c1/f6a/f9e/6c1f6af9e3c34aeff34a174870c31f74.jpg" alt="image"><br><br><pre> <code class="cpp hljs">uniform sampler2D uInputTex; <span class="hljs-comment"><span class="hljs-comment">// source image uniform sampler2D uLensFlareTex; // input from the blur stage uniform sampler2D uLensDirtTex; // full resolution dirt texture noperspective in vec2 vTexcoord; out vec4 fResult; void main() { vec4 lensMod = texture(uLensDirtTex, vTexcoord); vec4 lensFlare = texture(uLensFlareTex, vTexcoord) * lensMod; fResult = texture(uInputTex, vTexcoord) + lensflare; }</span></span></code> </pre><br>  The key to this is the very texture of the dirt on the lenses.  If the contrast is low, <b>lens flare</b> shapes tend to dominate the result.  As the contrast increases, the <b>lens flare</b> elements are muffled, which gives a different aesthetic appearance and also hides some defects. <br><br><h4>  DIFFRACTION STARBURST </h4><br>  As an additional improvement, we can use the <b>starburst</b> texture by adding it to <b>lens dirt</b> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/23b/81b/27e/23b81b27e47a3f5983b649ea0d368edb.jpg" alt="image"><br>  In the form of a <b>starburst</b> texture does not look very good.  However, we can transfer a transformation matrix to a shader, which will allow us to rotate / distort the <b>starburst</b> each frame and get the desired dynamic effect: <br><br><pre> <code class="cpp hljs">uniform sampler2D uInputTex; <span class="hljs-comment"><span class="hljs-comment">// source image uniform sampler2D uLensFlareTex; // input from the blur stage uniform sampler2D uLensDirtTex; // full resolution dirt texture uniform sampler2D uLensStarTex; // diffraction starburst texture uniform mat3 uLensStarMatrix; // transforms texcoords noperspective in vec2 vTexcoord; out vec4 fResult; void main() { vec4 lensMod = texture(uLensDirtTex, vTexcoord); vec2 lensStarTexcoord = (uLensStarMatrix * vec3(vTexcoord, 1.0)).xy; lensMod += texture(uLensStarTex, lensStarTexcoord); vec4 lensFlare = texture(uLensFlareTex, vTexcoord) * lensMod; fResult = texture(uInputTex, vTexcoord) + lensflare; }</span></span></code> </pre><br>  The <b>uLensStarMatrix</b> transformation <b>matrix is</b> based on the value obtained from the camera orientation as follows: <br><br><pre> <code class="cpp hljs">vec3 camx = cam.getViewMatrix().col(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// camera x (left) vector vec3 camz = cam.getViewMatrix().col(1); // camera z (forward) vector float camrot = dot(camx, vec3(0,0,1)) + dot(camz, vec3(0,1,0));</span></span></code> </pre><br>  There are other ways to get the camrot value;  the main thing is that it should change continuously when the camera is turned  The matrix itself is constructed as follows: <br><br><pre> <code class="cpp hljs">mat3 scaleBias1 = ( <span class="hljs-number"><span class="hljs-number">2.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">2.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, ); mat3 rotation = ( <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(camrot), -<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(camrot), <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(camrot), <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(camrot), <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span> ); mat3 scaleBias2 = ( <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, ); mat3 uLensStarMatrix = scaleBias2 * rotation * scaleBias1;</code> </pre><br>  <b>The scale</b> and <b>bias</b> matrices need the offset of the origin of the texture coordinates so that we can rotate the <b>starburst</b> relative to the center of the image. <br><br><h2>  Conclusion </h2><br>  So now everything!  This method demonstrates how a relatively simplified post process gives a decent looking <b>lens flare</b> .  It is not exactly photorealistic, but if used correctly, it can give an excellent result. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8a8/168/c34/8a8168c3447b9f9b97c7c240557e2f32.jpg" alt="image"><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/AjSr0zLBnx8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div><p>Source: <a href="https://habr.com/ru/post/439408/">https://habr.com/ru/post/439408/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>