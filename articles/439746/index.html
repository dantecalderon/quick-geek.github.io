<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Understand the promises in javascript</title>
  <meta name="description" content="Good day, Habr! I present to you the translation of the article ‚ÄúUnderstanding Promises in JavaScript‚Äù by Sukhjinder Arora. 



 From the author of th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Understand the promises in javascript</h1><div class="post__text post__text-html js-mediator-article">  Good day, Habr!  I present to you the translation of the article <a href="https://blog.bitsrc.io/understanding-promises-in-javascript-c5248de9ff8f">‚ÄúUnderstanding Promises in JavaScript‚Äù</a> by Sukhjinder Arora. <br><br><img src="https://habrastorage.org/webt/ox/6m/oa/ox6moan9gwhmc2oouqbhyfzumtm.png"><br><a name="habracut"></a><br>  <i>From the author of the translation: Just like the author himself, I hope that the article was useful for you.</i>  <i>Please, if she really helped you learn something new for yourself, then do not be lazy to go to the original article and thank the author!</i>  <i>I will be glad to your feedback!</i> <i><br><br></i>  <i><a href="https://habr.com/ru/post/439620/">Link to the translation of the article on asynchronous JavaScript from the same author</a> .</i> <br><br>  JavaScript is a single-threaded programming language, which means that one thing can be executed at once.  Before ES6, we used callbacks to manage asynchronous tasks, such as a network request. <br><br>  Using promises, we can avoid the ‚Äúhell of callbacks‚Äù and make our code cleaner, more readable and easier to understand. <br><br>  Suppose we want to asynchronously get some data from the server using callbacks, we would do something like this: <br><br><pre><code class="javascript hljs">getData(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(x); getMoreData(x, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">y</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(y); getSomeMoreData(y, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">z</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(z); }); }); });</code> </pre> <br>  Here I request some data from the server using the <i>getData ()</i> function, which gets the data inside the callback function.  Inside the callback function, I request additional data by calling the <i>getMoreData ()</i> function, passing previous data as an argument, and so on. <br><br>  This is what we call the ‚Äúcallback hell‚Äù, where each callback is nested inside the other, and each internal callback depends on its parent. <br><br>  We can rewrite the above fragment using promises: <br><br><pre> <code class="javascript hljs">getData() .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(x); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getMoreData(x); }) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">y</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getSomeMoreData(y); }) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">z</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(z); });</code> </pre> <br>  You can see what has become more readable than in the case of the first example with callbacks. <br><br><h2>  What are Promises? </h2><br>  Promis (Promise) is an object that contains the future value of an asynchronous operation.  For example, if you request some data from the server, promise promises us to get this data, which we can use in the future. <br><br>  Before plunging into all these technical things, let's look at the terminology of the promises. <br><br><h3>  States of promises </h3><br>  Promis in JavaScript, like a promise in real life, has 3 states.  This can be 1) unresolved (pending), 2) resolved / resolved (3) or 3) rejected. <br><br><img src="https://habrastorage.org/webt/pk/hr/zz/pkhrzzgtdsgqvtptwn26gmtbjhk.png"><br><br>  <b>Unsolved or Pending</b> - Promis waits if the result is not ready.  That is, it expects the completion of something (for example, the completion of an asynchronous operation). <br>  <b>Solved or Executed</b> - Promis resolved if the result is available.  That is, something completed its execution (for example, an asynchronous operation) and everything went well. <br>  <b>Rejected</b> - Promis rejected if an error occurred during execution. <br><br>  Now that we know what Promis and its terminology are, let's go back to the practical part of promises. <br><br><h3>  Create a Promise </h3><br>  In most cases, you will simply use promises rather than create them, but it is still important to know how they are created. <br><br>  Syntax: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { ... });</code> </pre> <br>  We have created a new promise using the constructor constructor, it accepts one argument, a callback, also known as an executive function, which accepts 2 callbacks, <i>resolve</i> and <i>reject</i> . <br><br>  The executive function is performed immediately after the creation of the promise.  Promis is executed by calling <i>resolve ()</i> , and rejected by <i>reject ()</i> .  For example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(allWentWell) { resolve(<span class="hljs-string"><span class="hljs-string">'–í—Å–µ –ø—Ä–æ—à–ª–æ –æ—Ç–ª–∏—á–Ω–æ!'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫'</span></span>); } });</code> </pre> <br>  <i>The resolve ()</i> and <i>reject ()</i> take one argument, which can be a string, a number, a logical expression, an array, or an object. <br><br>  Let's take a look at another example to fully understand how promises are created. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> randomNumber = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random(); setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(randomNumber &lt; <span class="hljs-number"><span class="hljs-number">.6</span></span>) { resolve(<span class="hljs-string"><span class="hljs-string">'–í—Å–µ –ø—Ä–æ—à–ª–æ –æ—Ç–ª–∏—á–Ω–æ!'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫'</span></span>); } }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); });</code> </pre> <br>  Here I created a new promise using the designer Promisov.  Promis is executed or rejected 2 seconds after its creation.  A prompt is executed if <i>randomNumber is</i> less than .6 and is rejected in other cases. <br><br>  When the promise has been created, it will be in a wait state and its value will be <i>undefined</i> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cs/wr/c2/cswrc2jdrixhaguff2w9oijiyf4.png"></div><br>  After 2 seconds, the timer ends, promis randomly either executed or rejected, and its value will be the one passed to the function <i>resolve</i> or <i>reject</i> .  Below is an example of two cases: <br><br>  Successful implementation: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tp/zy/pq/tpzypq48va7fl8lbt_hkrmipquy.png"></div><br>  Promise rejection: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ng/4p/aa/ng4paaepwrz1oo_2o5l6nuazms4.png"></div><br>  <b>Note:</b> Promis can only be executed or rejected once.  Further calls of <i>resolve ()</i> or <i>reject ()</i> will not affect the state of promis.  Example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise resolved'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// –ü—Ä–æ–º–∏—Å –≤—ã–ø–æ–ª–Ω–µ–Ω reject('Promise rejected'); // –ü—Ä–æ–º–∏—Å —É–∂–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –æ—Ç–∫–ª–æ–Ω–µ–Ω });</span></span></code> </pre> <br>  Since <i>resolve ()</i> was called first, the promise now turns out to be ‚Äúexecuted‚Äù.  A subsequent call to <i>reject ()</i> will not affect the state of the promise. <br><br><h3>  Using Promise </h3><br>  Now we know how to create promises, let's now figure out how to apply the already created promises.  We use promises using the <i>then ()</i> and <i>catch ()</i> methods. <br><br>  For example, querying data from an API using <i>fetch</i> , which returns a promise. <br><br>  <i>.then ()</i> <b>syntax:</b> <i>promise.then (successCallback, failureCallback)</i> <br><br>  <i>successCallback</i> is called if the promise was successfully completed.  Takes one argument, which is the value passed to <i>resolve ()</i> . <br><br>  <i>failureCallback</i> is called if the promise was rejected.  Accepts one argument, which is the value of a devotee in <i>reject ()</i> . <br><br>  Example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> randomNumber = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(randomNumber &lt; <span class="hljs-number"><span class="hljs-number">.7</span></span>) { resolve(<span class="hljs-string"><span class="hljs-string">'–í—Å–µ –ø—Ä–æ—à–ª–æ –æ—Ç–ª–∏—á–Ω–æ!'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫'</span></span>)); } }); promise.then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); <span class="hljs-comment"><span class="hljs-comment">// –≤—ã–≤–µ—Å—Ç–∏ '–í—Å–µ –ø—Ä–æ—à–ª–æ –æ—Ç–ª–∏—á–Ω–æ!' }, (error) =&gt; { console.log(error); // –≤—ã–≤–µ—Å—Ç–∏ –æ—à–∏–±–∫—É } );</span></span></code> </pre> <br>  If the promise was executed, then <i>successCallback</i> is <i>called</i> with the value passed to <i>resolve ()</i> .  And if the promise was rejected, then <i>failureCallback</i> is <i>called</i> with the value passed to reject (). <br><br>  <i>.catch ()</i> <b>syntax:</b> <i>promise.catch (failureCallback)</i> <br><br>  We use <i>catch ()</i> for error handling.  This is more readable than error handling inside <i>failureCallback</i> inside the <i>then ()</i> method callback. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Something went wrong'</span></span>)); }); promise .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); }) .catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error); <span class="hljs-comment"><span class="hljs-comment">// –≤—ã–≤–µ—Å—Ç–∏ –æ—à–∏–±–∫—É });</span></span></code> </pre> <br><h3>  Chain of promises </h3><br>  The <i>then ()</i> and <i>catch ()</i> methods can also return a new promise, which can be processed by a chain of other then () at the end of the previous then () method. <br><br>  We use a chain of promises when we want to perform a sequence of promises. <br><br>  For example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 –≤—ã–ø–æ–ª–Ω–µ–Ω'</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise2 –≤—ã–ø–æ–ª–Ω–µ–Ω'</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Promise3 –æ—Ç–∫–ª–æ–Ω–µ–Ω'</span></span>); }); promise1 .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); <span class="hljs-comment"><span class="hljs-comment">// Promise1 –≤—ã–ø–æ–ª–Ω–µ–Ω return promise2; }) .then((data) =&gt; { console.log(data); // Promise2 –≤—ã–ø–æ–ª–Ω–µ–Ω return promise3; }) .then((data) =&gt; { console.log(data); }) .catch((error) =&gt; { console.log(error); // Promise3 –æ—Ç–∫–ª–æ–Ω–µ–Ω });</span></span></code> </pre> <br><h4>  And so, what is happening here? </h4><br>  When <i>promise1 is</i> executed, the <i>then ()</i> method is called <i>,</i> which returns promise2. <br>  Then, when <i>promise2 is</i> executed, <i>then ()</i> is called again and returns <i>promise3</i> . <br><br>  Since promise3 is rejected, instead of the next <i>then ()</i> , <i>catch ()</i> is called, which handles the <i>promise3 rejection</i> . <br><br>  <b>Note:</b> As a rule, one <i>catch ()</i> method is enough to handle the rejection of any of the promises in the chain, if this method is at the end of it. <br><br><h4>  Common mistake </h4><br>  Quite a lot of newbies make a mistake by putting some promises inside the others.  For example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 –≤—ã–ø–æ–ª–Ω–µ–Ω'</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise2 –≤—ã–ø–æ–ª–Ω–µ–Ω); }); const promise3 = new Promise((resolve, reject) =&gt; { reject('</span></span>Promise3 –æ—Ç–∫–ª–æ–Ω–µ–Ω<span class="hljs-string"><span class="hljs-string">'); }); promise1.then((data) =&gt; { console.log(data); // Promise1 –≤—ã–ø–æ–ª–Ω–µ–Ω promise2.then((data) =&gt; { console.log(data); // Promise2 –≤—ã–ø–æ–ª–Ω–µ–Ω promise3.then((data) =&gt; { console.log(data); }).catch((error) =&gt; { console.log(error); // Promise3 –æ—Ç–∫–ª–æ–Ω–µ–Ω }); }).catch((error) =&gt; { console.log(error); }) }).catch((error) =&gt; { console.log(error); });</span></span></code> </pre> <br>  Although this will work fine, it is considered a bad style and makes the code less readable.  If you have a sequence of promises to perform, it would be better to put them one after the other than to put one inside the other. <br><br><h3>  Promise.all () </h3><br>  This method takes an array of promises and returns a new promise that will be executed when all the promises within the array are completed or rejected as soon as the promise that is rejected is encountered.  For example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 –≤—ã–ø–æ–ª–Ω–µ–Ω'</span></span>); }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise2 –≤—ã–ø–æ–ª–Ω–µ–Ω'</span></span>); }, <span class="hljs-number"><span class="hljs-number">1500</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([promise1, promise2]) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data[<span class="hljs-number"><span class="hljs-number">0</span></span>], data[<span class="hljs-number"><span class="hljs-number">1</span></span>])) .catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error));</code> </pre> <br>  Here, the argument inside <i>then ()</i> is an array that contains the values ‚Äã‚Äãof the promises in the same order in which they were passed to <i>Promise.all ()</i> . (Only if all promises are executed) <br><br>  The promis is rejected with the reason for the rejection of the first promis in the transmitted array.  For example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 resolved'</span></span>); }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Promise2 rejected'</span></span>); }, <span class="hljs-number"><span class="hljs-number">1500</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([promise1, promise2]) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data[<span class="hljs-number"><span class="hljs-number">0</span></span>], data[<span class="hljs-number"><span class="hljs-number">1</span></span>])) .catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error)); <span class="hljs-comment"><span class="hljs-comment">// Promise2 –æ—Ç–∫–ª–æ–Ω–µ–Ω</span></span></code> </pre> <br>  Here we have two promises, where one runs after 2 seconds and the other deflects after 1.5 seconds.  As soon as the second promise is rejected, returned from <i>Promise.all () the</i> promise is rejected without waiting for the first one to be executed. <br><br>  This method can be useful when you have more than one promise and you want to know when all promises are completed.  For example, if you are requesting data from a third-party API and you want to do something with this data only when all requests are successful. <br><br>  As a result, we have <i>Promise.all ()</i> , which is waiting for the successful execution of all promises, or terminates its execution when it detects the first failure in the array of promises. <br><br><h3>  Promise.race () </h3><br>  This method accepts an array of promises and returns one new promise, which will be executed as soon as the completed promise is encountered in the array or is rejected if the rejected promise is encountered earlier.  For example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 resolved'</span></span>); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Promise2 rejected'</span></span>); }, <span class="hljs-number"><span class="hljs-number">1500</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.race([promise1, promise2]) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data)) <span class="hljs-comment"><span class="hljs-comment">// Promise1 –≤—ã–ø–æ–ª–Ω–µ–Ω .catch((error) =&gt; console.log(error));</span></span></code> </pre> <br>  Here we have two promises, where one runs after 1 second, and the other deflects after 1.5 seconds.  As soon as the first promise is completed, the promise returned from Promise.race () will have the status completed without waiting for the second promise status. <br><br>  Here, the <i>data</i> that is passed to <i>then ()</i> is the value of the first, executed, promise. <br><br>  At the end, <i>Promise.race ()</i> waits for the first promise and takes its status as the status of the returned promise. <br><br>  <i>Comment author of the translation: Hence the actual name.</i>  <i>Race - race</i> <br><br><h2>  Conclusion </h2><br>  We learned what PROMIS are and what they eat in JavaScript.  Promises are made up of two parts 1) Creating promises and 2) Using promises.  Most of the time, you will use promises rather than create them, but it is important to know how they are created. <br><br>  That's all, I hope this article was useful for you! </div><p>Source: <a href="https://habr.com/ru/post/439746/">https://habr.com/ru/post/439746/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav><ul class="list-of-pages">
<li><a href="../439746/index.html">Understand the promises in javascript</a></li>
<li><a href="../439748/index.html">The digest of interesting materials for the mobile developer # 285 (February 4 - 10)</a></li>
<li><a href="../439750/index.html">Learn product management - where?</a></li>
<li><a href="../439752/index.html">Multicore MRI Method</a></li>
<li><a href="../439754/index.html">Google is going to be engaged in the development of smart watches</a></li>
<li><a href="../439756/index.html">Why do I need a thermo-acoustic generator?</a></li>
<li><a href="../439760/index.html">Engineers "twisted" the light in the fiber - a new technology will speed up the transfer of data a hundred times</a></li>
<li><a href="../439764/index.html">Corporate fruit</a></li>
<li><a href="../439772/index.html">Writing Unit Tests on Swift for Verifying Asynchronous Tasks</a></li>
<li><a href="../439778/index.html">The digest of fresh materials from the world of the frontend for the last week No. 351 (February 4 - 10, 2019)</a></li>
<li><a href="../439780/index.html">PHP Digest number 149 (January 28 - February 11, 2019)</a></li>
<li><a href="../439782/index.html">Headless CMS - the future of content management</a></li>
<li><a href="../439784/index.html">Methane engine "Raptor" broke the record RD-180</a></li>
<li><a href="../439788/index.html">Regular oddities in the GOST Grasshopper and Stribog algorithms</a></li>
<li><a href="../439790/index.html">Test JaCarta WebClient or store tokens in a safe</a></li>
<li><a href="../439792/index.html">NASA is looking for partners in the American industry to create a partially reusable manned lender</a></li>
<li><a href="../439794/index.html">Back pain - understanding from the perspective of modern medicine</a></li>
<li><a href="../439796/index.html">Spring Boot 2: what is not written in release notes</a></li>
<li><a href="../439800/index.html">RISEX and Julia. 5 stages of love customer and designer</a></li>
<li><a href="../439806/index.html">Valid SSL domain names for local Docker containers</a></li>
<li><a href="../439808/index.html">The biggest telescopes. From a notebook and eyes to 340 megapixel cameras and data centers. Part 1</a></li>
<li><a href="../439810/index.html">Get acquainted with the Moleculer microservice framework</a></li>
<li><a href="../439816/index.html">Practical blockchain in business</a></li>
<li><a href="../439818/index.html">Features of approaches to design in the real manufacturing sector</a></li>
<li><a href="../439820/index.html">We are trying to write a project alone. Introduction</a></li>
<li><a href="../439822/index.html">Creating an alternative display for the Ensoniq EPS16 + and ASR10 synthesizer / sampler</a></li>
<li><a href="../439824/index.html">When will the JavaScript frameworks disappear?</a></li>
<li><a href="../439826/index.html">Disable analog. What will happen to the TV?</a></li>
<li><a href="../439828/index.html">The network appeared "analog" Findface</a></li>
<li><a href="../439840/index.html">Conference DUMP-2019: we invite you to speak in the sections Design, Management and Testing</a></li>
<li><a href="../439852/index.html">Remote control application release: Aspia 1.1.0</a></li>
<li><a href="../439858/index.html">Prometheus + Grafana + Node Exporter + Docker in Azure with notifications in Telegram</a></li>
<li><a href="../439862/index.html">Digital events in Moscow from February 11 to 17</a></li>
<li><a href="../439866/index.html">Principles of design reference books in 1C Enterprise Management 2 (ERP 2.4.6)</a></li>
<li><a href="../439868/index.html">Life without Facebook: less radical views, good mood, more time for loved ones. Now proven by science</a></li>
<li><a href="../439878/index.html">Creation of architecture for a new high-load startup in 2019</a></li>
<li><a href="../439880/index.html">Security Week 07: Local IoT Device Vulnerabilities</a></li>
<li><a href="../439886/index.html">How I trained the neural network to implement the position estimation function on the Russian AI Cup CodeBall 2018</a></li>
<li><a href="../439894/index.html">How easy it is to monitor the site</a></li>
<li><a href="../439900/index.html">Julia and the method of coordinate descent</a></li>
<li><a href="../439902/index.html">Explaining the physical essence of the Wing Lift phenomenon without using the Bernouli equation. Part 2</a></li>
<li><a href="../439906/index.html">Critical vulnerability in Zemana products and not only</a></li>
<li><a href="../439908/index.html">Kohl, piss off ... Coax</a></li>
<li><a href="../439912/index.html">Unsolved mystery of view</a></li>
<li><a href="../439916/index.html">Unpacking: Dridex bootloader</a></li>
<li><a href="../439922/index.html">Taxation of IP in Kazakhstan how to be a freelancer?</a></li>
<li><a href="../439924/index.html">The volume of parcels from foreign online stores grew by 25%</a></li>
</ul></nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>