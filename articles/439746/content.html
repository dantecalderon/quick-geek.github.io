<div class="post__text post__text-html js-mediator-article">  Good day, Habr!  I present to you the translation of the article <a href="https://blog.bitsrc.io/understanding-promises-in-javascript-c5248de9ff8f">“Understanding Promises in JavaScript”</a> by Sukhjinder Arora. <br><br><img src="https://habrastorage.org/webt/ox/6m/oa/ox6moan9gwhmc2oouqbhyfzumtm.png"><br><a name="habracut"></a><br>  <i>From the author of the translation: Just like the author himself, I hope that the article was useful for you.</i>  <i>Please, if she really helped you learn something new for yourself, then do not be lazy to go to the original article and thank the author!</i>  <i>I will be glad to your feedback!</i> <i><br><br></i>  <i><a href="https://habr.com/ru/post/439620/">Link to the translation of the article on asynchronous JavaScript from the same author</a> .</i> <br><br>  JavaScript is a single-threaded programming language, which means that one thing can be executed at once.  Before ES6, we used callbacks to manage asynchronous tasks, such as a network request. <br><br>  Using promises, we can avoid the “hell of callbacks” and make our code cleaner, more readable and easier to understand. <br><br>  Suppose we want to asynchronously get some data from the server using callbacks, we would do something like this: <br><br><pre><code class="javascript hljs">getData(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(x); getMoreData(x, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">y</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(y); getSomeMoreData(y, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">z</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(z); }); }); });</code> </pre> <br>  Here I request some data from the server using the <i>getData ()</i> function, which gets the data inside the callback function.  Inside the callback function, I request additional data by calling the <i>getMoreData ()</i> function, passing previous data as an argument, and so on. <br><br>  This is what we call the “callback hell”, where each callback is nested inside the other, and each internal callback depends on its parent. <br><br>  We can rewrite the above fragment using promises: <br><br><pre> <code class="javascript hljs">getData() .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(x); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getMoreData(x); }) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">y</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getSomeMoreData(y); }) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">z</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(z); });</code> </pre> <br>  You can see what has become more readable than in the case of the first example with callbacks. <br><br><h2>  What are Promises? </h2><br>  Promis (Promise) is an object that contains the future value of an asynchronous operation.  For example, if you request some data from the server, promise promises us to get this data, which we can use in the future. <br><br>  Before plunging into all these technical things, let's look at the terminology of the promises. <br><br><h3>  States of promises </h3><br>  Promis in JavaScript, like a promise in real life, has 3 states.  This can be 1) unresolved (pending), 2) resolved / resolved (3) or 3) rejected. <br><br><img src="https://habrastorage.org/webt/pk/hr/zz/pkhrzzgtdsgqvtptwn26gmtbjhk.png"><br><br>  <b>Unsolved or Pending</b> - Promis waits if the result is not ready.  That is, it expects the completion of something (for example, the completion of an asynchronous operation). <br>  <b>Solved or Executed</b> - Promis resolved if the result is available.  That is, something completed its execution (for example, an asynchronous operation) and everything went well. <br>  <b>Rejected</b> - Promis rejected if an error occurred during execution. <br><br>  Now that we know what Promis and its terminology are, let's go back to the practical part of promises. <br><br><h3>  Create a Promise </h3><br>  In most cases, you will simply use promises rather than create them, but it is still important to know how they are created. <br><br>  Syntax: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { ... });</code> </pre> <br>  We have created a new promise using the constructor constructor, it accepts one argument, a callback, also known as an executive function, which accepts 2 callbacks, <i>resolve</i> and <i>reject</i> . <br><br>  The executive function is performed immediately after the creation of the promise.  Promis is executed by calling <i>resolve ()</i> , and rejected by <i>reject ()</i> .  For example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(allWentWell) { resolve(<span class="hljs-string"><span class="hljs-string">'Все прошло отлично!'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Что-то пошло не так'</span></span>); } });</code> </pre> <br>  <i>The resolve ()</i> and <i>reject ()</i> take one argument, which can be a string, a number, a logical expression, an array, or an object. <br><br>  Let's take a look at another example to fully understand how promises are created. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> randomNumber = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random(); setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(randomNumber &lt; <span class="hljs-number"><span class="hljs-number">.6</span></span>) { resolve(<span class="hljs-string"><span class="hljs-string">'Все прошло отлично!'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Что-то пошло не так'</span></span>); } }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); });</code> </pre> <br>  Here I created a new promise using the designer Promisov.  Promis is executed or rejected 2 seconds after its creation.  A prompt is executed if <i>randomNumber is</i> less than .6 and is rejected in other cases. <br><br>  When the promise has been created, it will be in a wait state and its value will be <i>undefined</i> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cs/wr/c2/cswrc2jdrixhaguff2w9oijiyf4.png"></div><br>  After 2 seconds, the timer ends, promis randomly either executed or rejected, and its value will be the one passed to the function <i>resolve</i> or <i>reject</i> .  Below is an example of two cases: <br><br>  Successful implementation: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tp/zy/pq/tpzypq48va7fl8lbt_hkrmipquy.png"></div><br>  Promise rejection: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ng/4p/aa/ng4paaepwrz1oo_2o5l6nuazms4.png"></div><br>  <b>Note:</b> Promis can only be executed or rejected once.  Further calls of <i>resolve ()</i> or <i>reject ()</i> will not affect the state of promis.  Example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise resolved'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Промис выполнен reject('Promise rejected'); // Промис уже не может быть отклонен });</span></span></code> </pre> <br>  Since <i>resolve ()</i> was called first, the promise now turns out to be “executed”.  A subsequent call to <i>reject ()</i> will not affect the state of the promise. <br><br><h3>  Using Promise </h3><br>  Now we know how to create promises, let's now figure out how to apply the already created promises.  We use promises using the <i>then ()</i> and <i>catch ()</i> methods. <br><br>  For example, querying data from an API using <i>fetch</i> , which returns a promise. <br><br>  <i>.then ()</i> <b>syntax:</b> <i>promise.then (successCallback, failureCallback)</i> <br><br>  <i>successCallback</i> is called if the promise was successfully completed.  Takes one argument, which is the value passed to <i>resolve ()</i> . <br><br>  <i>failureCallback</i> is called if the promise was rejected.  Accepts one argument, which is the value of a devotee in <i>reject ()</i> . <br><br>  Example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> randomNumber = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(randomNumber &lt; <span class="hljs-number"><span class="hljs-number">.7</span></span>) { resolve(<span class="hljs-string"><span class="hljs-string">'Все прошло отлично!'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Что-то пошло не так'</span></span>)); } }); promise.then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); <span class="hljs-comment"><span class="hljs-comment">// вывести 'Все прошло отлично!' }, (error) =&gt; { console.log(error); // вывести ошибку } );</span></span></code> </pre> <br>  If the promise was executed, then <i>successCallback</i> is <i>called</i> with the value passed to <i>resolve ()</i> .  And if the promise was rejected, then <i>failureCallback</i> is <i>called</i> with the value passed to reject (). <br><br>  <i>.catch ()</i> <b>syntax:</b> <i>promise.catch (failureCallback)</i> <br><br>  We use <i>catch ()</i> for error handling.  This is more readable than error handling inside <i>failureCallback</i> inside the <i>then ()</i> method callback. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Something went wrong'</span></span>)); }); promise .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); }) .catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error); <span class="hljs-comment"><span class="hljs-comment">// вывести ошибку });</span></span></code> </pre> <br><h3>  Chain of promises </h3><br>  The <i>then ()</i> and <i>catch ()</i> methods can also return a new promise, which can be processed by a chain of other then () at the end of the previous then () method. <br><br>  We use a chain of promises when we want to perform a sequence of promises. <br><br>  For example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 выполнен'</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise2 выполнен'</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Promise3 отклонен'</span></span>); }); promise1 .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); <span class="hljs-comment"><span class="hljs-comment">// Promise1 выполнен return promise2; }) .then((data) =&gt; { console.log(data); // Promise2 выполнен return promise3; }) .then((data) =&gt; { console.log(data); }) .catch((error) =&gt; { console.log(error); // Promise3 отклонен });</span></span></code> </pre> <br><h4>  And so, what is happening here? </h4><br>  When <i>promise1 is</i> executed, the <i>then ()</i> method is called <i>,</i> which returns promise2. <br>  Then, when <i>promise2 is</i> executed, <i>then ()</i> is called again and returns <i>promise3</i> . <br><br>  Since promise3 is rejected, instead of the next <i>then ()</i> , <i>catch ()</i> is called, which handles the <i>promise3 rejection</i> . <br><br>  <b>Note:</b> As a rule, one <i>catch ()</i> method is enough to handle the rejection of any of the promises in the chain, if this method is at the end of it. <br><br><h4>  Common mistake </h4><br>  Quite a lot of newbies make a mistake by putting some promises inside the others.  For example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 выполнен'</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise2 выполнен); }); const promise3 = new Promise((resolve, reject) =&gt; { reject('</span></span>Promise3 отклонен<span class="hljs-string"><span class="hljs-string">'); }); promise1.then((data) =&gt; { console.log(data); // Promise1 выполнен promise2.then((data) =&gt; { console.log(data); // Promise2 выполнен promise3.then((data) =&gt; { console.log(data); }).catch((error) =&gt; { console.log(error); // Promise3 отклонен }); }).catch((error) =&gt; { console.log(error); }) }).catch((error) =&gt; { console.log(error); });</span></span></code> </pre> <br>  Although this will work fine, it is considered a bad style and makes the code less readable.  If you have a sequence of promises to perform, it would be better to put them one after the other than to put one inside the other. <br><br><h3>  Promise.all () </h3><br>  This method takes an array of promises and returns a new promise that will be executed when all the promises within the array are completed or rejected as soon as the promise that is rejected is encountered.  For example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 выполнен'</span></span>); }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise2 выполнен'</span></span>); }, <span class="hljs-number"><span class="hljs-number">1500</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([promise1, promise2]) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data[<span class="hljs-number"><span class="hljs-number">0</span></span>], data[<span class="hljs-number"><span class="hljs-number">1</span></span>])) .catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error));</code> </pre> <br>  Here, the argument inside <i>then ()</i> is an array that contains the values ​​of the promises in the same order in which they were passed to <i>Promise.all ()</i> . (Only if all promises are executed) <br><br>  The promis is rejected with the reason for the rejection of the first promis in the transmitted array.  For example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 resolved'</span></span>); }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Promise2 rejected'</span></span>); }, <span class="hljs-number"><span class="hljs-number">1500</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([promise1, promise2]) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data[<span class="hljs-number"><span class="hljs-number">0</span></span>], data[<span class="hljs-number"><span class="hljs-number">1</span></span>])) .catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error)); <span class="hljs-comment"><span class="hljs-comment">// Promise2 отклонен</span></span></code> </pre> <br>  Here we have two promises, where one runs after 2 seconds and the other deflects after 1.5 seconds.  As soon as the second promise is rejected, returned from <i>Promise.all () the</i> promise is rejected without waiting for the first one to be executed. <br><br>  This method can be useful when you have more than one promise and you want to know when all promises are completed.  For example, if you are requesting data from a third-party API and you want to do something with this data only when all requests are successful. <br><br>  As a result, we have <i>Promise.all ()</i> , which is waiting for the successful execution of all promises, or terminates its execution when it detects the first failure in the array of promises. <br><br><h3>  Promise.race () </h3><br>  This method accepts an array of promises and returns one new promise, which will be executed as soon as the completed promise is encountered in the array or is rejected if the rejected promise is encountered earlier.  For example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 resolved'</span></span>); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Promise2 rejected'</span></span>); }, <span class="hljs-number"><span class="hljs-number">1500</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.race([promise1, promise2]) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data)) <span class="hljs-comment"><span class="hljs-comment">// Promise1 выполнен .catch((error) =&gt; console.log(error));</span></span></code> </pre> <br>  Here we have two promises, where one runs after 1 second, and the other deflects after 1.5 seconds.  As soon as the first promise is completed, the promise returned from Promise.race () will have the status completed without waiting for the second promise status. <br><br>  Here, the <i>data</i> that is passed to <i>then ()</i> is the value of the first, executed, promise. <br><br>  At the end, <i>Promise.race ()</i> waits for the first promise and takes its status as the status of the returned promise. <br><br>  <i>Comment author of the translation: Hence the actual name.</i>  <i>Race - race</i> <br><br><h2>  Conclusion </h2><br>  We learned what PROMIS are and what they eat in JavaScript.  Promises are made up of two parts 1) Creating promises and 2) Using promises.  Most of the time, you will use promises rather than create them, but it is important to know how they are created. <br><br>  That's all, I hope this article was useful for you! </div>