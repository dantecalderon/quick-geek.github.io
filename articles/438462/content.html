<div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/dcc/b3a/ec7/dccb3aec71cce1cd9dde70221c7fe132.jpg"><br><br>  Translated for you by <a href="https://medium.com/%40brandonwever/android-notifications-in-5-minutes-4d16d39894a1">Brandon Weaver</a> 's <a href="https://medium.com/%40brandonwever/android-notifications-in-5-minutes-4d16d39894a1">article</a> on working with notifications in the Android OS.  The programmer explains how to quickly add this functionality to your application.  The article, first of all, will be useful to novice Android developers. <br><br>  Notifications - one of the easiest and fastest ways to make your application more interactive, which will attract more users.  Notifications provide the user with brief information about what they may need right now.  It is also a way to inform about upcoming events.  Let's try to quickly add this feature to the app. <br><a name="habracut"></a><br><blockquote>  <b>Skillbox recommends:</b> Applied online course <a href="https://skillbox.ru/python-data/%3Futm_source%3Dskillbox.media%26utm_medium%3Dhabr.com%26utm_campaign%3DPTNANA%26utm_content%3Darticles%26utm_term%3Dandroidnotifications">"Python Data Analyst"</a> . <br><br>  <b>We remind:</b> <i>for all readers of "Habr" - a discount of 10,000 rubles when recording for any Skillbox course on the promotional code "Habr".</i> </blockquote><br><h3>  Create notification </h3><br>  The first step is to create a “Notification” object.  For this we use NotificationCompat.Builder.  The minimum notification content allowed by Android developers is a small icon.  This is good, but small and not very useful for the user.  Below is a standard notification scheme, which is well perceived. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4cc/eaf/f6f/4cceaff6f71d4b967bbcf91f2d566407.png"><br><br>  A small icon will be displayed constantly, and it is important to make it alpha-transparent.  Without this, instead of the icon, you get a white box. <br><br>  The notification header is also important.  This should be a short description, allowing you to understand why the user is worried at all. <br><br>  The body of the notification contains a detailed text with all the necessary information. <br><br>  A large icon can be a company logo or something else. <br><br>  Below are two options for the user. <br><br>  To display all this you need a short code: <br><br><pre><code class="java hljs">.setSmallIcon(R.drawable.ic_announcement) .setContentTitle(title) .setContentText(body) .build()</code> </pre> <br><h3>  Demonstrate notification </h3><br>  We created our notification, now the task is to show it.  Android makes it possible to do this with the help of NotificationManagerCompat.  To send a notification, you must use the notificationID and the notification itself. <br><br><pre> <code class="java hljs">with(NotificationManagerCompat.from(context)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getNotificationChannel(CHANNEL_ID) == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { createNotificationChannel(context) } notify(notificationId, builder.build()) }</code> </pre> <br>  Additional code is needed to check the existence of the notification channel. <br><br><h3>  Channels and importance </h3><br>  For the first time, the user was able to select the types of notifications from their applications in Oreo.  Creating multiple channels is important because if everything goes through the same channel, the user will not be able to select the types of notifications he needs and will block everything. <br><br><pre> <code class="java hljs">teNotificationChannel(context: Context) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) { val name = context.getString(R.string.channel_name) val descriptionText = context.getString(R.string.channel_description) val importance = NotificationManager.IMPORTANCE_HIGH val channel = NotificationChannel(CHANNEL_ID, name, importance).apply { description = descriptionText } NotificationManagerCompat.from(context).createNotificationChannel(channel) } }</code> </pre> <br>  The channel should include the following information: <br><br><ul><li>  ID - channel identifier; </li><li>  name - it should be short, for example, "Messages"; </li><li>  importance - it can be high, by default, low or minimal; </li><li>  Description - it will be displayed in the Android settings.  The developer should take care of the quality of the description. </li></ul><br><h3>  User interaction </h3><br>  There are several ways for a user to interact with notifications.  Fortunately, the APIs that allow you to control the process are quite similar.  Intents and PendingIntents are used to provide feedback to the application, providing a specific processing logic. <br><br>  The easiest way to handle a large number of notifications is to use BroadcastReceiver.  When the user starts interacting with the notification, the Intent will work and the onReceive method of BroadcastReceiver will be called. <br><br><pre> <code class="java hljs">val builder = NotificationCompat.Builder(context, CHANNEL_ID) ... .setContentIntent(onContentTapped <span class="hljs-comment"><span class="hljs-comment">/** Pending intent */</span></span>) .setDeleteIntent(onSwipedAway <span class="hljs-comment"><span class="hljs-comment">/** Pending intent */</span></span>) .addAction( R.drawable.ic_announcement, actionTitle, onActionTapped <span class="hljs-comment"><span class="hljs-comment">/** Pending intent */</span></span> )</code> </pre> <br>  ContentIntent will be launched by clicking on the notification.  It is worth remembering that the notification will not be rejected unless you call setAutoCancel (true) in it. <br>  DeleteIntent will run after the user deletes the notification. <br>  Actions are buttons at the bottom of the notification.  They also have badges and names. <br><br>  To create a BroadcastReceiver, you need to extend the BroadcastReceiver class, override the onReceive method, and remember to declare Receiver in AndroidManifest.xml. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NotificationBroadcastReceiver</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BroadcastReceiver</span></span></span><span class="hljs-class">() </span></span>{ <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onReceive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context: Context, intent: Intent)</span></span></span><span class="hljs-function"> </span></span>{ val action = intent.<span class="hljs-function"><span class="hljs-function">action </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">when</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action)</span></span></span><span class="hljs-function"> </span></span>{ ACTION_ONE -&gt; { Toast.makeText(context, <span class="hljs-string"><span class="hljs-string">"Action One hit!"</span></span>, Toast.LENGTH_SHORT).show() } ACTION_TWO -&gt; { Toast.makeText(context, <span class="hljs-string"><span class="hljs-string">"Action Two hit!"</span></span>, Toast.LENGTH_SHORT).show() } } } } object NotificationController { <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pendingIntent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context: Context, name: String, extras: Bundle?)</span></span></span><span class="hljs-function">: PendingIntent </span></span>{ val intent = Intent(context, NotificationBroadcastReceiver::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">).</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">apply</span></span></span><span class="hljs-class"> </span></span>{ action = <span class="hljs-function"><span class="hljs-function">name </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">putExtra</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(EXTRA_NOTIFICATION_ID, extras)</span></span></span><span class="hljs-function"> } return PendingIntent.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBroadcast</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, intent, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> } }</span></span></code> </pre> <br>  NotificationController is a fast tool for creating PendingIntents for notifications.  The most important thing is to set different names for actions in order to correctly handle user reactions to the notification.  Also, if you are going to launch an Activity from BroadcastReceiver, you must use the NEW_TASK IntentFlag. <br><br>  This is needed to process all notifications in one place.  Intents can also be registered for different BroadcastReceivers, so you can limit the scope to one BroadcastReceiver for each type of notification. <br><br>  All this is just the beginning of work.  There are many great examples in the documentation, so don't forget to study it if you have questions or a desire to do something more advanced. <br><blockquote>  <b>Skillbox recommends:</b> <br><br><ul><li>  Practical course <a href="https://skillbox.ru/agima/%3Futm_source%3Dskillbox.media%26utm_medium%3Dhabr.com%26utm_campaign%3DAGIMA%26utm_content%3Darticles%26utm_term%3Dandroidnotifications">"Mobile Developer PRO"</a> . </li><li>  Online course <a href="https://skillbox.ru/webdev/%3Futm_source%3Dskillbox.media%26utm_medium%3Dhabr.com%26utm_campaign%3DWEBDEV%26utm_content%3Darticles%26utm_term%3Dandroidnotifications">"Profession Web Developer"</a> . </li><li>  Two-year practical course <a href="https://iamwebdev.skillbox.ru/%3Futm_source%3Dskillbox.media%26utm_medium%3Dhabr.com%26utm_campaign%3DWEBDEVPRO%26utm_content%3Darticles%26utm_term%3Dandroidnotifications">"I am a web developer PRO"</a> . </li></ul></blockquote></div>