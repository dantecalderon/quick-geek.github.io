<div class="post__text post__text-html js-mediator-article">  I present to your attention a tutorial for generating accesses to the Kubernetes cluster using Dex, dex-k8s-authenticator and GitHub. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h8/uw/rg/h8uwrgvmlknxik99srgsgiokrbu.png" alt="image"></div><br>  <i>Local meme from Kubernetes Russian-language chat in <a href="https://t.me/kubernetes_ru">Telegram</a></i> <br><a name="habracut"></a><br><h3>  Introduction </h3><br>  We use Kubernetes to create dynamic environments for the development team and QA.  Thus, we want to give them access to the cluster for both dashboards and kubectl.  Unlike OpenShift, vanilla Kubernetes does not have native authentication, so we use third-party tools for this. <br><br>  In this configuration, we use: <br><br><ul><li>  <a href="https://github.com/mintel/dex-k8s-authenticator">dex-k8s-authenticator</a> - web application for generating the kubectl config </li><li>  <a href="https://github.com/dexidp/dex">Dex</a> - OpenID Connect Provider </li><li>  GitHub - just because we use GitHub in our company </li></ul><br>  We tried to use Google OIDC, but unfortunately we <a href="https://github.com/dexidp/dex/issues/1065">could not</a> get them with the groups, so the integration with GitHub completely satisfied us.  Without group mapping, itâ€™s not possible to create group-based RBAC policies. <br><br>  So, how does our authorization process in Kubernetes work in a visual representation: <br><br><img src="https://habrastorage.org/webt/4w/r4/tm/4wr4tmnconxmm4jctqba0cugq3u.png" alt="image"><br>  <i>Authorization process</i> <br><br>  A little more detail and the points: <br><br><ol><li> User logs in to dex-k8s-authenticator ( <code>login.k8s.example.com</code> ) </li><li>  dex-k8s-authenticator redirects the request to Dex ( <code>dex.k8s.example.com</code> ) </li><li>  Dex redirects to the GitHub login page. </li><li>  GitHub generates the necessary authorization information and returns it to Dex </li><li>  Dex transmits the received information to the dex-k8s-authenticator </li><li>  User gets OIDC token from github </li><li>  dex-k8s-authenticator adds a token to kubeconfig </li><li>  kubectl transfers a token to KubeAPIServer </li><li>  KubeAPIServer, based on the transferred token, returns access to kubectl </li><li>  User gets access from kubectl </li></ol><br><h3>  Preparatory actions </h3><br>  Of course, we already have the Kubernetes cluster ( <code>k8s.example.com</code> ) installed, and also the HELM pre-installed.  We also have an organization on GitHub (super-org). <br>  If you do not have HELM, it is <a href="https://docs.helm.sh/using_helm/">very easy to</a> install. <br><br>  First we need to set up GitHub. <br><br>  Go to the organization's settings page ( <code>https://github.com/organizations/super-org/settings/applications</code> ) and create a new application (Authorized OAuth App): <br><img src="https://habrastorage.org/webt/9r/yo/5a/9ryo5atriau2yxzbetbzisdkawc.png" alt="image"><br>  <i>Creating a new application in GitHub</i> <br><br>  Fill in the fields with the required URLs, for example: <br><br><ul><li>  Homepage URL: <code>https://dex.k8s.example.com</code> </li><li>  Authorization callback URL: <code>https://dex.k8s.example.com/callback</code> </li></ul><br>  <i>Be careful with links, it is important not to lose slashes.</i> <br><br>  In response to the completed form, GitHub will generate a <code>Client ID</code> and <code>Client secret</code> , save them in a safe place, they will be useful to us (for example, we use <a href="https://www.vaultproject.io/">Vault</a> to store secrets): <br><br><pre> <code class="plaintext hljs">Client ID: 1ab2c3d4e5f6g7h8 Client secret: 98z76y54x32w1</code> </pre> <br>  Prepare DNS records for subdomains <code>login.k8s.example.com</code> and <code>dex.k8s.example.com</code> , as well as SSL certificates for ingress. <br><br>  Create SSL certificates: <br><br><pre> <code class="plaintext hljs">cat &lt;&lt;EOF | kubectl create -f - apiVersion: certmanager.k8s.io/v1alpha1 kind: Certificate metadata: name: cert-auth-dex namespace: kube-system spec: secretName: cert-auth-dex dnsNames: - dex.k8s.example.com acme: config: - http01: ingressClass: nginx domains: - dex.k8s.example.com issuerRef: name: le-clusterissuer kind: ClusterIssuer --- apiVersion: certmanager.k8s.io/v1alpha1 kind: Certificate metadata: name: cert-auth-login namespace: kube-system spec: secretName: cert-auth-login dnsNames: - login.k8s.example.com acme: config: - http01: ingressClass: nginx domains: - login.k8s.example.com issuerRef: name: le-clusterissuer kind: ClusterIssuer EOF kubectl describe certificates cert-auth-dex -n kube-system kubectl describe certificates cert-auth-login -n kube-system</code> </pre> <br>  ClusterIssuer with the name <code>le-clusterissuer</code> should already exist, but if not, create it with HELM: <br><br><pre> <code class="plaintext hljs">helm install --namespace kube-system -n cert-manager stable/cert-manager cat &lt;&lt; EOF | kubectl create -f - apiVersion: certmanager.k8s.io/v1alpha1 kind: ClusterIssuer metadata: name: le-clusterissuer namespace: kube-system spec: acme: server: https://acme-v02.api.letsencrypt.org/directory email: k8s-admin@example.com privateKeySecretRef: name: le-clusterissuer http01: {} EOF</code> </pre> <br><h3>  KubeAPIServer configuration </h3><br>  For kubeAPIServer to work, you need to configure the OIDC and update the cluster: <br><br><pre> <code class="plaintext hljs">kops edit cluster ... kubeAPIServer: anonymousAuth: false authorizationMode: RBAC oidcClientID: dex-k8s-authenticator oidcGroupsClaim: groups oidcIssuerURL: https://dex.k8s.example.com/ oidcUsernameClaim: email kops update cluster --yes kops rolling-update cluster --yes</code> </pre> <br>  We use <a href="https://github.com/kubernetes/kops">kops</a> to deploy clusters, but this works similarly for <a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/">other cluster managers</a> . <br><br><h3>  Dex and dex-k8s-authenticator configuration </h3><br>  For Dex to work, you must have a certificate and a key from the Kubernetes wizard, which will pull it out of there: <br><br><pre> <code class="plaintext hljs">sudo cat /srv/kubernetes/ca.{crt,key} -----BEGIN CERTIFICATE----- AAAAAAAAAAABBBBBBBBBBCCCCCC -----END CERTIFICATE----- -----BEGIN RSA PRIVATE KEY----- DDDDDDDDDDDEEEEEEEEEEFFFFFF -----END RSA PRIVATE KEY-----</code> </pre> <br>  Clone the dex-k8s-authenticator repository: <br><br><pre> <code class="plaintext hljs">git clone git@github.com:mintel/dex-k8s-authenticator.git cd dex-k8s-authenticator/</code> </pre> <br>  With the help of values-files we can flexibly set variables for our <a href="https://github.com/mintel/dex-k8s-authenticator/tree/master/charts">HELM-charts</a> . <br><br>  We describe the configuration for Dex: <br><br><pre> <code class="plaintext hljs">cat &lt;&lt; \EOF &gt; values-dex.yml global: deployEnv: prod tls: certificate: |- -----BEGIN CERTIFICATE----- AAAAAAAAAAABBBBBBBBBBCCCCCC -----END CERTIFICATE----- key: |- -----BEGIN RSA PRIVATE KEY----- DDDDDDDDDDDEEEEEEEEEEFFFFFF -----END RSA PRIVATE KEY----- ingress: enabled: true annotations: kubernetes.io/ingress.class: nginx kubernetes.io/tls-acme: "true" path: / hosts: - dex.k8s.example.com tls: - secretName: cert-auth-dex hosts: - dex.k8s.example.com serviceAccount: create: true name: dex-auth-sa config: | issuer: https://dex.k8s.example.com/ storage: # https://github.com/dexidp/dex/issues/798 type: sqlite3 config: file: /var/dex.db web: http: 0.0.0.0:5556 frontend: theme: "coreos" issuer: "Example Co" issuerUrl: "https://example.com" logoUrl: https://example.com/images/logo-250x25.png expiry: signingKeys: "6h" idTokens: "24h" logger: level: debug format: json oauth2: responseTypes: ["code", "token", "id_token"] skipApprovalScreen: true connectors: - type: github id: github name: GitHub config: clientID: $GITHUB_CLIENT_ID clientSecret: $GITHUB_CLIENT_SECRET redirectURI: https://dex.k8s.example.com/callback orgs: - name: super-org teams: - team-red staticClients: - id: dex-k8s-authenticator name: dex-k8s-authenticator secret: generatedLongRandomPhrase redirectURIs: - https://login.k8s.example.com/callback/ envSecrets: GITHUB_CLIENT_ID: "1ab2c3d4e5f6g7h8" GITHUB_CLIENT_SECRET: "98z76y54x32w1" EOF</code> </pre> <br>  And for dex-k8s-authenticator: <br><pre> <code class="plaintext hljs">cat &lt;&lt; EOF &gt; values-auth.yml global: deployEnv: prod dexK8sAuthenticator: clusters: - name: k8s.example.com short_description: "k8s cluster" description: "Kubernetes cluster" issuer: https://dex.k8s.example.com/ k8s_master_uri: https://api.k8s.example.com client_id: dex-k8s-authenticator client_secret: generatedLongRandomPhrase redirect_uri: https://login.k8s.example.com/callback/ k8s_ca_pem: | -----BEGIN CERTIFICATE----- AAAAAAAAAAABBBBBBBBBBCCCCCC -----END CERTIFICATE----- ingress: enabled: true annotations: kubernetes.io/ingress.class: nginx kubernetes.io/tls-acme: "true" path: / hosts: - login.k8s.example.com tls: - secretName: cert-auth-login hosts: - login.k8s.example.com EOF</code> </pre> <br>  Install Dex and dex-k8s-authenticator: <br><br><pre> <code class="plaintext hljs">helm install -n dex --namespace kube-system --values values-dex.yml charts/dex helm install -n dex-auth --namespace kube-system --values values-auth.yml charts/dex-k8s-authenticator</code> </pre> <br>  Check the service operability (Dex should return code 400, and dex-k8s-authenticator code 200): <br><br><pre> <code class="plaintext hljs">curl -sI https://dex.k8s.example.com/callback | head -1 HTTP/2 400 curl -sI https://login.k8s.example.com/ | head -1 HTTP/2 200</code> </pre> <br><h3>  RBAC configuration </h3><br>  Create a ClusterRole for the group, in our case with read-only access: <br><br><pre> <code class="plaintext hljs">cat &lt;&lt; EOF | kubectl create -f - apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: cluster-read-all rules: - apiGroups: - "" - apps - autoscaling - batch - extensions - policy - rbac.authorization.k8s.io - storage.k8s.io resources: - componentstatuses - configmaps - cronjobs - daemonsets - deployments - events - endpoints - horizontalpodautoscalers - ingress - ingresses - jobs - limitranges - namespaces - nodes - pods - pods/log - pods/exec - persistentvolumes - persistentvolumeclaims - resourcequotas - replicasets - replicationcontrollers - serviceaccounts - services - statefulsets - storageclasses - clusterroles - roles verbs: - get - watch - list - nonResourceURLs: ["*"] verbs: - get - watch - list - apiGroups: [""] resources: ["pods/exec"] verbs: ["create"] EOF</code> </pre> <br>  Create a configuration for the ClusterRoleBinding: <br><br><pre> <code class="plaintext hljs">cat &lt;&lt;EOF | kubectl create -f - apiVersion: rbac.authorization.k8s.io/v1beta1 kind: ClusterRoleBinding metadata: name: dex-cluster-auth namespace: kube-system roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: cluster-read-all subjects: - kind: Group name: "super-org:team-red" EOF</code> </pre> <br>  Now we are ready for testing. <br><br><h3>  Tests </h3><br>  Go to the login page ( <code>https://login.k8s.example.com</code> ) and log in using a GitHub account: <br><br><img src="https://habrastorage.org/webt/ub/vc/hi/ubvchi3ybq1vqhebfqyd3m13tzq.png" alt="image"><br>  <i>Login page</i> <br><br><img src="https://habrastorage.org/webt/9s/dv/pd/9sdvpdy1r7up9fyzhhow1cak0ru.png" alt="image"><br>  <i>Login page redirected to GitHub</i> <br><br><img src="https://habrastorage.org/webt/vx/s9/io/vxs9iotjf-be36hfwpr46dbhqfa.png" alt="image"><br>  <i>Follow the generated instructions for access</i> <br><br>  After copying from the web page, we can use kubectl to manage our cluster resources: <br><br><pre> <code class="plaintext hljs">kubectl get po NAME READY STATUS RESTARTS AGE mypod 1/1 Running 0 3d kubectl delete po mypod Error from server (Forbidden): pods "mypod" is forbidden: User "amet@example.com" cannot delete pods in the namespace "default"</code> </pre> <br>  And it works, all GitHub users in our organization can see the resources and go to the subs, but they have no rights to change them. </div>