<div class="post__text post__text-html js-mediator-article">  <i>Does your own or someone else's code slip away?</i> <i><br><br></i>  <i>Can't understand the algorithm?</i> <i><br><br></i>  <i>Spend a lot of time debugging, but you can’t find the wrong initialization, but do you want to enjoy coding?</i> <i><br><br></i>  <i>Remember the rules below and apply them!</i> <i><br></i> <br>  The article does not cover the basic rules for naming variables and functions, syntactic indents, or large-scale refactoring.  We consider 5 simple rules to simplify the code and reduce the load on the brain in the development process. <br><br>  Consider the process of perception of data in order to relate the described rules with the process of perception and determine the criteria for simple code. <br><br>  The simplified process of perception consists of the following steps: <br><br><ol><li>  Receiving through receptors data correlate with previous experience. </li><li>  If there is no correlation, it is noise.  Noise is quickly forgotten.  If there is something to correlate with, recognition of facts takes place. </li><li>  If the fact is important - we memorize, or we generalize, or we act, for example, we speak or type the code. </li><li>  A generalization is used to reduce the amount of memorized and analyzed information. </li><li>  After summarizing, the information is again correlated and analyzed (step 1). </li></ol><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qe/gs/0_/qegs0_rplnoxgz0angdzj7xsn-u.png"></div><br>  Scientists divide memory into short-term and long-term.  Short-term memory is small in volume, but retrieving and saving information performs instantly.  Short-term memory - brain cache.  It can store 7 + -2 words, numbers, items.  Long-term memory is more in volume, but it requires a lot of energy (effort) to store and retrieve information than short-term. <br><br>  Findings: <br><br><ul><li>  the less elements, the less energy is spent, </li><li>  it is required to reduce the number of perceived elements to 9, </li><li>  use less long-term memory as little as possible: summarize or forget. </li></ul><br>  We proceed to the description of the rules. <br><br>  <strong>Rule 1. We use the statement in conditions, we get rid of "not".</strong> <br><br>  Removing the "no" operator reduces the number of elements analyzed.  Also, in many programming languages, the “!” Operator is used for the negation operator.  This sign is easy to miss when reading the code. <br><br>  Compare: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!entity.IsImportAvaible) { <span class="hljs-comment"><span class="hljs-comment">//код 1 } else { //код 2 }</span></span></code> </pre> <br>  After: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entity.IsImportAvaible) { <span class="hljs-comment"><span class="hljs-comment">//код 2 } else { //код 1 }</span></span></code> </pre><br>  <strong>Rule 2. Reduce the level of nesting.</strong> <br><br>  While analyzing the code, each level of nesting is required to be kept in memory.  Reduce the number of levels - reduce the costs of fuel. <br><br>  Consider ways to reduce the number of nesting levels. <br><br>  1) Return management.  We cut off some of the cases and focus on the remaining ones. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conributor != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//код }</span></span></code> </pre><br>  Convert to <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(contributor == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//код</span></span></code> </pre><br>  or <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(условие <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(условие <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//код }</span></span></code> </pre><br>  or <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;условие <span class="hljs-number"><span class="hljs-number">1</span></span>;) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(условие <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//код }</span></span></code> </pre><br>  An advanced example is given in rule 5. Note the discard exception. <br><br>  2) the selection method.  The name of the function is the result of the generalization. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(условие рассылки) { foreach(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sender in senders) { sender.Send(message); } }</code> </pre><br>  at <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(условие рассылки) { SendAll(senders, message); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IEnumerable&lt;Sender&gt; senders, string message)</span></span></span><span class="hljs-function"> </span></span>{ foreach(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sender in senders) { sender.Send(message); } }</code> </pre><br>  3) Combining conditions. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (contributor == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (accessMngr == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//код } }</span></span></code> </pre><br>  at <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (contributor == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; accessMngr == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//код }</span></span></code> </pre><br>  4) The introduction of variables and the division into semantic blocks.  As a result, blocks can be changed independently, and most importantly, it is much easier to read and perceive such code.  One block - one functionality.  A frequent case is search with processing.  It is necessary to break the code into separate semantic blocks: element search, processing. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;array.length;i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (array[i] == findItem) { <span class="hljs-comment"><span class="hljs-comment">//обработка array[i] break; } }</span></span></code> </pre><br>  at <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;array.length;i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(array[i] == findItem) { foundItem =array[i]; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (foundItem != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//обработка foundItem }</span></span></code> </pre><br>  <strong>Rule 3. We get rid of indexers and hits through properties.</strong> <br><br>  Indexer is the operation of accessing an array element at index arr [index]. <br><br>  In the process of perception of the code, the brain operates with [] characters as delimiters, and the indexer as an expression. <br><br><pre> <code class="hljs matlab"><code class="java"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateActiveColumnsSetting</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fieldsGroups)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">var</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-function"> = {}; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(var i = 0; i &lt; fieldsGroups.length; i++)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">var</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fields</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fieldsGroups</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[i]</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fields</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(var j = 0; j &lt; fields.length; j++)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(!result[fieldsGroups[i].groupName])</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[fieldsGroups[j]</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">groupName</span></span></span><span class="hljs-function">] = {}; } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[fieldsGroups[i]</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">groupName</span></span></span><span class="hljs-function">]</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[fields[j]</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">field</span></span></span><span class="hljs-function">] = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createColumnAttributes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(j, fields[j].isActive)</span></span></span><span class="hljs-function">; } } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">JSON</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stringify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(result)</span></span></span><span class="hljs-function">; }</span></span></code></code> </pre><br>  Indexer - a place of frequent errors.  Due to short index names, it is very easy to confuse I, j or k. <br><br>  In the example above, in the line result [fieldsGroups [j] .groupName] = {};  mistake: <br>  j is used instead of i. <br><br>  In order to find out where the ith value is used, it is necessary to: <br><br>  1) visually select an array variable <br><br><pre> <code class="hljs matlab"><code class="java"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateActiveColumnsSetting</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fieldsGroups)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">var</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-function"> = {}; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(var i = 0; i &lt; fieldsGroups.length; i++)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">var</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fields</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fieldsGroups</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[i]</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fields</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(var j = 0; j &lt; fields.length; j++)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(!result[fieldsGroups[i].groupName])</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[fieldsGroups[j]</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">groupName</span></span></span><span class="hljs-function">] = {}; } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[fieldsGroups[i]</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">groupName</span></span></span><span class="hljs-function">]</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[fields[j]</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">field</span></span></span><span class="hljs-function">] = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createColumnAttributes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(j, fields[j].isActive)</span></span></span><span class="hljs-function">; } } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">JSON</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stringify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(result)</span></span></span><span class="hljs-function">; }</span></span></code></code> </pre><br>  2) analyze each occurrence for the use of the desired indexer I, j, i-1, j-1, etc., keeping in perception the place of use of the indexers and the already identified circulation. <br>  Selecting the indexer into a variable, reduce the number of dangerous places, and we can easily use the brain to perceive the variable, without the need for memorization. <br><br>  After processing: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateActiveColumnsSetting</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fieldsGroups)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> columnsGroups = {}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; fieldsGroups.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fieldsGroup = fieldsGroups[i]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> groupName = fieldsGroup.groupName; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> columnsGroup = columnsGroups[groupName]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!columnsGroup) { columnsGroup = columnsGroups[groupName] = {}; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fields = fieldsGroup.fields; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; fields.length; j++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fieldInfo = fields[j]; columnsGroup[fieldInfo.field] = createColumnAttributes(j, field.isActive); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> columnsGroups; }</code> </pre> <br>  Visual selection is much easier, and modern development environments and editors help by highlighting the substrings in different parts of the code. <br><br><pre> <code class="hljs actionscript"><code class="java"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateActiveColumnsSetting</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fieldsGroups)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> columnsGroups = {}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; fieldsGroups.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fieldsGroup = fieldsGroups[i]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> groupName = fieldsGroup.groupName; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> columnsGroup = columnsGroups[groupName]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!columnsGroup) { columnsGroup = columnsGroups[groupName] = {}; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fields = fieldsGroup.fields; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; fields.length; j++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fieldInfo = fields[j]; columnsGroup[fieldInfo.field] = createColumnAttributes(j, field.isActive); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> columnsGroups; }</code></code> </pre><br>  <strong>Rule 4. We group the blocks by meaning.</strong> <br><br>  We use the psychological effect of perception - “The proximity effect”: closely spaced figures are combined in perception.  Get the code prepared for analysis and synthesis in the process of perception, and reduce the amount of information stored in memory, you can arrange a number of lines, united by meaning or similar in functionality, separating them with an empty line. <br><br>  Before: <br><br><pre> <code class="hljs cs"><code class="java"><span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> abcFactInfo <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> abcFactInfos) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentFact = abcInfoManager.GetFact(abcFactInfo); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> percentage = GetPercentage(summaryFact, currentFact); abcInfoManager.SetPercentage(abcFactInfo, percentage); accumPercentage += percentage; abcInfoManager.SetAccumulatedPercentage(abcFactInfo, accumPercentage); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> category = GetAbcCategory(accumPercentage, categoryDictionary); abcInfoManager.SetCategory(abcFactInfo, category); }</code></code> </pre><br>  After: <br><br><pre> <code class="hljs cs"><code class="java"><span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> abcFactInfo <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> abcFactInfos) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentFact = abcInfoManager.GetFact (abcFactInfo); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> percentage = GetPercentage(summaryFact, currentFact); accumPercentage += percentage; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> category = GetAbcCategory(accumPercentage, categoryDictionary); abcInfoManager.SetPercentage(abcFactInfo, percentage); abcInfoManager.SetAccumulatedPercentage(abcFactInfo, accumPercentage); abcInfoManager.SetCategory(abcFactInfo, category); }</code></code> </pre><br>  In the upper example, 7 blocks, in the lower 3: getting values, accumulating in a loop, setting manager properties. <br><br>  Indentation is good to allocate places that are worth paying attention to.  So strings <br><br><pre> <code class="hljs nginx"><code class="java"><span class="hljs-attribute"><span class="hljs-attribute">accumPercentage</span></span> += percentage; <span class="hljs-attribute"><span class="hljs-attribute">var</span></span> category = GetAbcCategory(accumPercentage, categoryDictionary);</code></code> </pre><br>  In addition to dependence on previous calculations, they accumulate values ​​in the accumulatedPercentage variable.  To emphasize the differences, the code is indented. <br><br>  One of the special cases of the rule application is the declaration of local variables as close as possible to the place of use. <br><br>  <strong>Rule 5. Following the principle of uniqueness of responsibility.</strong> <br><br>  This is the first principle of SOLID in OOP, but in addition to classes it can be applied to projects, modules, functions, code blocks, project teams or individual developers.  When asking who or what is responsible for this area, it is immediately clear who or what.  One connection is always simple.  Each class is summarized to a single concept, phrase, metaphor.  As a result, less to remember, the process of perception is easier and more efficient. <br><br>  In conclusion, a comprehensive example: <br><br><pre> <code class="hljs pgsql"><code class="java">private PartnerState GetPartnerStateForUpdate( PartnerActivityInfo partner, <span class="hljs-keyword"><span class="hljs-keyword">Dictionary</span></span>&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>, PartnerState&gt; currentStates, <span class="hljs-keyword"><span class="hljs-keyword">Dictionary</span></span>&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>, PartnerState&gt; prevStates) { PartnerState updatingState; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prevStates.ContainsKey(partner.id)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentStates.ContainsKey(partner.id)) { var prevState = prevStates[partner.id]; updatingState = currentStates[partner.id]; //Код <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //Код <span class="hljs-number"><span class="hljs-number">2</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentStates.ContainsKey(partner.id)) { updatingState = currentStates[partner.id]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>(string.Format("Для партнера {0} не найдено текущее и предыдущее состояние на месяц {1}", partner.id, month)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> updatingState; }</code></code> </pre><br>  After replacing the ContainsKe indexers, inverting the branching, selecting the method and reducing the nesting levels, it turned out: <br><br><pre> <code class="hljs pgsql"><code class="java">private PartnerState GetPartnerStateForUpdate( PartnerActivityInfo partner, <span class="hljs-keyword"><span class="hljs-keyword">Dictionary</span></span>&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>, PartnerState&gt; currentStates, <span class="hljs-keyword"><span class="hljs-keyword">Dictionary</span></span>&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>, PartnerState&gt; prevStates) { PartnerState currentState = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; PartnerState prevState = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; prevStates.TryGetValue(partner.id, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> prevState); currentStates.TryGetValue(partner.id, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> currentState); currentState = CombineStates(currentState, prevState); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentState; } private PartnerState CombineStates( PartnerState currentState, PartnerState prevState) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentState == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; prevState == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>(string.Format( "Для партнера {0} не найдено текущее и предыдущее состояние на месяц {1}" , partner.id, month)); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentState == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { //Код <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prevState != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { //Код } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentState; }</code></code> </pre><br>  The first function is responsible for obtaining states from dictionaries, the second for combining them into a new one. <br><br>  The presented rules are simple, but in combination give a powerful tool to simplify the code and reduce the load on memory during the development process.  Always follow them will not work, but if you realize that you do not understand the code, the easiest way is to start with them.  They have helped the author more than once in the most difficult cases. </div>