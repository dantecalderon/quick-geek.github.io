<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Basics of Flutter Application Architecture: Vanilla, Scoped Model, BLoC</title>
  <meta name="description" content="(the original article in English is published on Medium ) 


 Flutter provides a modern jet framework, a large set of widgets and bodies. Unfortunatel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Basics of Flutter Application Architecture: Vanilla, Scoped Model, BLoC</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/2j/2p/yu/2j2pyudr-kde4fqeczqoic_9lpq.png"></p><br><p>  (the original article in English is published on <a href="https://link.medium.com/vxGf7jKtXT">Medium</a> ) </p><br><p>  Flutter provides a modern jet framework, a large set of widgets and bodies.  Unfortunately, there is nothing in the documentation that looks like a <a href="https://medium.com/%40savjolovs/flutter-app-architecture-101-vanilla-scoped-model-bloc-7eff7b2baf7e">guide to the recommended architecture of the Android application</a> . </p><br><p>  There is no ideal, universal architecture that could fit any conceivable requirements of the technical specification, but let's recognize that most of the mobile applications we are working on have the following functionality: </p><br><ol><li>  Request and download data. </li><li>  Transformation and preparation of data for the user. </li><li>  Write and read data from a database or file system. </li></ol><br><p>  Given all this, I created a demo application that solves the same problem using different approaches to architecture. <a name="habracut"></a></p><br><p>  Initially, the user is shown a screen with the ‚ÄúLoad user data‚Äù button located in the center.  When the user clicks a button, asynchronous data loading occurs, and the button is replaced with a loading indicator.  When data loading is complete, the load indicator is replaced with data. </p><br><p>  So, let's begin. </p><br><p><img src="https://habrastorage.org/webt/c5/by/8g/c5by8gjmz_oov-ukuy4_dwo4njs.gif"></p><br><h2 id="dannye">  Data </h2><br><p> To simplify the task, I created the <code>Repository</code> class, which contains the <code>getUser()</code> method.  This method simulates asynchronous data download from the network and returns <code>Future&lt;User&gt;</code> . </p><br><p>  If you are not familiar with Futures and asynchronous programming in Dart, you can read more about it <a href="https://www.dartlang.org/tutorials/language/futures">here</a> and get acquainted with the <a href="https://api.dartlang.org/stable/2.1.0/dart-async/Future-class.html">documentation of the Future class</a> . </p><br><pre> <code class="plaintext hljs">class Repository { Future&lt;User&gt; getUser() async { await Future.delayed(Duration(seconds: 2)); return User(name: 'John', surname: 'Smith'); } }</code> </pre> <br><pre> <code class="plaintext hljs">class User { User({ @required this.name, @required this.surname, }); final String name; final String surname; }</code> </pre> <br><h2 id="vanilla">  Vanilla </h2><br><p>  Let's develop the application, as a developer would do if he read the Flutter documentation on the official website. </p><br><p>  Open <code>VanillaScreen</code> with <code>Navigator</code> </p><br><pre> <code class="plaintext hljs">Navigator.push( context, MaterialPageRoute( builder: (context) =&gt; VanillaScreen(_repository), ), );</code> </pre> <br><p>  Since the state of the widget can change several times during its life cycle, we need to inherit from <code>StatefulWidget</code> .  To implement your stateful widget, you also need the <code>State</code> class.  The <code>bool _isLoading</code> and <code>User _user</code> fields in the <code>_VanillaScreenState</code> class represent the widget state.  Both fields are initialized before the <code>build(BuildContext context)</code> method is called for the first time. </p><br><pre> <code class="plaintext hljs">class VanillaScreen extends StatefulWidget { VanillaScreen(this._repository); final Repository _repository; @override State&lt;StatefulWidget&gt; createState() =&gt; _VanillaScreenState(); } class _VanillaScreenState extends State&lt;VanillaScreen&gt; { bool _isLoading = false; User _user; @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Vanilla'), ), body: SafeArea( child: _isLoading ? _buildLoading() : _buildBody(), ), ); } Widget _buildBody() { if (_user != null) { return _buildContent(); } else { return _buildInit(); } } Widget _buildInit() { return Center( child: RaisedButton( child: const Text('Load user data'), onPressed: () { setState(() { _isLoading = true; }); widget._repository.getUser().then((user) { setState(() { _user = user; _isLoading = false; }); }); }, ), ); } Widget _buildContent() { return Center( child: Text('Hello ${_user.name} ${_user.surname}'), ); } Widget _buildLoading() { return const Center( child: CircularProgressIndicator(), ); } }</code> </pre> <br><p>  After the widget's status object is created, the <code>build(BuildContext context)</code> method is called to construct the UI.  All decisions about which widget should be displayed at the moment on the screen are made directly in the code of the UI declaration. </p><br><pre> <code class="plaintext hljs">body: SafeArea( child: _isLoading ? _buildLoading() : _buildBody(), )</code> </pre> <br><p>  In order to display the progress indicator when the user clicks the ‚ÄúLoad user details‚Äù button, we do the following. </p><br><pre> <code class="plaintext hljs">setState(() { _isLoading = true; });</code> </pre> <br><p>  From the documentation (translation): </p><br><blockquote>  Calling the setState () method notifies the framework that the internal state of this object has changed, and may affect the user interface in the subtree.  This causes the framework to call the build method of this state object. </blockquote><p>  This means that after calling the <code>setState()</code> method, the framework will again call the <code>build(BuildContext context)</code> method, which will <strong>re-create the entire widget tree</strong> .  Since the <code>_isLoading</code> field <code>_isLoading</code> changed to <code>true</code> , the <code>_buildBody()</code> method will be called instead of the <code>_buildBody()</code> method, and the progress indicator will be displayed on the screen. <br>  Exactly the same thing happens when we get a callback from <code>getUser()</code> and call the method <br>  <code>setState()</code> to assign new values ‚Äã‚Äãto the <code>_isLoading</code> and <code>_user</code> fields. </p><br><pre> <code class="plaintext hljs">widget._repository.getUser().then((user) { setState(() { _user = user; _isLoading = false; }); });</code> </pre> <br><h3 id="plyusy">  pros </h3><br><ol><li>  Low threshold of entry. </li><li>  No third party libraries are required. </li></ol><br><h3 id="minusy">  Minuses </h3><br><ol><li>  When the state of the widget changes, the widget tree is re-created each time. </li><li>  Violates the principle of sole responsibility.  The widget is responsible not only for creating the UI, but also for loading the data, business logic and state management. </li><li>  Decisions about exactly how to display the current state are made directly in the UI code.  If the state becomes more complex, then the readability of the code will greatly decrease. </li></ol><br><h2 id="scoped-model">  Scoped Model </h2><br><p>  Scoped Model is a <a href="https://pub.dartlang.org/packages/scoped_model">third-party library</a> .  Here's how the developers describe it: </p><br><blockquote>  A set of utilities that allow you to transfer the data model of the ancestor widget to all its descendants.  In addition to this, when these models change, all descendants that use the model will be re-created.  This library was originally taken from the <a href="https://en.wikipedia.org/wiki/Google_Fuchsia">Fuchsia</a> project code. </blockquote><p>  Let's create the same screen as in the previous example, but using the Scoped Model.  First we need to add the Scoped Model library to the project.  Add the <code>scoped_model</code> dependency to the <code>scoped_model</code> file in the <code>dependencies</code> section. </p><br><pre> <code class="plaintext hljs">scoped_model: ^1.0.1</code> </pre> <br><p>  Let's look at the <code>UserModelScreen</code> code and compare it with the previous example, in which we did not use the Scoped Model.  To make our model available for the descendants of the widget, it is necessary to wrap the widget and model in <code>ScopedModel</code> . </p><br><pre> <code class="plaintext hljs">class UserModelScreen extends StatefulWidget { UserModelScreen(this._repository); final Repository _repository; @override State&lt;StatefulWidget&gt; createState() =&gt; _UserModelScreenState(); } class _UserModelScreenState extends State&lt;UserModelScreen&gt; { UserModel _userModel; @override void initState() { _userModel = UserModel(widget._repository); super.initState(); } @override Widget build(BuildContext context) { return ScopedModel( model: _userModel, child: Scaffold( appBar: AppBar( title: const Text('Scoped model'), ), body: SafeArea( child: ScopedModelDescendant&lt;UserModel&gt;( builder: (context, child, model) { if (model.isLoading) { return _buildLoading(); } else { if (model.user != null) { return _buildContent(model); } else { return _buildInit(model); } } }, ), ), ), ); } Widget _buildInit(UserModel userModel) { return Center( child: RaisedButton( child: const Text('Load user data'), onPressed: () { userModel.loadUserData(); }, ), ); } Widget _buildContent(UserModel userModel) { return Center( child: Text('Hello ${userModel.user.name} ${userModel.user.surname}'), ); } Widget _buildLoading() { return const Center( child: CircularProgressIndicator(), ); } }</code> </pre> <br><p>  In the previous example, each time the widget changes state, the widget tree is completely re-created.  But do we really need to re-create the widget tree entirely (the whole screen)?  For example, AppBar does not change at all, and there is no point in recreating it.  Ideally, it is worth recreating only those widgets that should change in accordance with the change of state.  And Scoped Model can help us in this task. </p><br><p>  The <code>ScopedModelDescendant&lt;UserModel&gt;</code> widget is used to find <code>UserModel</code> in the widget tree.  It will automatically be recreated every time the <code>UserModel</code> reports that there has been a change. </p><br><p>  Another improvement is that <code>UserModelScreen</code> no longer responsible for managing state, business logic, and data loading. </p><br><p>  Let's look at the code of the class <code>UserModel</code> . </p><br><pre> <code class="plaintext hljs">class UserModel extends Model { UserModel(this._repository); final Repository _repository; bool _isLoading = false; User _user; User get user =&gt; _user; bool get isLoading =&gt; _isLoading; void loadUserData() { _isLoading = true; notifyListeners(); _repository.getUser().then((user) { _user = user; _isLoading = false; notifyListeners(); }); } static UserModel of(BuildContext context) =&gt; ScopedModel.of&lt;UserModel&gt;(context); }</code> </pre> <br><p>  Now <code>UserModel</code> contains and manages the state.  In order to notify listeners (and re-create descendants) that a change has occurred, you must call the <code>notifyListeners()</code> method. </p><br><h3 id="plyusy-1">  pros </h3><br><ol><li>  State management, business logic, and data loading are separated from UI code. </li><li>  Low threshold of entry. </li></ol><br><h3 id="minusy-1">  Minuses </h3><br><ol><li>  Dependence on a third-party library. </li><li>  If the model becomes complicated enough, it will be hard to keep track of when it is really necessary to call the <code>notifyListeners()</code> method to prevent unnecessary re-creation. </li></ol><br><h2 id="bloc">  BLoC </h2><br><p>  BLoC ( <strong>B</strong> usiness <strong>Lo</strong> gic <strong>C</strong> omponents) is a pattern recommended by Google developers.  Streams are used for state management and for state notification. </p><br><p>  <strong>For Android developers:</strong> You can imagine that <code>Bloc</code> is a <code>ViewModel</code> , and <code>StreamController</code> is <code>LiveData</code> .  This will make the following code easy to understand, since you are already familiar with the fundamentals. </p><br><pre> <code class="plaintext hljs">class UserBloc { UserBloc(this._repository); final Repository _repository; final _userStreamController = StreamController&lt;UserState&gt;(); Stream&lt;UserState&gt; get user =&gt; _userStreamController.stream; void loadUserData() { _userStreamController.sink.add(UserState._userLoading()); _repository.getUser().then((user) { _userStreamController.sink.add(UserState._userData(user)); }); } void dispose() { _userStreamController.close(); } } class UserState { UserState(); factory UserState._userData(User user) = UserDataState; factory UserState._userLoading() = UserLoadingState; } class UserInitState extends UserState {} class UserLoadingState extends UserState {} class UserDataState extends UserState { UserDataState(this.user); final User user; }</code> </pre> <br><p>  You can see from the code that it is no longer necessary to call additional methods to notify about state changes. </p><br><p>  I created 3 classes to represent possible states: </p><br><p>  <code>UserInitState</code> for the state when the user opens the screen with a button in the center. </p><br><p>  <code>UserLoadingState</code> for the state when the load indicator is displayed while data is being loaded. </p><br><p>  <code>UserDataState</code> for the state when the data is already loaded and shown on the screen. </p><br><p>  Passing a state in this way allows us to completely get rid of logic in the UI code.  In the Scoped Model example, we still checked whether the value of the <code>_isLoading</code> field <code>_isLoading</code> <code>true</code> or <code>false</code> to determine which widget to create.  In the case of BLoC, we pass the new state to the stream, and the only task of the <code>UserBlocScreen</code> widget <code>UserBlocScreen</code> create a UI for the current state. </p><br><pre> <code class="plaintext hljs">class UserBlocScreen extends StatefulWidget { UserBlocScreen(this._repository); final Repository _repository; @override State&lt;StatefulWidget&gt; createState() =&gt; _UserBlocScreenState(); } class _UserBlocScreenState extends State&lt;UserBlocScreen&gt; { UserBloc _userBloc; @override void initState() { _userBloc = UserBloc(widget._repository); super.initState(); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Bloc'), ), body: SafeArea( child: StreamBuilder&lt;UserState&gt;( stream: _userBloc.user, initialData: UserInitState(), builder: (context, snapshot) { if (snapshot.data is UserInitState) { return _buildInit(); } if (snapshot.data is UserDataState) { UserDataState state = snapshot.data; return _buildContent(state.user); } if (snapshot.data is UserLoadingState) { return _buildLoading(); } }, ), ), ); } Widget _buildInit() { return Center( child: RaisedButton( child: const Text('Load user data'), onPressed: () { _userBloc.loadUserData(); }, ), ); } Widget _buildContent(User user) { return Center( child: Text('Hello ${user.name} ${user.surname}'), ); } Widget _buildLoading() { return const Center( child: CircularProgressIndicator(), ); } @override void dispose() { _userBloc.dispose(); super.dispose(); } }</code> </pre> <br><p>  The widget code of the <code>UserBlocScreen</code> even simpler than the previous examples.  <a href="https://docs.flutter.io/flutter/widgets/StreamBuilder-class.html">StreamBuilder is</a> used to listen to state <a href="https://docs.flutter.io/flutter/widgets/StreamBuilder-class.html">changes</a> .  <code>StreamBuilder</code> is a <code>StatefulWidget</code> that creates itself in accordance with the last value (Snapshot) of the stream ( <a href="https://docs.flutter.io/flutter/dart-async/Stream-class.html">Stream</a> ). </p><br><h3 id="plyusy-2">  pros </h3><br><ol><li>  No third party libraries are required. </li><li>  Business logic, state management, and data loading are separated from UI code. </li><li>  Reactivity.  There is no need to call additional methods, as in the Scoped Model <code>notifyListeners()</code> example. </li></ol><br><h3 id="minusy-2">  Minuses </h3><br><ol><li>  The threshold of entry is slightly higher.  Need experience in working with threads or rxdart. </li></ol><br><h2 id="linki">  Links </h2><br><p>  You can view the full code by downloading it from <a href="https://github.com/savjolovs/flutter_arch_examples">my repository on github</a> . </p><br><p>  Original article published on <a href="https://link.medium.com/vxGf7jKtXT">Medium</a> </p></div><p>Source: <a href="https://habr.com/ru/post/438574/">https://habr.com/ru/post/438574/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>