<div class="post__text post__text-html js-mediator-article">  Bill Kennedy in one of the lectures of his wonderful course <a href="https://www.safaribooksonline.com/library/view/ultimate-go-programming/9780134757476/">Ultimate Go programming</a> said: <br><blockquote>  Many developers strive to optimize their code.  They take the line and rewrite it, saying that it will be faster this way.  Need to stop.  To say that one or another code is faster, it is possible only after it has been profiled and benchmarks are made.  Divination is not the right approach to writing code. </blockquote>  I have long wanted on a practical example to demonstrate how this can work.  And the other day, my attention was attracted by the following code, which just could be used as such an example: <br><a name="habracut"></a><br><pre><code class="go hljs">builds := store.Instance.GetBuildsFromNumberToNumber(stageBuild.BuildNumber, lastBuild.BuildNumber) tempList := model.BuildsList{} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(builds) - <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; i-- { b := builds[i] b.PatchURLs = b.ReversePatchURLs b.ExtractedSize = b.RPatchExtractedSize tempList = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(tempList, b) }</code> </pre> <br>  Here, in all the slice elements of the <i>builds</i> returned from the database, <i>PatchURLs</i> is replaced with <i>ReversePatchURLs</i> , <i>ExtractedSize</i> - with <i>RPatchExtractedSize</i> and reversed - the order of the elements changes so that the last element becomes the first and the first element is the last. <br><br>  In my opinion, the source code is a bit difficult to read and can be optimized.  This code performs a simple algorithm consisting of two logical parts: changing slice elements and sorting.  But in order for a programmer to isolate these two components, it will take time. <br><br>  Despite the fact that both parts are important, the reverse is not as emphasized in the code as we would like.  It is scattered in three lines separated from each other: initializing a new slice, iterating an existing slice in reverse order, adding an element to the end of a new slice.  Nevertheless, the undoubted advantages of this code cannot be ignored: the code is working and tested, and speaking objectively, it is quite adequate.  The subjective perception of code by an individual developer cannot serve as an excuse for rewriting it.  Unfortunately or fortunately, we don’t rewrite the code just because we simply don’t like it (or, as often happens, simply because it’s not ours, see <a href="http://lurkmore.to/%25D0%25A4%25D0%25B0%25D1%2582%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BD%25D0%25B5%25D0%25B4%25D0%25BE%25D1%2581%25D1%2582%25D0%25B0%25D1%2582%25D0%25BE%25D0%25BA">Fatal flaw</a> ). <br><br>  But what if we can not only improve the perception of the code, but also significantly speed it up?  This is a completely different matter.  You can offer several alternative algorithms that perform the functionality laid down in the code. <br><br>  The first option: enumeration of all elements in the <i>range</i> ;  To reverse the initial slice in each iteration, we add an element to the beginning of the final array.  So we could get rid of the cumbersome <i>for</i> , variable <i>i</i> , use the <i>len</i> function, hard to read elements from the end, and also reduce the amount of code by two lines (from seven lines to five), and the smaller the code, the less likely it is an error. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tempList []*store.Build <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, build := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> builds { build.PatchUrls, build.ExtractedSize = build.ReversePatchUrls, build.RPatchExtractedSize tempList = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>([]*store.Build{build}, tempList...) }</code> </pre><br>  By removing the slice iteration from the end, we clearly distinguished the operations of changing the elements (3rd row) and reverse the original array (4th row). <br><br>  The main idea of ​​the second option is to further spread the change of elements and sorting.  First we iterate over the elements and change them, and then sort the slice by a separate operation.  This method will require an additional implementation of the sorting interface for the slice, but it will increase readability and allow you to completely separate and isolate the reverse from changing elements, and the <i>Reverse</i> method will unambiguously point the reader to the desired result. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tempList []*store.Build <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, build := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> builds { build.PatchUrls, build.ExtractedSize = build.ReversePatchUrls, build.RPatchExtractedSize } sort.Sort(sort.Reverse(sort.IntSlice(keys)))</code> </pre><br>  The third option is almost a repetition of the second, but <i>sort.Slice is</i> used for sorting, which increases the amount of code by one line, but avoids the additional implementation of the sorting interface. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, build := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> builds { build.PatchUrls, build.ExtractedSize = build.ReversePatchUrls, build.RPatchExtractedSize } sort.Slice(builds, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, j </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> builds[i].Id &gt; builds[j].Id })</code> </pre><br>  At first glance, in terms of internal complexity, the number of iterations, the functions used, the initial code and the first algorithm are close;  The second and third options may seem more complicated, but it is still impossible to say which of the four options will be optimal. <br><br>  So, we have forbidden ourselves to make decisions based on assumptions that are not supported by evidence, but it is obvious that the most interesting thing here is how the append function behaves when adding an element to the end and to the beginning of the slice.  After all, in fact, this function is not as simple as it seems. <br><br>  <i>Append</i> works <a href="https://blog.golang.org/slices">as follows</a> : it either adds a new element to the existing slice in memory, if its capacity is greater than the total length, or reserves space in the memory for a new slice, copying the data from the first slice into it, adding the second data and returning the result slice. <br><br>  The most interesting feature of this function is the algorithm used to reserve memory for a new array.  Since the most expensive operation is to allocate a new chunk of memory, in order to make the <i>append</i> operation cheaper, the Go developers went for a little trick.  Initially, in order not to re-reserve the memory every time an element is added, the memory is allocated with a certain margin - twice the initial one, but after a certain number of elements the volume of the newly reserved memory section becomes not more than twice, but by 25%. <br><br>  Given the new understanding of the <i>append</i> function <i>, the</i> answer to the question: “What will be faster: add one element to the end of an existing slice or add an existing slice to a slice from one element?” Is already more transparent.  It can be assumed that in the second case, compared with the first, there will be more memory allocations, which will directly affect the speed of work. <br><br>  So we smoothly approached the benchmarks.  Using benchmarks, you can estimate the load of the algorithm on the most critical resources, such as runtime and RAM. <br><br>  Let's write a benchmark for evaluating all four of our algorithms, at the same time we will evaluate what increase we can refuse from sorting (in order to understand how much of the total time is spent on sorting).  Benchmark Code: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> services <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"testing"</span></span> <span class="hljs-string"><span class="hljs-string">"sort"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Build <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Id <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ExtractedSize <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> PatchUrls <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ReversePatchUrls <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> RPatchExtractedSize <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Builds []*Build <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a Builds)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Len</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(a) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a Builds)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, j </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { a[i], a[j] = a[j], a[i] } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a Builds)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Less</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, j </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a[i].Id &lt; a[j].Id } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Builds</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> builds Builds <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">100000</span></span>; i++ { builds = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(builds, &amp;Build{Id: i}) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> builds } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkF1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { data := prepare() builds := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(Builds, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(data)) b.ResetTimer() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tempList Builds <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>(builds, data) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(builds) - <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; i-- { b := builds[i] b.PatchUrls, b.ExtractedSize = b.ReversePatchUrls, b.RPatchExtractedSize tempList = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(tempList, b) } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkF2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { data := prepare() builds := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(Builds, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(data)) b.ResetTimer() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tempList Builds <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>(builds, data) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, build := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> builds { build.PatchUrls, build.ExtractedSize = build.ReversePatchUrls, build.RPatchExtractedSize tempList = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>([]*Build{build}, tempList...) } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkF3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { data := prepare() builds := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(Builds, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(data)) b.ResetTimer() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>(builds, data) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, build := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> builds { build.PatchUrls, build.ExtractedSize = build.ReversePatchUrls, build.RPatchExtractedSize } sort.Sort(sort.Reverse(builds)) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkF4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { data := prepare() builds := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(Builds, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(data)) b.ResetTimer() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>(builds, data) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, build := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> builds { build.PatchUrls, build.ExtractedSize = build.ReversePatchUrls, build.RPatchExtractedSize } sort.Slice(builds, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, j </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> builds[i].Id &gt; builds[j].Id }) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkF5</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { data := prepare() builds := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(Builds, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(data)) b.ResetTimer() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>(builds, data) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, build := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> builds { build.PatchUrls, build.ExtractedSize = build.ReversePatchUrls, build.RPatchExtractedSize } } }</code> </pre><br>  Run the benchmark with the <i>go test command -bench =.</i>  <i>-benchmem</i> . <br><br>  The results of calculations for slices of 10, 100, 1000, 10 000 and 100 000 elements are shown in the graph below, where F1 is the initial algorithm, F2 is the addition of an element to the beginning of the array, F3 is the use of <i>sort.Reverse</i> for sorting, F4 is the use of <i>sort.Slice</i> , F5 - rejection of sorting. <br><br>  <i>Operation time</i> <br><br><img src="https://habrastorage.org/webt/f_/i2/qp/f_i2qp8xvo7iqoj0k1noa9x1fii.png" alt="Operation time"><br><br>  <i>Number of memory allocations</i> <br><br><img src="https://habrastorage.org/webt/vh/fk/lu/vhfkluqv8_spb0-hnd482kgxigm.png"><br><br>  As can be seen from the graph, you can increase the array, but the final result is already in principle distinguishable on a slice of 10 elements.  <b>None of the proposed alternative algorithms (F2, F3, F4) could not surpass the original algorithm (F1) in speed.</b>  Even in spite of the fact that for all but F2, the number of memory allocations is slightly less than that of the original.  The first algorithm (F2) with the addition of an element to the beginning of the slice turned out to be the most inefficient: as it was supposed, there are too many memory allocations in it, so much so that it cannot be used in product development.  The algorithm using the built-in reverse sorting function (F3) is significantly slower than the original one.  And only the algorithm with <i>sort.Slice</i> sorting is comparable in speed with the original algorithm, but it is slightly inferior to it. <br><br>  You may also notice that the rejection of sorting (F5) gives a significant acceleration.  Therefore, if you really want to rewrite the code, then you can go in this direction, for example, by raising the initial slice <i>builds</i> from the database, use sorting by id DESC in the query instead of ASC.  But at the same time, we are forced to go beyond the boundaries of the code section under consideration, which entails the risk of introducing multiple changes. <br><br><h3>  findings </h3><br>  Write benchmarks. <br><br>  It makes little sense to spend your time thinking about whether a particular code will be faster.  Information from the Internet, judgments of colleagues and other people, no matter how authoritative they may be, serve as supporting arguments, but the role of the main judge, who decides whether or not the new algorithm should be, should remain behind benchmarks. <br><br>  Go only at first glance rather simple language.  Comprehensive 80-20 rule applies here.  These 20% are the subtleties of the internal structure of the language, the knowledge of which distinguishes a beginner from an experienced developer.  The practice of writing benchmarks to resolve their questions is one of the cheapest and most effective ways to get both an answer and a deeper understanding of the internal structure and principles of the Go language. </div>