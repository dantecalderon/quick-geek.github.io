<div class="post__text post__text-html js-mediator-article"><p>  About a month ago I had a choice: whether to write a module for puppet "in the table" (that is, for internal infrastructure) or to make it universal, open the source code and publish it on <a href="https://forge.puppet.com/">puppet forge</a> .  Of course, it would be faster and easier to sketch out 2-3 classes under you quickly and calm down, but the experience gained during the module publishing process is valuable and I want to share it.  In Runet, there is no information on the use of the puppet development kit (hereinafter <a href="https://puppet.com/docs/pdk/1.x/pdk.html">PDK</a> ), so this can be considered a kind of tutorial. </p><br><h2 id="o-chyom-statya">  What is the article about </h2><br><p>  In the process of developing a module (or rather, two), I discovered PDK, which greatly facilitates both the development and maintenance of modules.  Namely: </p><br><ul><li> Automatic <code>metadata.json</code> formatting when updating the latest </li><li>  Configuration generation for various CI systems that can do the following: <br><ul><li>  Check ruby ​​code with rubocop linter </li><li>  Run unit tests </li><li>  Under certain conditions - automatic filling of the working code on puppet forge </li></ul></li><li>  Tag-based documentation generation in comments using yard </li><li>  Dish <code>[PDK]</code> for a module on puppet forge.  Trifle, but nice! </li></ul><br><p>  All interested <a name="habracut"></a>  I ask under the cat! </p><br><h4 id="v-kachestve-primerov">  As examples </h4><br><p>  If you want to look and feel in the process of reading what is meant, you can open one of the two (or both) mentioned modules: <a href="https://github.com/innogames/puppet-clickhouse">clickhouse</a> and <a href="https://github.com/innogames/puppet-xmlsimple">xmlsimple</a> .  Both were developed using PDK and other tools described in the article. </p><br><h2 id="soderzhanie">  Content </h2><br><ul><li>  <a href="https://habr.com/ru/post/435954/">What is the article about</a> <br><ul><li>  <a href="https://habr.com/ru/post/435954/">As examples</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/435954/">What is PDK?</a> <br><ul><li>  <a href="https://habr.com/ru/post/435954/">Installation</a> </li><li>  <a href="https://habr.com/ru/post/435954/">PDK content</a> </li><li>  <a href="https://habr.com/ru/post/435954/">Create a module</a> </li><li>  <a href="https://habr.com/ru/post/435954/">new class</a> </li><li>  <a href="https://habr.com/ru/post/435954/">new defined_type</a> </li><li>  <a href="https://habr.com/ru/post/435954/">new provider &amp; task</a> </li><li>  <a href="https://habr.com/ru/post/435954/">Documentation generation with puppet-strings</a> </li><li>  <a href="https://habr.com/ru/post/435954/">Customize templates</a> </li><li>  <a href="https://habr.com/ru/post/435954/">Run various CI</a> </li><li>  <a href="https://habr.com/ru/post/435954/">Bonus: write unit tests for classes, types and functions</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/435954/">Instead of output</a> </li></ul><br><h1 id="chto-zhe-takoe-pdk">  What is PDK? </h1><br><p>  From official documentation: </p><br><blockquote>  Create a complete module.  PDK provides a complete module structure, defined types of tasks, and a testing infrastructure.  You can validate your application. </blockquote><p>  In my free translation: </p><br><blockquote>  Allows you to create a complete module with classes, types, tasks and tests to verify the operation of the module.  PDK provides complete structure and templates for all of the above.  With this tool, you can test the operation of the module with different versions of puppet, as well as in different operating systems. </blockquote><p>  Sounds good?  Well, so it really is.  Until the moment when I started working on a module that was decided to write immediately for open source, I had no idea about this tool, and now I intend to transfer all internal infrastructure to PDK. </p><br><p>  I will describe how to put it, and what tools and commands it contains. </p><br><h2 id="ustanovka">  Installation </h2><br><p>  <a href="https://puppet.com/download-puppet-development-kit">The official installation page</a> .  Under this link you are almost guaranteed to find the right way to install the PDK on your host.  If for some reason you are not lucky and your OS is not there, there is always a detour in the form: </p><br><pre> <code class="bash hljs">gem install pdk</code> </pre> <br><p>  In fact, the PDK is just a heme, and it is put that way. </p><br><h2 id="soderzhimoe-pdk">  PDK content </h2><br><p>  In general, a PDK is nothing more than a set of gems to facilitate the development of modules.  It contains the following tools: </p><br><table><thead><tr><th>  Utility </th><th>  Description </th></tr></thead><tbody><tr><td>  metadata-json-lint </td><td>  Checks metadata.json matches against puppet style guides. </td></tr><tr><td>  pdk </td><td>  A tool for generating and testing modules and their contents (classes, types, etc.) from the command line </td></tr><tr><td>  puppet-lint </td><td>  Checks puppet code for matching Puppet Language style guides. </td></tr><tr><td>  puppet-syntax </td><td>  Check the correctness of the manifest syntax </td></tr><tr><td>  puppetlabs_spec_helper </td><td>  Provides Rake classes, methods, and tasks for puppet spec tests </td></tr><tr><td>  rspec-puppet </td><td>  Tests the behavior of puppet during the compilation of manifests in the resource directory (?) </td></tr><tr><td>  rspec-puppet-facts </td><td>  Allows you to run rspec-puppet with user-defined puppet-facts </td></tr></tbody></table><br><h2 id="sozdayom-modul">  Create a module </h2><br><p>  PDK is installed, now you can play.  The simplest <code>pdk help</code> command <code>pdk help</code> display the available commands.  Suppose that we are in the folder where you have all the other modules.  Then let's create a new one: </p><br><pre> <code class="plaintext hljs">$ pdk new module --template-url=https://github.com/puppetlabs/pdk-templates.git *** We need to create the metadata.json file for this module, so we're going to ask you 5 questions. *** [Q 1/5] If you have a name for your module, add it here. --&gt; dummy [Q 2/5] If you have a Puppet Forge username, add it here. --&gt; felixoid [Q 3/5] Who wrote this module? --&gt; Mikhail f. Shiryaev [Q 4/5] What license does this module code fall under? --&gt; MIT [Q 5/5] What operating systems does this module support? --&gt; RedHat based Linux, Debian based Linux, Windows Metadata will be generated based on this information, continue? Yes pdk (INFO): Module 'dummy' generated at path '/tmp/dummy', from template 'https://github.com/puppetlabs/pdk-templates.git'.</code> </pre> <br><p>  The utility asks questions to fill in the metadata.json file, and at the output we have exactly what is indicated: the module and the auxiliary files, compiled according to templates from the gita. </p><br><p>  A small remark - Templates change quite often, including some critical bugs fixed recently.  Therefore, it is better to use not the defaults from the installed PDK, but the latest version.  True, there is a downside: when using the <code>--template-url</code> PDK argument, this parameter is added to the <code>~.pdk/cache/answers.json</code> and, judging by the delays in the further execution of any of the <code>pdk</code> commands, it tries to download them.  So either remove this parameter from <code>answers.json</code> , or do not use it when creating a module and change it in <code>metadata.json</code> . </p><br><p>  Let's go through the next steps that can be performed using the PDK. </p><br><h3 id="new-class">  new class </h3><br><pre> <code class="plaintext hljs">$ pdk new class dummy::class pdk (INFO): Creating '/tmp/dummy/manifests/class.pp' from template. pdk (INFO): Creating '/tmp/dummy/spec/classes/class_spec.rb' from template. $ cat manifests/class.pp # A description of what this class does # # @summary A short summary of the purpose of this class # # @example # include dummy::class class dummy::class { } $ cat spec/classes/class_spec.rb require 'spec_helper' describe 'dummy::class' do on_supported_os.each do |os, os_facts| context "on #{os}" do let(:facts) { os_facts } it { is_expected.to compile } end end end</code> </pre> <br><p>  This command creates 2 files: directly the manifest for the class and the spec-file for its testing.  On the tags for documentation, I’ll talk about it a bit later. </p><br><h3 id="new-defined_type">  new defined_type </h3><br><pre> <code class="plaintext hljs">$ pdk new defined_type type pdk (INFO): Creating '/tmp/dummy/manifests/type.pp' from template. pdk (INFO): Creating '/tmp/dummy/spec/defines/type_spec.rb' from template.</code> </pre> <br><p>  All the same: manifest for resource type and spec-file. </p><br><h4 id="new-provider--task">  new provider &amp; task </h4><br><p>  PDK can also create a new provider or a tusk, but I didn’t work closely with them, so I’ll honestly say that, if necessary, it’s better to learn more about this topic yourself. </p><br><h2 id="generaciya-dokumentacii-pri-pomoschi-puppet-strings">  Documentation generation with puppet-strings </h2><br><p>  I don’t really understand why <code>puppet strings</code> not part of the PDK toolkit, however, ce la vi.  If during development you correctly set the <a href="https://puppet.com/docs/puppet/latest/puppet_strings.html">tags</a> for the yard, then there are 2 main ways to provide documentation to the user: </p><br><ul><li>  Generate it as HTML / Markdown / JSON and put it next to the code.  This is done with the command <code>puppet string generate [--format FORMAT]</code> , where the format can be omitted or take the value <code>json</code> / <code>markdown</code> . <br><ul><li>  The standard for documentation is to have <code>REFERENCE.md</code> in the root of the repository, which is generated by the command <code>puppet strings generate --format markdown</code> . </li></ul></li><li>  Publish to the repository with code (provided that it is on github) github-pages.  This is quite simple, you need 3 commands: <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># удаляем Gemfile.lock, который мог создать PDK rm -f Gemfile.lock # Устанавливаем все гемы из Gemfile при помощи bundle bundle install --path vendor/bundle # Генерируем непосредственно gh-pages при помощи rake-task bundle exec rake strings:gh_pages:update</span></span></code> </pre> </li></ul><br><p>  It seems to be no magic, but at the exit we have a module with instructions.  The advantage is that even if you do not describe, say, each of the parameters using the <code>@param</code> tag, the output will still be a class / type / function with a minimum description of the parameters with the type and default value.  In my humble opinion, even this is better than nothing, and will make the module more attractive for use. </p><br><p>  Of course, all this can be automated and added as a stage CI.  It would be perfect.  My hands have not reached me yet, but it is gathering dust in the backlog.  If suddenly someone has something to say on this topic - I will be grateful.  As a thought: at least add a check to see if REFERENCE.md changes after running puppet-strings.  And if so, consider the tests failed. </p><br><h2 id="nastroyka-shablonov">  Customize templates </h2><br><p>  Template documentation is located in the <a href="">pdk-templates</a> repository.  In short, everything is configured using the <code>.sync.yml</code> file in the root directory of the module, and the changes are applied using the <code>pdk update</code> command.  Each of the parameters of this file is the name of a different file in the module directory that needs to be changed in one way or another.  Most of the parameters for each of the templates I had to pick up "by touch", looking at the source code, often - by trial and error.  Documentation here sometimes lags far behind.  Unfortunately, there is almost nothing more to say, except to give a link to <a href="">an example</a> from our own repository. </p><br><p>  Very fluently I will describe several parameters that I changed using the <code>.sync.yml</code> from the example above: </p><br><ul><li>  <code>Gemfile</code> : added two <code>Gemfile</code> as dependencies in different groups: pdk in the development group;  xml-simple in the dependencies group.  When running tests, the system_tests group is not installed, so I add the dependency to another group. </li><li>  <code>spec/spec_helper.rb</code> : <code>spec/spec_helper.rb</code> method was changed, a minimum test coverage threshold was added, below which tests are considered failed. </li><li>  <code>.travis.yml</code> : this file has been polished for a long time, as it is used to check the code base and load the finished module to puppet-forge.  Changes: <br><ul><li>  User and encrypted password to fill the module on puppet-forge.  You can read more about the warmth in puppet-forge with Travis. </li><li>  Created the order tests → deploy with the launch of the latter only with successful tests. </li><li>  Added the deployment stage of the module to puppet-forge, provided that CI is launched from a tag that starts with the character "v". </li></ul></li><li>  <code>Rakefile</code> : added some exceptions for the linter. </li></ul><br><h2 id="zapusk-razlichnyh-ci">  Run various CI </h2><br><p>  Everything is quite simple here.  Immediately after the module is generated using PDK, validation can be launched in appveyor, travis and gitlab-ci.  To start the tests, everything is ready right out of the box, while the same <code>.sync.yml</code> used for tuning.  I have no special preferences, so I will not recommend anything.  Just use what is more convenient. </p><br><h2 id="bonus-pishem-yunit-testy-dlya-klassov-tipov-i-funkciy">  Bonus: write unit tests for classes, types and functions </h2><br><p>  This item is quite a bit beyond the basic material, which I planned to describe, but it seems to me very useful. </p><br><p>  So, we have a module with manifests and a library, which, in turn, contain classes, types, and functions (also do not forget about Tasks and Providers, but in this part I have no expertise).  Since any code exists for the purpose of changing, it would be nice, obviously, to impose tests on it to make sure of 2 things: </p><br><ul><li>  Changes do not break current behavior (or behavior changes with tests) </li><li>  Your manifestos do exactly what is expected and use all the resources as expected. </li></ul><br><p>  Puppetlabs provides an extension for the rspec framework called <a href="https://rspec-puppet.com/">puppet-rspec</a> .  Links to documentation on testing <a href="https://rspec-puppet.com/documentation/classes/">classes</a> , <a href="https://rspec-puppet.com/documentation/defined_types/">types</a> and <a href="https://rspec-puppet.com/documentation/functions/">functions</a> .  Do not be lazy to look more closely, there are other sections. </p><br><p>  It's easy enough to start using it without even knowing ruby.  If classes or types were created, as shown above, with the help of <code>pdk new &lt;thing&gt;</code> , then the <code>*_spec.rb</code> file also already exists.  So, suppose we have a class <code>dummy::class</code> .  To test it, the file <code>spec/classes/class_spec.rb</code> should be created with the following content: </p><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'spec_helper'</span></span> describe <span class="hljs-string"><span class="hljs-string">'dummy::class'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> on_supported_os.each <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|os, os_facts|</span></span> context <span class="hljs-string"><span class="hljs-string">"on </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{os}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> let(<span class="hljs-symbol"><span class="hljs-symbol">:facts</span></span>) { os_facts } it { is_expected.to compile } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  You can check it by running the <code>pdk test unit</code> from the root directory of the module. </p><br><p>  This is almost all we need.  Now it remains to supplement the <code>class_spec.rb</code> necessary <code>is_expected</code> with the appropriate conditions.  For example, to verify that the class contains the resource <code>file {'/file/path': }</code> with certain parameters, you can do this: </p><br><pre> <code class="ruby hljs">it <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> is_expected.to contain_file(<span class="hljs-string"><span class="hljs-string">'/file/path'</span></span>).with( <span class="hljs-string"><span class="hljs-string">'ensure'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'file'</span></span>, <span class="hljs-string"><span class="hljs-string">'mode'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'0644'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  You can set class parameters using <code>let(:params) { {'param1' =&gt; 'value'} }</code> , it is possible to conduct tests under various input conditions, placing each <code>it</code> inside the selected sections of the <code>context 'some description' {}</code> .  You can check both dependencies between resources and between classes: if it is implied, for example, that the class declaration contains <code>inherits</code> , then you can add the <code>is_expected.to contain_class('parent_class_name')</code> .  Need to test behavior in different OS?  It is also possible: we simply indicate the necessary facts in a separate context: </p><br><pre> <code class="ruby hljs">context <span class="hljs-string"><span class="hljs-string">'with Debian'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> let(<span class="hljs-symbol"><span class="hljs-symbol">:facts</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-symbol"><span class="hljs-symbol">os:</span></span> { <span class="hljs-symbol"><span class="hljs-symbol">architecture:</span></span> <span class="hljs-string"><span class="hljs-string">'amd64'</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">distro:</span></span> { <span class="hljs-symbol"><span class="hljs-symbol">codename:</span></span> <span class="hljs-string"><span class="hljs-string">'stretch'</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">id:</span></span> <span class="hljs-string"><span class="hljs-string">'Debian'</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">release:</span></span> { <span class="hljs-symbol"><span class="hljs-symbol">full:</span></span> <span class="hljs-string"><span class="hljs-string">'9.6'</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">major:</span></span> <span class="hljs-string"><span class="hljs-string">'9'</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">minor:</span></span> <span class="hljs-string"><span class="hljs-string">'6'</span></span>, }, }, <span class="hljs-symbol"><span class="hljs-symbol">family:</span></span> <span class="hljs-string"><span class="hljs-string">'Debian'</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">name:</span></span> <span class="hljs-string"><span class="hljs-string">'Debian'</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">release:</span></span> { <span class="hljs-symbol"><span class="hljs-symbol">full:</span></span> <span class="hljs-string"><span class="hljs-string">'9.6'</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">major:</span></span> <span class="hljs-string"><span class="hljs-string">'9'</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">minor:</span></span> <span class="hljs-string"><span class="hljs-string">'6'</span></span>, }, <span class="hljs-symbol"><span class="hljs-symbol">selinux:</span></span> { <span class="hljs-symbol"><span class="hljs-symbol">enabled:</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>, }, }, <span class="hljs-symbol"><span class="hljs-symbol">osfamily:</span></span> <span class="hljs-string"><span class="hljs-string">'Debian'</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> it { is_expected.to something } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  In general, as far as I could notice in the process of writing tests, the framework allows you to check almost everything that may be needed.  And the presence of tests once helped me out when some parameters were moved from the child classes to the top class of the module: they showed that the refactoring did not break anything and the behavior of the whole module did not change. </p><br><h1 id="vmesto-vyvoda">  Instead of output </h1><br><p>  As it could already be understood from the general intonation of the article, I am greatly inspired by how much Puppet made it easier to work with modules and manifests thanks to the PDK.  Routine actions are automated, wherever possible, templates are used, configs are available from the box for popular CIs.  It may seem like some kind of overhead, and using it may not bring the expected fruits, but it is definitely worth it.  If we compare how to develop modules without and with PDK, then for me it looks like this: </p><br><table><thead><tr><th>  Development without <del>  beards </del>  PDK </th><th>  PDK Development </th></tr></thead><tbody><tr><td><img src="https://habrastorage.org/webt/hb/gg/xd/hbggxdj1znic1fgofyl-sb3oz0c.jpeg" width="300"></td><td><img src="https://habrastorage.org/webt/rw/4n/j-/rw4nj-vux8ricpk46hih5iu_3js.jpeg" width="300"></td></tr></tbody></table><br><p>  Try, put, facilitate yourself and colleagues life.  I will be happy to answer potential questions. </p><br><p>  May the automatization be with us! </p></div>