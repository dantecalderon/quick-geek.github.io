<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Analysis of the problem with the interview in Google: synonymous queries</title>
  <meta name="description" content="This is a new article from the analysis of tasks with interviews in Google . When I worked there, I offered candidates such tasks. Then there was a le...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Analysis of the problem with the interview in Google: synonymous queries</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ec4/467/e92/ec4467e926275a35882c2a8848097877.png" width="530"></div><br><br>  This is a new article from the <a href="https://medium.com/%40alexgolec/introducing-google-interview-questions-deconstructed-a012e41ea631">analysis of tasks with interviews in Google</a> .  When I worked there, I offered candidates such tasks.  Then there was a leak, and they were banned.  But the medal has a downside: now I can freely explain the solution. <br><a name="habracut"></a><br>  First of all, great news: I left Google!  I am glad to announce that I am now working as a technical manager for Reddit in New York!  But this series of articles will still be continued. <br><br>  <i>Disclaimer: although interviewing candidates is one of my professional duties, on this blog I share personal observations, stories and personal opinions.</i>  <i>Please do not consider this as the official statement of Google, Alphabet, Reddit, any other person or organization.</i> <br><br><h1>  Question </h1><br>  After the <a href="https://hackernoon.com/google-interview-questions-deconstructed-the-knights-dialer-f780d516f029">last two</a> <a href="https://medium.com/%40alexgolec/google-interview-questions-deconstructed-the-knights-dialer-impossibly-fast-edition-c288da1685b8">articles</a> about the horse in the process of dialing a phone number, I received critical remarks that this is not a realistic problem.  No matter how useful it is to study the thinking skills of a candidate, but I have to admit: the task is really a bit unrealistic.  Although I have some thoughts about the correlation between the questions at the interviews and the reality, but for the time being I will keep them with me.  Be sure, I read comments everywhere and I have something to answer, but not now. <br><br>  But when the task about the knight's move was banned a few years ago, I took the criticism to heart and tried to replace it with a question that is a little more related to Google.  And what could be more relevant for Google than search engine mechanics?  So I found this question and used it for a long time before it got into public too and was banned.  As before, I will formulate the question, immerse myself in its explanation, and then tell you how I used it in interviews and why I like it. <br><br>  So the question is. <br><br>  Imagine that you run a popular search engine and see two requests in the logs: let's say Obama's approval ratings and Obama's popularity level (if I remember correctly, these are real examples from the question base, although now they are a bit outdated ...) .  We see different requests, but everyone will agree: users are essentially looking for the same information, so requests should be considered equivalent when calculating the number of requests, showing results, etc. <b>How to determine that two requests are synonymous?</b> <br><br>  Let's formalize the problem.  Suppose there are two sets of pairs of lines: pairs of synonyms and pairs of queries. <br><br>  Specifically, here is an example of input for illustration: <br><br><pre><code class="python hljs">SYNONYMS = [ (<span class="hljs-string"><span class="hljs-string">'rate'</span></span>, <span class="hljs-string"><span class="hljs-string">'ratings'</span></span>), (<span class="hljs-string"><span class="hljs-string">'approval'</span></span>, <span class="hljs-string"><span class="hljs-string">'popularity'</span></span>), ] QUERIES = [ (<span class="hljs-string"><span class="hljs-string">'obama approval rate'</span></span>, <span class="hljs-string"><span class="hljs-string">'obama popularity ratings'</span></span>), (<span class="hljs-string"><span class="hljs-string">'obama approval rates'</span></span>, <span class="hljs-string"><span class="hljs-string">'obama popularity ratings'</span></span>), (<span class="hljs-string"><span class="hljs-string">'obama approval rate'</span></span>, <span class="hljs-string"><span class="hljs-string">'popularity ratings obama'</span></span>) ]</code> </pre> <br>  It is necessary to produce a list of logical values: are the queries in each pair synonymous? <br><br><h1>  All new questions ... </h1><br>  At first glance, this is a simple task.  But the longer you think, the harder it becomes.  Can a word have several synonyms?  Does word order matter?  Are synonymous relations transitive, that is, if A is synonymous with B and B is synonymous with C, is A a synonym for C?  Can synonyms cover a few words, as ‚ÄúUS‚Äù is a synonym for the phrases ‚ÄúUnited States of America‚Äù or ‚ÄúUnited States‚Äù? <br><br>  This ambiguity immediately gives the opportunity to prove himself a good candidate.  The first thing he does is seeks out such ambiguities and tries to resolve them.  Everyone does it differently: some approach the board and try to solve specific cases manually, while others look at the question and immediately see the spaces.  In any case, identifying these problems at an early stage is crucial. <br><br>  The ‚Äúproblem understanding‚Äù phase is important.  I like to call software engineering a fractal discipline.  Like fractals, the approximation reveals additional complexity.  You think that you understand the problem, then look closer - and see that you have missed some subtlety or implementation detail that can be improved.  Or a different approach to the problem. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ee2/53b/e5a/ee253be5a2b504b310dea6050559bcba.gif"><br>  <i><font color="gray">Mandelbrot Set</font></i> <br><br>  <b>The caliber of an engineer is largely determined by how deeply he can understand the problem.</b>  Transforming a vague formulation of the problem into a detailed set of requirements is the first step in this process, and deliberate innuendo allows you to assess how well the candidate approaches new situations. <br><br>  <i>Let us leave aside trivial questions like ‚ÄúDo capital letters matter?‚Äù, Which do not affect the basic algorithm.</i>  <i>I always give the simplest answer to these questions (in this case, ‚ÄúSuppose that all the letters have already been processed and reduced to lower case‚Äù)</i> <br><br><h1>  Part 1. (Not really) a simple case. </h1><br>  If candidates ask questions, I always start with the simplest case: a word can have several synonyms, word order matters, synonyms are not transitive.  This gives a fairly limited functionality to the search engine, but it has enough subtleties for an interesting interview. <br><br>  The high-level review looks like this: Break the query into words (for example, by spaces) and compare the corresponding pairs to search for identical words and synonyms.  Visually, it looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c1/a65/908/7c1a6590877f4632beffa60d8cbb0afa.png"><br><br>  In the code: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">synonym_queries</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(synonym_words, queries)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">''' synonym_words: iterable of pairs of strings representing synonymous words queries: iterable of pairs of strings representing queries to be tested for synonymous-ness '''</span></span> output = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> q1, q2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> queries: q1, q2 = q1.split(), q2.split() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(q1) != len(q2): output.append(<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(q1)): w1, w2 = q1[i], q2[i] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w1 == w2: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> words_are_synonyms(w1, w2): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> output.append(result) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output</code> </pre> <br>  Easy, right?  Algorithmically, this is pretty simple.  No dynamic programming, recursion, complex structures, etc. Simple manipulation of the standard library and an algorithm that works in linear time, right? <br><br>  But there are more nuances than it seems at first glance.  Of course, the most difficult component is the comparison of synonyms.  Although the component is easy to understand and describe, there are many ways to go wrong.  I'll tell you about the most common mistakes. <br><br>  For clarity: no errors disqualify a candidate;  If anything, I just point out an error in the implementation, it fixes it, and we move on.  However, an interview is, above all, a struggle with time.  You will make, notice and correct mistakes, but it takes time that can be spent on another, for example, to create a more optimal solution.  Practically everyone makes mistakes, this is normal, but candidates who make them smaller show better results simply because they spend less time correcting. <br><br>  That's why I like this problem.  If the knight's move requires insight in understanding the algorithm, and then (hopefully) a simple implementation, then the solution here is a lot of steps in the right direction.  Each step represents a tiny obstacle through which the candidate can either gracefully jump over or stumble and climb.  Good candidates thanks to experience and intuition avoid these little traps - and get a more detailed and correct solution, while the weaker spend time and energy on errors and usually stay with an erroneous code. <br><br>  At each interview I saw a different combination of successes and failures, here are the most common mistakes. <br><br><h4>  Random performance killers </h4><br>  First, some candidates implemented synonym detection using a simple traversal of the list of synonyms: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> (w1, w2) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> ...</code> </pre> <br>  At first glance, this seems reasonable.  But on closer inspection, the idea turns out to be very, very bad.  For those of you who don‚Äôt know Python, the in keyword is the syntax sugar for the <i>contains</i> method and works on all standard Python containers.  This is a problem because <code>synonym_words</code> is a list that implements the in keyword using a linear search.  Python users are especially sensitive to this error, because the language hides types, but C ++ and Java users also sometimes made similar errors. <br><br>  In my entire career, I have just written a few times a code with a linear search, and each in a list no more than two dozen elements in length.  And even in this case, he wrote a long commentary explaining why he chose such a seemingly non-optimal approach.  I suspect that some candidates used it simply because they did not know how the keyword <code>in</code> in the standard Python library worked with lists.  This is a simple mistake, not fatal, but a poor acquaintance with your favorite language is not very good. <br><br>  In practice, this error is easy to avoid.  First, never forget your object types, even if you use an untyped language such as Python!  Second, remember that when using the in keyword <i>in</i> the list, a linear search is started.  If there is no guarantee that this list will always remain very small, it will kill the performance. <br><br>  In order for the candidate to come to his senses, it is usually enough to remind him that the input structure is a list.  It is very important to observe how the candidate responds to the hint.  The best candidates immediately try to somehow pre-process synonyms, which is a good start.  However, this approach is not devoid of its pitfalls ... <br><br><h4>  Use the correct data structure </h4><br>  It is immediately apparent from the above code that in order to implement this algorithm in linear time, it is necessary to quickly find synonyms.  And when we talk about quick search, it is always a map or an array of hashes. <br><br>  I don't care if the candidate chooses a card or an array of hashes.  The important thing is that he will invest there (by the way, never use dict / hashmap with a transition to <code>True</code> or <code>False</code> ).  Most candidates choose some kind of dict / hashmap.  The most common mistake is a subconscious assumption that each word has no more than one synonym: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span>synonyms = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: synonyms[w1] = w2 ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> synonyms[w1] == w2: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span></code> </pre> <br>  I do not punish candidates for this mistake.  The task is specifically formulated so as not to focus on the fact that words may have several synonyms, and some candidates simply did not encounter such a situation.  Most quickly correct the error when I point it out.  Good candidates notice it at an early stage and usually do not spend a lot of time. <br><br>  A slightly more serious problem is the unawareness that the relationship of synonyms spreads in both directions.  Note that this is taken into account in the code above.  But there are implementations with an error: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span>synonyms = defaultdict(set) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: synonyms[w1].append(w2) synonyms[w2].append(w1) ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms.get(w1, tuple()): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span></code> </pre> <br>  Why do two inserts and use twice the memory? <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span>synonyms = defaultdict(set) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: synonyms[w1].append(w2) ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> (w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms.get(w1, tuple()) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> w1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms.get(w2, tuple())): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span></code> </pre> <br>  Conclusion: <i>always think how to optimize the code</i> !  In retrospect, rearrangement of search functions is an obvious optimization, otherwise it can be concluded that the candidate did not think over the optimization options.  Again, I am happy to give a hint, but it is better to guess myself. <br><br><h1>  Sorting? </h1><br>  Some smart candidates want to sort the list of synonyms and then use binary search.  In fact, this approach has an important advantage: it does not require additional space, except for the list of synonyms (provided that the list can be changed). <br><br>  Unfortunately, time complexity interferes: sorting the list of synonyms requires <code>Nlog(N)</code> time, and then <code>log(N)</code> to search for each pair of synonyms, while the described preprocessing solution occurs in linear and then constant time.  In addition, I am categorically opposed to forcing the candidate to implement sorting and binary search on the blackboard, because: 1) the sorting algorithms are well known, therefore, as far as I know, the candidate can issue it without thinking;  2) these algorithms are devilishly difficult to implement correctly, and often even the best candidates will make mistakes that say nothing about their programming skills. <br><br>  Whenever a candidate proposed such a solution, I was interested in the program execution time and asked if there was a better option.  For information: if the interviewer asks you if there is a better option, the answer is almost always yes.  If I ever ask you this question, the answer will definitely be. <br><br><h4>  Finally, the solution </h4><br>  In the end, the candidate offers something correct and reasonably optimal.  Here is the implementation in linear time and linear space for the given conditions: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">synonym_queries</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(synonym_words, queries)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">''' synonym_words: iterable of pairs of strings representing synonymous words queries: iterable of pairs of strings representing queries to be tested for synonymous-ness '''</span></span> synonyms = defaultdict(set) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: synonyms[w1].add(w2) output = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> q1, q2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> queries: q1, q2 = q1.split(), q2.split() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(q1) != len(q2): output.append(<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(q1)): w1, w2 = q1[i], q2[i] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w1 == w2: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> ((w1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms[w1]) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> w1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms[w2])): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> output.append(result) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output</code> </pre> <br>  A few quick notes: <br><br><ul><li>  Note the use of <code>dict.get()</code> .  You can implement a check whether the key is in dict and then get it, but this is a complicated approach, although in this way you will show your knowledge of the standard library. </li><li>  I personally am not a fan of code with frequent <code>continue</code> , and <a href="https://stackoverflow.com/questions/10975722/why-continue-is-considered-as-a-c-violation-in-misra-c2004">some style guides forbid or recommend them</a> .  I myself in the first edition of this code forgot the <code>continue</code> statement after checking the length of the request.  This is not a bad approach, just know that it is error prone. </li></ul><br><h1>  Part 2: It gets harder! </h1><br>  Good candidates still have ten to fifteen minutes left after solving the problem.  Fortunately, there are a lot of additional questions, although we are unlikely to write a lot of code during this time.  However, this is not necessary.  I want to know about the candidate two things: is he able to develop algorithms and can he encode?  The task with the knight's move first answers the question about the development of the algorithm, and then checks the coding, and here we get the answers in the reverse order. <br><br>  By the time the candidate completed the first part of the question, he had already solved the problem with (surprisingly non-trivial) coding.  At this stage, I can talk with confidence about his ability to develop rudimentary algorithms and translate ideas into code, as well as about getting to know his favorite language and standard library.  Now the conversation becomes much more interesting, because the requirements for programming can be mitigated, and we dive into the algorithms. <br><br>  To this end, let us return to the basic tenets of the first part: the word order is important, synonyms are nontransitive, and for each word there can be several synonyms.  As the interview progresses, I change each of these limitations, and in this new phase we have a purely algorithmic discussion with the candidate.  Here I will provide code examples to illustrate my point of view, but in a real interview we are only talking about algorithms. <br><br>  Before you begin, I will explain my position: all subsequent actions at this stage of the interview are mainly ‚Äúbonus points‚Äù.  My personal approach is to identify candidates who accurately pass the first stage and are suitable for work.  The second stage is needed to highlight the best.  The first rating is already very strong and means that the candidate is good enough for the company, and the second rating says that the candidate is excellent and his hiring will be a big victory for us. <br><br><h1>  Transitivity: naive approaches </h1><br>  First, I like to remove the restriction on transitivity, so if the synonyms are the pairs A ‚àí B and B ‚àí C, then the words A and C are also synonyms.  Smart candidates will quickly understand how to adapt their previous solution, although with further removal of other constraints, the basic logic of the algorithm will stop working. <br><br>  However, how to adapt it?  One common approach is to maintain a complete set of synonyms for each word based on transitive relationships.  Every time we insert a word into a set of synonyms, we also add it to the corresponding sets for all the words in this set: <br><br><pre> <code class="python hljs">synonyms = defaultdict(set) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms[w1]: synonyms[w].add(w2) synonyms[w1].add(w2) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms[w2]: synonyms[w].add(w1) synonyms[w2].add(w1)</code> </pre> <br>  <i><font color="gray">Please note that by creating the code, we have already gone deep into this solution.</font></i> <br><br>  This solution works, but far from optimal.  To understand the reasons, let us estimate the spatial complexity of this solution.  Each synonym must be added not only to the set of the initial word, but also to the sets of all its synonyms.  If the synonym is one, then one entry is added.  But if we have 50 synonyms, we have to add 50 entries.  In the figure, it looks like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e3f/ab6/e25/e3fab6e25d14821ec06d623925db9ac5.png"></div><br><br>  Notice that we switched from three keys and six records to four keys and twelve records.  A word with 50 synonyms will require 50 keys and almost 2500 entries.  The necessary space for representing a single word grows quadratically with an increase in the set of synonyms, which is quite wasteful. <br><br>  There are other solutions, but I will not go too deeply in order not to inflate the article.  The most interesting of them is the use of the synonyms data structure for building a directed graph, and then searching for width to find the path between two words.  This is a great solution, but the search becomes linear in terms of the set of synonyms for the word.  Since we perform this search for each query several times, this approach is not optimal. <br><br><h1>  Transitivity: the use of disjoint sets </h1><br>  It turns out that the search for synonyms is possible in (almost) constant time due to a data structure called disjoint set.  This structure offers slightly different possibilities than a regular data set (set). <br><br>  A regular set structure (hashset, treeset) is a container that allows you to quickly determine whether an object is inside or outside of it.  Non-intersecting sets solve a completely different problem: instead of defining a specific element, they allow one to determine <i>whether two elements belong to the same set</i> .  Moreover, the structure does this for a blindingly fast time <code>O(a(n))</code> , where <code>a(n)</code> is the inverse function of Ackermann.  If you have not studied advanced algorithms, you may not know this function, which for all reasonable inputs is actually performed in constant time. <br><br>  At a high level, the algorithm works as follows.  Sets are represented by trees with parents for each element.  Since each tree has a root (an element that is itself a parent), we can determine if two elements belong to the same set by tracing their parents to the root.  If two elements have one root, they belong to the same set.  Combining sets is also easy: just find the root elements and make one of them the root of the other. <br><br>  So far so good, but not yet seen blinding speed.  The genius of this structure is in a procedure called <i>compression</i> .  Suppose you have the following tree: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4b/132/102/e4b13210226d0375adc1acf7835ef4a2.png"></div><br><br>  Imagine that you want to find out if the words <i>speedy</i> and <i>hasty</i> are synonymous.  Follow the parents of each one and find the same <i>fast</i> root.  Now suppose that we perform a similar test for the words <i>speedy</i> and <i>swift</i> .  Again we go up to the root, and from <i>speedy</i> we go the same route.  Is it possible to avoid duplication of work? <br><br>  It turns out you can.  In a sense, every element in this tree is destined to come to <i>fast</i> .  Instead of going through the whole tree every time, why not change the parent for all descendants of <i>fast</i> to shorten the route to the root?  This process is called compression, and in non-intersecting sets it is embedded in the root search operation.  For example, after the first operation, compared to <i>speedy</i> and <i>hasty, the</i> structure will understand that they are synonymous, and will compress the tree as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d4/381/3b9/2d43813b9925bf86d0e4b3a2c9a99707.png"></div><br>  <i><font color="gray">For all words between speedy and fast, the parent is updated, the same thing happened with the hasty</font></i> <br><br>  Now all subsequent calls will occur in constant time, because each node in this tree points to <i>fast</i> .  It is not very easy to assess the time complexity of operations: in fact, it is not constant, because it depends on the depth of trees, but is close to constant, because the structure is quickly optimized.  For simplicity, we assume that time is constant. <br><br>  With this concept, we implement unrelated sets for our problem: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DisjointSet</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.parents = {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_root</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, w)</span></span></span><span class="hljs-function">:</span></span> words_traversed = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> self.parents[w] != w: words_traversed.append(w) w = self.parents[w] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> word <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> words_traversed: self.parents[word] = w <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> w <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_synonyms</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, w1, w2)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w1 <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.parents: self.parents[w1] = w1 <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w2 <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.parents: self.parents[w2] = w2 w1_root = self.get_root(w1) w2_root = self.get_root(w2) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w1_root &lt; w2_root: w1_root, w2_root = w2_root, w1_root self.parents[w2_root] = w1_root <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">are_synonymous</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, w1, w2)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.get_root(w1) == self.get_root(w2)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Using this structure, you can pre-process synonyms and solve the problem in linear time. </font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rating and notes </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At this point, we have reached the limit of what the candidate can show in 40‚Äì45 minutes of an interview. </font><font style="vertical-align: inherit;">For all candidates who did the introductory part and made significant progress in describing (not implementing) unrelated sets, I assigned the rating ‚ÄúHighly recommended to hire‚Äù and let them ask any questions. </font><font style="vertical-align: inherit;">I have never seen a candidate go so far and have a lot of time left. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In principle, there are still variants of the problem with transitivity: for example, remove the restriction on the word order or on several synonyms for a word. </font><font style="vertical-align: inherit;">Each decision will be difficult and delightful, but I will leave them for later.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The advantage of this task is that it allows candidates to make mistakes. </font><font style="vertical-align: inherit;">Daily software development consists of endless cycles of analysis, execution and refinement. </font><font style="vertical-align: inherit;">This problem enables candidates to demonstrate their abilities at each stage. </font><font style="vertical-align: inherit;">Consider the skills needed to get the maximum score on this issue:</font></font><br><br><ul><li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analyze the formulation of the problem</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">determine where it is not clearly formulated</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , develop an unambiguous wording. </font><font style="vertical-align: inherit;">Continue doing this as new issues are resolved. </font><font style="vertical-align: inherit;">For maximum efficiency, perform these operations as early as possible, because the further work has gone, the longer it takes to correct the error.</font></font><br></li><li> <i>–°—Ñ–æ—Ä–º—É–ª–∏—Ä—É–π—Ç–µ –ø—Ä–æ–±–ª–µ–º—É</i> —Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, —á—Ç–æ–±—ã –∫ –Ω–µ–π –±—ã–ª–æ –ª–µ–≥—á–µ –ø–æ–¥–æ–π—Ç–∏ –∏ —Ä–µ—à–∏—Ç—å. –í –Ω–∞—à–µ–º —Å–ª—É—á–∞–µ —Å–∞–º—ã–º –≤–∞–∂–Ω—ã–º —è–≤–ª—è–µ—Ç—Å—è –Ω–∞–±–ª—é–¥–µ–Ω–∏–µ, —á—Ç–æ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ —Å–ª–æ–≤–∞ –≤ –∑–∞–ø—Ä–æ—Å–∞—Ö –≤—ã—Å—Ç—Ä–∞–∏–≤–∞—é—Ç—Å—è –¥—Ä—É–≥ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –¥—Ä—É–≥–∞. <br></li><li> <i>–†–µ–∞–ª–∏–∑—É–π—Ç–µ —Å–≤–æ–µ —Ä–µ—à–µ–Ω–∏–µ</i> . –≠—Ç–æ –≤–∫–ª—é—á–∞–µ—Ç –≤ —Å–µ–±—è –≤—ã–±–æ—Ä –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö –∏ –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤, –∞ —Ç–∞–∫–∂–µ –ø—Ä–æ–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ª–æ–≥–∏–∫–∏, —á–∏—Ç–∞–µ–º–æ–π –∏ –ª–µ–≥–∫–æ –∏–∑–º–µ–Ω—è–µ–º–æ–π –≤ –±—É–¥—É—â–µ–º. <br></li><li> –í–µ—Ä–Ω–∏—Ç–µ—Å—å –Ω–∞–∑–∞–¥, <i>–ø–æ–ø—ã—Ç–∞–π—Ç–µ—Å—å –Ω–∞–π—Ç–∏ –±–∞–≥–∏ –∏ –æ—à–∏–±–∫–∏</i> . –≠—Ç–æ –º–æ–≥—É—Ç –±—ã—Ç—å —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –æ—à–∏–±–∫–∏, –∫–∞–∫ —è –∑–∞–±—ã–ª –≤—Å—Ç–∞–≤–∏—Ç—å –æ–ø–µ—Ä–∞—Ç–æ—Ä <code>continue</code> –≤—ã—à–µ, –∏–ª–∏ –æ—à–∏–±–∫–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏, –∫–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö. <br></li><li> –ö–æ–≥–¥–∞ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø—Ä–æ–±–ª–µ–º—ã –∏–∑–º–µ–Ω–∏—Ç—Å—è, <i>–ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –≤–µ—Å—å –ø—Ä–æ—Ü–µ—Å—Å: –∞–¥–∞–ø—Ç–∏—Ä—É–π—Ç–µ —Å–≤–æ—ë —Ä–µ—à–µ–Ω–∏–µ, –≥–¥–µ —ç—Ç–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ</i> , –∏–ª–∏ –æ—Ç–∫–∞–∂–∏—Ç–µ—Å—å –æ—Ç –Ω–µ–≥–æ, –µ—Å–ª–∏ –æ–Ω–æ –Ω–µ –ø–æ–¥—Ö–æ–¥–∏—Ç. –ü–æ–Ω–∏–º–∞–Ω–∏–µ, –∫–æ–≥–¥–∞ –Ω—É–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å –æ–¥–Ω–æ –∏–ª–∏ –¥—Ä—É–≥–æ–µ, —è–≤–ª—è–µ—Ç—Å—è –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏ –≤–∞–∂–Ω—ã–º –Ω–∞–≤—ã–∫–æ–º –∏ –≤ —Å–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏–∏, –∏ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –º–∏—Ä–µ. <br></li><li> <i>–û—Å–≤–∞–∏–≤–∞–π—Ç–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö –∏ –∞–ª–≥–æ—Ä–∏—Ç–º—ã</i> . –ù–µ–ø–µ—Ä–µ—Å–µ–∫–∞—é—â–∏–µ—Å—è –º–Ω–æ–∂–µ—Å—Ç–≤–∞ ‚Äî –Ω–µ –æ—á–µ–Ω—å –∏–∑–≤–µ—Å—Ç–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞, –Ω–æ –Ω–∞ —Å–∞–º–æ–º –¥–µ–ª–µ –Ω–µ —Ç–∞–∫–∞—è —É–∂ —Ä–µ–¥–∫–∞—è –∏ —É—Ç–æ–Ω—á—ë–Ω–Ω–∞—è. –ï–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π —Å–ø–æ—Å–æ–± –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å –∑–Ω–∞–Ω–∏–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞—Ä–∏—è –¥–ª—è —Ä–∞–±–æ—Ç—ã ‚Äî –∫–∞–∫ –º–æ–∂–Ω–æ –±–æ–ª—å—à–µ —É—á–∏—Ç—å—Å—è. </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">None of these skills can be learned from textbooks (with the possible exception of data structures and algorithms). </font><font style="vertical-align: inherit;">The only way to acquire these is their regular and extensive practice, which agrees well with what the employer needs: experienced candidates who are able to effectively apply their knowledge. </font><font style="vertical-align: inherit;">The meaning of interviews is to find such people, and the task from this article has helped me for a long time.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Future plans </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you could understand, the task eventually </font></font><a href="https://www.careercup.com/question%3Fid%3D5713824039567360"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">became known to the public</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Since then, I have used several other questions, depending on what was asked by past interviewers and on my mood (it‚Äôs boring to ask one question all the time). I still use some questions so far, so I‚Äôll keep them secret, but not some! You can learn them in the following articles. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the near future I am planning two articles. First, as promised above, I will explain the solution of the two remaining problems for this task. I never asked them at interviews, but they are interesting in themselves. In addition, I will share my thoughts and personal opinions on the procedure for finding employees in IT, which is especially interesting to me now, because I am looking for engineers for my team in Reddit.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As always, if you want to learn about new articles, follow me </font></font><a href="https://twitter.com/alex_golec"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on twitter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or on </font></font><a href="https://medium.com/%40alexgolec"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Medium</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">If you liked this article, do not forget to vote for it or leave a comment. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thanks for reading! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS: You can examine the code of all the articles in </font></font><a href="https://github.com/alexgolec/interview-problems"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the repository GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font></font><a href="https://repl.it/%40alexgolec/SynonymQueries"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">play with them live</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> thanks to my good friends from </font></font><a href="http://repl.it/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repl.it</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div><p>Source: <a href="https://habr.com/ru/post/437702/">https://habr.com/ru/post/437702/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>