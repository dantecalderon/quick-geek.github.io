<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Training Cisco 200-125 CCNA v3.0. Cisco Certified Network Specialist (CCNA). Day 2. OSI and TCP-IP models</title>
  <meta name="description" content="From the previous video, we learned about the basics of the network, and today we'll talk about the OSI model and the TCP / IP model. When I say model...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Training Cisco 200-125 CCNA v3.0. Cisco Certified Network Specialist (CCNA). Day 2. OSI and TCP-IP models</h1><div class="post__text post__text-html js-mediator-article">  From the previous video, we learned about the basics of the network, and today we'll talk about the OSI model and the TCP / IP model.  When I say models, I mean nothing more than a set of rules, or a set of standards.  You may ask why we need a set of rules or standards in the computer industry?  To understand this, we need to learn a little about the history of the computer industry. <br><br><img src="https://habrastorage.org/webt/xo/xf/in/xoxfiny2l6u01cuwnueecnpo-ee.jpeg"><br><br>  Not so long ago, a fierce battle took place between IBM and Digital Equipment Corporation (DEC) over who is the leading manufacturer of computers.  But there was a problem.  Both of these manufacturers produced computer equipment that was incompatible with each other.  That is, if you bought an IBM computer, then you had to purchase a monitor for it, a printer and everything else from IBM too.  Similarly, if you bought a device from DEC, then you had to buy all the accessories and other devices from the same manufacturer so that they can be used. <a name="habracut"></a><br><br>  There were many companies that bought equipment from both manufacturers, so that, for example, there were IBM computers in accounting, and the marketing department was equipped with DEC computers.  As a result, these devices could neither communicate nor share information with each other.  Thus, the lack of a unified standard did not allow computer technology to move forward.  This happened around the time when the International Standards Organization, known as ISO, came to the conclusion that there was a need for a common computer standard.  ISO developed OSI - Open System Interconnect, or the OSI reference model.  At about the same time, a competing standard was created - the TCP / IP model, the appearance of which was facilitated by the Ministry of Defense.  The TCP / IP model is more like a stripped-down version of the OSI model and, due to its greater relevance, has become the industry standard.  To get the concept of models, it is necessary to consider the concept of "stack level".  Let's consider it on the example of the office shown in the picture.  Each office has different levels of employees: CEO, senior office staff, salary manager, account manager, service manager, support staff, and junior office staff are all different employees.  The reason why each company has different employees with different job titles is due to the fact that they perform different duties and have different levels of responsibility. <br><br>  Therefore, when something is not done or a specific task is not completed, you know who is responsible for it.  For example, if a salary is not paid on time, then the salary manager is responsible for this.  No matter what the bank may be to blame for, the first contact you use to clarify the issue is the payroll manager.  If your office is not cleaned, then this is responsible economic department.  That is, the job hierarchy allows you to distribute responsibility. <br><br>  Similarly, we need to have knowledge of the OSI model and the TCP / IP model, because when studying computer networks or when problems arise in them, we need to know what works at what level.  Because in the event of a malfunction, we will not need to check all the equipment, as using the level approach, we will know exactly what could be the problem. <br><br>  Let us go directly to the models to figure out how they work and what levels are involved in this.  Let's compare both models. <br><br><img src="https://habrastorage.org/webt/wt/uu/jw/wtuujwps1k4sfv3ruzths5yau1m.jpeg"><br><br>  On the left you see the levels of the OSI model, on the right - TCP / IP.  Let me take the marker to make it clearer.  I marked the levels with different colors, so you won‚Äôt get confused.  Let's start the discussion on the left, with the OSI model.  Before we go further, I will emphasize that as networker students, you should know all these levels and their location by heart! <br><br><img src="https://habrastorage.org/webt/p-/uh/fz/p-uhfzrp_cs38qx3bdkfw30w-ki.jpeg"><br><br>  You need to know that level 7 is the application level, level 6 is the presentation level, level 5 is the session level.  You need to know where these levels are!  One way to memorize a sequence of levels is to use mnemonics.  One of the most popular phrases for memorizing OSI levels is Physical, Data link, Network, Transport, Session, Presentation, Application, from bottom to top, like this: Please, Do Not Throw Sausage Pizza Away (Please do not throw away the pizza with sausage)! <br><br>  If you want to memorize the layout of the levels from top to bottom, use the phrase All People Seem To Need Data Processing (It seems that all people need data processing). <br><br>  In the way of memorization - from top to bottom or from bottom to top - the choice is yours, you just have to remember that 1 level is physical, and 7 is applied.  Some people are confused, believing that the levels go on increasing from top to bottom, and level 1 is applied.  It is not, the first level is physical, and the applied level is level 7. <br><br>  If you want to remember the location of the levels of the TCP / IP model, use the "TCP / IP comes in A TIN" mnemonic.  It means nothing, you just need to remember A TIN - Application, Transport, Internet, Network.  If you have a better way to memorize, use it until you firmly learn these sequences. <br><br>  Let's start with the application layer.  The application layer is the point of contact for all network applications, a common point of contact.  Many authors say and write that all applications on your computer are at this application level, which is not true.  First, the application layer only applies to network applications, and secondly, any applications on your computer have nothing to do with the application layer if they do not communicate over the network. <br><br>  To make it easier for you to understand, I will give a simple example.  Suppose you have removed Wi-Fi and Bluetooth wireless interface drivers, Ethernet network card drivers from your PC, or even physically removed these devices.  So, if you now run, for example, Microsoft Word, it will not be able to communicate with the application level and because of this it will not be able to communicate with any other level.  This is because Microsoft cannot access the network, because your operating system does not even have a network card! <br><br>  Similarly, in a regular system, if you launch a web browser, for example, Chrome, IE, Safari and type in the address bar something like <a href="http://www.cnn.com/">www.cnn.com</a> , the web browser will create an http request that interacts with the application layer.  The application layer transmits this data to the presentation level (often erroneously called the representative level), the presentation level transmits it to the session level, that is to the transport level and so on until the data reaches the physical level.  Here is how it works. <br><br>  Thus, if an application interacts with networks, then this happens only through the application layer.  This level provides access to network services.  The FTP, TFTP, SNMP, DNS, HTTP protocols work at this level, there are quite a lot of them.  You can simply ‚Äúgoogle‚Äù a complete list of all the protocols running at this level! <br><br>  Next we look at the presentation level.  This level performs data presentation and encryption.  The presentation layer is where all the data conversion takes place, it is responsible for encoding the data, that is, after it the data for other levels become the same, regardless of whether it is a picture or a document.  Then it takes the data arriving on the way back from the session level, converts it into a presentable form and transmits it to the application level.  Therefore, if you have raw data coming from the session level, they are converted at the presentation level.  If this is an image, the level creates an image; if it is a Word document, it creates a Word document.  In addition, all encryption services, such as TLS and SSL, work at this level. <br><br><img src="https://habrastorage.org/webt/pz/xs/4e/pzxs4elseq94sixe5q2xkdng4ls.jpeg"><br><br>  Next we have a session level that creates and maintains data transfer sessions.  Suppose that your computer starts two applications ‚Äî Telnet and IE.  Both of these applications gain access to the network.  Therefore, this level creates 2 different sessions and supports them.  Thus, when a web browser session is terminated, the Telnet session will not terminate because they are separate sessions.  That is, this level supports different sessions. <br><br>  You can see that the top three levels 5,6,7 of the OSI model and level 4 of the TCP / IP model are marked with the same blue color.  As a network engineer, especially a Cisco network engineer, I did this for the reason that we very rarely turn to levels 5,6,7.  This is due to the fact that most Cisco devices do not look beyond Level 4.  Levels 1, 2, 3, and 4 are very important to a Cisco engineer, and levels 5,6,7 are not so critical.  You just need to know how it works, and you basically learned what these top three levels do.  The fact is that the operating system basically takes care of them, but as for the work of levels 1, 2, 3 and 4, you as a network engineer should know absolutely everything. <br><br>  We now turn to the consideration of the transport level.  This level is also important for the network engineer.  When the information coming from above arrives at the transport level, it breaks up the data into manageable segments, and on the way back it collects them from the segments again.  To create encapsulation, the transport layer adds its own header to each segment. <br><br><img src="https://habrastorage.org/webt/ro/6b/id/ro6bidm3bmwkyfpsrcuaxfejfqk.jpeg"><br><br>  The transport layer makes two important decisions: use a trusted (TCP) or untrusted (UDP) connection, and creates port numbers.  When applications need to use a trusted connection, TCP is the transmission control protocol.  If an untrusted connection is allowed, the transport layer uses the UDP (User Datagram Protocol).  When I say "trusted", it does not mean that it is better than "untrusted", the only difference between them is that when you install a trusted connection, you must receive confirmation for each package sent.  In an untrusted connection, you do not need to acknowledge receipt of each transmission segment, so it works faster due to lower overhead.  So, if we have real-time applications, they will use UDP because it is faster and it happens in real time.  If you watched streaming video or live online broadcast, sometimes green pixels appear on the screen.  This means that information for this image segment, or this pixel, was not received, and the receiving device has no way of informing the sending device. <br><br>  The second function that the transport layer takes care of is the creation of port numbers.  A port number is a number that is attached to an IP address to determine which process information comes from.  The transport layer creates a random port number of the source (the sending process) and appends the port number of the destination (recipient).  So if your traffic arrives at the server, then the server has the standard port number 80. If you are going to send data to the IP address 10.10.10.10, then the transport layer adds port 80 to this address, which creates a socket 10.10.10.10. 80, which is nothing more than an IP address and port number. <br><br>  The transport layer creates a socket and sends it below the network layer.  It also adds the source port number.  Why do you need this number?  The reason is that if there are 2 applications running on the computer, and the data comes to the same IP address, the transport layer needs to know what data is being transferred to which application.  It will determine this by the source port number. <br><br>  Next we look at the network layer.  When the network layer receives a segment from the transport layer, it adds a network layer header to it.  Adding a header turns a segment into a package. <br><br><img src="https://habrastorage.org/webt/yo/uw/cr/youwcrefsymjhld_yjnoj3ieo6s.jpeg"><br><br>  Thus, one of the most important functions of the network layer is the translation of physical IP addresses into logical addresses, that is, logical addressing.  We will learn about it in the next video ‚ÄúDay 3‚Äù.  For now, just remember that the network layer is the level at which IP addresses are added and the optimal path for data transfer is selected.  The best path means that the network layer compares IP addresses and checks whether the destination IP address is on the local subnet.  If it is not on the local subnet, then the level will find the best path to the destination. <br><br>  Next we have the link level.  When a packet arrives from the network, the link layer adds a channel header to it.  As a result, the package turns into a frame.  The link layer is responsible for MAC addressing.  A MAC is nothing more than an acronym for Media Access Control, and a MAC address is a hardware address. <br><br>  This means that each network card on your computer has its own MAC address.  It is also known as Burn-in-Address, which cannot be changed.  There are software ways to spoof an address, but it is physically impossible to change it. <br><br><img src="https://habrastorage.org/webt/jf/c-/hk/jfc-hk_rp-akf5_odo8m6j6td1i.jpeg"><br><br>  This is the level at which error checking occurs.  Therefore, when information comes from the physical layer, the link layer checks it for errors that occurred during the transfer process and corrects them.  It can use cyclic redundancy checking ‚Äî a CRC checksum calculation algorithm, parity check, or any other error checking mechanism. <br><br>  Then follows the physical layer, where data is actually transmitted.  Here the data is in the form of bits.  This layer deals with wires, cables, hardware ports or connectors, and the like, which ensure the processes taking place at this level.  When someone tells you that the Internet does not work for him, you, as a computer or network engineer, start working with physical troubleshooting.  First of all, you will check all the connectors and cables, and if they are in order, you will proceed to troubleshoot at 2,3,4 levels.  That is why we need to know about network models and remember that any change at one of the levels will not affect the neighboring ones, because this is provided for by the standard. <br><br>  Therefore, if I prefer to use a wireless connection at the physical level instead of the LAN cable, this should not affect the other levels at all, because the change occurred only at the physical level.  Thus, while at the physical level information is received in the normal mode, the method of obtaining this information does not matter. <br><br>  Similarly, it happens at the network level.  We are now in the midst of a transitional phase from IPv4 to IPv6, so this change only applies to level three.  Layer 4 and layer 2 will not be affected by this, as long as the existing standard is respected and they receive data in the same way as before. <br><br><img src="https://habrastorage.org/webt/26/n8/ft/26n8ftjoz01ivteufid5gnwuiam.jpeg"><br><br>  Such is the beauty of a multi-level approach to networking.  If you compare the left and right half of the figure, you can see that level 5,6,7 of the OSI model is comparable to level 4 of the TCP / IP model.  The transport layer performs similar functions in both models, a similar correspondence occurs at levels 2 and 3, and levels 1 and 2 of the OSI model in their functions correspond to level 1 of the TCP / IP model. <br><br>  Next, we look at how the OSI model works.  Let's say the little man on the left is going to send information to the right little man and for this creates data.  Since we have agreed that the top three levels 5.6 and 7 are not of particular interest to us, let us go straight to level 4 of the transport level, where our data arrive. <br><br><img src="https://habrastorage.org/webt/oc/0a/8t/oc0a8tcwhmp1ur1o3gc-lu4k4h8.jpeg"><br><br>  The transport layer accepts data, segments it and adds its own header ‚Äî you can see it in the figure.  Suppose we are dealing with UDP here, so he does not wait for confirmations.  It sends segment 1 to the network layer, it adds a network header to the segment, and now it becomes a packet. <br><br><img src="https://habrastorage.org/webt/cf/ew/ql/cfewqlb6timagqagojf4xguta-w.jpeg"><br><br>  Next, the network layer sends this packet 1 to the data link layer.  He accepts the packet and provides it with a Data Link header. <br><br><img src="https://habrastorage.org/webt/a6/-z/xf/a6-zxfeuy0zm7fxb2pa_lzar7hi.jpeg"><br><br>  As you can see, the same procedure applies to segment 2.  Then segment 1 goes to the physical communication layer, which converts it into a sequence of bits and sends it to the physical layer of our addressee. <br><br><img src="https://habrastorage.org/webt/l7/dm/gt/l7dmgtya6idhunvme8ckoliwyje.jpeg"><br><br>  So, our segment 1 has been converted, and the second segment will also be converted into a sequence of bits.  By that time, the right physical layer will already accept the previous segment as physical bits and convert it to a segment with a corresponding set of headers. <br><br><img src="https://habrastorage.org/webt/bc/ff/ls/bcfflsbjudzyjt_n5k0djmp_ymg.jpeg"><br><br>  Receiving levels at each step cut off the corresponding header and transmit the segment above.  Thus, when segment 1 switches from the link layer to the network layer, it will lose the link layer header. <br><br><img src="https://habrastorage.org/webt/js/kn/z4/jsknz4bqeg6igpqfjk84to36qae.jpeg"><br><br>  Similarly, it will happen with the second segment.  When segment 1 reaches the transport layer, the network header will be removed.  Further, the transport layer will wait until it receives all the transmitted segments. <br><br><img src="https://habrastorage.org/webt/jh/ge/gx/jhgegxlstvstbg41uqslutfdiim.jpeg"><br><br>  This is what the transport level does - it waits for the 2nd segment to reach it. <br><br><img src="https://habrastorage.org/webt/ka/kk/h_/kakkh_cn6svysyymsyjrvv_f4fc.jpeg"><br><br>  After that, the transport layer will delete all its headers, merge the segments into an array of data and transmit the data to the upper levels, and the right little man will receive exactly the same data that the left little man sent him. <br><br><img src="https://habrastorage.org/webt/qj/t2/5t/qjt25tshhe0lzpdkuw7mwnp2gec.jpeg"><br><br>  This is a generalized representation of how data transfer over the network works.  That's all we had to learn in the second video tutorial. –í –ø–æ—Å–ª–µ–¥—É—é—â–∏—Ö —É—Ä–æ–∫–∞—Ö –º—ã –∏–∑—É—á–∏–º –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –ø–æ–Ω—è—Ç–∏—è, –∫–∞—Å–∞—é—â–∏–µ—Å—è —Å–µ—Ç–µ–π, –∏ –µ—Å–ª–∏ –≤—ã —á–µ–≥–æ-—Ç–æ –Ω–µ –ø–æ–π–º—ë—Ç–µ, –æ–±—Ä–∞—â–∞–π—Ç–µ—Å—å –∫–æ –º–Ω–µ –Ω–∞ —ç–ª–µ–∫—Ç—Ä–æ–Ω–Ω—É—é –ø–æ—á—Ç—É imran.rafai@nwking.org.  Thank you for attention. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/l_OPR2yh2co" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Thank you for staying with us.  Do you like our articles?  Want to see more interesting materials?  Support us by placing an order or recommending to friends, <b>30% discount for Habr users on a unique analogue of the entry-level servers that we invented for you:</b> <a href="https://habr.com/company/ua-hosting/blog/347386/">The whole truth about VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps from $ 20 or how to share the server?</a>  (Options are available with RAID1 and RAID10, up to 24 cores and up to 40GB DDR4). <br><br>  <b>VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps until spring for free</b> if you pay for a period of six months, you can order <a href="https://ua-hosting.company/vpsnl">here</a> . <br><br>  <b>Dell R730xd 2 times cheaper?</b>  Only we have <b><a href="https://ua-hosting.company/serversnl">2 x Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 TV from $ 249</a> in the Netherlands and the USA!</b>  Read about <a href="https://habr.com/company/ua-hosting/blog/329618/">How to build an infrastructure building.</a>  <a href="https://habr.com/company/ua-hosting/blog/329618/">class c using servers Dell R730xd E5-2650 v4 worth 9000 euros for a penny?</a> </div><p>Source: <a href="https://habr.com/ru/post/439050/">https://habr.com/ru/post/439050/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>