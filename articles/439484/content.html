<div class="post__text post__text-html js-mediator-article"><h1 id="nemnogo-likbeza">  Bit of education </h1><br><p> I really love Automapper, especially its <a href="https://automapper.readthedocs.io/en/latest/Queryable-Extensions.html">QueryableExtensions and the ProjectTo &lt;&gt; method</a> .  In short, this method allows you to make a projection of types directly in the SQL query.  This made it possible to get dto from the actual database.  Those.  You do not need to get all the entity from the database, load them into memory, use <code>Automapper.Map&lt;&gt;</code> , which led to a large consumption and memory traffic. </p><a name="habracut"></a><br><h1 id="proekciya-tipa">  Projection type </h1><br><p>  To obtain a projection in linq, it was necessary to write something like this: </p><br><pre> <code class="plaintext hljs"> from user in dbContext.Users where user.IsActive select new { Name = user.Name, Status = user.IsConnected ? "Connected" : "Disconnected" }</code> </pre> <br><p>  Using QueryableExtensions, this code can be replaced with the following (of course, provided that the User-&gt; UserInfo conversion rules are already described) </p><br><pre> <code class="plaintext hljs">dbContext.Users.Where(x =&gt; x.IsActive).ProjectTo&lt;UserInfo&gt;();</code> </pre> <br><h1 id="enum-i-problemy-s-nim">  Enum and problems with it </h1><br><p>  There is one drawback to the projection that needs to be considered.  This is a limitation on the operations performed.  <a href="https://automapper.readthedocs.io/en/latest/Queryable-Extensions.html">Not everything can be translated into a SQL query</a> .  In particular, it is impossible to obtain information on the type of transfer.  For example, there is the following Enum </p><br><pre> <code class="plaintext hljs"> public enum FooEnum { [Display(Name = "Любой")] Any, [Display(Name = "Открытый")] Open, [Display(Name = "Закрытый")] Closed }</code> </pre> <br><p>  There is an entity in which a property of type FooEnum is declared.  In dto, you do not need to get Enum itself, but the value of the Name property of the DisplayAttribute attribute.  To realize this through a projection does not work out, since  retrieving an attribute value requires a Reflection, which SQL simply "knows nothing" about. </p><br><p>  As a result, you have to either use the usual <code>Map&lt;&gt;</code> , loading all the entities into memory, or get an additional table with Enum values ​​and foreign keys on it. </p><br><h1 id="reshenie-est---expressions">  The solution is - Expressions </h1><br><p>  But "there is a hole on the old woman."  After all, all Enum values ​​are known in advance.  In SQL, there is a <code>switch</code> implementation that you can insert when creating a projection.  It remains to understand how to do it.  HashTag: "Trees-expressions-our-all." </p><br><p>  Automapper, when projecting types, can convert expression to an expression that converts to the corresponding SQL query after the Entity Framework. </p><br><p>  At first glance, the syntax for creating expression trees at runtime is extremely inconvenient.  But after a few small tasks solved, everything becomes obvious.  To solve the Enum problem, you need to create an embedded tree of conditional expressions that return values, depending on the source data.  About </p><br><pre> <code class="plaintext hljs">IF enum=Any THEN RETURN "Любой" ELSE IF enum=Open THEN RETURN "Открытый" ELSE enum=Closed THEN RETURN "Закрытый" ELSE RETURN ""</code> </pre> <br><p>  Let's define the method signature. </p><br><pre> <code class="plaintext hljs"> public class FooEntity { public int Id { get; set; } public FooEnum Enum { get; set; } } public class FooDto { public int Id { get; set; } public string Name { get; set; } } //Задаем правило Automapper CreateMap&lt;FooEntity, FooDto&gt;() .ForMember(x =&gt; x.Enum, options =&gt; options.MapFrom(GetExpression())); private Expression&lt;Func&lt;FooEntity, string&gt;&gt; GetExpression() { }</code> </pre> <br><p>  The <code>GetExpression()</code> method should form an expression that gets an instance of FooEntity and returns a string representation for the <code>Enum</code> property. <br>  First we define the input parameter and get the property value itself. </p><br><pre> <code class="plaintext hljs">ParameterExpression value = Expression.Parameter(typeof(FooEntity), "x"); var propertyExpression = Expression.Property(value, "Enum");</code> </pre> <br><p>  Instead of using the property name string, you can use the <code>nameof(FooEntity.Enum)</code> compiler <code>nameof(FooEntity.Enum)</code> or even get information about the <code>System.Reflection.PropertyInfo</code> property or the <code>System.Reflection.MethodInfo</code> getter.  But for example, we have enough and explicitly set the name of the property. </p><br><p>  To return a specific value, use the <code>Expression.Constant</code> method.  We form the default </p><br><pre> <code class="plaintext hljs"> Expression resultExpression = Expression.Constant(string.Empty);</code> </pre> <br><p>  After that, consistently "wrap" the result in the condition. </p><br><pre> <code class="plaintext hljs"> resultExpression = Expression.Condition( Expression.Equal(propertyExpression, Expression.Constant(FooEnum.Any)), Expression.Constant(EnumHelper.GetShortName(FooEnum.Any)), resultExpression); resultExpression = Expression.Condition( Expression.Equal(propertyExpression, Expression.Constant(FooEnum.Open)), Expression.Constant(EnumHelper.GetShortName(FooEnum.Open)), resultExpression); resultExpression = Expression.Condition( Expression.Equal(propertyExpression, Expression.Constant(FooEnum.Closed)), Expression.Constant(EnumHelper.GetShortName(FooEnum.Closed)), resultExpression);</code> </pre> <br><pre> <code class="plaintext hljs"> public static class EnumHelper { public static string GetShortName(this Enum enumeration) { return (enumeration .GetType() .GetMember(enumeration.ToString())? .FirstOrDefault()? .GetCustomAttributes(typeof(DisplayAttribute), false)? .FirstOrDefault() as DisplayAttribute)? .ShortName ?? enumeration.ToString(); } }</code> </pre> <br><p>  All that is left is to issue a result. </p><br><pre> <code class="plaintext hljs"> return Expression.Lambda&lt;Func&lt;TEntity, string&gt;&gt;(resultExpression, value);</code> </pre> <br><h1 id="esche-nemnogo-refleksii">  A little more reflection </h1><br><p>  Copying all Enum values ​​is extremely inconvenient.  Let's fix it </p><br><pre> <code class="plaintext hljs"> var enumValues = Enum.GetValues(typeof(FooEnum)).Cast&lt;Enum&gt;(); Expression resultExpression = Expression.Constant(string.Empty); foreach (var enumValue in enumValues) { resultExpression = Expression.Condition( Expression.Equal(propertyExpression, Expression.Constant(enumValue)), Expression.Constant(EnumHelper.GetShortName(enumValue)), resultExpression); }</code> </pre> <br><h1 id="usovershenstvuem-poluchenie-znacheniya-svoystva">  Improve the retrieval of the property value. </h1><br><p>  The disadvantage of the code above is the hard binding of the type of entity being used.  If a similar problem needs to be solved in relation to another class, it is necessary to think of a way to get the value of an enumerated type property.  So let expression do it for us.  As a parameter of the method, we will pass an expression that gets the value of the property, and the code itself - we simply generate a set of results for the possible properties.  Templates to help us </p><br><pre> <code class="plaintext hljs"> public static Expression&lt;Func&lt;TEntity, string&gt;&gt; CreateEnumShortNameExpression&lt;TEntity, TEnum&gt;(Expression&lt;Func&lt;TEntity, TEnum&gt;&gt; propertyExpression) where TEntity : class where TEnum : struct { var enumValues = Enum.GetValues(typeof(TEnum)).Cast&lt;Enum&gt;(); Expression resultExpression = Expression.Constant(string.Empty); foreach (var enumValue in enumValues) { resultExpression = Expression.Condition( Expression.Equal(propertyExpression.Body, Expression.Constant(enumValue)), Expression.Constant(EnumHelper.GetShortName(enumValue)), resultExpression); } return Expression.Lambda&lt;Func&lt;TEntity, string&gt;&gt;(resultExpression, propertyExpression.Parameters); }</code> </pre> <br><p>  A few explanations.  Since  we get the input value through another expression, we do not need to declare the parameter through the <code>Expression.Parameter</code> .  We take this parameter from the property of the input expression, and use the body of the expression to get the value of the property. <br>  Then use the new method as follows: </p><br><pre> <code class="plaintext hljs"> CreateMap&lt;FooEntity, FooDto&gt;() .ForMember(x =&gt; x.Enum, options =&gt; options.MapFrom(GetExpression&lt;FooEntity, FooEnum&gt;(x =&gt; x.Enum)));</code> </pre> <br><hr><br><p>  All successful development of trees of expression. </p><br><p>  I highly recommend reading articles by <a href="https://habr.com/ru/users/marshinov/">Maxim Arshinov</a> .  Especially about <a href="https://habr.com/ru/company/jugru/blog/423891/">expression trees in enterprise development</a> . </p></div>