<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>HTTP / 3: from root to tip</title>
  <meta name="description" content="The application layer protocol HTTP is the basis of the Internet. He began his life in 1991 as HTTP / 0.9, and by 1999 turned into HTTP / 1.1, which w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>HTTP / 3: from root to tip</h1><div class="post__text post__text-html js-mediator-article">  The application layer protocol HTTP is the basis of the Internet.  He began his life in 1991 as HTTP / 0.9, and by 1999 turned into HTTP / 1.1, which was standardized by the Internet Engineering Task Force (IETF). <br><br>  HTTP / 1.1 satisfied everyone for a long time, but the growing needs of the Network required an upgrade - and in 2015 they accepted HTTP / 2.  The story is not over: just recently, the IETF announced a new version of HTTP / 3.  For some, this came as a surprise and caused some confusion.  If you are not tracking IETF, HTTP / 3 may seem to come from nowhere.  Nevertheless, we can trace its origin in the history of experiments and the evolution of web protocols, in particular, the QUIC transport protocol. <br><br>  If you are not familiar with QUIC, my Cloudflare colleagues have covered various aspects in some detail: for example, see the articles on the <a href="https://blog.cloudflare.com/the-quicening/">real disadvantages of modern HTTP</a> and <a href="https://blog.cloudflare.com/the-road-to-quic/">details on the transport layer protocol</a> .  We have collected these and other materials on <a href="https://cloudflare-quic.com/">cloudflare-quic.com</a> .  And if you're interested, be sure to check out <a href="https://blog.cloudflare.com/enjoy-a-slice-of-quic-and-rust/">quiche</a> : this is our own QUIC implementation, written in Rust with open source code. <br><a name="habracut"></a><br>  HTTP / 3 - translation of the QUIC transport protocol for the application layer.  The name HTTP / 3 was officially approved only recently, in the 17th version of the draft ( <a href="http-17">draft-ietf-quic-http-17</a> ).  It was proposed at the end of October 2018, and consensus was reached at the IETF 103 meeting in Bangkok in November. <br><br>  Previously, HTTP / 3 was known as HTTP by QUIC, and before that it was known as HTTP / 2 by gQUIC, and even earlier - SPDY by gQUIC.  But the bottom line is that HTTP / 3 is just the new HTTP syntax that runs on the IETF QUIC protocol, a multiplexed and secure UDP-based transport. <br><br>  In this article, we will look at the history of some of the previous HTTP / 3 names and present the motivation for the last name change.  Let's go back to the first days of HTTP and everything that happened during this time.  If you want to get the full picture, you can go directly to the end of the article or open <a href="">this very detailed version of SVG</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d2b/841/607/d2b841607ca3e0a8bffad1a787913c5f.png"><br>  <i><font color="gray">HTTP / 3 layer cake</font></i> <br><br><h1>  Situation </h1><br>  Just before focusing on HTTP, it‚Äôs worth recalling that there are two protocols called QUIC.  As we have already <a href="https://blog.cloudflare.com/the-road-to-quic/">explained</a> , gQUIC is commonly used as an acronym for Google QUIC (the original protocol), and QUIC as an IETF version that differs from gQUIC. <br><br>  Since the beginning of the 90s, the needs of the Internet have changed.  We have new versions of HTTP and a new level of security in the form of the Transport Layer Security (TLS) protocol.  In this article we will only touch on TLS, and in <a href="https://blog.cloudflare.com/tag/tls/">other articles of</a> our blog you can study the topic in more detail. <br><br>  The history of HTTP and TLS cannot be expressed by a simple list of dates, since some branches evolved in parallel and overlapped in time.  When you are trying to connect all the points for almost 30 years of Internet history, you cannot do without visualization.  So I made this schedule: Cloudflare Secure Web Timeline.  (note: technically this is a <a href="https://en.wikipedia.org/wiki/Cladogram">cladogram</a> , although people are more familiar with the word "chart"). <br><br> <a href=""><img src="https://habrastorage.org/webt/j_/uv/ww/j_uvww5d_hmiykedtaritata8ja.png"></a> <br><br>  For the sake of beauty, I dropped some of the information, focusing only on the successful branches in the IETF space.  For example, the efforts of the HTTP-NG working group of the W3 consortium are not shown here, as well as some exotic technologies that the authors are still trying to explain their pronunciation: <a href="http-with-minimal-protocol.html">HMURR</a> (pronounced "hummer") and <a href="https://github.com/HTTPWorkshop/workshop2017/blob/master/talks/waka.pdf">WAKA</a> (pronounced "wah-kah"). <br><br>  In the following sections, we will go through this cladogram and consider some turning points in the HTTP history.  I hope this helps to understand why standardization is beneficial to all, and how the IETF approaches this issue.  Therefore, let us begin with a very brief overview of the topic, before returning to the wig itself.  Feel free to skip the next section if you are already familiar with the IETF. <br><br><h1>  Types of Internet Standard </h1><br>  Typically, standards define general competence, scope, limitations, applicability, and other considerations.  Standards exist in different shapes and sizes.  They can be informal (de facto standard) or formal (agreed / published by a standard setting organization such as IETF, ISO or MPEG).  Standards are used in many areas, there is even a formal British tea-making standard - BS 6008. <br><br>  The first definitions of the HTTP and SSL protocols were published outside the IETF: they are marked with <b>red lines</b> in the graph.  But widespread use made them de facto standards. <br><br>  At some point, it was decided to formalize these protocols (some reasons are described below).  Internet standards are usually defined in the IETF, which is guided by the unofficial principle of ‚Äúexemplary consensus and current code‚Äù based on actual applications on the Internet.  This is different from the ‚Äúclean room‚Äù approach when someone tries to develop ideal protocols in a vacuum. <br><br>  IETF standards are commonly known as RFCs.  This is difficult to explain in brief, therefore I recommend the article <a href="https://www.ietf.org/blog/how-read-rfc/">‚ÄúHow to read RFCs‚Äù</a> from Mark Nottingham, co-chair of the QUIC working group.  A working group or WG is, in essence, just a mailing list. <br><br>  Three meetings are held each year for the personal meetings of members of all working groups, if they so wish.  The agenda for these weeks can be very rich, there is not enough time for an in-depth discussion of technical issues.  Therefore, some prefer to have more interim meetings between general IETF meetings.  Since 2017, the QUIC working group has held several intermediate meetings, the full list is available on the <a href="https://datatracker.ietf.org/wg/quic/meetings/">page for meetings</a> . <br><br>  These meetings have the opportunity to meet with experts from other organizations, such as <a href="https://www.iab.org/">the Internet Architecture Board</a> (IAB) or the <a href="https://irtf.org/">Internet Technology Research Group</a> (IRTF).  In recent years, the IETF <a href="https://www.ietf.org/how/runningcode/hackathons/">hackathon</a> has traditionally been held at the weekend before the IETF meeting.  This is where real code is developed and, importantly, pass compatibility tests.  This helps to find problems in the specifications that can be discussed directly at the meeting. <br><br>  It is important to understand that RFCs do not arise from nowhere.  They go through a whole process.  It usually starts with the IETF Internet Draft (ID) draft that is submitted for review.  In the case when the specification is already published, the preparation of the ID will be a simple reformat.  The service life of the ID is 6 months from the date of publication.  To keep it active, you need to publish new versions.  In practice, there is nothing terrible in the fact that the ID expires.  This happens quite often.  Documents are still stored on the IETF website and are open to all. <br><br>  On the cladogram, drafts are presented in <b>purple</b> .  Each has its <i>own</i> name in the <i>draft- {author} - {working group} - {theme} - {version}</i> format.  The WG field is optional, it may indicate a future IETF working group and sometimes changes.  If the ID is approved by the IETF or initiated directly within the IETF, then the draft is called <i>draft-ietf- {working group} - {topic} - {version}</i> .  IDs may branch, merge or fade.  The version starts at 00 and is increased by one with each new project.  For example, the fourth draft will receive the version number 03. Each time the ID name is changed, its version is reset to 00. <br><br>  It is important to note that anyone can submit a draft to the IETF: they cannot be considered as standards.  But if the standardization process reaches a consensus and the final document passes the test, we will get an RFC.  At this stage, the name is changed again.  Each RFC receives a unique number, for example, <a href="https://tools.ietf.org/html/rfc7230">RFC 7230</a> .  Documents with this status are presented in the form of <b>blue lines</b> . <br><br>  RFC is forbidden to change.  That is, changes in the RFC require the adoption of a document with a new number.  Changes are allowed only for the correction of editorial or technical errors or for a simple optimization of the layout.  Newer RFCs can completely replace old ones or supplement them. <br><br>  All IETF documents are publicly available at <a href="http://tools.ietf.org/">http://tools.ietf.org</a> .  Personally, it seems to me a bit more comfortable with <a href="https://datatracker.ietf.org/">IETF Datatracker</a> , because the document path from ID to RFC is visually displayed there. <br><br>  Below is an example that shows the evolution of the <a href="https://tools.ietf.org/html/rfc1945">RFC 1945</a> standard, that is, HTTP / 1.0. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c38/ce9/2bb/c38ce92bb2a76e0e029c695597f6ccd0.png"><br>  <i><font color="gray">RFC 1945 history in the IETF Datatracker interface</font></i> <br><br>  Interestingly, in the course of the work, I found that the above visualization is incorrect.  For some reason, <a href="http-v10-spec-05">draft-ietf-http-v10-spec-05 is</a> missing.  Since the ID lifetime is 6 months, it probably expired before the adoption of the RFC, although in reality the draft was active until August 1996. <br><br><h1>  Cladogram study </h1><br>  After a small theoretical introduction, we can proceed to the study of the cladogram.  This section presents some excerpts from the most important parts.  Each dot indicates the date of submission of the document or function.  For clarity, IETF documents have project numbers omitted, but they are all in the <a href="">full version</a> . <br><br>  HTTP appeared in 1991 as the HTTP / 0.9 protocol, and in 1994 a draft <a href="http-spec-00">draft-fielding-http-spec-00</a> was published.  Soon it was adopted by the IETF, with the result that the name changed to <a href="http-v10-spec-00">draft-ietf-http-v10-spec-00</a> .  After six drafts of the draft in 1996, the <a href="https://tools.ietf.org/html/rfc1945">RFC 1945</a> standard was adopted - HTTP / 1.0. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae8/ca6/67c/ae8ca667c9e3f471863cc33ff3e9935e.png"><br><br>  However, even before the completion of work on HTTP / 1.0, a separate HTTP / 1.1 project was launched.  The draft version of <a href="http-v11-spec-00">draft-ietf-http-v11-spec-00 was</a> published in November 1995, and officially adopted as <a href="https://tools.ietf.org/html/rfc2068">RFC 2068</a> in 1997.  The keen eye will notice that the cladogram does not quite reflect this sequence of events - an unsuccessful visualization tool glitch.  I tried as much as possible to minimize such problems. <br><br>  In mid-1997, HTTP / 1.1 revision began as <a href="http-v11-spec-rev-00">draft-ietf-http-v11-spec-rev-00</a> .  It ended in 1999 with the publication of <a href="https://tools.ietf.org/html/rfc2616">RFC 2616</a> .  Until 2007, everything was quiet in the IETF HTTP world.  Let's come back to this later. <br><br><h1>  SSL and TLS history </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/902/65c/c12/90265cc128b3bc4445c3845d7ded1726.png"><br><br>  Let's switch attention to the SSL trajectory.  We see that the SSL 2.0 specification came out around 1995, and SSL 3.0 came out in November 1996.  Interestingly, SSL 3.0 is approved in <a href="https://tools.ietf.org/html/rfc6101">RFC 6101</a> , which appeared only in August 2011.  It is located in the <b>historical</b> section.  <a href="https://www.ietf.org/blog/iesg-statement-designating-rfcs-historic/%3Fprimary_topic%3D7%26">According to the IETF</a> , it was created ‚Äúto document ideas that were reviewed and rejected, or protocols that already existed by the time they decided to document them.‚Äù  In this case, an IETF document with a description of SSL 3.0 was needed to be used everywhere as a canonical link. <br><br>  We are more interested in how SSL inspired the engineers to develop TLS, which began with a draft <a href="https://tools.ietf.org/html/draft-ietf-tls-protocol-00">draft-ietf-tls-protocol-00</a> in November 1996.  It went through 6 draft versions and was published as <a href="https://tools.ietf.org/html/rfc2246">RFC 2246</a> - TLS 1.0 in early 1999. <br><br>  In 1995-1999, SSL and TLS protocols were used to protect HTTP connections on the Internet.  It worked great as a de facto standard.  Only in January 1998, with the publication of the draft <a href="https-00">draft-ietf-tls-https-00</a> , the process of official standardization of HTTPS began.  The work ended in May 2000 with the publication of <a href="https://tools.ietf.org/html/rfc2616">RFC 2616</a> - HTTP over TLS. <br><br>  TLS continued to evolve from 2000 to 2007, with the adoption of TLS 1.1 and 1.2 standards.  Then there was a seven-year pause before work began on the next version of the TLS protocol, which will be published as <a href="https://tools.ietf.org/html/draft-ietf-tls-tls13-00">draft-ietf-tls-tls13-00</a> in April 2014, and after 28 drafts will be <a href="https://tools.ietf.org/html/rfc8446">approved</a> as <a href="https://tools.ietf.org/html/rfc8446">RFC 8446</a> - TLS 1.3 in August 2018. <br><br><h1>  Internet standardization process </h1><br>  After a brief introduction to the cladogram, I hope it became better to understand how the IETF works.  When creating standards, researchers or engineers develop experimental protocols for specific use cases.  At various levels, they experiment with public or private protocols.  The information obtained allows you to identify problems or improve the protocol.  The publication of the work helps to explain the experiment, the collection of the opinion of a wider range of specialists or to find the help of other performers.  If other participants accept this work at an early stage, then it will become a de facto standard, and eventually there will be enough momentum for official standardization. <br><br>  The official status of the protocol is an important factor for organizations that are thinking about using it.  The formal standardization process increases the attractiveness of the standard de facto, because it usually provides stability.  The management and leadership is undertaken by a reputable organization, such as the IETF, which reflects the interests and experience of many participants.  But it should be noted that not all formal standards become successful. <br><br>  The process of creating a standard is almost as important as the standard itself.  Processing the initial idea, inviting people to discuss with broader knowledge, experience and use cases - all this helps to create something more useful for a wide audience.  However, the standardization process is not always easy.  There are pitfalls and obstacles.  Sometimes the process takes so much time that the result is no longer relevant. <br><br>  Each organization that defines the standards usually has its own process, focused on its field of activity and participants.  Explaining all the details of how the IETF works is well beyond the scope of this article.  If you're interested, a great starting point would be the <a href="https://www.ietf.org/how/">‚ÄúHow we work‚Äù</a> page on the IETF website.  As usual, the best way to figure it out is to take part yourself.  Simply join the mailing list or the discussion in the corresponding GitHub repository. <br><br><h1>  Cloudflare Work Code </h1><br>  Cloudflare is proud to be one of the first to introduce new protocols, as was the case with <a href="http2/">HTTP / 2</a> and other technologies.  We also test experimental and not yet approved features, such as <a href="https://blog.cloudflare.com/introducing-tls-1-3/">TLS 1.3</a> and <a href="https://blog.cloudflare.com/introducing-spdy/">SPDY</a> . <br><br>  Running a real code helps to understand how well the protocol will work in practice.  We combine expert knowledge with experimental information to help improve the code and, where it makes sense, report problems or improvements to a working group that standardizes the protocol. <br><br>  Testing innovations is not the only priority.  A true innovator always knows when to postpone innovation until better times.  Sometimes this refers to security-oriented protocols: for example, Cloudflare has <a href="https://blog.cloudflare.com/sslv3-support-disabled-by-default-due-to-vulnerability/">disabled SSLv3 by default</a> due to the POODLE vulnerability.  In other cases, the protocols are replaced by more technologically advanced ones: for example, we <a href="https://blog.cloudflare.com/deprecating-spdy/">replaced SPDY with HTTP / 2</a> . <br><br>  The introduction and deactivation of protocols on Cloudflare is represented by <b>orange lines</b> .  Vertical landmarks help align Cloudflare events with relevant IETF documents.  For example, Cloudflare introduced support for TLS 1.3 in September 2016, and the final <a href="https://tools.ietf.org/html/rfc8446">RFC 8446</a> document was published almost two years later, in August 2018. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/78a/699/924/78a699924a011dbbf00d9adb4e3bdf67.png"><br><br><h1>  Refactoring: HTTPbis </h1><br>  HTTP / 1.1 is a very successful protocol.  The chart does not show much IETF activity after 1999.  But in reality, years of active use of the protocol gave experience and revealed hidden problems of RFC 2616, including some compatibility issues.  In addition, the protocol has been extended by other RFCs, such as 2817 and 2818. As a result, in 2007 it was decided to begin activities to improve the HTTP specification.  It is called HTTPbis (where ‚Äúbis‚Äù is derived from the Latin word for ‚Äútwo,‚Äù ‚Äútwice,‚Äù or ‚Äúrepetition‚Äù).  The initial <a href="httpbis-2007-10-23.txt">charter of the</a> new working group well describes the problems that it tried to solve. <br><br>  In general, <a href="https://tools.ietf.org/html/rfc2616">RFC 2616</a> began refactoring on HTTPbis.  It includes bug fixes and the introduction of some aspects from other specifications that are published at the same time.  It was decided to divide the document into parts.  As a result, in December 2007, six drafts were published: <br><br><ul><li>  draft-ietf-httpbis-p1-messaging </li><li>  draft-ietf-httpbis-p2-semantics </li><li>  draft-ietf-httpbis-p4-conditional </li><li>  draft-ietf-httpbis-p5-range </li><li>  draft-ietf-httpbis-p6-cache </li><li>  draft-ietf-httpbis-p7-auth </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/bd3/d56/984/bd3d5698449ecb1d26c6df428c4ac9c2.png"><br><br>  The diagram shows how the work progressed during the long seven-year development process.  Before the final standardization, 27 drafts were accepted.  In June 2014, the so-called RFC 723x series came out (where x ranges from 0 to 5).  The chairman of the HTTPbis working group noted this achievement with the phrase <a href="https://www.mnot.net/blog/2014/06/07/rfc2616_is_dead">‚ÄúRFC2616 is dead‚Äù</a> .  If someone did not understand, the new documents sent to the archive the old <a href="https://tools.ietf.org/html/rfc2616">RFC 2616</a> . <br><br><h1>  What does this have to do with HTTP / 3? </h1><br>  While the IETF was refining RFC 723x, the world was not in place.  People continued to expand and complement HTTP.  Among them are Google engineers who have begun to experiment with their own protocol called SPDY (pronounced ‚Äúspeedy‚Äù).  They said that this protocol speeds up the loading of web pages, which is an essential function of HTTP.  At the end of 2009, the first version was announced, and in 2010 SPDY v2 quickly appeared. <br><br>  I do not want to go into the technical details of SPDY, but it is important to understand that SPDY took the main HTTP paradigms and slightly changed the exchange format for optimization.  Looking back, we see that HTTP has clearly defined semantics and syntax.  Semantics describes the concept of exchanging requests and responses, including methods, status codes, header fields (metadata) and bodies (useful data).  The syntax describes how to map semantics to bytes on a network. <br><br>  HTTP / 0.9, 1.0 and 1.1 have a lot of common semantics.  They also use a common syntax in the form of character strings sent via TCP connections.  SPDY took the HTTP / 1.1 semantics and changed the syntax to binary.  This is a really interesting topic, but today we will not go deep into this rabbit hole. <br><br>  Experiments with SPDY have shown that changing the syntax of HTTP really brings effect.  At the same time, it is important to preserve the existing semantics.  For example, saving the URL format for using <code>https://</code> allowed us to avoid many problems that could affect the implementation of HTTPS. <br><br>  After seeing some positive results, the IETF decided it was time to consider the options for HTTP / 2.0.  The <a href="httpwg/wg-materials/blob/gh-pages/ietf83/HTTP2.pdf">slides</a> from the HTTPbis session, held during the IETF 83 meeting in March 2012, outlined the requirements and goals that the developers had set for themselves.  It is also clearly stated: "HTTP / 2.0 only means that the transport protocol (wire format) is not compatible with HTTP / 1.x" <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ef/97d/7cd/3ef97d7cd4e2637b3b44ba03696917bd.png"><br><br>  During this meeting, the community was invited to express their ideas.  Among the drafts submitted for review were <a href="httpbis-spdy-00">draft-mbelshe-httpbis-spdy-00</a> , <a href="httpbis-speed-mobility-00">draft-montenegro-httpbis-speed-mobility-00</a> and <a href="httpbis-network-friendly-00">draft-tarreau-httpbis-network-friendly-00</a> .  In the end, the draft SPDY was adopted, and in November 2012 work began on <a href="http2-00">draft-ietf-httpbis-http2-00</a> .  After 18 drafts for a little over two years, <a href="https://tools.ietf.org/html/rfc7540">RFC 7540</a> appeared - HTTP / 2.  By 2015, the HTTP / 2 syntax has gone just enough to make HTTP / 2 and SPDY incompatible. <br><br>  These years have become a very stressful period for working groups, which in parallel carried out HTTP / 1.1 refactoring and accepted HTTP / 2.  This contrasts sharply with the many years of calm in the early 2000s.  Be sure to check out the full cladogram to truly appreciate the amount of work done. <br><br>  Despite the standardization of HTTP / 2, experiments with SPDY are still beneficial.  Cloudflare introduced support for SPDY in August 2012 and removed it only in February 2018, when our statistics showed that less than 4% of web clients request it.  Meanwhile, shortly after the publication of the RFC in December 2015, we introduced HTTP / 2 support, when the analysis showed significant support for web clients. <br><br>  The SPDY and HTTP / 2 protocols use TLS by default.  The introduction of <a href="https://blog.cloudflare.com/introducing-universal-ssl/">universal SSL</a> in September 2014 made it possible to ensure that all Cloudflare users will take advantage of new protocols as they are implemented. <br><br><h1>  gQUIC </h1><br>  Google continued to experiment and until 2015 released another version of SPDY v3 and v3.1.  They also began working on the gQUIC protocol, the first draft of which was published in early 2012. <br><br>  Earlier versions of gQUIC used HTTP SPDY v3 syntax.  This choice made sense, because HTTP / 2 is not yet approved.  SPDY's binary syntax is packaged in QUIC packets, which are sent in UDP datagrams.  This is a departure from the TCP transport that HTTP traditionally relied on.  The entire system assembly looked like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a04/510/139/a045101397b293777a61ad1986dd89bc.png"><br>  <i><font color="gray">SPDY puff pie by gQUIC</font></i> <br><br>  To improve the performance of gQUIC used clever tricks.  One of them - to blur the clear boundary between the application and transport.  In practice, this meant that gQUIC only supports HTTP.  This connection was so strong that gQUIC, which at the time was called QUIC, was considered as a candidate for the next version of HTTP.  Although many changes were made to QUIC later, many still believe that it supports HTTP only.  Unfortunately, this leads to constant confusion when discussing the protocol. <br><br>  gQUIC continued to evolve and eventually switched to syntax much closer to HTTP / 2.  So close that most people began to call it "HTTP / 2 by QUIC".  But due to technical limitations, some very subtle differences emerged.  One example is serialization and the exchange of HTTP headers.  This is a minor difference, but in practice it means that HTTP / 2 by gQUIC is incompatible with HTTP / 2 from IETF. <br><br>  Last but not least, you should always consider the security aspects of Internet protocols.  And the gQUIC developers decided to abandon TLS in favor of a different approach called QUIC Crypto.  One of the interesting innovations there is a new method of speeding up handshakes.  After establishing a secure session with the server, the client can reuse the information and fix the ‚Äúzero‚Äù time of a handshake, that is, 0-RTT.  This trick was later included in the TLS 1.3 protocol. <br><br><h1>  Can you finally find out what HTTP / 3 is? </h1><br>  Nearly. <br><br>  Now we understand how standardization works.  So, consideration gQUIC went on the same scenario.  In June 2015, the first draft of the <a href="https://tools.ietf.org/html/draft-tsvwg-quic-protocol-00">draft-tsvwg-quic-protocol-00</a> , entitled ‚ÄúQUIC: secure and reliable UDP-based transport for HTTP / 2‚Äù, was submitted.  But do not forget that in the end, the syntax of the protocol is almost brought to compatibility with HTTP / 2. <br><br>  Google has <a href="https://groups.google.com/a/chromium.org/forum/">announced</a> that "BoF will be held at the IETF 93 meeting in Prague."  If you are interested in what BoF is, please refer to <a href="https://tools.ietf.org/html/rfc6771">RFC 6771</a> .  In short, BoF ( <a href="https://en.wikipedia.org/wiki/Birds_of_a_feather_(computing)">Birds of a Feather</a> ) is an informal meeting at the conference. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1e3/70a/7f0/1e370a7f0ab85f7d274498c658f833d9.png"><br><br>  Following the discussion with the IETF, it was decided that QUIC has many advantages at the transport level, this protocol should be separated from HTTP and a clear separation between layers should be reintroduced.  In addition, for this protocol they decided to return the handshake on the basis of TLS (which is not so bad, because by this time they have already developed TLS 1.3 with the 0-RTT scheme). <br><br>  About a year later, in 2016, a new set of drafts was released: <br><br><ul><li>  <a href="https://tools.ietf.org/html/draft-hamilton-quic-transport-protocol-00">draft-hamilton-quic-transport-protocol-00</a> </li><li>  <a href="https://tools.ietf.org/html/draft-thomson-quic-tls-00">draft-thomson-quic-tls-00</a> </li><li>  <a href="https://tools.ietf.org/html/draft-iyengar-quic-loss-recovery-00">draft-iyengar-quic-loss-recovery-00</a> </li><li>  <a href="http2-mapping-00">draft-shade-quic-http2-mapping-00</a> </li></ul><br>  This is where the confusion reappeared: <a href="http2-mapping-00">draft-shade-quic-http2-mapping-00</a> is called "HTTP / 2 semantics using the QUIC transport protocol" and describes the "display of HTTP / 2 semantics by QUIC".  However, this is the wrong name.  The essence of HTTP / 2 is in changing syntax while maintaining semantics.  In addition, ‚ÄúHTTP / 2 by gQUIC‚Äù has never been an accurate syntax description, for the reasons I stated earlier.  Keep this in mind when meeting further events. <br><br>  This IETF version of QUIC should be a completely new transport protocol.  This is a serious undertaking, so the IETF tried to assess the interest in the project from its members.  To this end, a BoF session ( <a href="https://datatracker.ietf.org/meeting/96/materials/slides-96-quic-0">slides</a> ) was held at the IETF 96 meeting in Berlin in 2016.  I was fortunate to be present in person at that meeting, which attracted hundreds of participants, as evidenced by the <a href="https://www.flickr.com/photos/adam-roach/28343796722/in/photostream/">photograph of Adam Roach</a> .  As a result, consensus was reached: QUIC will be adopted and standardized in the IETF. <br><br>  The first IETF QUIC <a href="http-00">draft draft-ietf-quic-http-00</a> for translating HTTP to the QUIC transport logically simplified the name of the protocol to ‚ÄúHTTP by QUIC‚Äù (HTTP over QUIC).  Unfortunately, the work was not completed, therefore, throughout the organization, various HTTP / 2 terms were used.  The new standards editor repository store, Mike Bishop, saw the problem and began correcting the incorrect HTTP / 2 mentions.  In the next protocol version, the description has changed to ‚Äúmapping HTTP semantics over QUIC‚Äù (mapping of HTTP semantics over QUIC). <br><br>  Gradually, over time and with newer versions, the term ‚ÄúHTTP / 2‚Äù was used less frequently, if necessary, simply by pointing to <a href="https://tools.ietf.org/html/rfc7540">RFC 7540</a> .  Two years later, in October 2018, the seventeenth version of the draft (number 16) was published.  Although the HTTP over QUIC protocol has similarities with HTTP / 2, in fact it is an independent and incompatible HTTP syntax.  However, for people who are not closely following the work of the IETF (and this is a very large percentage of the world's population), the title of the document does not reflect this difference.  One of the main objectives of standardization is the promotion of communication and interoperability.  And such a simple thing as naming has become the main cause of confusion in the community. <br><br>  Recall what was said in 2012: ‚ÄúHTTP / 2.0 means only that the format is incompatible with HTTP / 1.x for transport‚Äù.  The IETF followed this precedent.  After much discussion before and during the IETF 103 conference, there was still a consensus about renaming ‚ÄúHTTP over QUIC‚Äù to HTTP / 3. <br><br>  The world has become better, and we can move on to more important discussions. <br><br><h1>  But RFC 7230 and 7231 do not agree with your definition of semantics and syntax! </h1><br>  Sometimes the names of the documents can be confusing.  Here are the HTTP documents describing syntax and semantics: <br><br><ul><li>  <a href="https://tools.ietf.org/html/rfc7230">RFC 7230</a> - Hypertext Transfer Protocol (HTTP / 1.1): Message Syntax and Routing </li><li>  <a href="https://tools.ietf.org/html/rfc7231">RFC 7231</a> - Hypertext Transfer Protocol (HTTP / 1.1): Semantics and Content </li></ul><br>  For such names, it can be assumed that the fundamental semantics of HTTP is specific to a specific version of HTTP, that is, HTTP / 1.1.  But this is a random side effect of the HTTP family tree.  The good news is that the HTTPbis working group is trying to solve the problem.  Some brave WG members have begun another round of document revision.  This work is being done right now and is known as the work of HTTP Core (you may have heard about this working group under the name HTTPtre or HTTPter: everything is also ambiguous here) Their efforts will allow you to compress six drafts to three: <br><br><ul><li>  HTTP Semantics (draft-ietf-httpbis-semantics) </li><li>  HTTP Caching (draft-ietf-httpbis-caching) </li><li>  HTTP / 1.1 Message Syntax and Routing (draft-ietf-httpbis-messaging) </li></ul><br>  Within this new structure, it becomes more obvious that HTTP / 2 and HTTP / 3 are syntactic definitions for the general HTTP semantics.  This does not mean that they do not have their own functions outside of syntax, but this should help in further discussion. <br><br><h1>  Putting it all together </h1><br>  This article has superficially described the HTTP standardization process in the IETF over the past three decades.  Without really touching on the technical details, I tried to explain how we now came to HTTP / 3.  If you missed the middle and are looking for the essence in one phrase, here it is: <b>HTTP / 3 is just a new HTTP syntax that works on IETF QUIC, a multiplexed and secure UDP-based transport</b> .  There are many interesting technical nuances, but you have to postpone them for another time. <br><br>  We looked at the important steps in developing HTTP and TLS, but separately from each other.  Now at the end of the article once again publish the full cladogram.  You can calmly and carefully study it in a comfortable environment.  And for super funders: here is <a href="">an absolutely full version, including drafts</a> . <br><br> <a href=""><img src="https://habrastorage.org/webt/j_/uv/ww/j_uvww5d_hmiykedtaritata8ja.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/438810/">https://habr.com/ru/post/438810/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
</ul></nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>