<div class="post__text post__text-html js-mediator-article">  Last year, Mozilla released <a href="https://hacks.mozilla.org/2017/08/inside-a-super-fast-css-engine-quantum-css-aka-stylo/">Quantum CSS</a> for Firefox, which culminated in eight years of development of Rust, a memory-safe system programming language.  It took more than a year to rewrite the main component of the browser to Rust. <br><br>  So far, all the major browser engines have been written in C ++, mostly for efficiency reasons.  But with great performance comes a big responsibility: C ++ programmers have to manually manage the memory, which opens the Pandora's vulnerability box.  Rust not only eliminates such errors, but its methods also prevent <a href="https://blog.regehr.org/archives/490">data races</a> , allowing programmers to more effectively implement parallel code. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8bb/3c1/378/8bb3c13783ff1502b161e92f5818c2aa.jpg"></div><a name="habracut"></a><br><h1>  What is memory security </h1><br>  When we talk about creating secure applications, we often mention memory security.  Unofficially, we mean that in no state can a program get access to invalid memory.  Causes of security breaches: <br><br><ul><li>  saving the pointer after freeing memory (use-after-free); <br></li><li>  null pointer dereference; <br></li><li>  use of uninitialized memory; <br></li><li>  program attempt to free the same cell twice (double-free); <br></li><li>  buffer overflow. </li></ul><br>  For a more formal definition, see the article <a href="http://www.pl-enthusiast.net/2014/07/21/memory-safety/">“What is safety of memory” by</a> Michael Hicks, as well as a <a href="https://arxiv.org/pdf/1705.07354.pdf">scientific article</a> on this topic. <br><br>  Such violations may lead to an unexpected failure or change in the intended behavior of the program.  Potential consequences: information leakage, arbitrary code execution and remote code execution. <br><br><h1>  Memory management </h1><br>  Memory management is critical to application performance and security.  In this section, we consider the basic memory model.  One of the key concepts is <i>pointers</i> .  These are variables that store memory addresses.  If we go to this address, we will see there some data.  Therefore, we say that the pointer is a link to (or points to) this data.  Just as the home address tells people where to find you, the memory address shows the program where to find the data. <br><br>  Everything in the program is located at specific memory addresses, including code instructions.  Incorrect use of pointers can lead to serious vulnerabilities, including information leakage and the execution of arbitrary code. <br><br><h3>  Allocation / Release </h3><br>  When we create a variable, the program must allocate enough memory space to store the data of this variable.  Since each process has a limited amount of memory, of course, we need a way to <i>free up</i> resources.  When the memory is released, it becomes available for storing new data, but the old data lives there until the cell is overwritten. <br><br><h3>  Buffers </h3><br>  <i>A buffer</i> is a contiguous area of ​​memory in which several instances of the same data type are stored.  For example, the phrase "My cat - Batman" will be saved in a 16-byte buffer.  Buffers are determined by starting address and length.  In order not to damage the data in the neighboring memory, it is important to make sure that we do not read or write outside the buffer. <br><br><h3>  Control flow </h3><br>  Programs consist of subroutines that are executed in a specific order.  At the end of the subroutine, the computer goes to the saved pointer to the next part of the code (which is called the <i>return address</i> ).  When you go to the return address, one of three things happens: <br><br><ol><li>  The process continues normally (the return address is not changed). <br></li><li>  The process crashes (the address is changed and indicates non-executable memory). <br></li><li>  The process continues, but not as expected (the return address has changed and the control flow has been changed). </li></ol><br><h1>  How languages ​​provide memory security </h1><br>  All programming languages ​​belong to different parts of the <a href="https://www.memorymanagement.org/mmref/lang.html">spectrum</a> .  On the one hand of the spectrum - languages ​​such as C / C ++.  They are effective, but require manual memory management.  On the other hand, interpreted languages ​​with automatic memory management (for example, reference counting and garbage collection (GC)), but they pay for with performance.  Even languages ​​with well-optimized garbage collection cannot compare in <a href="http://greenlab.di.uminho.pt/wp-content/uploads/2017/09/paperSLE.pdf">performance</a> to languages ​​without GC. <br><br><h3>  Manual memory management </h3><br>  Some languages ​​(for example, C) require programmers to manually manage memory: when and how much to allocate memory, when to free it.  This gives the programmer complete control over how the program uses resources, providing fast and efficient code.  But this approach is error prone, especially in complex code bases. <br><br>  Errors that are easy to make: <br><br><ul><li>  forget that resources are released and try to use them; <br></li><li>  do not allocate enough space for data storage; <br></li><li>  read memory out of buffer. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/657/0a0/242/6570a02427a2d03632cb41c73aa5a48d.jpg"></div><br>  <i><font color="gray">Appropriate safety instructions for manual memory managers.</font></i> <br><br><h3>  Smart pointers </h3><br>  <a href="http://ootips.org/yonat/4dev/smart-pointers.html">Smart pointers</a> are provided with additional information to prevent memory misuse.  They are used for automatic memory management and border checking.  Unlike a regular pointer, a smart pointer is able to self-destruct and will not wait until the programmer deletes it manually. <br><br>  There are various variants of such a construction that wraps the source pointer in several useful abstractions.  Some smart pointers <i>count references</i> to each object, while others implement a scoping policy to limit the pointer's lifetime to certain conditions. <br><br>  When link counting, resources are freed when the last object link is deleted.  Basic reference counting implementations suffer from poor performance, increased memory consumption and are difficult to use in multi-threaded environments.  If objects refer to each other (circular references), then reference counting for each object will never reach zero, so more complex methods are required. <br><br><h1>  Garbage collection </h1><br>  In some languages ​​(for example, Java, Go, Python) <i><a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection">garbage collection is</a></i> implemented.  The part of the runtime environment, called the garbage collector (GC), keeps track of variables and identifies unavailable resources in the link graph between objects.  As soon as the object becomes unavailable, the GC frees the base memory for future reuse.  Any allocation and release of memory occurs without an explicit programmer’s command. <br><br>  Although GC ensures that memory is always used correctly, it does not free memory in the most efficient way — sometimes the last use of an object occurs much earlier than the garbage collector frees memory.  Performance costs are prohibitive for critical applications: to avoid performance degradation, sometimes you have to use 5 times more memory. <br><br><h3>  Possession </h3><br>  In Rust, ownership is used to ensure high performance and memory security.  More formally, this is an example of <a href="https://gankro.github.io/blah/linear-rust/">affine typing</a> .  All Rust code follows certain rules that allow the compiler to manage memory without losing runtime: <br><br><ol><li>  Each value has a variable called the owner. <br></li><li>  Only one owner at a time. <br></li><li>  When the owner goes out of scope, the value is removed. </li></ol><br>  Values ​​can be <a href="https://doc.rust-lang.org/beta/rust-by-example/scope/move.html">transferred</a> or <a href="https://doc.rust-lang.org/beta/rust-by-example/scope/borrow.html">borrowed</a> from one variable to another.  These rules apply part of the compiler called the borrow checker. <br><br>  When a variable goes out of scope, Rust frees that memory.  In the following example, the variables <code>s1</code> and <code>s2</code> are outside the region, both trying to free the same memory, which leads to a double-free error.  To prevent this, when transferring a value from a variable, the previous owner becomes invalid.  If the programmer then tries to use an invalid variable, the compiler will reject the code.  This can be avoided by creating a deep copy of the data or using links. <br><br>  <a href="https://play.rust-lang.org/%3Fversion%3Dstable%26mode%3Ddebug%26edition%3D2018%26gist%3D758b475abc30e7a4f28398545791b4c7">Example 1</a> : Transfer of ownership <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s1 = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s2 = s1; <span class="hljs-comment"><span class="hljs-comment">//won't compile because s1 is now invalid println!("{}, world!", s1);</span></span></code> </pre> <br>  Another set of rules borrow checker'a refers to the lifetime of variables.  Rust prohibits the use of uninitialized variables and hanging pointers to non-existent objects.  If you compile the code from the example below, <code>r</code> will refer to memory, which is released when <code>x</code> goes out of scope: a dangling pointer appears.  The compiler keeps track of all areas and checks the admissibility of all hyphenation, sometimes requiring the programmer to explicitly indicate the lifetime of the variable. <br><br>  <a href="https://play.rust-lang.org/%3Fversion%3Dstable%26mode%3Ddebug%26edition%3D2018%26gist%3D174cf01d8372d0edb9405ada891e8316">Example 2</a> : Hanging Index <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> r; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span>; r = &amp;x; } <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"r: {}"</span></span>, r);</code> </pre> <br>  The ownership model provides a solid foundation for correct memory access, preventing undefined behavior. <br><br><h1>  Memory vulnerabilities </h1><br>  The main consequences of vulnerable memory: <br><br><ol><li>  <b>Failure</b> : access to invalid memory may lead to an unexpected application termination. <br></li><li>  <b>Information leakage</b> : the inadvertent provision of private data, including confidential information, such as passwords. <br></li><li>  <b>Random Code Execution (ACE)</b> : allows an attacker to execute arbitrary commands on the target machine.  If this happens over the network, we call it remote code execution (RCE). </li></ol><br>  Another problem is <a href="https://en.wikipedia.org/wiki/Memory_leak">a memory leak</a> , when the allocated memory is not released after the program ends.  So you can use up all the available memory: then requests for resources will be blocked, which will lead to a denial of service.  This is a memory problem that cannot be solved at the level of PL. <br><br>  At best, if a memory error occurs, the application crashes.  In the worst case, the attacker will gain control of the program through vulnerability (which may lead to further attacks). <br><br><h3>  Abuse of released memory (use-after-free, double free) </h3><br>  This subclass of vulnerabilities occurs when a resource is released, but the link to its address is still preserved.  This is a <a href="https://sensepost.com/blog/2017/linux-heap-exploitation-intro-series-used-and-abused-use-after-free/">powerful hacker method</a> that can lead to out-of-range access, information leakage, code execution and much more. <br><br>  Languages ​​with garbage collection and link counting prevent the use of invalid pointers, destroying only inaccessible objects (which can lead to poor performance), and manual languages ​​are subject to this vulnerability (especially in complex code bases).  The borrow checker tool in Rust does not allow to destroy objects as long as there are links to it, so these bugs are fixed at the compilation stage. <br><br><h3>  Uninitialized variables </h3><br>  If a variable is used before initialization, then there can be any data in this memory, including random garbage or previously discarded data, which leads to information leakage (sometimes referred to as <i>invalid pointers</i> ).  To prevent these problems, in languages ​​with memory management, an automatic initialization procedure is often used after memory allocation. <br><br>  As in C, most of the variables in Rust are not initially initialized.  But unlike C, you cannot read them before initialization.  The following code will not compile: <br><br>  <a href="https://play.rust-lang.org/%3Fversion%3Dstable%26mode%3Ddebug%26edition%3D2018%26gist%3D616d9186c8eb4c6ae1ddb24aae54a88f">Example 3</a> : Using an uninitialized variable <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, x); }</code> </pre> <br><h3>  Null pointers </h3><br>  When an application dereferences a pointer, which turns out to be zero, it usually simply accesses the garbage and causes a crash.  In some cases, these vulnerabilities could lead to the execution of arbitrary code ( <a href="https://lwn.net/Articles/342330/">1</a> , <a href="http://www.fuzzysecurity.com/tutorials/expDev/16.html">2</a> , <a href="https://hackernoon.com/fixing-the-billion-dollar-mistake-in-go-by-borrowing-from-rust-66fab3ea715e">3</a> ).  Rust has two types of pointers: <a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html">links</a> and raw pointers.  Links are safe, but untreated pointers can be a problem. <br><br>  Rust prevents null pointer dereferencing in two ways: <br><br><ol><li>  Avoids pointers that admit zero values. <br></li><li>  Avoids dereferencing unprocessed pointers. </li></ol><br>  Rust avoids null pointers by replacing them with a special <a href="https://doc.rust-lang.org/rust-by-example/std/option.html"><code>типом Option</code></a> .  To change the value of possibly-null in the <code>Option</code> type, the language requires the programmer to explicitly handle the case with a zero value, otherwise the program will not be compiled. <br><br>  What to do if pointers admitting a zero value cannot be avoided (for example, when interacting with code in another language)?  Try to isolate the damage.  The dereferencing of unprocessed pointers should occur in an isolated unsafe block.  It <a href="https://doc.rust-lang.org/nomicon/meet-safe-and-unsafe.html">relaxes the rules of Rust</a> and allows some operations that can cause undefined behavior (for example, dereferencing an unprocessed pointer). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e58/bd7/b69/e58bd7b69e8f2f399e431bdb4f6d151f.jpg"></div><br>  <i><font color="gray">“All that concerns a borrow chekcer ... but what about that dark place?”</font></i> <i><font color="gray"><br></font></i>  <i><font color="gray">- This is an unsafe block.</font></i>  <i><font color="gray">Never go there Simba</font></i> <br><br><h3>  Buffer overflow </h3><br>  We discussed vulnerabilities that can be avoided by limiting access to undefined memory.  But the problem is that the buffer overflow incorrectly refers not to the indefinite, but to the legally allocated memory.  Like the use-after-free bug, such access can be a problem because it accesses the freed memory, which still contains confidential information that should not already exist. <br><br>  Buffer overflow simply means out-of-bounds.  Because of how the buffers are stored in memory, they often lead to leaks of information that may contain sensitive data, including passwords.  In more serious cases, ACE / RCE vulnerabilities are possible by rewriting the instruction pointer. <br><br>  Example 4: Buffer overflow (C code) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> buf[] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// print out of bounds printf("Out of bounds: %d\n", buf[10]); // write out of bounds buf[10] = 10; printf("Out of bounds: %d\n", buf[10]); return 0; }</span></span></code> </pre> <br>  The simplest buffer overflow protection is to always require border checking when accessing elements, but this leads to a <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4487316/">decrease in performance</a> . <br><br>  What does Rust do?  The built-in buffer types in the standard library require border checking for any random access, but also provide iterator APIs to speed up sequential calls.  This ensures that reading and writing beyond the boundaries for these types is impossible.  Rust promotes templates that require border checking only in places where you will almost certainly have to manually place them in C / C ++. <br><br><h1>  Memory security is only half the battle </h1><br>  Security breaches lead to vulnerabilities, such as data leakage and remote code execution.  There are various ways to protect memory, including smart pointers and garbage collection.  You can even <a href="https://eprint.iacr.org/2017/536.pdf">formally prove memory safety</a> .  Although some languages ​​have come to terms with the decline in performance for the sake of memory security, the concept of ownership in Rust provides security and minimizes overhead. <br><br>  Unfortunately, memory errors are only part of the story when we talk about writing safe code.  In the next article, we will look at thread safety and attacks on parallel code. <br><br><h1>  Exploiting Memory Vulnerabilities: Additional Resources </h1><br><ul><li>  <a href="https://heap-exploitation.dhavalkapil.com/">Heap Memory and Operation</a> <br></li><li>  <a href="http://www-inst.eecs.berkeley.edu/~cs161/fa08/papers/stack_smashing.pdf">Hacker stance destruction</a> <br></li><li>  <a href="https://brage.bibsys.no/xmlui/bitstream/handle/11250/2403236/15860_FULLTEXT.pdf%3Fsequence%3D1">Information Security Analogies</a> <br></li><li>  <a href="https://www.purehacking.com/blog/lloyd-simon/an-introduction-to-use-after-free-vulnerabilities">Introduction to use-after-free vulnerabilities</a> </li></ul></div>