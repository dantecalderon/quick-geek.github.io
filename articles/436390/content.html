<div class="post__text post__text-html js-mediator-article">  New Year's holidays have passed, but my desire to write <a href="https://habr.com/ru/post/434892/">useful</a> and <a href="https://habr.com/ru/post/433940/">not-so</a> articles is not!  Today we will talk about <i>UITableView</i> , working with <i>UITableViewDataSource</i> and reusing cells.  We will touch on how to install a root controller without a storyboard, errors when working with a table, a layout and a large header for a <i>UINavigationBar</i> . <br><br>  For those who like unfunny jokes, I recorded a <a href="https://youtu.be/JKIpuNFpZn0">video on YouTube</a> .  Well, here everything will be serious.  Let's start. <br><a name="habracut"></a><br>  Create an empty project, call it whatever you want and go to the controller.  UIKit has a class <i>UITableViewController</i> .  You can google a lot of tutorials where the table is shown exactly in the context of this class.  But for more understanding, we'll do everything in the base <i>UIViewController</i> . <br><br>  Most often, when a table is needed, a <i>UINavigationController is</i> used: <br><br><img src="https://habrastorage.org/webt/v5/of/o4/v5ofo4g0t_v2fcx5n3ei1aojl-i.png" width="300"><br><br>  Let's add it.  In the file <i>AppDelegate</i> , the function <i>didFinishLaunchingWithOptions insert the</i> following code: <br><br><pre><code class="plaintext hljs">let navigationController = UINavigationController.init(rootViewController: ViewController()) self.window = UIWindow.init(frame: UIScreen.main.bounds) self.window?.rootViewController = navigationController self.window?.makeKeyAndVisible()</code> </pre> <br>  A short educational program for what: storyboards and constraints are <b>good</b> , but in this tutorial we will try to do without them.  This code will allow you to ignore the storyboard (you can delete it) and wrap the <i>ViewController</i> in a <i>UINavigationController</i> . <br><br>  It would be nice to set the title for the <i>UINavigationBar</i> .  To do this, we will go to the <i>ViewController</i> class (we will do all further work here) and add the following code to the <i>viewDidLoad</i> method: <br><br><pre> <code class="plaintext hljs">self.view.backgroundColor = UIColor.white self.navigationItem.title = "Table" self.navigationController?.navigationBar.prefersLargeTitles = true</code> </pre><br>  Now the headline will be big and fashionable.  Having started the project, we will see the following: <br><br><img src="https://habrastorage.org/webt/n5/p_/pl/n5p_playz_fifspbvenzgceja1i.png" width="300"><br><br><h2>  Making a tableview </h2><br>  Preparatory actions are completed, we can move on to the main thing.  In the controller, create a <i>UITableView</i> .  Choose an initializer that has a Style parameter.  Frame set any, we will return to it later.  And for style, install <i>Grouped</i> . <br><br><pre> <code class="plaintext hljs">let tableView = UITableView.init(frame: .zero, style: UITableView.Style.grouped)</code> </pre><br>  Why I’m having such a style name, I have no idea, but it will allow us to make a native table, as in the <b>Settings</b> application.  If you need a non-stylized table - use the initializer only with the frame parameter. <br><br><img src="https://habrastorage.org/webt/iq/w6/km/iqw6kmonwk0eea4r8q5lbjljkh4.png"><br><br><h2>  Layout </h2><br>  Here we were saved by the constraints, but we will not look for easy ways.  I will show the way that I use.  He, of course, does not claim to be canonical and does not have to do just that.  Let's declare a function that will set the frame of the views, and the parameter will take the size of the controller: <br><br><pre> <code class="plaintext hljs">private func updateLayout(with size: CGSize) { self.tableView.frame = CGRect.init(origin: .zero, size: size) }</code> </pre><br>  You need to call the function in two places - in the <i>viewDidLoad</i> method and in <i>viewWillTransition</i> : <br><br><pre> <code class="plaintext hljs">override func viewWillTransition(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator) { super.viewWillTransition(to: size, with: coordinator) coordinator.animate(alongsideTransition: { (contex) in self.updateLayout(with: size) }, completion: nil) }</code> </pre><br>  Now the table at any orientation will be placed on the whole screen.  <i>You</i> can add other processing to the <i>updateLayout</i> method. <br><br><h2>  We do UITableViewCell </h2><br>  Since the tutorial is not about cells, but the table, we will not dwell on customization in detail.  Let's make a cell class inherited from the base one: <br><br><pre> <code class="plaintext hljs">class TableViewCell: UITableViewCell { }</code> </pre><br>  To use a cell in a table, you need to register a class.  To do this, in <i>ViewController,</i> we call the following method on the table: <br><br><pre> <code class="plaintext hljs">self.tableView.register(TableViewCell.self, forCellReuseIdentifier: "TableViewCell")</code> </pre><br>  If the class is clear, then the identifier deserves attention.  In 99% of cases the rule will work: <br><br>  - " <i>Cells of one class must have one identifier</i> " <br><br>  There are very few situations where cells of the same class need different identifiers, and they are mostly associated with <a href="https://habr.com/ru/post/434892/">drawing code</a> and animations. <br><br><h2>  Datasource </h2><br>  This is the property that points to the object that will fill the table.  Those.  implement the <i>UITableViewDataSource</i> protocol.  Two methods are required: <br><br><pre> <code class="plaintext hljs">func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {} func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {}</code> </pre><br>  The first is responsible for the number of cells in the section.  We still have one section, a multisection (is there such a word?) Will not be considered.  The second method is for getting the cell object.  It works slyly, do not think that you saw a fighter! <br><br>  But first, let's add an array of strings to fill the table with. <br><br><img src="https://habrastorage.org/webt/hu/k2/v9/huk2v9wmvks54enp76dm-fa8q-c.png"><br><br>  We now turn to the implementation of the first method: <br><br><pre> <code class="plaintext hljs">func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { switch tableView { case self.tableView: return self.data.count default: return 0 } }</code> </pre><br>  We tell the table that in the 0th section there will be as many cells as there are elements in the <b>data</b> array.  The second method is a bit more complicated.  Just initialize the cell does not work, and all because of the system reuse cells.  But do not scold Apple, in fact it is good!  To get an object, call the following code: <br><br><pre> <code class="plaintext hljs">func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { let cell = self.tableView.dequeueReusableCell(withIdentifier: "TableViewCell", for: indexPath) as! TableViewCell cell.textLabel?.text = self.data[indexPath.row] return cell }</code> </pre><br>  The <i>dequeueReusableCell</i> method will get the cell object by its identifier, and we will do a type conversion using <b>as</b> to the <i>TableViewCell</i> class, which should be the cell.  <i>textLabel</i> is the base class property, no additional configuration is required. <br><br>  It remains to specify the <i>dataSource</i> for the table and the <i>viewDidLoad</i> method <i>should</i> now look like this: <br><br><pre> <code class="plaintext hljs">override func viewDidLoad() { super.viewDidLoad() self.view.backgroundColor = UIColor.white self.navigationItem.title = "Table" self.navigationController?.navigationBar.prefersLargeTitles = true self.view.addSubview(self.tableView) self.tableView.register(TableViewCell.self, forCellReuseIdentifier: "TableViewCell") self.tableView.dataSource = self self.updateLayout(with: self.view.frame.size) }</code> </pre><br>  If we run the project, we will see a table filled with content: <br><br><img src="https://habrastorage.org/webt/k_/fv/fe/k_fvfeyld46q6gcg7uskechljiu.png" width="300"><br><br><h2>  Reuse </h2><br>  While it seems that everything is in order.  Let's add a <i>disclosureIndicator</i> for one of the cells.  This is an accessory that you definitely met in iOS: <br><br><img src="https://habrastorage.org/webt/2b/vf/h6/2bvfh6mrnuvefnhuptsr8kjk4c8.png" width="60"><br><br>  Let's say the task is to set the indicator only for the first cell.  The first thing that comes to mind is to add a simple if to the <i>cellForRowAt</i> method: <br><br><pre> <code class="plaintext hljs">if indexPath.row == 0 { cell.accessoryType = .disclosureIndicator }</code> </pre><br>  But the enemy is hiding!  Let's run the project, and scroll the table off the screen: <br><br><img src="https://habrastorage.org/webt/_t/w_/sj/_tw_sj2hqsmkqd69l9cb9ui3-vi.gif" width="249"><br><br>  The indicator appeared for the first, but haphazardly appears for other cells!  This is a reuse - a cell is taken, which is more conveniently stored in memory (an excellent explanation for beginners, isn’t it?) And is configured according to the method.  Sometimes it happens that a cell with an indicator is drawn.  As a result, we have such a bug.  What to do? <br><br>  It's simple.  There are two solutions.  The first is in the else block and in essence implies the unambiguous configuration of any cell.  The method will look like this: <br><br><pre> <code class="plaintext hljs">func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { let cell = self.tableView.dequeueReusableCell(withIdentifier: "TableViewCell", for: indexPath) as! TableViewCell cell.textLabel?.text = self.data[indexPath.row] if indexPath.row == 0 { cell.accessoryType = .disclosureIndicator } else { cell.accessoryType = .none } return cell }</code> </pre><br>  There is another way - to implement the <i>prepareForuse</i> method <i>on</i> the cell.  As the name implies - the method is called before reuse.  All you need is to reset the cell to default.  The code looks like this: <br><br><pre> <code class="plaintext hljs">class TableViewCell: UITableViewCell { override func prepareForReuse() { super.prepareForReuse() self.accessoryType = .none } }</code> </pre><br>  There are many nuances associated with re-use.  For example, the task of loading images for a cell in the background with pagination, adaptive height, animated deletion and insertion.  But about this in the second part, if my hands reach me) <br><br><h2>  For seekers </h2><br>  I try to regularly record a tutorial on <a href="http://youtube.com/ivanvorobei">my channel</a> .  You can find videos <a href="https://youtu.be/ID5JvGbXXTY">how to draw code</a> or <a href="https://youtu.be/wOTNGswT2-0">how to make the controller of the Apple Music player</a> , as well as the video for this article: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/JKIpuNFpZn0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div>