<div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg"><br><br><h1>  Introduction </h1><br>  On the one hand, the OpenSceneGraph engine itself has an advanced window management, user input event handling, user message sending and receiving subsystem.  We talked about this in some detail in previous articles in this series.  In general, in sum with the capabilities of C ++ / STL, this is quite enough for the development of arbitrarily complex applications. <br><br>  <i>An example of integrating OSG into an application developed in QtDesigner.</i>  <i>This example will be discussed in detail below.</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1LWLSxAUWwU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  On the other hand, to speed up C ++ development, both third-party libraries are used, which extend the capabilities of this language (like boost), as well as whole frameworks, which make it possible to develop cross-platform applications of a wide functional purpose easily and naturally.  One such framework is the ultra popular Qt.  No matter how much Qt is blamed for its meta-object compiler and other shortcomings and inconveniences, Qt is powerful in an extensive class library that solves all conceivable tasks of cross-platform development, as well as in the "signals-slots" concept that implements the messaging subsystem between classes.  Signals and slots are also based on how the application interacts with the operating system, as well as interprocess communication. <br><br>  And, damn it, it would be very interesting to combine two technologies: Qt and OSG.  A similar task had to be solved by my team, which I already wrote in <a href="https://habr.com/ru/post/436276/">one of my publications</a> .  However, I would like to reveal this question a little wider, and this article will be just about this topic. <br><a name="habracut"></a><br>  There are two ways to integrate OSG and Qt: <br><br><ol><li>  Using Qt Signals and Slots to Interact Objects within an OSG Application <br></li><li>  Integration of the OSG viewer in a graphical user interface developed in C ++ / Qt, including the use of the QtDesigner form designer <br></li></ol><br>  The first option is applicable when the use of GUI elements provided by Qt is not required, but it is required to ensure the interaction of application components by means of signals and slots.  For example, I had such a need to integrate an OSG application with an interprocess communication library via TCP sockets using Qt. <br><br>  The second option is necessary when the integration of the OSG engine and a graphical application developed using Qt is required.  Signals and slots are becoming available to us, and besides them, the full range of standardized GUI elements provided by Qt. <br><br><h1>  1. Qt signals in the OSG window system </h1><br>  The first example will be somewhat synthetic: we will write a simple OSG application with a primitive scene;  create two classes, one of which will handle keystrokes, and the other will display in the console a message about which key is pressed.  In this case, the handler will generate a Qt signal, with a message about the key pressed as a parameter. <br><br>  To integrate with Qt, it is sufficient to satisfy the following three conditions. <br><br><ol><li>  Inherit QObject Interactive Classes <br></li><li>  Arrange a signal processing loop <br></li><li>  Create an instance of the QApplication class (or QCoreApplication) that exists in memory during the operation of the application <br></li></ol><br>  The full code of the example can be seen <a href="https://github.com/maisvendoo/OSG-lessons/tree/master/qt-signals">here</a> , in <a href="https://github.com/maisvendoo/OSG-lessons">my OSG-lessons repository</a> , where all the lessons for this cycle are collected. <br><br>  To begin, create a class that will "turn" the signal processing queue <br><br>  <strong>qt-events.h</strong> <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> QT_EVENTS_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> QT_EVENTS_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgGA/GUIEventHandler&gt; #include &lt;QCoreApplication&gt; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class QtEventsHandler : public osgGA::GUIEventHandler { public: QtEventsHandler(); virtual bool handle(const osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa); protected: }; #endif // QT_EVENTS_H</span></span></span></span></code> </pre> <br>  <strong>qt-events.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"qt-events.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ QtEventsHandler::QtEventsHandler() { } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ bool QtEventsHandler::handle(const osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa) { Q_UNUSED(aa) switch (ea.getEventType()) { case osgGA::GUIEventAdapter::FRAME: { // Process qt signals and event QCoreApplication::processEvents(QEventLoop::AllEvents); break; } default: break; } return false; }</span></span></span></span></code> </pre><br>  Everything is very simple - this class is a standard OSG event handler that, when a frame is drawn, initiates Qt's signal queue processing <br><br><pre> <code class="cpp hljs">QCoreApplication::processEvents(QEventLoop::AllEvents);</code> </pre><br>  Now we will create a class that processes the keyboard, again, using the mechanism built into OSG, but still capable of sending a Qt signal.  To do this, we will apply the anathema committed recently to multiple inheritance <br><br>  <strong>keyhandler.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> KEY_HANDLER_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> KEY_HANDLER_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgGA/GUIEventHandler&gt; #include &lt;QObject&gt; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class KeyboardHandler : public QObject, public osgGA::GUIEventHandler { Q_OBJECT public: KeyboardHandler(QObject *parent = Q_NULLPTR) : QObject(parent) , osgGA::GUIEventHandler () { } bool handle(const osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa) { switch (ea.getEventType()) { case osgGA::GUIEventAdapter::KEYDOWN: emit sendMessage("Pressed key " + QString(ea.getKey())); break; default: break; } return false; } signals: void sendMessage(QString msg); private: }; #endif // KEY_HANDLER_H</span></span></span></span></code> </pre><br>  The class will process the keystroke message and send a signal with a message containing the key code.  This signal will be received by a class that is not related in any way to OSG, which is a QObject successor and contains a single slot that prints a message to the standard output stream. <br><br>  <strong>receiver.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> RECEIVER_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RECEIVER_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QObject&gt; #include &lt;iostream&gt; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class Receiver : public QObject { Q_OBJECT public: Receiver(QObject *parent = Q_NULLPTR) : QObject(parent) {} public slots: void printMessage(QString msg) { std::cout &lt;&lt; msg.toStdString() &lt;&lt; std::endl; } }; #endif // RECEIVER_H</span></span></span></span></code> </pre><br>  Now let's put everything together by writing an OSG application. <br><br>  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgViewer/Viewer&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;QCoreApplication&gt; #include "qt-events.h" #include "keyhandler.h" #include "receiver.h" #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { QCoreApplication app(argc, argv); osg::ref_ptr&lt;osg::Node&gt; scene = osgDB::readNodeFile("../data/cessnafire.osg"); osgViewer::Viewer viewer; viewer.setSceneData(scene.get()); viewer.addEventHandler(new QtEventsHandler); viewer.setUpViewInWindow(0, 0, 1024, 768); KeyboardHandler *keyboardHandler = new KeyboardHandler; Receiver *receiver = new Receiver; QObject::connect(keyboardHandler, &amp;KeyboardHandler::sendMessage, receiver, &amp;Receiver::printMessage); viewer.addEventHandler(keyboardHandler); return viewer.run(); }</span></span></span></span></code> </pre><br>  First, we create an instance of the QCoreApplication class. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">QCoreApplication </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">app</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(argc, argv)</span></span></span></span>;</code> </pre><br>  This is necessary for the work of the described technology.  However, we <em>will not call the QCoreApplication :: exec () method</em> !  Instead, the signal processing cycle will be rotated inside the osgViewer :: Viewer :: run () loop, for which we create and register the corresponding handler. <br><br><pre> <code class="cpp hljs">viewer.addEventHandler(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QtEventsHandler);</code> </pre><br>  Create instances of classes that will interact through Qt signals, associating the signal of one with the slot of another <br><br><pre> <code class="cpp hljs">KeyboardHandler *keyboardHandler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyboardHandler; Receiver *receiver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Receiver; QObject::connect(keyboardHandler, &amp;KeyboardHandler::sendMessage, receiver, &amp;Receiver::printMessage);</code> </pre><br>  Register the keyboard handler <br><br><pre> <code class="cpp hljs">viewer.addEventHandler(keyboardHandler);</code> </pre><br>  All, run the viewer <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewer.run();</code> </pre><br>  and see such a picture <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HKJJb0cMl7I" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Yes, the example is somewhat contrived, but it illustrates the main principles of integrating code using Qt mechanisms into an application using OSG.  This idea, taken from the book <a href="https://www.amazon.com/OpenSceneGraph-3-Cookbook-Rui-Wang/dp/184951688X">OpenSceneGraph 3. Cookbook</a> , saved me and my development team a lot of time and nerves by allowing us to use a Qt-based module that was debugged and standardized within our codebase. <br><br>  What if we want to use OSG inside a Qt GUI application? <br><br><h1>  2. The osgQt library </h1><br>  <a href="https://github.com/openscenegraph/osgQt">osgQt</a> is an integration library intended for: <br><br><ol><li>  Embedding a three-dimensional scene implemented on OSG into a graphical interface of an application developed on Qt </li><li>  Embedding Qt widgets on the surface of three-dimensional geometry inside the OSG scene.  Yes, you heard right - Qt widgets can work quietly inside the virtual world.  Someday I will definitely demonstrate it. </li></ol><br>  There were certain problems with this library that were overcome by carefully studying the examples attached to it and reading the already mentioned <a href="https://www.amazon.com/OpenSceneGraph-3-Cookbook-Rui-Wang/dp/184951688X">OpenSceneGraph 3. Cookbook</a> <br><br>  The library should be assembled, and this process is similar to the assembly of the engine itself, described in detail in the very <a href="https://habr.com/ru/post/429816/">first article of the cycle</a> .  The only note is that -DCMAKE_INSTALL_PREFIX should be chosen the same as was specified when building the engine - so osgQt will be installed next to the engine, and it will be convenient to use it during development. <br><br><h1>  3. Integrating osgViewer :: Viewer into Qt GUI </h1><br>  The following example will be quite useful.  We will write a viewer that allows you to load * .osg format models using standard Qt controls.  And for development of the graphic interface we use QtDeisgner. <br><br>  Create a new project like "Qt Widgets Application" <br><br><img src="https://habrastorage.org/webt/hk/t5/sj/hkt5sjllzcuqyfyfm08ugnag0bw.png"><br><br>  At the same time, the main application window will be generated with a menu preset, toolbar and status bar.  In QtDesigner, add a QFrame component to this window. <br><br> <a href=""><img src="https://habrastorage.org/webt/ek/4r/8c/ek4r8can5b5v63ex03jbw0v4czu.png"></a> <br><br>  In this frame we will place an OSG viewer.  The OSG viewer will essentially be a Qt widget; to implement it, we will write the QViewerWidget class.  Full source code will put on the spoiler, so as not to zamylativ statement sheets of code <br><br><div class="spoiler">  <b class="spoiler_title">qviewerwidget.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> QVIEWER_WIDGET_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> QVIEWER_WIDGET_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QWidget&gt; #include &lt;osgViewer/Viewer&gt; #include &lt;osgQt/GraphicsWindowQt&gt; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class QViewerWidget : public QWidget { public: QViewerWidget(const QRect &amp;geometry); virtual ~QViewerWidget(); osg::Group *getScene(); osgViewer::Viewer *getViewer(); protected: osg::ref_ptr&lt;osg::Group&gt; scene; osgViewer::Viewer viewer; private: osgQt::GraphicsWindowQt *createGraphicsWindow(const QRect &amp;geometry); void initCamera(const QRect &amp;geometry); void paintEvent(QPaintEvent *); }; #endif // QVIEWER_WIDGET_H</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">qviewerwidget.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs">include <span class="hljs-string"><span class="hljs-string">"qviewerwidget.h"</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgViewer/ViewerEventHandlers&gt; #include &lt;osgGA/TrackballManipulator&gt; #include &lt;QGridLayout&gt; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ QViewerWidget::QViewerWidget(const QRect &amp;geometry) : QWidget() , scene(new osg::Group) { initCamera(geometry); viewer.setSceneData(scene); viewer.addEventHandler(new osgViewer::StatsHandler); viewer.setCameraManipulator(new osgGA::TrackballManipulator); viewer.setThreadingModel(osgViewer::Viewer::SingleThreaded); osgQt::GraphicsWindowQt *gw = static_cast&lt;osgQt::GraphicsWindowQt *&gt;(viewer.getCamera()-&gt;getGraphicsContext()); QGridLayout *layout = new QGridLayout; if (layout != Q_NULLPTR) { layout-&gt;addWidget(gw-&gt;getGLWidget()); this-&gt;setLayout(layout); } } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ QViewerWidget::~QViewerWidget() { } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osg::Group *QViewerWidget::getScene() { return scene.get(); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osgViewer::Viewer *QViewerWidget::getViewer() { return &amp;viewer; } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osgQt::GraphicsWindowQt *QViewerWidget::createGraphicsWindow(const QRect &amp;geometry) { osg::DisplaySettings *ds = osg::DisplaySettings::instance().get(); osg::ref_ptr&lt;osg::GraphicsContext::Traits&gt; traits = new osg::GraphicsContext::Traits; traits-&gt;windowName = ""; traits-&gt;windowDecoration = false; traits-&gt;x = geometry.x(); traits-&gt;y = geometry.y(); traits-&gt;width = geometry.width(); traits-&gt;height = geometry.height(); if (traits-&gt;height == 0) traits-&gt;height = 1; traits-&gt;doubleBuffer = true; traits-&gt;alpha = ds-&gt;getMinimumNumAlphaBits(); traits-&gt;stencil = ds-&gt;getMinimumNumStencilBits(); traits-&gt;sampleBuffers = ds-&gt;getMultiSamples(); traits-&gt;samples = ds-&gt;getNumMultiSamples(); return new osgQt::GraphicsWindowQt(traits.get()); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void QViewerWidget::initCamera(const QRect &amp;geometry) { osg::Camera *camera = viewer.getCamera(); osg::ref_ptr&lt;osgQt::GraphicsWindowQt&gt; gw = createGraphicsWindow(geometry); gw-&gt;setTouchEventsEnabled(true); camera-&gt;setGraphicsContext(gw.get()); const osg::GraphicsContext::Traits *traits = gw-&gt;getTraits(); camera-&gt;setClearColor(osg::Vec4(0.7f, 0.7f, 0.7f, 1.0f)); camera-&gt;setViewport(0, 0, traits-&gt;width, traits-&gt;height); double aspect = static_cast&lt;double&gt;(traits-&gt;width) / static_cast&lt;double&gt;(traits-&gt;height); camera-&gt;setProjectionMatrixAsPerspective(30.0, aspect, 1.0, 1000.0); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void QViewerWidget::paintEvent(QPaintEvent *) { viewer.frame(); }</span></span></span></span></code> </pre><br></div></div><br>  The main idea of ​​the implementation is to use the osgQt :: GraphicsWindow class, which creates a graphic window based on the QGLWidget class.  To create this window is the method <br><br><pre> <code class="cpp hljs">osgQt::GraphicsWindowQt *QViewerWidget::createGraphicsWindow(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QRect &amp;geometry) { osg::DisplaySettings *ds = osg::DisplaySettings::instance().get(); osg::ref_ptr&lt;osg::GraphicsContext::Traits&gt; traits = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::GraphicsContext::Traits; traits-&gt;windowName = <span class="hljs-string"><span class="hljs-string">""</span></span>; traits-&gt;windowDecoration = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; traits-&gt;x = geometry.x(); traits-&gt;y = geometry.y(); traits-&gt;width = geometry.width(); traits-&gt;height = geometry.height(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (traits-&gt;height == <span class="hljs-number"><span class="hljs-number">0</span></span>) traits-&gt;height = <span class="hljs-number"><span class="hljs-number">1</span></span>; traits-&gt;doubleBuffer = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; traits-&gt;alpha = ds-&gt;getMinimumNumAlphaBits(); traits-&gt;stencil = ds-&gt;getMinimumNumStencilBits(); traits-&gt;sampleBuffers = ds-&gt;getMultiSamples(); traits-&gt;samples = ds-&gt;getNumMultiSamples(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osgQt::GraphicsWindowQt(traits.get()); }</code> </pre><br>  The window is configured in accordance with the geometry parameters transmitted to the input and the required settings of the three-dimensional OSG render.  The returned pointer is the OSG graphics context that should be passed to the camera.  Therefore, the next step is to initialize the camera. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QViewerWidget::initCamera(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QRect &amp;geometry) { osg::Camera *camera = viewer.getCamera(); osg::ref_ptr&lt;osgQt::GraphicsWindowQt&gt; gw = createGraphicsWindow(geometry); gw-&gt;setTouchEventsEnabled(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); camera-&gt;setGraphicsContext(gw.get()); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> osg::GraphicsContext::Traits *traits = gw-&gt;getTraits(); camera-&gt;setClearColor(osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); camera-&gt;setViewport(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, traits-&gt;width, traits-&gt;height); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> aspect = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(traits-&gt;width) / <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(traits-&gt;height); camera-&gt;setProjectionMatrixAsPerspective(<span class="hljs-number"><span class="hljs-number">30.0</span></span>, aspect, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1000.0</span></span>); }</code> </pre><br>  Actually call <br><br><pre> <code class="cpp hljs">camera-&gt;setGraphicsContext(gw.get());</code> </pre><br>  and passes the camera the required context associated with the QGLWidget widget.  The entire routine for creating a widget is placed in the class constructor. <br><br><pre> <code class="cpp hljs">QViewerWidget::QViewerWidget(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QRect &amp;geometry) : QWidget() , scene(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Group) { initCamera(geometry); viewer.setSceneData(scene); viewer.addEventHandler(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osgViewer::StatsHandler); viewer.setCameraManipulator(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osgGA::TrackballManipulator); viewer.setThreadingModel(osgViewer::Viewer::SingleThreaded); osgQt::GraphicsWindowQt *gw = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osgQt::GraphicsWindowQt *&gt;(viewer.getCamera()-&gt;getGraphicsContext()); QGridLayout *layout = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QGridLayout; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (layout != Q_NULLPTR) { layout-&gt;addWidget(gw-&gt;getGLWidget()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;setLayout(layout); } }</code> </pre><br>  Here we set up a viewer and pay special attention to the challenge. <br><br><pre> <code class="cpp hljs">viewer.setThreadingModel(osgViewer::Viewer::SingleThreaded);</code> </pre><br>  switching viewer in single-threaded mode.  This is a necessary measure when integrating OSG into Qt, since in some Linux distributions the program will fall out into a segfolt when using multi-threaded rendering, which OSG uses by default.  The reasons for this require separate debriefing, so go ahead and pay attention to this code. <br><br><pre> <code class="cpp hljs">osgQt::GraphicsWindowQt *gw = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osgQt::GraphicsWindowQt *&gt;(viewer.getCamera()-&gt;getGraphicsContext()); QGridLayout *layout = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QGridLayout; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (layout != Q_NULLPTR) { layout-&gt;addWidget(gw-&gt;getGLWidget()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;setLayout(layout); }</code> </pre><br>  in which we create a layer, interrupting the QGLWidget in it, returned from the camera's graphic context, converted to the pointer osgQt :: GraphicsWindows.  The created layer is added to our QViewerWidget widget by calling <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;setLayout(layout);</code> </pre><br>  In order for our widget, and with it, the scene to be updated when the window is updated, you need to redefine the QPaintEvent event handler. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QViewerWidget::paintEvent(QPaintEvent *) { viewer.frame(); }</code> </pre><br>  in which we initiate frame rendering by calling the osgViewer :: Viewer :: frame () method. <br><br>  Ok, the code of our widget is ready, now we build it into the frame located on the form.  To do this, in the constructor of the class MainWindow we write such code <br><br><pre> <code class="cpp hljs">MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Ui::MainWindow) , qviewer(Q_NULLPTR) { ui-&gt;setupUi(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); QGridLayout *layout = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QGridLayout; qviewer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QViewerWidget(QRect(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, ui-&gt;frame-&gt;width(), ui-&gt;frame-&gt;height())); layout-&gt;addWidget(qviewer); ui-&gt;frame-&gt;setLayout(layout); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;setCentralWidget(ui-&gt;frame); connect(&amp;timer, &amp;QTimer::timeout, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;MainWindow::update); timer.start(<span class="hljs-number"><span class="hljs-number">40</span></span>); connect(ui-&gt;actionQuit, &amp;QAction::triggered, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;MainWindow::quit); connect(ui-&gt;actionClean, &amp;QAction::triggered, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;MainWindow::clean); connect(ui-&gt;actionOpen, &amp;QAction::triggered, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;MainWindow::open); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;setWindowTitle(<span class="hljs-string"><span class="hljs-string">"QViewerWidget example"</span></span>); }</code> </pre><br>  or rather, we are still interested in this part of it <br><br><pre> <code class="cpp hljs">QGridLayout *layout = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QGridLayout; qviewer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QViewerWidget(QRect(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, ui-&gt;frame-&gt;width(), ui-&gt;frame-&gt;height())); layout-&gt;addWidget(qviewer); ui-&gt;frame-&gt;setLayout(layout); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;setCentralWidget(ui-&gt;frame);</code> </pre><br>  where we create a layer, create our widget with dimensions equal to the frame size, add the created widget to the layer, and attach the layer to the frame.  And, in order not to bother in this example with the layout, we stretch the frame to the entire client area of ​​the window, designating it as the central widget. <br><br>  To perform rendering, you should organize a periodic update of the window by timer.  To do this, we create a timer with an interval of 40 milliseconds (25 frames per second) and associate its timeout signal with the window update slot.  I do it like this using Qt5 syntax <br><br><pre> <code class="cpp hljs">connect(&amp;timer, &amp;QTimer::timeout, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;MainWindow::update); timer.start(<span class="hljs-number"><span class="hljs-number">40</span></span>);</code> </pre><br>  pre-defining the update slot for the window class in this way <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MainWindow::update() { QMainWindow::update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;geometry()); }</code> </pre><br>  Why so, because you can directly link the timer signal to the QMainWindow :: update slot in the way shown in most osgQt usage examples. <br><br><pre> <code class="plaintext hljs">connect(&amp;timer, SIGNAL(timeout), this, SLOT(update));</code> </pre><br>  The fact is that the syntax with the SIGNAL () and SLOT () macros has been declared obsolete, and should be abandoned in anticipation of the transition to Qt6.  At the same time, the QMainWindow class does not overload the update () slot without parameters, which will cause an error on the binding call when compiling.  To do this, I had to define my update () slot without parameters, calling the base QMainWindow :: update () in it, passing the window client area to it. <br><br>  Having added to this place and running the program we will get a certain result. <br><br><img src="https://habrastorage.org/webt/s4/hb/h7/s4hbh78isikshkekfsbefaht8wg.png"><br><br>  By pressing "S" we can activate the OSG statistics monitor and make sure that our widget works as it should by drawing an empty scene. <br><br><div class="spoiler">  <b class="spoiler_title">What kind of statistics monitor?</b> <div class="spoiler_text">  In order not to overload the article I will write about it here.  OSG has a built-in monitor that displays engine statistics in real time.  To add it to the viewer, connect the header file <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgViewer/ViewerEventHandlers&gt;</span></span></span></span></code> </pre><br>  and add a handler to the viewer <br><br><pre> <code class="cpp hljs">viewer.addEventHandler(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osgViewer::StatsHandler);</code> </pre><br>  then at any time by pressing "S" display a lot of useful information. <br></div></div><br><h1>  4. Finish our viewer: add menu </h1><br>  In the form designer, we customize the menu by applying “mouse-oriented” programming (to which I am indifferent, but yes, it is sometimes convenient).  In the end we will get something like this <br><br> <a href=""><img src="https://habrastorage.org/webt/5h/lg/4y/5hlg4ynz134k85tyg9gko_mzjlm.png"></a> <br><br>  Now we will create the appropriate slot handlers that allow you to load the model along the path selected from the dialog box, clear the scene and exit the application. <br><br><div class="spoiler">  <b class="spoiler_title">Menu Handler Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void MainWindow::open() { osg::Group *scene = qviewer-&gt;getScene(); if (scene == nullptr) return; QString path = QFileDialog::getOpenFileName(Q_NULLPTR, tr("Open model file"), "./", tr("OpenSceneGraph (*.osg *.osgt *.osgb *.ivi)")); if (path.isEmpty()) return; scene-&gt;removeChildren(0, scene-&gt;getNumChildren()); osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(path.toStdString()); scene-&gt;addChild(model.get()); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void MainWindow::clean() { osg::Group *scene = qviewer-&gt;getScene(); if (scene == nullptr) return; scene-&gt;removeChildren(0, scene-&gt;getNumChildren()); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void MainWindow::quit() { QApplication::quit(); }</span></span></code> </pre><br></div></div><br>  After that we will get a very convenient model viewer * .osg. <br><br><img src="https://habrastorage.org/webt/vj/ub/ml/vjubmllisl3w25nyca0dn90udv0.png"><br><br>  The demonstration of his work is shown in the video at the beginning of the article  Full source code for this example is <a href="https://github.com/maisvendoo/OSG-lessons/tree/master/qviewerwidget">available here.</a> <br><br><h1>  Conclusion </h1><br>  As we have seen, the integration of OSG and Qt is not particularly difficult either in understanding or in implementation.  This is an excellent tool for creating cross-platform applications for technical visualization, and possibly games. <br><br>  This article opens the continuation of the OSG cycle, where complex development techniques will be presented.  I think she was successful.  Thank you for your attention and see you soon! </div>