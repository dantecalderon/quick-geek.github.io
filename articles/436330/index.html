<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Making a Game Boy Game</title>
  <meta name="description" content="A few weeks ago, I decided to work on a Game Boy game, the creation of which gave me great pleasure. Her working title is ‚ÄúAqua and Ashes‚Äù. The game h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Making a Game Boy Game</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/913/597/052/91359705210df58524bc0e6c9e9955a8.png" alt="image"></div><br>  A few weeks ago, I decided to work on a Game Boy game, the creation of which gave me great pleasure.  Her working title is ‚ÄúAqua and Ashes‚Äù.  The game has open source and is available on <a href="https://github.com/InvisibleUp/AquaAndAshes">GitHub</a> . <br><br><h2>  How did I come up with this idea </h2><br>  Recently, I got a job in the PHP and Python backend internship for my university's website.  This is a good and interesting work, for which I am very grateful.  But ... at the same time, all of this high-level web development code has infected me with an insatiable desire.  And it was the pursuit of low-level work with bats. <br><br>  I received a weekly digest of itch.io about game jams, announcing the start of <a href="https://itch.io/jam/mini-jam-4th-edition">Mini Jam 4</a> .  It was a 48-hour (well, actually a little more) jam, in which the limitation was the creation of graphics in the Game Boy style.  My first logical response was the desire to create a Game Boy homebrew game.  The theme of the jam was ‚Äúseasons‚Äù and ‚Äúflame‚Äù. <br><br>  After thinking a bit about the plot and the mechanics that can be implemented in 48 hours and the topics that fit into the restrictions, I came up with a <s>clone of a</s> new interpretation of the level from the game for SNES 1993 Tiny Toon Adventures: Buster Busts Loose !, in which the player plays Buster . <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/XmyJZkJ-zeA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  I always liked how the creators of this level took an incredibly difficult sport, got rid of all the tricks, positions and strategic elements, as a result of getting an extremely interesting and easy game.  Obviously, such a simplified view of American football will not replace Madden, just like the NBA Jam (a similar idea: only 4 players in a much smaller field with more straightforward gameplay than in a regular game) will not replace the 2K series.  But this idea has a certain charm, and NBA Jam sales figures confirm this. <br><br>  How does all this relate to my idea?  I decided to take this football level and remake it so that it remains similar to the original and at the same time is fresh.  First, I cut the game to just four players - one defender and one attacking team.  This is mainly done due to the limitations of the hardware, but at the same time it will allow me to experiment a bit with a smarter AI, not limited to the principle of ‚Äúrun left and sometimes jump up‚Äù from the game on SNES. <br><br>  For the sake of compliance with the topic, I will replace the gate with burning columns, or fires, or something like that (I have not decided yet), and a soccer ball with torches and a bucket with water.  The winner will be the team that controls both fires, and around this simple concept you can easily come up with a plot.  The seasons are also taken into account: I decided that the seasons would change at every turn, so that the fire team would take precedence in the summer and the fire fighting team in the winter.  This advantage looks like obstacles on the field, hindering only the opposing team. <br><br>  Of course, when creating two teams, two animals were needed that love and dislike fire.  At first I thought about fire ants and some water beetle, a praying mantis and the like, but after examining the question, I did not find insects that were active in the winter, so I replaced them with polar foxes and geckos.  Polar foxes love snow, geckos love to lie in the sun, so everything seems logical.  In the end, it's just a game for Game Boy. <br><br>  In addition, in case it is still not clear, by the end of the jam the game was not even close to completion.  Anyway, it was still fun. <br><br><h2>  Game Boy Training </h2><br>  First you need to decide on the requirements.  I decided to write for DMG (internal name of the Game Boy model, short for Dot Matrix Game).  Mainly in order to meet the requirements of game jam, but also because I so wanted.  Personally, I have never had games for DMG (although there are several games for Game Boy Color), but I find 2-bit aesthetics a very nice and interesting limitation for experiments.  Perhaps I will add an additional color for SGB and CGB, but so far I have not thought about it. <br><br>  I also decided to use a cartridge with 32K ROM + without RAM, just in case I want to create a physical copy of the game.  CatSkull, who has published several Game Boy games, for example, Sheep it Up!, Has <a href="https://catskullelectronics.com/32kcart">very cheap 32-kilobyte flash cartridges on sale</a> that are perfect for me.  This is another additional limitation, but I do not think that in the near future I will be able to overcome the volume of 32K with such a simple game.  The hardest thing will be with graphics, and if everything is really bad, then I will try to squeeze it. <br><br>  As for the work of the Game Boy, then everything is quite difficult.  However, to be honest, of all the retroconsoles I had to work with, the Game Boy was the most enjoyable.  I started with an <a href="http://assemblydigest.tumblr.com/post/77198211186/tutorial-making-an-empty-game-boy-rom-in-rgbds">excellent tutorial</a> (at least for the first time, because it was never completed) by the ‚ÄúAssemblyDigest‚Äù.  I knew that it was best to write in ASM, no matter how painful it sometimes was, because the hardware was not designed for C, and I was not sure that the cool Wiz language mentioned in the tutorial would be applicable for the long term.  Plus, I do it mainly because <em>I can</em> work with ASM. <br><br>  Check with the <a href="https://github.com/InvisibleUp/AquaAndAshes/commit/8c0a4ea36fc481656a9d64d7d4c7b3f02243b96f">8c0a4ea commit</a> <br><br>  The first thing to do was get the Game Boy to load.  If the Nintendo logo is not found at the <code>$104</code> offset, and the rest of the header is not configured correctly, the Game Boy equipment will assume that the cartridge is inserted incorrectly and will refuse to load.  To solve this problem is very simple, because a lot of tutorials have already been written about it.  <a href="https://github.com/InvisibleUp/AquaAndAshes/commit/8c0a4ea36fc481656a9d64d7d4c7b3f02243b96f">Here is how I solved the problem with the title.</a>  There is nothing worthy of special attention. <br><br>  It will be more difficult to perform meaningful actions after loading.  It is very simple to make the system go into an infinite busy cycle, in which it runs one line of code again and again.  The execution of the code begins with the <code>main</code> label (where the transition to the address <code>$100</code> indicates), so some simple code should be inserted there.  For example: <br><br><pre> <code class="hljs pgsql">main: .<span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>: halt jr .<span class="hljs-keyword"><span class="hljs-keyword">loop</span></span></code> </pre> <br>  and it does nothing at all except wait for the interrupt to start, after which it returns to the <code>.loop</code> label.  (Hereinafter I will omit the detailed description of ASM operation. If you get confused, <a href="https://rednex.github.io/rgbds/">study the assembler documentation that I use</a> .) You may be curious why I just don‚Äôt go back to the <code>main</code> label.  This is done because I want everything up to the mark. <code>.loop</code> be the initialization of the program, and everything after it happens every frame.  Thus, I will not have to bypass the loading of data from the cartridge in a loop and clear the memory in each frame. <br><br>  Let's take one more step.  The RGBDS assembler package used by me contains an image converter.  Since at this stage I have not yet drawn any resources for the game, I decided to use the monochrome button from my About page as a test bit image.  Using RGBGFX, I converted it to the Game Boy format and used the .incbin assembler command to insert it after the <code>main</code> function. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26e/1d4/8b2/26e1d48b29e761edb6df6c6a3a3d035b.png" alt="image"></div><br>  To display it on the screen, I need the following: <br><br><ol><li>  Turn off the LCD </li><li>  Set palette </li><li>  Set scrolling position </li><li>  Clear Video Memory (VRAM) </li><li>  Upload tile graphics to VRAM </li><li>  Upload a tile background map to VRAM </li><li>  Turn on the LCD display again </li></ol><br><h3>  LCD off </h3><br>  For beginners, this becomes the most serious obstacle.  On the first Game Boy, it‚Äôs impossible to simply write data to VRAM at any time.  It is necessary to wait for the moment when the system does not draw anything.  Simulating the phosphorus glow in old CRT TVs, the interval between each frame, when VRAM is open, is called Vertical-Blank, or VBlank (in CRT this is the impulse to extinguish the kinescope beam during frame reversal).  (There is also HBlank between each line of the display, but it is very short.) However, you can bypass this problem by turning off the LCD screen, that is, we <em>can</em> write to VRAM regardless of where the phosphor trace of the CRT screen is located. <br><br>  If you mess up, <a href="https://www.youtube.com/watch%3Fv%3DQ8ph2OVqZeM">this review has a lot to explain to you</a> .  It examines the issue from the point of view of SNES, so do not forget that there is no electron beam, but the numbers are different, but for all the rest it is completely applicable.  Essentially, we need to set the ‚ÄúFBlank‚Äù flag. <br><br>  However, the Game Boy trick is that you can only turn off the LCD during VBlank.  That is, we have to wait for VBlank.  For this you need to use interrupts.  Interrupts are signals that the Game Boy "hardware" sends to the central processor.  If the interrupt handler is set, the processor stops its work and calls the handler.  Game Boy supports five interrupts, and one of them starts when VBlank starts. <br><br>  Interrupts can be processed in two different ways.  The first and most common is the task of <em>the interrupt handler</em> , which works as I explained above.  However, we can enable a specific interrupt and disable all handlers by setting the interrupt enable flag and using the <code>di</code> opcode.  Usually, it does nothing, but it has the side effect of exiting the HALT opcode, which stops the CPU before an interrupt occurs.  (This also happens when handlers are enabled, which allows us to exit the HALT loop into <code>main</code> .) In case you are interested, we will eventually create a VBlank handler, but much of it will depend on certain values ‚Äã‚Äãat certain addresses.  Since in RAM we have not yet specified anything, an attempt to call the VBlank handler can lead to a system crash. <br><br>  To set the values, we must send commands to the Game Boy hardware registers.  There are special memory addresses directly associated with various pieces of equipment, in our case with the CPU, which allow you to change the way it works.  We are particularly interested in the addresses <code>$FFFF</code> (interrupt enable bit field), <code>$FF0F</code> (activated but unprocessed interrupt bit field) and <code>$FF40</code> (LCD display control).  A list of these registers can be found <a href="https://github.com/avivace/awesome-gbdev">on the pages</a> related to the ‚ÄúDocumentation‚Äù section of the Awesome Game Boy Development list. <br><br>  To turn off the LCD, we enable only the VBlank interrupt, setting <code>$FFFF</code> to <code>$01</code> , performing HALT until the condition <code>$FF0F == $01</code> satisfied, and then assigning the value 7 to the address <code>$FF40</code> to bit 0. <br><br><h3>  Setting the palette and scrolling position </h3><br>  This is easy to do.  Now that the LCD is off, we don‚Äôt need to worry about VBlank.  To set the scrolling position, it is enough to set the X and Y registers to 0. With the palette, everything is a little trickier.  In Game Boy, you can assign the first to fourth shades of graphics of any of the 4 shades of gray (or marsh green, if you will), which is useful for making transitions and the like.  I specify a simple gradient as a palette, defined as a list of bits <code>%11100100</code> . <br><br><h3>  Cleaning VRAM and Loading Tile Graphics </h3><br>  At startup, all image data and the background map will consist only of the scrolling Nintendo logo, which is displayed when the system boots.  If I turn on sprites (they are disabled by default), then they will be scattered around the screen.  You need to clear the video memory to start from scratch. <br><br>  To do this, I need a function like <code>memset</code> from C. (I also need an analog <code>memcpy</code> to copy the graphics data.) The <code>memset</code> function sets the specified memory fragment to a specific byte.  It will be easy for me to implement myself, but <a href="http://assemblydigest.tumblr.com/post/77432349682/code-helpful-libraries">AssemblyDigest</a> already has these functions <a href="http://assemblydigest.tumblr.com/post/77432349682/code-helpful-libraries">in the tutorial</a> , so I use them. <br><br>  At this stage, I can clear the VRAM using <code>memset</code> , writing <code>$00</code> into it (although the first commit used the <code>$FF</code> value, which was also appropriate), and then upload the tile graphics to VRAM using <code>memcpy</code> .  More specifically, I need to copy it at <code>$9000</code> , because these are tiles that are used only for background graphics.  ( <code>$8000-$87FF</code> are used only for sprite tiles, and <code>$8800-$8FFF</code> are common to both types.) <br><br><h3>  Job tile card </h3><br>  Game Boy has one background layer, divided into 8x8 tiles.  The background layer itself occupies about 32x32 tiles, that is, it has a total size of 256x256.  (For comparison: the console screen has a resolution of 160x144.) I needed to manually specify the tiles that make up my image line by line.  Fortunately, all the tiles were arranged in order, so I just needed to fill each line with values ‚Äã‚Äãfrom <code>N*11</code> to <code>N*11 + 10</code> , where <code>N</code> is the line number and the remaining 22 tile elements fill <code>$FF</code> . <br><br><h3>  Turn on the LCD </h3><br>  Here, we do not need to wait for VBlank, because the screen will still not turn on until VBlank, so I just wrote the register in the LCD control register again.  I also included background layers and sprites, as well as the correct addresses of the tile map and tile graphics.  After that, I got the following results.  I also re-enabled interrupt handlers using the opcode <code>ei</code> . <br><br>  At this stage, to make it even more interesting, I wrote a very simple interrupt handler for VBlank.  By adding an opcode to the address of <code>$40</code> , I can make the handler any function I need.  In this case, I wrote a simple function that scrolls the screen up and left. <br><br>  Here are the finished results.  [Supplement: I just realized that GIF is looped wrong, it must constantly transfer the image.] <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd0/c84/9db/fd0c849dbe3bc68910d186b1ef014c66.gif"></div><br>  So far, nothing particularly surprising, but still great that theoretically I can get my old Game Boy Color and see how my own code runs on it. <br><br><h2>  Plaid Sheet Fun </h2><br>  To draw something on the screen, I naturally need some kind of sprites.  After examining the Game Boy console's PPU (Picture Processing Unit), I decided to stop at 8x8 or 8x16 sprites.  Probably, I will need the last option, but just to feel the size, I quickly scribbled on the checkered paper a screenshot of the game in 1: 8 scale. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/887/b5b/ece/887b5becec39b13f2fd167e9436c63e5.jpg"></div><br>  I wanted to leave the top of the screen under the HUD.  It seemed to me that it would look more natural than the bottom, because when it is up, if the characters need to temporarily block the HUD, as in Super Mario Bros, they can do it.  In this game, there will not be any complex platforming, and in fact there will be no level design either, so I don‚Äôt need to show a very general field view.  It is quite enough to position the characters on the screen and, possibly, from time to time obstacles.  So I can afford big enough sprites. <br><br>  So, if one square was one 8x8 tile, then one sprite wo <em>n't</em> be enough, no matter what size I choose.  This is especially true given the fact that there will be almost no vertical movement in the game, with the exception of jumps.  So I decided to create sprites from four 8x16 sprites.  The exception was the tail of the fox, which occupies two 8x16 sprites.  After a simple calculation, it became clear that two foxes and two geckos would occupy 20 of 40 sprites, that is, you can add many more additional sprites.  (8x8 sprites would quickly exhaust my limit, which I don‚Äôt want to do in the early stages of development.) <br><br>  For now, I just need to render the sprites.  Below are rough sketches on checkered paper.  I have a waiting sprite, a ‚Äúthinking‚Äù sprite for choosing whether to make a pass or run like in a game on SNES ... and that‚Äôs it.  I also planned to make sprites of running characters, jumping characters, and characters that opponents grab.  But for a start I drew only waiting and thinking sprites in order not to complicate things.  The rest I still did not do, I have to do it. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/623/20c/124/62320c12434cacf0c0ca06a2aad33fae.jpg"></div><br>  Yes, I know, I'm not drawing very well.  Perspective is a complicated thing.  (Yes, and this face of the polar fox is terrible.) But it suits me perfectly.  Character design does not have any special features, but is suitable for game jam.  Of course, I used real geckos and polar foxes as references.  Is it imperceptible? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1fe/b2e/936/1feb2e936415aeceaf8cd35596d7e55d.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/215/cc8/568/215cc856884bb518df111799d6e10a87.jpg"></div><br>  You can not tell.  (For the record: having just looked at these pictures again, I realized that there is a huge difference between geckos and lizards. I don‚Äôt know what to do with this, except consider myself to be stupid ...) I think you can guess that the source of inspiration for Fox heads served Blaze the Cat from the Sonic game series. <br><br>  Initially, I wanted the defenders and forwards in each team to be of different sexes and it was easier to distinguish between them.  (I was also going to let the players choose the gender of their character.) However, this would require much more to draw.  Therefore, I stopped at the male geckos and female foxes. <br><br>  And finally, I drew the screen saver, because there was room for it on a sheet of checkered paper. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c67/5ac/30a/c675ac30af04025014da7eee842d285d.jpg"></div><br>  Yes, action poses are far from ideal.  The polar fox should be more upset and run, and the gecko look threatening.  The defender-fox in the background is a funny reference to the art on the Doom box. <br><br><h2>  Digitizing Sprites </h2><br>  Then I started to turn the paper drawings into sprites.  For this, I used the program GraphicsGale, which recently made free.  (I know it was possible to use asesprite, but I prefer the GraphicsGale.) The work on the sprites was much more difficult than I expected.  Each of these squares of the sprites shown above takes up to 4 pixels in a 2x2 grid.  And in these squares there was often MUCH more details than in 4 pixels.  Therefore, I had to get rid of many details of sketches.  Sometimes it was even difficult to adhere to a simple form, because it was necessary to leave a place acceptable for the eyes or nose.  But it seems to me that everything looks good, even if the sprite is completely different. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39f/789/d16/39f789d16e3c10c85fa4f0613a0cf571.png"></div><br>  The eyes of the fox lost their almond shape and turned into a line two pixels high.  The eyes of the gecko have retained their roundness.  The head of the gecko had to be enlarged, getting rid of the broad shoulders, and all the bends that the fox could have, were significantly smoothed.  But frankly, all these easy changes are not so bad.  Sometimes I hardly managed to choose which of the variations is better. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a52/32f/d71/a5232fd71193a02dfaebdc2c043edbe5.png"></div><br>  GraphicsGale also has handy layer and animation functions.  This means that I can animate the fox's tail separately from its body.  This is a great help to save precious VRAM space, because I don‚Äôt need to duplicate the tail in each frame.  In addition, it meant that you can wag your tail with variable speed, slowing down when a character is standing, and accelerating while running.  However, programming is a bit more complicated.  But I still take on this task.  I stopped at 4 frames of animation, because that's enough. <br><br>  You can see that in the polar fox three of the lightest shades of gray are used, and in the gecko there are three of the darkest.  On the GameBoy, this is permissible, because although there are only three colors in the sprite, the console allows you to set two palettes.  I made it so that the fox uses a palette of 0, and for a gecko, palette 1. This completes the whole available set of palettes, but I don‚Äôt think I will need others. <br><br>  I also needed to take care of the background.  I did not bother with his sketches, because I planned that it would be a solid color or a simple geometric pattern.  I haven't digitized the splash screen either, because I didn't have enough time. <br><br><h2>  Download sprites to the game </h2><br>  Check with the <a href="https://github.com/InvisibleUp/AquaAndAshes/commit/be99d97944bcc7e2b946ef2b070266605e7ef542">be99d97</a> commit. <br><br>  After each individual frame of the character graphics was saved, it was possible to start converting them into the GameBoy format.  It turned out that the RGBDS for this is a very handy utility called RGBGFX.  You can call it with the <code>rgbgfx -h -o output.bin input.png</code> and it will create a GameBoy compatible tile set.  (The -h switch sets the 8x16 compatible tile mode so that the conversion is performed from top to bottom, not from left to right.) However, it does not provide bindings and cannot track duplicate tiles when each frame is a separate picture.  But we will leave this problem for later. <br><br>  After generating the output .bin files, simply add them to the assembler using <code>incbin "output.bin"</code> .  To keep everything together, I created a common file "gfxinclude.z80", which contains all the added graphics. <br><br>  However, it was very boring to manually re-generate the graphics each time something changed.  So I edited the build.bat file, adding the line <code>for %%f in (gfx/*.png) do rgbds\rgbgfx -h -o gfx/bin/%%f.bin gfx/%%f</code> , which converts each file. png in the gfx / folder in the bin file and save it to gfx / bin.  This greatly simplified my life. <br><br>  To create the background graphics, I used a <em>much</em> more lazy way.  RGBASM has the <code>dw `</code> directive.  It is followed by a row of 8 values ‚Äã‚Äãfrom 0 to 4, equal to one row of pixel data.  Since the background sprites were very simple, it turned out to be easier to copy and paste a simple geometric pattern to create a solid, striped or checkerboard pattern.  For example, what a land tile looks like. <br><br><pre> <code class="hljs markdown">bg_dirt: dw <span class="hljs-code"><span class="hljs-code">`00110011 dw `</span></span>00000000 dw <span class="hljs-code"><span class="hljs-code">`01100110 dw `</span></span>00000000 dw <span class="hljs-code"><span class="hljs-code">`11001100 dw `</span></span>00000000 dw <span class="hljs-code"><span class="hljs-code">`10011001 dw `</span></span>00000000</code> </pre> <br>  He creates a series of shifted stripes with the illusion of perspective.  This is a simple but smart approach.  Everything was a little harder with grass.  Initially, it was a group of horizontal lines with a height of 2 pixels, but I manually added a few pixels, giving a bit of noise with which the grass looks better: <br><br><pre> <code class="hljs markdown">bg_grass: dw <span class="hljs-code"><span class="hljs-code">`12121112 dw `</span></span>12121212 dw <span class="hljs-code"><span class="hljs-code">`22112211 dw `</span></span>11121212 dw <span class="hljs-code"><span class="hljs-code">`22112211 dw `</span></span>21212121 dw <span class="hljs-code"><span class="hljs-code">`12121212 dw `</span></span>12211222</code> </pre> <br><h2>  Graphics rendering </h2><br>  In GameBoy, sprites are stored in an area called OAM, or Object Attribute Memory.  It contains only attributes (direction, palette and priority), as well as the tile number.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It was enough for me to fill this area of ‚Äã‚Äãmemory to display the sprites on the screen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although there are some minor features. First, you need to load graphics from ROM to VRAM. GameBoy can only render tiles that are stored in a special area of ‚Äã‚Äãmemory called VRAM. Fortunately, to copy from ROM to VRAM, it‚Äôs enough to execute </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at the initialization stage of the program. At the same time, it turned out that with only 6 characters sprites and 4 tail tiles, I already took a quarter of the VRAM area allocated for sprites. (VRAM is usually divided into background and sprites, and 128 bytes are common to them.)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, access to OAM is only possible during VBlank. I started by saying that before performing the sprite calculations I waited for VBlank, but I ran into problems because the sprite calculations were stretched for all the time allocated to VBlank and could not be completed. The solution here is to write to a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">separate</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memory area outside the VBlank and simply copy them into the OAM during VBlank. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As it turned out, GameBoy has a special hardware copy procedure, a kind of DMA (Direct Memory Access), which does just that. By writing to a specific register and going to the busy cycle in HiRAM (because it is not available during DMA ROM), you can copy data from RAM to OAM much faster than using the function</font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">If interested, you can find juicy details </font></font><a href="http://gbdev.gg8.se/wiki/articles/Video_Display"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At this stage, all I had to do was create a procedure that determines </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">what</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will eventually be written into the DMA. </font><font style="vertical-align: inherit;">For this, I needed to store the state of the objects somewhere else. </font><font style="vertical-align: inherit;">At a minimum, the following was required:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Type (gecko, polar fox or portable item of one of the teams) </font></font></li><li>  Direction </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> X position </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y position </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Frame animation </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Animation timer </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the first, very sloppy decision, I checked the type of the object, and depending on it, I made the transition to the procedure that spritically rendered this type of object. The polar fox procedure, for example, took a position on X, added or subtracted 16, depending on the direction, added two tail sprites, and then moved up and down along the main sprite. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is a screenshot of what the sprite looked like when it was drawn on the screen. The left part is the individual sprites, hexadecimal numbers next to them, from top to bottom - the position of the vertical and horizontal, Tile and attribute flags. On the right you can see how it all looked after assembly.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e9/e7d/240/8e9e7d2401e1a07d0c77e2f0c6c99e3d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With the tail animation, everything was a bit more complicated. In the first solution, I simply performed the increment of the animation timer in each frame and produced a Boolean </font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with the value </font></font><code>%11</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to get the frame number. Then you could simply add to the first tail tile in VRAM 4 * the frame number (each animation frame consists of 4 tiles) to get 4 different frames stored in VRAM. It worked (especially the tail tail search part), but the tail wagged </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">insanely</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fast, and I needed to find a way to slow it down. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the second, better solution, I performed the increment of the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">global</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> timer </font><font style="vertical-align: inherit;">in each frame </font><font style="vertical-align: inherit;">, and when the value of the operation </font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and the power of two chosen by me was equal to 0, the object timer increment was performed. </font><font style="vertical-align: inherit;">Thus, each individual object could perform the countdown of its animation timer at any speed it needs. </font><font style="vertical-align: inherit;">It worked perfectly and allowed me to slow the tail to a reasonable level.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Difficulties </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But if everything was so simple. Do not forget that I managed all of this in the code, using my own subprocedure for each object, and if it was necessary to continue, then it should be done in each frame. I had to specify how to proceed to the next sprite, as well as which tile it consists of, by manually manipulating the registers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It was a completely unstable system. To draw a single frame, it was necessary to juggle a sufficiently large number of registers and CPU time. It was almost impossible to add support for other cadres, and even if I succeeded, support for the system would be very painful. </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Believe me, it was real chaos.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I needed a system in which the code for rendering sprites would be generalized and straightforward, so that it would not be an interweaving of conditions, manipulation of registers and mathematical operators. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How did I manage to fix it? </font><font style="vertical-align: inherit;">I will tell about it in the following part of article.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/47d/f64/3a2/47df643a2bd620cf8899b3601162748b.gif" alt="image"></div></div><p>Source: <a href="https://habr.com/ru/post/436330/">https://habr.com/ru/post/436330/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>