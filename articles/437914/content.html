<div class="post__text post__text-html js-mediator-article"><p> I think many Java-developers who at least once came across <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B5%25D0%25B1-%25D1%2581%25D0%25BB%25D1%2583%25D0%25B6%25D0%25B1%25D0%25B0"><code>Web-сервисами</code></a> , used generation of <code>Java</code> <code>DTO</code> classes according to the description of <a href="https://ru.wikipedia.org/wiki/XML_Schema_(W3C)"><code>XML Schema</code> ( <code>XSD</code> )</a> .  <a href="https://en.wikipedia.org/wiki/Java_Architecture_for_XML_Binding">Jaxb copes</a> with this with a bang, no matter how to use it, via <a href="https://docs.oracle.com/javase/7/docs/technotes/tools/share/xjc.html"><code>xjc</code></a> or <code>wsimport</code> command line call, maven or gradle plugins. </p><br><p>  It is so quick and easy to generate classes from an <code>XSD</code> schema.  <strong>But here is one problem - the descriptions in the source diagram are almost completely lost!</strong> </p><br><p>  <em>Practically</em> , because <code>Javadoc</code> will only have a description of the class itself, in a fixed format (where we can’t separate the description and the <code>XML</code> fragment without regulars, for example), the description of the fields (fields) is completely missing.  <strong>And if you need them, like me, you also need them at runtime ( <code>runtime</code> ) - this is a real disaster</strong> . </p><br><p>  It was with this that I had to fight, oddly enough, the task took a lot of time, and as a result I wrote a plugin, which I would like to present in the hope that he could save someone a few hours in the future. </p><a name="habracut"></a><br><h1 id="kratkiy-obzor-vozmozhnostey-jaxb">  Jaxb features overview </h1><br><p>  <a href="https://en.wikipedia.org/wiki/Java_Architecture_for_XML_Binding">Jaxb</a> has a great history and a good <a href="https://javaee.github.io/jaxb-v2/doc/user-guide/ch03.html">official description, including the addition of behavior</a> to the generated classes. </p><br><p>  The main tool for invoking class generation from the command line - <a href="https://docs.oracle.com/javase/7/docs/technotes/tools/share/xjc.html">xjc</a> also has not the smallest number of keys.  But none of them, not for our case. </p><br><p>  Of course, one can not fail to mention about <code>-b</code> , where you can provide your own binding.  And this is a very powerful weapon, especially in conjunction with multiple plug-ins.  Very good <a href="https://blog.frankel.ch/customize-your-jaxb-bindings/">blog post (in English)</a> - I recommend reading as a brief introduction.  But the binding is mostly limited to the static values ​​of the assigned annotations or given names, indicating the elements to which it is applied.  It doesn't help my problem. </p><br><h2 id="jaxb-xjc-plaginy">  Jaxb (XJC) plugins </h2><br><p>  While looking for a ready-made solution, I found many plug-ins that extend generation.  I believe their review is beyond the scope of this post.  What is important, doing what is necessary to me, I have not found. </p><br><p>  But then, while reading the answers and questions at <a href="http://stackoverflow.com/">http://stackoverflow.com/</a> , I found several questions of this kind, for example: </p><br><ol><li>  <a href="https://stackoverflow.com/questions/25750847/using-jaxb-to-handle-schema-annotations/25753858">Using JAXB to handle schema annotations</a> . </li><li>  <a href="https://stackoverflow.com/questions/1650249/how-to-make-generated-classes-contain-javadoc-from-xml-schema-documentation">How to make generated classes contain Javadoc from XML Schema documentation</a> </li><li>  <a href="https://stackoverflow.com/questions/42223784/how-can-i-generate-a-class-from-which-i-can-retrieve-the-xml-of-a-node-as-a-stri">How can I generate a XML from a node as a String</a> </li></ol><br><p>  and no complete answer, some over many years! </p><br><p>  But, returning to the topic of possibilities, it turned out that there is an <code>API</code> for writing plugins!  Low-level, sometimes confusing, almost without documentation ... But I can say this is very advanced, that is, you can directly intervene in many processes.  By the way, the responses to it are often referenced, for many non-standard cases.  So I tried to write a plugin. </p><br><p>  For those who are interested in the details of the process of writing their plug-ins, I can recommend articles: </p><br><ul><li>  <a href="http://www.archive.ricston.com/blog/xjc-plugin/">Creating an XJC plugin</a> </li><li>  <a href="https://blog.jooq.org/tag/xjc-plugin/">How to Implement Your Own XJC Plugin to Generate toString (), equals (), and hashCode () Methods</a> </li><li>  StackOverflow has very detailed answers: <br><ul><li>  <a href="https://stackoverflow.com/questions/43233629/xjc-java-classes-generation-where-fields-have-the-same-name-as-xmlelement/43381317">xjc java classes generation, where fields have the same name as @XmlElement</a> </li><li>  <a href="https://stackoverflow.com/questions/21606248/jaxb-convert-non-ascii-characters-to-ascii-characters/21780020">JAXB convert non-ASCII characters to ASCII characters</a> </li></ul></li></ul><br><h1 id="chto-hotel-i-zachem">  What you wanted and why </h1><br><p>  For one of our integrations, the customer provided an archive with <code>XSD</code> files, according to which we had to generate a model in <a href="https://unidata-platform.com/">Unidata</a> <a href="https://ru.wikipedia.org/wiki/%25D0%25A3%25D0%25BF%25D1%2580%25D0%25B0%25D0%25B2%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BE%25D1%2581%25D0%25BD%25D0%25BE%25D0%25B2%25D0%25BD%25D1%258B%25D0%25BC%25D0%25B8_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D0%25BC%25D0%25B8">MDM</a> , with which we work, to further adjust the quality rules. </p><br><blockquote>  I note that the <code>MDM</code> system itself is proprietary, it is unlikely that many are familiar with it, but this does not really matter.  The bottom line is that we had to create reference books and registers for <code>XSD</code> descriptions.  At the same time, the registries have fields in which both the identifier (the name of the field) and the "display name" are used - the name that the person understands is in Russian.  A simple analogy can be drawn (and this is probably also a useful example for use) with <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25BB%25D1%258F%25D1%2586%25D0%25B8%25D0%25BE%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25A1%25D0%25A3%25D0%2591%25D0%2594">RDBMS</a> in terms of which we can assume that we wanted to make database tables, but at the same time give descriptions ( <code>comment</code> ) for each column for later use. </blockquote><p>  My plan was this: </p><br><ol><li>  Generating <code>XSD</code> Classes with <code>XJC</code> </li><li>  Then we take an excellent library of <a href="https://github.com/ronmamo/reflections">reflections</a> and iterate over all objects, recursively descending through the fields. </li></ol><br><p>  <em>Everything worked quickly for Latin names that were taken from fields of the <code>field</code> .</em>  <em>But the Russian, humane description was nowhere to take!</em> </p><br><p>  Manual description is not an option, because there are tens of thousands of nested fields. </p><br><p>  The first attempt was to write a similar parser on <code>Groovy</code> yourself, tearing out descriptions from <code>XSD</code> .  And in general, it was implemented.  But it quickly became clear that there are many cases where additional processing is required - recursive calls, support for <code>XSD</code> 1.1 extensions in the form of a <code>restriction</code> / <code>extension</code> (with support for inheritance and overriding), different types of which generate class fields like <code>&lt;element&gt;</code> and <code>&lt;attribute&gt;</code> , <code>&lt;sequence&gt;</code> , <code>&lt;choose&gt;</code> and many other small things.  Realization overgrown with additions, but she was not slim. </p><br><p>  As a result, I returned to the idea of ​​writing a plug-in <a href="https://github.com/Hubbitus/xjc-documentation-annotation-plugin">xjc-documentation-annotation-plugin</a> , which I represent to you, in the hope that it will be useful to someone other than me! </p><br><h1 id="xjc-documentation-annotation-plugin">  xjc-documentation-annotation-plugin </h1><br><p>  Everything is posted on the githaba: <a href="https://github.com/Hubbitus/xjc-documentation-annotation-plugin">https://github.com/Hubbitus/xjc-documentation-annotation-plugin</a> <br>  There are also instructions, tests and a separate <a href="https://github.com/Hubbitus/xjc-documentation-annotation-plugin/tree/master/example-project-gradle"><code>демо-проект для gradle</code></a> with an example of use. </p><br><p>  I think it makes no sense to copy the description here from there, just briefly show you what he does. </p><br><p>  Let's say there is such an <code>XSD</code> fragment: </p><br><pre> <code class="xml hljs"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">xs:complexType</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"CadastralBlock"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">xs:annotation</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">xs:documentation</span></span></span><span class="hljs-tag">&gt;</span></span>Кадастровый квартал<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">xs:documentation</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">xs:annotation</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">xs:sequence</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">xs:element</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"number"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"xs:string"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">xs:annotation</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">xs:documentation</span></span></span><span class="hljs-tag">&gt;</span></span>Кадастровый номер<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">xs:documentation</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">xs:annotation</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">xs:element</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">xs:sequence</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">xs:complexType</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  By default, <code>XJC</code> generate a <code>XJC</code> class from it (getters, setters, and some irrelevant details are omitted for readability): </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Кадастровый квартал * * &lt;p&gt;Java class for CadastralBlock complex type. * * &lt;p&gt;The following schema fragment specifies the expected content contained within this class. * * &lt;pre&gt; * &amp;lt;complexType name="CadastralBlock"&amp;gt; * &amp;lt;complexContent&amp;gt; * &amp;lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&amp;gt; * &amp;lt;sequence&amp;gt; * &amp;lt;element name="number" type="{http://www.w3.org/2001/XMLSchema}string"/&amp;gt; * &amp;lt;/sequence&amp;gt; * &amp;lt;/restriction&amp;gt; * &amp;lt;/complexContent&amp;gt; * &amp;lt;/complexType&amp;gt; * &lt;/pre&gt; * * */</span></span> <span class="hljs-meta"><span class="hljs-meta">@XmlAccessorType</span></span>(XmlAccessType.FIELD) <span class="hljs-meta"><span class="hljs-meta">@XmlType</span></span>(name = <span class="hljs-string"><span class="hljs-string">"CadastralBlock"</span></span>, namespace = <span class="hljs-string"><span class="hljs-string">"http://hubbitus.info/xjc-plugin-demo"</span></span>, propOrder = { <span class="hljs-string"><span class="hljs-string">"number"</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CadastralBlock</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@XmlElement</span></span>(required = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> String number; }</code> </pre> <br><p>  With the plugin you will get: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@XmlAccessorType</span></span>(XmlAccessType.FIELD) <span class="hljs-meta"><span class="hljs-meta">@XmlType</span></span>(name = <span class="hljs-string"><span class="hljs-string">"CadastralBlock"</span></span>, namespace = <span class="hljs-string"><span class="hljs-string">"http://hubbitus.info/xjc-plugin-demo"</span></span>, propOrder = { <span class="hljs-string"><span class="hljs-string">"number"</span></span> }) <span class="hljs-meta"><span class="hljs-meta">@XsdInfo</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Кадастровый квартал"</span></span>, xsdElementPart = <span class="hljs-string"><span class="hljs-string">"&lt;complexType name=\"CadastralBlock\"&gt;\n &lt;complexContent&gt;\n &lt;restriction base=\"{http://www.w3.org/2001/XMLSchema}anyType\"&gt;\n &lt;sequence&gt;\n &lt;element name=\"number\" type=\"{http://www.w3.org/2001/XMLSchema}string\"/&gt;\n &lt;/sequence&gt;\n &lt;/restriction&gt;\n &lt;/complexContent&gt;\n&lt;/complexType&gt;"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CadastralBlock</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@XmlElement</span></span>(required = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) <span class="hljs-meta"><span class="hljs-meta">@XsdInfo</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Кадастровый номер"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> String number; }</code> </pre> <br><p>  Notice the added annotations <strong><code>@XmlType</code></strong> . </p><br><p>  Using it is then as simple as any other annotation: </p><br><pre> <code class="java hljs"> XsdInfo xsdAnnotation = CadastralBlock.class.getDeclaredAnnotation(XsdInfo.class); System.out.println(<span class="hljs-string"><span class="hljs-string">"XSD description: "</span></span> + xsdAnnotation.name());</code> </pre> <br><p>  A working example is in the tests: <a href="https://github.com/Hubbitus/xjc-documentation-annotation-plugin/blob/master/src/test/groovy/info/hubbitus/XJCPluginDescriptionAnnotationTest.groovy">1</a> , <a href="https://github.com/Hubbitus/xjc-documentation-annotation-plugin/blob/master/example-project-gradle/src/test/groovy/TestGeneratedMavenModel.groovy">2</a> . </p></div>