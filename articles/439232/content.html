<div class="post__text post__text-html js-mediator-article"><p>  Have you heard of the new JAMstack approach?  The ability to write web applications on your favorite framework, manage content from the admin panel, and get fully valid HTML pages based on the latest SEO, PWA and a11y recommendations. </p><br><p>  Interesting?  Then here is a list of issues addressed in this article: </p><br><ul><li>  What is this new stack and why is it needed? </li><li>  How to run a basic application using gatsby? </li><li>  Working with Contentful and creating the first chunk of data. </li><li>  How to connect Contentful and Gatsby using GraphQL? </li><li>  Set up automatic deployment using Netlify </li></ul><a name="habracut"></a><br><h2 id="jamstack">  JAMstack </h2><br><p>  As you know: “Everything new is a long forgotten old one” and this is another confirmation that the mod on static sites is back.  What was the internet ten years ago?  It was PHP server-rendering, which substituted data from the database into HTML templates and sent it to the client. </p><br><p><img src="https://habrastorage.org/webt/nk/4j/lr/nk4jlri46dpf-yeilgloknxtx8o.png" alt="server rendering"></p><br><p>  This approach has been replaced by JavaScript frameworks, which in recent years are represented by the holy trinity of the web <em>React Angular Vue.</em> <del>  Amen </del>  .  What was the fundamental difference?  In the speed and responsiveness of the interface, because now all the logic of the site was on the client, and for any mouse movement you can call a beautiful animation with changing content, sending requests to the API. </p><br><p><img src="https://habrastorage.org/webt/yz/yl/yd/yzylydcklduuinekhlfcf6lqwmk.png" alt="client rendering"></p><br><p>  What's next?  JAM offers: </p><br><ul><li>  no server-side rendering, and generally remove the server as such </li><li> no client-side rendering, <code>&lt;div id=”root”&gt;&lt;/div&gt;</code> </li><li>  compile the site into plain HTML code, once, at the time of the content change </li><li>  placing the site on any file hosting </li></ul><br><p><img src="https://habrastorage.org/webt/s_/cl/8x/s_cl8xgwabvmmlr8yp7rssmwg48.png" alt="Jam"></p><br><p>  The client always receives a pre-rendered page with a fully valid layout and the question of performance now concerns only the speed of the Internet connection (but of course you should not forget about the coefficient of the developer’s hands-onness). </p><br><h2 id="instrumentariy">  Tools </h2><br><p>  JAM is just an approach, the means for which the market is already enough, but as you know, nails can be driven with anything, but I would prefer a hammer. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/179/dfe/b70/179dfeb70ac283b713825a98e3492554.gif" alt="hammer nail"></p><br><p>  <strong>List of the best tools for 2019:</strong> </p><br><p>  <a href="https://www.gatsbyjs.org/">Gatsby</a> is a static site generator from <em>React + GraphQL</em> applications.  Why is it such a choice, rather than <em>Angular</em> or <em>Vue,</em> I find it difficult to answer, but most likely it’s about the evil statistics, which says that despite all the controversy, <em>React is the</em> most popular framework of the last three years (do not throw stones at me in the comments, for this statement actually paid me).  For a more visual representation, <code>create-react-app</code> compiles the code in a JavaScript build, for further rendering when the page is launched, Gatsby generates full-fledged HTML pages with valid layout that are shown as is, even with JS turned off. </p><br><p>  <a href="https://www.contentful.com/">Contentful</a> - content management system on static pages.  This is <em>WordPress</em> , which does not save the connection between templates and data in the database, but instead changes the data directly in HTML files. </p><br><p>  <a href="https://app.netlify.com/">Netlify</a> is a very easy-to-use deployment system that allows you to associate most of the popular file hosts with a JAM application, and even on the HTTPS protocol. </p><br><h2 id="ot-teorii-k-praktike">  From theory to practice </h2><br><p>  Now that you have decided on the tools, you can proceed. </p><br><h3 id="contentful">  Contentful </h3><br><p>  We create an account and see that by default the service generates an exemplary project, which I recommend to delete immediately, as in my subjective opinion it interferes more than helps to understand.  Create a new free project, without generating examples. </p><br><p>  The content management system is based on two entities - the <strong>Content model</strong> , which describes the structure and types of data, and the <strong>Content itself</strong> .  First, create a simple model for our blog.  <strong>Content model</strong> consists of data types, for example for a blog data types will be: <em>Article</em> , <em>Person</em> . </p><br><p><img src="https://habrastorage.org/webt/tf/h_/ae/tfh_aezqyltilbnfometsxytrfg.gif"></p><br><blockquote>  Of course, you can choose any level of abstraction that you like, for example, you can abolish <em>Person</em> and specify information about the author inside the <em>Article</em> , as _Article.author <em>name</em> </blockquote><br><div class="spoiler">  <b class="spoiler_title">The structure of my model</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> article/ ├── title (Short text) ├── text (Long text) ├── banner (Single media) └── publishedAt (Date &amp; Time) person/ ├── fullName (Short text) └── avatar (Single media)</code> </pre> </div></div><br><p>  Further, using the already created data types, we add content, for texts you can use <a href="http://saganipsum.com/">SaganIpsum</a> for <a href="https://unsplash.com/search/photos/space">Unsplash</a> pictures. </p><br><p><img src="https://habrastorage.org/webt/t_/je/1u/t_je1uev3db2j6-io_f7xpnq9fm.gif" alt="contentful add content"></p><br><h3 id="gatsby">  Gatsby </h3><br><p>  We open the terminal and create a working environment </p><br><pre> <code class="plaintext hljs">## Установка npm install --global gatsby-cli ## Создание проекта gatsby new personal-blog ## Для любителей минимализма можно установить Hello World проект ## gatsby new minimal-gatsby https://github.com/gatsbyjs/gatsby-starter-hello-world ## Переходим в папку cd personal-blog</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Project structure</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> personal-blog/ ├── gatsby-browser.js ├── gatsby-config.js ├── gatsby-node.js ├── gatsby-ssr.js ├── LICENSE ├── node_modules ├── package.json ├── README.md └── src ├── components │ ├── header.js │ ├── image.js │ ├── layout.css │ ├── layout.js │ └── seo.js ├── images │ ├── gatsby-astronaut.png │ └── gatsby-icon.png └── pages ├── 404.js ├── index.js └── page-2.js</code> </pre> </div></div><br><pre> <code class="plaintext hljs">## Запуск проекта с hot-reloading gatsby develop</code> </pre> <br><p>  What happened?  <em>React + GraphQL</em> application is collected using <em>Gatsby</em> , which means that any old project that is rendered for a long time can be transferred to a static HTML site and get a speed increase several times. </p><br><h3 id="gatsbycontentful">  Gatsby + contentful </h3><br><pre> <code class="plaintext hljs">## Установка дополнительных пакетов npm install gatsby-source-contentful dotenv</code> </pre> <br><p>  Create a <em>.env</em> file in the application root with the following contents: </p><br><pre> <code class="plaintext hljs">/* 12-и значный ключ из Contentful → Settings → API keys → Example key 1→ Space ID */ CONTENTFUL_SPACE_ID=xxxxxxxxxxxx /* 64-х значный ключ из Contentful → Settings → API keys → Example key 1→ Content Delivery API - access token */ CONTENTFUL_ACCESS_TOKEN=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</code> </pre> <br><p>  <em>Extending the</em> configuration in <em>gatsby-config.js</em> : </p><br><pre> <code class="plaintext hljs">if (process.env.NODE_ENV === "development") { require("dotenv").config(); } module.exports = { /* other settings */ plugins: [ /* other plugins */ { resolve: `gatsby-source-contentful`, options: { spaceId: process.env.CONTENTFUL_SPACE_ID, accessToken: process.env.CONTENTFUL_ACCESS_TOKEN, }, } ] }</code> </pre> <br><p>  Restart the Gatsby server and if the console does not show any errors, then the connection with Contentful is established and you can proceed further. </p><br><h3 id="gatsbygraphqlcontentful">  Gatsby + GraphQL + Contentful </h3><br><p>  If you are not familiar with GraphQL, then do not worry because it is quite simple.  Our site is now located at: </p><br><p>  <a href="http://localhost:8000/">http: // localhost: 8000 /</a> </p><br><p>  But for the time being we will leave it and open the second tab: </p><br><p>  <a href="http://localhost:8000/">http: // localhost: 8000 / ___ graphql</a> </p><br><p>  We have an IDE for <em>GraphQL</em> right in the browser.  It is very convenient to build queries and test them.  Click on the <strong>Docs</strong> in the upper right corner to expand the sidebar with the documentation, but the surprise is not the <em>GraphQL</em> documentation, it is the documentation of your API.  Expand the <strong>Query</strong> list to see all available schemas for queries, with their data types. </p><br><p>  The schemes of interest to us have something like the following name: </p><br><p>  <strong>contentful your</strong> <em>datatype</em> - one copy <br>  <strong>allContentful Your</strong> <em>TypeData</em> - list of instances </p><br><div class="spoiler">  <b class="spoiler_title">An example of my data</b> <div class="spoiler_text"><ul><li>  contentfulrticle </li><li>  contentfulerson </li><li>  allContentfulArticle </li><li>  allContentfulPerson </li></ul></div></div><br><p>  Using the left panel we will construct the correct request for our data (try autocompletion, very convenient). </p><br><div class="spoiler">  <b class="spoiler_title">An example requesting a single instance of type Person and a list from Article</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> { contentfulPerson { fullName avatar { file { url } } } allContentfulArticle { edges { node { title text { text } banner { file { url } } publishedAt } } } }</code> </pre> </div></div><br><p>  What can be noted from the query structure: </p><br><ul><li>  to get the URL for the file, you need to contact the path <code>typeName.file.url</code> </li><li>  to get the text from the Long text type, go along the path <code>typeName.typeName</code> </li><li>  To get a list of instances of a type, use the following path <code>allContentfulName.edges</code> </li></ul><br><p>  We transfer the query schema to the project and render it as normal data in a React application.  It is generally accepted Best Practice to use the <code>&lt;StaticQuery /&gt;</code> component from the <a href="https://www.npmjs.com/package/gatsby">gatsby</a> package that is already installed in the project. </p><br><div class="spoiler">  <b class="spoiler_title">Sample index.js file</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> import React from "react" import { StaticQuery, graphql } from "gatsby" import Layout from "../components/layout" import Article from "../components/article" const IndexPage = () =&gt; ( &lt;Layout&gt; &lt;StaticQuery query={graphql` { allContentfulArticle { edges { node { id title text { text } banner { file { url } } publishedAt } } } } `} render={({ allContentfulArticle: { edges } }) =&gt; ( edges.map(({ node }) =&gt; ( &lt;Article key={node.id} content={node} /&gt; )) )} /&gt; &lt;/Layout&gt; ) export default IndexPage</code> </pre> </div></div><br><p>  How it works?  The <code>query</code> passes the <em>GraphQL</em> query <em>schema</em> , and the <code>render</code> our favorite JSX.  Use destructuring to make the code more readable. </p><br><div class="spoiler">  <b class="spoiler_title">Destructuring by example of components / article.js</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> import React from "react" const Article = ({ content: { title, text, banner: { file: { url } }, publishedAt } }) =&gt; ( &lt;div&gt; &lt;h2&gt;{title}&lt;/h2&gt; &lt;img src={url} alt={title}/&gt; &lt;p&gt; {text} &lt;/p&gt; &lt;h5&gt;{publishedAt}&lt;/h5&gt; &lt;/div&gt; ) export default Article</code> </pre> </div></div><br><p>  Now, when it became clear how to get and render the data, you can start developing, but since this article is not about how to make a site on the reactor, we will skip this moment and imagine that the site is ready. </p><br><p>  Let's place our project on GitHub, from where it can be deployed in the next step. </p><br><div class="spoiler">  <b class="spoiler_title">For those who still do not know how to do it</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> ## Находясь в папке с проектом инициализируем пустой репозиторий git init ## Сделаем первый коммит git add . git commit -m “initial commit” ## Создаем репозиторий на GitHub и подключаем git remote add origin git@github.com:yourname/my-repository-name.git ## Публикуем изменения git push origin master</code> </pre> </div></div><br><h3 id="nastraivaem-netlify">  Configuring Netlify </h3><br><p>  We create an account using the service on which the planned placement of projects.  I chose GitHub, so after successful authorization we set up a new project by clicking on <strong>New site from Git</strong> .  We connect our repository, and <em>Netlify</em> will automatically determine that this is a <em>Gatsby</em> project and will configure all the scripts to build. </p><br><p>  Select the desired branch, and do not forget about environment variables. To do this, open the <strong>Advanced settings</strong> menu and add the contents of the local <em>.env</em> file and confirm the settings. </p><br><p>  A couple of minutes of magic and a site on the spot: <br>  <a href="https://tender-liskov-ce3ad0.netlify.com/">https://tender-liskov-ce3ad0.netlify.com</a> </p><br><p>  It remains to add a hook to update the content.  Go to settings: </p><br><p>  <strong>Deploy settings → Build hooks → Add build hook</strong> <br><img src="https://habrastorage.org/webt/qp/ry/1o/qpry1oyehcw2wvh9v9yq--odrgg.gif" alt="netlify webhook"><br>  Set any clear name, for the example <em>"Contentful hook"</em> , select the branch with which we will build and confirm.  The result will be a link, copy and go to the <em>Contentful</em> panel: </p><br><p>  <strong>Settings → Webhooks</strong> <br><img src="https://habrastorage.org/webt/he/en/i8/heeni8del9_aw7o-wlgkypmb6b0.gif" alt="contentful webhook"><br>  We are looking for a template for <em>Netlify</em> on the right sidebar and in two clicks we connect two systems.  We try to change the content and see how new data appear on the site. </p><br><h2 id="itogo">  Total </h2><br><p>  JAM-stack combines the solution of the problems of previous approaches and seems to claim to seize power and worldwide popularity, but is it a revolution?  There is nothing new and special, but this is the most advanced methodology of the last two years, there, <a href="https://jamstack.org/community/">in a foreign land</a> , but what about us?  We have just started to translate projects from <em>WordPress</em> to <em>React,</em> and this is definitely progress, but can we not take steps as a legendary Indian outsourcing, should we take more decisive steps? </p><br><p>  <a href="https://github.com/alexandrtovmach/gatsby-contentful-example">Link to the repository with the project</a> </p></div>