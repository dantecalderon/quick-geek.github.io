<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>DMA: Myths and Reality</title>
  <meta name="description" content="Introduction 
 In the last article ( ‚ÄúPart 2: Using Cypress‚Äôs UDB PSoC controllers to reduce interruptions in a 3D printer‚Äù ), I noted one very intere...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>DMA: Myths and Reality</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/m4/12/q3/m412q3b8zbug620xzvv0the7ix0.jpeg"><br><br><h2>  Introduction </h2><br>  In the last article ( <a href="https://habr.com/ru/post/434742/">‚ÄúPart 2: Using Cypress‚Äôs UDB PSoC controllers to reduce interruptions in a 3D printer‚Äù</a> ), I noted one very interesting fact: if an automaton in UDB removed data from a FIFO too quickly, he managed to notice that There is no data in the FIFO, after which it went into a false <b>Idle</b> state.  Of course, I was interested in this fact.  I showed the revealed results to a group of friends.  One person answered that it was all quite obvious, and even gave the reasons.  The rest were no less surprised than I was at the beginning of the research.  So some experts will not find anything new here, but it would be nice to convey this information to the general public so that all programmers for microcontrollers have it in mind. <br><a name="habracut"></a><br>  Not that it was a breakdown of some covers.  It turned out that all this is well documented, but the trouble is that it is not in the main documents, but in additional documents.  And personally, I was in a happy ignorance, believing that DMA is a very smart subsystem that allows you to dramatically improve the efficiency of programs, since there goes a systematic transfer of data without distracting the register increments and cycle organization to the same commands.  As for efficiency, that's all right, but at the expense of a few other things. <br><br>  But first things first. <br><br><h2>  Cypress PSoC Experiments </h2><br>  Let's make the simplest automaton.  It will conditionally have two states: a state of rest and a state in which it will fall when there is at least one byte of data in the FIFO.  Upon entering such a state, he will simply remove this data, after which he will again fall into a state of rest.  The word "conditionally" I brought not by chance.  We have two FIFOs, so I will make two such states, one for each FIFO, to make sure that they are completely identical in behavior.  The transition graph of the machine turned out to be this: <br><br><img src="https://habrastorage.org/webt/pv/cu/1q/pvcu1qmbxk9zkbgxk8u51unthpe.png"><br><br>  Flags to exit from the Idle state are defined as: <br><br><img src="https://habrastorage.org/webt/h8/re/rp/h8rerphupbsfvawmjiwgwqr_thw.png"><br><br>  Do not forget on the inputs of Datapath to submit the status number bits: <br><br><img src="https://habrastorage.org/webt/ze/dz/ab/zedzab8iuaoxnu0esg32xwwga3g.png"><br><br>  Outward, we display two groups of signals: a couple of signals that there is free space in the FIFO (so that DMA can start uploading data to them), and a couple of signals that the FIFO is empty (to display this fact on an oscilloscope). <br><br><img src="https://habrastorage.org/webt/ts/bm/dn/tsbmdn-puyugsmixnsipf81pboa.png"><br><br>  The ALU will simply fictitiously collect data from the FIFO: <br><br><img src="https://habrastorage.org/webt/px/5s/_w/px5s_wj1zqwjedrk0h7ty7tbu_4.png"><br><br>  Let me show you the details for the state ‚Äú0001‚Äù: <br><br><img src="https://habrastorage.org/webt/mb/-s/j0/mb-sj05-chkdijmqn3mue8hmjnk.png"><br><br>  I also set the bus width, which was in the project on which I noticed this effect, 16 bits: <br><br><img src="https://habrastorage.org/webt/sa/hc/br/sahcbrgearj6wnw5-4lykaew1qy.png"><br><br>  We turn to the scheme of the project itself.  Outward, I give out not only signals that the FIFO is empty, but also clock pulses.  This will allow me to do without cursor measurements on the oscilloscope.  I can just count the finger strokes. <br><br><img src="https://habrastorage.org/webt/b-/8v/iq/b-8viqzbm1isamdkiljvmwevwme.png"><br><br>  As you can see, I made a clock frequency of 24 megahertz.  The processor core frequency is exactly the same.  The lower the frequency, the less noise on the Chinese oscilloscope (officially it has a band of 250 MHz, but the Chinese megahertz), and all measurements will be carried out relative to the clock pulses.  Whatever the frequency, the system will still work on them.  I would put one megahertz, but the development environment forbade me to enter the value of the frequency of the processor core less than 24 MHz. <br><br>  Now test things.  To write to FIFO0, I made this function: <br><br><pre><code class="plaintext hljs">void WriteTo0FromROM() { static const uint16 steps[] = { 0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001, 0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001 }; // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–ª–∏ DMA –ø—Ä—è–º–æ –∑–¥–µ—Å—å, —Ç–∞–∫ –∫–∞–∫ –º–∞—Å—Å–∏–≤ –∂–∏–≤—ë—Ç –∑–¥–µ—Å—å uint8 channel = DMA_0_DmaInitialize (sizeof(steps[0]),1,HI16(steps),HI16(JustReadFromFIFO_1_Datapath_1_F0_PTR)); CyDmaChRoundRobin (channel,1); // –¢–∞–∫ –∫–∞–∫ –º—ã –≤—Å—ë –¥–µ–ª–∞–µ–º –¥–ª—è –æ–ø—ã—Ç–æ–≤, –≤—ã–¥–µ–ª–∏–ª–∏ –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä –¥–ª—è –∑–∞–¥–∞—á–∏ —Ç–æ–∂–µ –∑–¥–µ—Å—å uint8 td = CyDmaTdAllocate(); // –ó–∞–¥–∞–ª–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä–∞ –∏ –¥–ª–∏–Ω—É –≤ –±–∞–π—Ç–∞—Ö. –¢–∞–∫–∂–µ —Å–∫–∞–∑–∞–ª–∏, —á—Ç–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä–∞ –Ω–µ—Ç. CyDmaTdSetConfiguration(td, sizeof(steps), CY_DMA_DISABLE_TD, TD_INC_SRC_ADR / TD_AUTO_EXEC_NEXT); // –¢–µ–ø–µ—Ä—å –∑–∞–¥–∞–ª–∏ –Ω–∞—á–∞–ª—å–Ω—ã–µ –∞–¥—Ä–µ—Å–∞ –¥–ª—è –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä–∞ CyDmaTdSetAddress(td, LO16((uint32)steps), LO16((uint32)JustReadFromFIFO_1_Datapath_1_F0_PTR)); // –ü–æ–¥–∫–ª—é—á–∏–ª–∏ —ç—Ç–æ—Ç –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä –∫ –∫–∞–Ω–∞–ª—É CyDmaChSetInitialTd(channel, td); // –ó–∞–ø—É—Å—Ç–∏–ª–∏ –ø—Ä–æ—Ü–µ—Å—Å —Å –≤–æ–∑–≤—Ä–∞—Ç–æ–º –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä–∞ –∫ –∏—Å—Ö–æ–¥–Ω–æ–º—É –≤–∏–¥—É CyDmaChEnable(channel, 1); }</code> </pre> <br>  The word ROM in the function name is connected with the fact that the sent array is stored in the ROM area, and the Cortex M3 has a Harvard architecture.  The speed of access to the RAM bus and the ROM bus can vary, I wanted to check this, so I have a similar function to send an array from RAM (the <b>steps</b> array in its body does not have the <b>static const</b> modifier).  Well, there is the same pair of functions for sending to FIFO1, there the receiver register is different: not F0, but F1.  Otherwise, all functions are identical.  Since I didn‚Äôt notice much difference in the results, I‚Äôll consider the results of calling the above function.  Yellow beam - clock pulses, blue - output <b>FIFO0empty</b> . <br><br><img src="https://habrastorage.org/webt/ko/65/0j/ko650jp1nj58h1nm5dzal4bzdhw.png"><br><br>  First, let's check the plausibility, why the FIFO is filled for two cycles.  Let's look at this site in more detail: <br><br><img src="https://habrastorage.org/webt/ox/fi/x_/oxfix_l8jpspyxgbiumrlagm9ma.png"><br><br>  On front 1, the data falls into the FIFO, the flag <b>FIFO0enmpty</b> drops.  On the front 2, the automaton enters the state <b>GetDataFromFifo1</b> .  On the front 3 in this state, the data from the FIFO is copied to the ALU register, the FIFO is empty, the <b>FIFO0empty</b> flag is <b>set</b> again.  That is, the oscillogram behaves plausibly, you can count on it the cycles per cycle.  We get 9 pieces. <br><br><img src="https://habrastorage.org/webt/fc/mq/bj/fcmqbjhfee7mf7u7_xnkgyspq18.png"><br><br>  <b>In total, in the surveyed area, it takes 9 clocks to copy one word of data from RAM to UDB using DMA.</b> <br><br>  And now the same thing, but by the processor core.  First - the ideal code, poorly achievable in real life: <br><br><pre> <code class="plaintext hljs"> volatile uint16_t* ptr = (uint16_t*)JustReadFromFIFO_1_Datapath_1_F0_PTR; ptr[0] = 0; ptr[0] = 0;</code> </pre><br>  that will turn into assembly code: <br><br><pre> <code class="plaintext hljs"> ldr r3, [pc, #8] ; (90 &lt;main+0xc&gt;) movs r2, #0 strh r2, [r3, #0] strh r2, [r3, #0] bn 8e &lt;main+0xa&gt; .word 0x40006898</code> </pre><br>  No breaks, no extra cycles.  Two pairs of bars in a row ... <br><br><img src="https://habrastorage.org/webt/ms/po/gq/mspogqifm21mt0o34s0ltbh1fyu.png"><br><br>  Let's make the code a little more real (with the overhead of organizing a cycle for retrieving data and incrementing pointers): <br><br><pre> <code class="plaintext hljs">void SoftWriteTo0FromROM() { // –í —ç—Ç–æ–º —Ç–µ—Å—Ç–µ –ø—Ä–æ—Å—Ç–æ —à–ª—ë–º –º–∞—Å—Å–∏–≤ –∏–∑ –¥–≤–∞–¥—Ü–∞—Ç–∏ —à–∞–≥–æ–≤. // –•–∏—Ç—Ä—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º —Å —É–ø–∞–∫–æ–≤–∫–æ–π –±—É–¥–µ–º –ø—Ä–æ–≤–µ—Ä—è—Ç—å —á—É—Ç—å –ø–æ–∑–∂–µ static const uint16 steps[] = { 0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001, 0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001 }; uint16_t* src = steps; volatile uint16_t* dest = (uint16_t*)JustReadFromFIFO_1_Datapath_1_F0_PTR; for (int i=sizeof(steps)/sizeof(steps[0]);i&gt;0;i--) { *dest = *src++; } }</code> </pre><br>  Received assembly code: <br><br><pre> <code class="plaintext hljs"> ldr r3, [pc, #14] ; (9c &lt;CYDEV_CACHE_SIZE&gt;) ldr r0, [pc, #14] ; (a0 &lt;CYDEV_CACHE_SIZE+0x4&gt;) add.w r1, r3, #28 ; 0x28 ldrh.w r2, [r3], #2 cmp r3, r1 strh r2, [r0, #0] bne.n 8e &lt;main+0xa&gt;</code> </pre><br>  On the oscillogram we see only 7 cycles per cycle against nine in the case of DMA: <br><br><img src="https://habrastorage.org/webt/h5/5k/y0/h55ky0f4pfsfaco90dvfgahwwki.png"><br><br><h2>  Little about the myth </h2><br>  To be honest, for me it was originally a shock.  I somehow used to assume that the DMA mechanism allows you to quickly and efficiently transfer data.  1/9 of the bus frequency is not that fast.  But it turned out that no one is hiding it.  The TRM document for PSoC 5LP even contains a number of theoretical calculations, and the document ‚ÄúAN84810 - PSoC 3 and PSoC 5LP Advanced DMA Topics‚Äù describes in detail the process of accessing DMA.  Blame the latency.  The cycle of exchange with the bus takes a certain number of cycles.  Actually, it is these bars that play a crucial role in the occurrence of a delay.  In general, no one hides anything, but you need to know. <br><br>  <b>If the famous GPIF, used in FX2LP (another architecture manufactured by Cypress), does not limit the speed, then the speed limit is due to latencies that occur when accessing the bus.</b> <br><br><h2>  Check DMA on STM32 </h2><br>  I was so impressed that I decided to conduct an experiment on STM32.  The STM32F103 was used as a guinea pig, having the same Cortex M3 processor core.  It does not have a UDB from which it would be possible to derive overhead signals, but it is quite possible to check DMA.  What is GPIO?  This is a set of registers in a shared address space.  That's fine.  We configure DMA in the ‚Äúmemory-memory‚Äù copying mode, specifying the actual memory (ROM or RAM) as the source, and the data register GPIO without the address increment as the receiver.  We will send there one by one, then 0, then 1, and the result will be recorded with an oscilloscope.  For a start, I chose port B, it was easier to connect to it on the breadboard. <br><br><img src="https://habrastorage.org/webt/od/u2/es/odu2esatrpusmpi8od4ecfaftk8.png"><br><br>  I really liked counting bars with a finger, not cursors.  Can I do the same on this controller?  Completely!  We take the reference clock frequency for the oscilloscope from the leg of the MCO, which in the STM32F10C8T6 is connected to the PA8 port.  The choice of sources for this cheap crystal is not great (the same STM32F103, but more impressive, gives much more options), let us send a SYSCLK signal to this output.  Since the frequency at the MCO cannot be higher than 50 MHz, we will reduce the total system clock frequency to 48 MHz.  We will multiply the frequency of 8 MHz quartz not by 9, but by 6 (since 6 * 8 = 48): <br><br><img src="https://habrastorage.org/webt/0x/de/1a/0xde1acpu3rpgslyseaw2kcysc4.png"><br><br><div class="spoiler">  <b class="spoiler_title">Same text:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void SystemClock_Config(void) { RCC_OscInitTypeDef RCC_OscInitStruct; RCC_ClkInitTypeDef RCC_ClkInitStruct; RCC_PeriphCLKInitTypeDef PeriphClkInit; /**Initializes the CPU, AHB and APB busses clocks */ RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; // RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6; if (HAL_RCC_OscConfig(&amp;RCC_OscInitStruct) != HAL_OK) { _Error_Handler(__FILE__, __LINE__); }</code> </pre><br></div></div><br>  The MCO will be programmed by the means of the <b>mcucpp</b> library of Konstantin Chizhov (I will continue to refer to the hardware through this wonderful library): <br><br><pre> <code class="plaintext hljs"> // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º MCO Mcucpp::Clock::McoBitField::Set (0x4); // –ü–æ–¥–∫–ª—é—á–∞–µ–º –Ω–æ–≥—É MCO –∫ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–æ–º—É –ø–æ—Ä—Ç—É Mcucpp::IO::Pa8::SetConfiguration (Mcucpp::IO::Pa8::Port::AltFunc); // –ü—Ä–æ–≥—Ä–∞–º–º–∏—Ä—É–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å –≤—ã—Ö–æ–¥–Ω–æ–≥–æ –∫–∞—Å–∫–∞–¥–∞ Mcucpp::IO::Pa8::SetSpeed (Mcucpp::IO::Pa8::Port::Fastest);</code> </pre><br>  Well, now we set the output of the data array to GPIOB: <br><br><pre> <code class="plaintext hljs">typedef Mcucpp::IO::Pb0 dmaTest0; typedef Mcucpp::IO::Pb1 dmaTest1; ... // –ó–∞–ø—É—Å–∫–∞–µ–º GPIOB –∏ –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –±–∏—Ç—ã –Ω–∞ –≤—ã—Ö–æ–¥ dmaTest0::ConfigPort::Enable(); dmaTest0::SetDirWrite(); dmaTest1::ConfigPort::Enable(); dmaTest1::SetDirWrite(); uint16_t dataForDma[]={0x0000,0x8001,0x0000,0x8001,0x0000, 0x8001,0x0000,0x8001,0x0000,0x8001,0x0000,0x8001,0x0000,0x8001}; typedef Mcucpp::Dma1Channel1 channel; // –ü–µ—Ä–µ–¥—ë—Ä–≥–∏–≤–∞–µ–º –≥–æ–ª—É–±–æ–π –ª—É—á dmaTest1::Set(); dmaTest1::Clear(); dmaTest1::Set(); // –í—Å—ë, –Ω–∞—Å—Ç—Ä–æ–∏–ª–∏ –∏ –∑–∞–ø—É—Å—Ç–∏–ª–∏ DMA channel::Init (channel::Mem2Mem|channel::MSize16Bits|channel::PSize16Bits|channel::PeriphIncriment,(void*)&amp;GPIOB-&gt;ODR,dataForDma,sizeof(dataForDma)/2); while (1) { } }</code> </pre><br>  The resulting waveform is very similar to the one that was on PSoC. <br><br><img src="https://habrastorage.org/webt/ee/nl/2i/eenl2ix0_9zgzgaaxxeffbjzwjk.png"><br><br>  In the middle of a big blue hump.  This is the DMA initialization process.  The blue pulses on the left are obtained purely by software on PB1.  Stretch them wider: <br><br><img src="https://habrastorage.org/webt/9l/y8/tp/9ly8tp_8hj1vohrh6jcnyktfa_a.png"><br><br>  2 bars per pulse.  System performance is as expected.  But now let's take a closer look at the area marked on the main oscillogram with a dark blue background.  At this point, the DMA block is already running. <br><br><img src="https://habrastorage.org/webt/jw/fu/ds/jwfudsdqtgwfunc3htoczgrw5eg.png"><br><br>  10 clocks per change GPIO line.  In fact, the work goes on with RAM, and the program loops in a constant loop.  There are no calls to RAM from the processor core.  The bus is completely at the disposal of the DMA block, but 10 clocks.  But in fact, the results are not very different from what they saw on PSoC, so we are just starting to look for Application Notes related to DMA on STM32.  They turned out to be several.  There is AN2548 on F0 / F1, there is AN3117 on L0 / L1 / L3, there is AN4031 on F2 / F4 / F77.  Perhaps there are some more ... <br><br>  But, nevertheless, from them we see that here the latency is to blame for everything.  And with the F103 batch calls to the DMA bus are impossible.  They are possible for F4, but no more than four words.  Next comes the latency problem. <br><br>  Let's try to perform the same actions, but with the help of program recording.  Above, we have seen that direct recording to ports is instant.  But there was more of a perfect record.  Lines: <br><br><pre> <code class="plaintext hljs">// –ü–µ—Ä–µ–¥—ë—Ä–≥–∏–≤–∞–µ–º –≥–æ–ª—É–±–æ–π –ª—É—á dmaTest1::Set(); dmaTest1::Clear(); dmaTest1::Set();</code> </pre><br>  subject to such optimization settings (be sure to specify the optimization for the time): <br><br><img src="https://habrastorage.org/webt/zz/cs/vt/zzcsvtte2m06u7tzhkfefvfa8wg.png"><br><br>  turned into the following assembly code: <br><br><pre> <code class="plaintext hljs"> STR r6,[r2,#0x00] MOV r0,#0x20000 STR r0,[r2,#0x00] STR r6,[r2,#0x00]</code> </pre><br>  In real copying there will be an appeal to the source, to the receiver, changing the loop variable, branching ... In general, the mass of overhead costs (from which, it is believed, just relieves DMA).  What will be the speed of change in the port?  So, we write: <br><br><pre> <code class="plaintext hljs">uint16_t* src = dataForDma; uint16_t* dest = (uint16_t*)&amp;GPIOB-&gt;ODR; for (int i=sizeof(dataForDma)/sizeof(dataForDma[0]);i&gt;0;i--) { *dest = *src++; }</code> </pre><br>  This C ++ code turns into such an assembler code: <br><br><pre> <code class="plaintext hljs"> MOVS r1,#0x0E LDRH r3,[r0],#0x02 STRH r3,[r2,#0x00] LDRH r3,[r0],#0x02 SUBS r1,r1,#2 STRH r3,[r2,#0x00] CMP r1,#0x00 BGT 0x080032A8</code> </pre><br>  And we get: <br><br><img src="https://habrastorage.org/webt/oj/m5/1d/ojm51d2qjhkz_rii2zfb4zvzdos.png"><br><br>  8 cycles in the upper half-cycle and 6 - in the lower (I checked, the result is repeated for all half-periods).  The difference arose because the optimizer made 2 copies for each iteration.  Therefore, 2 bars in one of the half periods are added to the branch operation. <br><br>  <b>Roughly speaking, during software copying, 14 cycles are spent on copying two words versus 20 cycles on the same thing, but by DMA.</b>  <b>The result is completely documented, but very unexpected for those who have not yet read the extended literature.</b> <br><br>  Good.  And what will happen if you start writing data in two DMA streams at once?  How much speed will fall?  Connect the blue ray to PA0 and rewrite the program as follows: <br><br><pre> <code class="plaintext hljs">typedef Mcucpp::Dma1Channel1 channel1; typedef Mcucpp::Dma1Channel2 channel2; // –í—Å—ë, –Ω–∞—Å—Ç—Ä–æ–∏–ª–∏ –∏ –∑–∞–ø—É—Å—Ç–∏–ª–∏ DMA channel1::Init (channel1::Mem2Mem|channel1::MSize16Bits|channel1::PSize16Bits|channel1::PeriphIncriment,(void*)&amp;GPIOB-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel2::Init (channel2::Mem2Mem|channel2::MSize16Bits|channel2::PSize16Bits|channel2::PeriphIncriment,(void*)&amp;GPIOA-&gt;ODR,dataForDma,sizeof(dataForDma)/2);</code> </pre><br>  First, examine the nature of the pulses: <br><br><img src="https://habrastorage.org/webt/vu/ki/pg/vukipghxkaqqtxdnvz4a2qjp1wu.png"><br><br>  While the second channel is setting up, the copy speed for the first is higher.  Then, when copying in pairs, speed drops.  When the first channel has finished work, the second starts to work faster.  Everything is logical, it remains only to find out how much speed drops. <br><br>  While the channel is one, the recording takes from 10 to 12 cycles (the numbers are floating). <br><br><img src="https://habrastorage.org/webt/iw/1l/lk/iw1llkwh0nki1yczmva7gzxgrgk.png"><br><br>  During collaboration, we get 16 cycles for one record in each port: <br><br><img src="https://habrastorage.org/webt/f6/vf/o3/f6vfo3mgv4mpos2kdrrwmo9dzsm.png"><br><br>  That is, the speed does not fall twice.  And what if you start writing in three streams at once?  We add work with PC15, since PC0 is not displayed (that is why it is not 0, 1, 0, 1 ... issued in the array, but 0x0000.0x8001, 0x0000, 0x8001 ...). <br><br><pre> <code class="plaintext hljs">typedef Mcucpp::Dma1Channel1 channel1; typedef Mcucpp::Dma1Channel2 channel2; typedef Mcucpp::Dma1Channel3 channel3; // –í—Å—ë, –Ω–∞—Å—Ç—Ä–æ–∏–ª–∏ –∏ –∑–∞–ø—É—Å—Ç–∏–ª–∏ DMA channel1::Init (channel1::Mem2Mem|channel1::MSize16Bits|channel1::PSize16Bits|channel1::PeriphIncriment,(void*)&amp;GPIOB-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel2::Init (channel2::Mem2Mem|channel2::MSize16Bits|channel2::PSize16Bits|channel2::PeriphIncriment,(void*)&amp;GPIOA-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel3::Init (channel3::Mem2Mem|channel3::MSize16Bits|channel3::PSize16Bits|channel3::PeriphIncriment,(void*)&amp;GPIOC-&gt;ODR,dataForDma,sizeof(dataForDma)/2);</code> </pre><br>  Here the result is so unexpected that I will turn off the beam that displays the clock frequency.  We are not up to measurement.  We look at the logic of work. <br><br><img src="https://habrastorage.org/webt/zo/u3/5s/zou35sqtetrlryln8lxe04tdkwy.png"><br><br>  Until the first channel finished, the third one did not start.  Three channels do not work at the same time!  Something on this topic can be derived from AppNote on DMA, it says that the F103 has only two Engine in one block (and we copy by means of one DMA block, the second one is now idle, and the volume of the article is such that I let it go I will not).  Let's rewrite the sample program so that the third channel starts up before everyone else: <br><br><img src="https://habrastorage.org/webt/bs/ld/kc/bsldkce9ztqrbk15x7e1omcharg.png"><br><br><div class="spoiler">  <b class="spoiler_title">Same text:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">// –í—Å—ë, –Ω–∞—Å—Ç—Ä–æ–∏–ª–∏ –∏ –∑–∞–ø—É—Å—Ç–∏–ª–∏ DMA channel3::Init (channel3::Mem2Mem|channel3::MSize16Bits|channel3::PSize16Bits|channel3::PeriphIncriment,(void*)&amp;GPIOC-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel1::Init (channel1::Mem2Mem|channel1::MSize16Bits|channel1::PSize16Bits|channel1::PeriphIncriment,(void*)&amp;GPIOB-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel2::Init (channel2::Mem2Mem|channel2::MSize16Bits|channel2::PSize16Bits|channel2::PeriphIncriment,(void*)&amp;GPIOA-&gt;ODR,dataForDma,sizeof(dataForDma)/2);</code> </pre><br></div></div><br>  The picture will change as follows: <br><br><img src="https://habrastorage.org/webt/jg/wr/_2/jgwr_2kidbaoxg_-17muiyvo3n4.png"><br><br>  The third channel was launched, it even worked together with the first, but as it entered the second one, the third one was pushed out until the first channel finished its work. <br><br><h2>  A little bit about priorities </h2><br>  Actually, the previous picture is related to the priorities of the DMA, there are some.  If all working channels have the same priority, their numbers come into play.  Within the limits of one given priority, who has a smaller number, that is more important.  Let's try to indicate to the third channel a different global priority, raising it above all others (at the same time we will raise the priority to the second channel): <br><br><img src="https://habrastorage.org/webt/40/qo/c5/40qoc5ngwnq2tenzpmcc2ornd4w.png"><br><br><div class="spoiler">  <b class="spoiler_title">Same text:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">channel3::Init (channel3::PriorityVeryHigh|channel3::Mem2Mem|channel3::MSize16Bits|channel3::PSize16Bits|channel3::PeriphIncriment,(void*)&amp;GPIOC-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel1::Init (channel1::Mem2Mem|channel1::MSize16Bits|channel1::PSize16Bits|channel1::PeriphIncriment,(void*)&amp;GPIOB-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel2::Init (channel1::PriorityVeryHigh|channel2::Mem2Mem|channel2::MSize16Bits|channel2::PSize16Bits|channel2::PeriphIncriment,(void*)&amp;GPIOA-&gt;ODR,dataForDma,sizeof(dataForDma)/2);</code> </pre><br></div></div><br>  Now the first will be infringed upon, which was the coolest before. <br><br><img src="https://habrastorage.org/webt/te/mq/_7/temq_7wguw109a0t-oi_rsi3jju.png"><br><br>  In total, we see that even playing in priorities, more than two streams on one DMA block in STM32F103 will not work.  In principle, the third thread can be run on the processor core.  This will allow us to compare performance. <br><br><pre> <code class="plaintext hljs">// –í—Å—ë, –Ω–∞—Å—Ç—Ä–æ–∏–ª–∏ –∏ –∑–∞–ø—É—Å—Ç–∏–ª–∏ DMA channel3::Init (channel3::Mem2Mem|channel3::MSize16Bits|channel3::PSize16Bits|channel3::PeriphIncriment,(void*)&amp;GPIOC-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel2::Init (channel2::Mem2Mem|channel2::MSize16Bits|channel2::PSize16Bits|channel2::PeriphIncriment,(void*)&amp;GPIOA-&gt;ODR,dataForDma,sizeof(dataForDma)/2); uint16_t* src = dataForDma; uint16_t* dest = (uint16_t*)&amp;GPIOB-&gt;ODR; for (int i=sizeof(dataForDma)/sizeof(dataForDma[0]);i&gt;0;i--) { *dest = *src++; }</code> </pre><br>  First, the general picture, which shows that everything works in parallel and the copy speed of the processor core is the highest: <br><br><img src="https://habrastorage.org/webt/yq/bc/ah/yqbcahagnawdxrr70dh7zvbetmo.png"><br><br>  And now I will give everyone the opportunity to count the bars at a time when all the copy streams are active: <br><br> <a href=""><img src="https://habrastorage.org/webt/_m/m9/2b/_mm92b5yfgjltz6cizilmdtg4d4.png"></a> <br><br><h2>  The processor core is the top priority </h2><br>  Now back to the fact that in a two-stream operation, while the second channel was tuned, the first one gave out data for a different number of cycles.  This fact is also well documented in AppNote on DMA.  The fact is that during the setup of the second channel, there were periodic requests to the RAM, and the processor core has a higher priority when accessing the RAM than the DMA core.  When the processor requested some data, DMA took the clock cycles, it received data with a delay, so it copied more slowly.  Let's do the last experiment for today.  Let's work more real.  After starting DMA, we will not go into an empty cycle (when there are definitely no calls to RAM), but perform the copy operation from RAM to RAM, but this operation will not relate to the operation of DMA cores: <br><br><pre> <code class="plaintext hljs">channel1::Init (channel1::Mem2Mem|channel1::MSize16Bits|channel1::PSize16Bits|channel1::PeriphIncriment,(void*)&amp;GPIOB-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel2::Init (channel2::Mem2Mem|channel2::MSize16Bits|channel2::PSize16Bits|channel2::PeriphIncriment,(void*)&amp;GPIOA-&gt;ODR,dataForDma,sizeof(dataForDma)/2); uint32_t src1[0x200]; uint32_t dest1 [0x200]; while (1) { uint32_t* src = src1; uint32_t* dest = dest1; for (int i=sizeof(src1)/sizeof(src1[0]);i&gt;0;i--) { *dest++ = *src++; } }</code> </pre><br> <a href=""><img src="https://habrastorage.org/webt/ks/k-/c6/ksk-c6feobygy2krzseq0nlka78.png"></a> <br><br>  In some places the cycle stretched from 16 to 17 cycles.  I was afraid it would be worse. <br><br><h2>  We begin to draw conclusions </h2><br>  Actually, we proceed to what I wanted to say. <br><br>  I'll start from afar.  A few years ago, starting to learn STM32, I studied the MiddleWare versions for USB that existed at that time and wondered why the developers removed the data transfer through DMA.  It was evident that initially such an option was visible, then it was removed to the back, and in the end only the rudiments of it remained.  Now I begin to suspect that I understand the developers. <br><br>  In the <a href="https://habr.com/ru/post/429882/">first article about UDB,</a> I said that even though UDB can work with parallel data, it is unlikely to be able to replace GPIF with itself, since PSoC has a USB bus running at Full Speed ‚Äã‚Äãspeed versus High Speed ‚Äã‚Äãfor FX2LP.  It turns out that there is a more serious limiting factor.  DMA simply does not have time to deliver data at the same speed as it delivers its GPIF even within the controller, without taking into account the USB bus. <br><br>  As you can see, there is no single entity DMA.  First, each manufacturer makes it its own way.  Moreover, even one manufacturer for different families can vary the approach to the construction of DMA.  If you plan a serious load on this unit, you should carefully consider whether the needs will be met. <br><br>  Probably, it is necessary to dilute the pessimistic flow with one optimistic remark.  I will even highlight it. <br><br>  <b>DMA at the Cortex M controllers can improve system performance on the principle of the famous Javelin: "Launched and forgotten."</b>  <b>Yes, software data copying is a little faster.</b>  <b>But if you need to copy several threads, no optimizer will be able to make the processor drive all of them without the overhead of reloading registers and twisting loops.</b>  <b>In addition, for slower ports, the processor must still wait for readiness, while DMA does it at the hardware level.</b> <br><br>  But even here various nuances are possible.  If the port is only conditionally slow ... Well, let's say, SPI, working at the highest possible frequency, then theoretically there are situations when DMA does not have time to take data from the buffer, and an overflow will occur.  Or vice versa - put the data in the buffer register.  When there is only one stream of data, this is unlikely to happen, but when there are a lot of them, we have seen what amazing overlays can occur.  To combat this, it is necessary to develop tasks not separately, but as a whole.  And testers try to provoke similar problems (such as testers have destructive work). <br><br>  I repeat once again that nobody hides this data.  But for some reason, all this is usually contained not in the main document, but in Application Notes.  So my task was precisely to draw the attention of programmers to the fact that DMA is not a panacea, but just a handy tool. <br><br>  But, of course, not only programmers, but also hardware developers.  For example, in our organization a large hardware and software complex is being developed for remote debugging of embedded systems.  The idea is that someone is developing a device, and wants to order the firmware on the side.  And for some reason can not provide equipment to the side.  It can be cumbersome, it can be expensive, it can be unique and ‚Äúneed it yourself‚Äù, different groups can work with it in different time zones, providing such multi-shift work, it can be constantly brought to mind ... In general, you can think of reasons a lot, our group just lowered this task as a given. <br><br>  Accordingly, the complex for debugging should be able to imitate as many external devices as possible, from the banal imitation of pressing buttons to various SPI, I2C, CAN, 4-20 mA protocols and other things, other things, so that emulators can recreate various external behavior through them. units connected to the equipment under development (I personally made many simulators for ground debugging of attachments for helicopters, we search <a href="https://www.astrosoft.ru/about/clients/cassel-aero/">for the corresponding cases on the site according to the word Cassel Aero</a> ). <br><br>  And so, in the TOR for the development of certain requirements are lowered.  So much SPI, so much I2C, so much GPIO.  They must operate at such a certain frequency limit.  It seems that everything is clear.  We put STM32F4 and ULPI to work with USB in HS mode.  Technology waste.  But here come the long weekend with the November holidays, on which I figured out with the UDB.  Seeing something was amiss, in the evenings I got those practical results that are given at the beginning of this article.  And I realized that everything, of course, is great, but not for this project.  As I have already noted, when the possible peak performance of the system approaches the upper boundary, everything should be designed not separately, but in combination. <br><br>  And here the complex design tasks can not be in principle.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Today we are working with one third-party equipment, tomorrow - with a completely different one. Tires will be used by programmers for each emulation at their discretion. Therefore, the variant was rejected, a number of different FTDI bridges were added to the scheme. Within the bridge one or two or four functions will be destroyed according to a rigid scheme, and between the bridges everything will be settled by the USB host.</font></font> Alas.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this task, I cannot trust DMA. </font><font style="vertical-align: inherit;">You can, of course, say that programmers will then get out, but the clock on the process of frills is the work to be avoided. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But this is extreme. </font><font style="vertical-align: inherit;">Most often, you should just keep the limitations of the DMA subsystem in your mind (for example, to introduce a correction factor of 10: if a flow of 1 million transactions per second is required, consider that it is not 1 million, but 10 million cycles) and consider the performance in the complex.</font></font></div><p>Source: <a href="https://habr.com/ru/post/437112/">https://habr.com/ru/post/437112/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>