<div class="post__text post__text-html js-mediator-article"><p>  I think it is not a secret to anyone that “Fool” (hereinafter this word will be written in small letters and without quotes) is the most popular card game in Russia and the countries of the former USSR (although almost unknown outside of it).  Despite its name and rather simple rules, the gain in it still depends more on the player’s skill than on the random layout of the cards (in English terminology, games of both types are called <a href="https://en.wikipedia.org/wiki/Game_of_skill">game of skill</a> and <a href="https://en.wikipedia.org/wiki/Game_of_chance">game of chance,</a> respectively. So, the fool in more <em>game of skill</em> ). </p><br><p>  The purpose of the article is to write a simple AI for the game.  The word "simple" means the following: </p><br><ul><li>  an intuitive decision-making algorithm (that is, as a result, no machine learning in which this algorithm is hidden deep "under the hood"); </li><li>  lack of state (that is, the algorithm is guided only by the data at the current time, in other words, it does not remember anything (for example, it does not "count" the cards that have left the game). </li></ul><a name="habracut"></a><br><p>  (Strictly speaking, the first paragraph no longer gives such an AI the right to be called <strong>artificial intelligence</strong> <em>per se</em> , but only a pseudo-AI. But such terminology in game development is well-established, so we will not change it.) </p><br><p>  I think the rules of the game are known to everyone, so I’ll not remind them again.  For those who want to check, I advise you to contact <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D1%2583%25D1%2580%25D0%25B0%25D0%25BA_(%25D0%25BA%25D0%25B0%25D1%2580%25D1%2582%25D0%25BE%25D1%2587%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B8%25D0%25B3%25D1%2580%25D0%25B0)">Wikipedia</a> , there is a pretty good article on this topic. </p><br><p>  So, let's begin.  Obviously, the more foolish a card is, the more profitable it is to have it in your hand.  Therefore, we will build an algorithm on the classical assessment of the strength of the hand and making a decision (for example, about throwing one or another card) on the basis of this assessment.  We assign cards values, for example: </p><br><ul><li>  <strong>ace</strong> (A) - +600 points, </li><li>  <strong>King</strong> (K) - +500, </li><li>  <strong>lady</strong> (Q) - +400, </li><li>  <strong>Jack</strong> (J) - +300, </li><li>  <strong>ten</strong> (10) - 200, </li><li>  <strong>nine</strong> (9) - +100, </li><li>  <strong>eight</strong> (8) - 0, </li><li>  <strong>seven</strong> (7) - -100, </li><li>  <strong>six</strong> (6) - -200, </li><li>  <strong>the five</strong> (5) - -300, </li><li>  <strong>four</strong> (4) - -400, </li><li>  <strong>three</strong> (3) - -500, </li><li>  and finally, <strong>two</strong> (2) - -600 points. </li></ul><br><p>  (We use numbers that are multiples of 100 in order to get rid of floating-point in calculations and operate only with whole numbers. For what we need negative estimates, see later in the article.) </p><br><p>  The trump cards are more valuable than any simple ones (even a trump deuce beats an "ordinary" ace), and the hierarchy in the trump suit is the same, so for their evaluation we simply add 1300 to the "base" value - then, for example, the trump deuce will cost 600 + 1300 = 700 points (that is, just a little more than an uncensored ace). </p><br><p> In the code (all code examples in the article will be on Kotlin), it looks like this (the <code>relativaCardValue()</code> function returns that same estimate, and <code>RANK_MULTIPLIER</code> is just a factor of 100): </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> hand) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r = c.rank <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> s = c.suit res += ((relativeCardValue(r.value)) * RANK_MULTIPLIER).toInt() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s === trumpSuit) res += <span class="hljs-number"><span class="hljs-number">13</span></span> * RANK_MULTIPLIER <span class="hljs-comment"><span class="hljs-comment">// еще не все, продолжение чуть ниже }</span></span></code> </pre> <br><p>  Alas, that's not all.  It is also important to consider the following evaluation rules: </p><br><ul><li>  it is advantageous to have many cards of the same value - not only because they can “overwhelm” an opponent, but also easily repel the attack (especially if the cards are of high value).  For example, at the end of the game, the hand (for simplicity, we suppose that here and below trumps are diamonds) <p><math> </math> $$ display $$ \ clubsuit 2 \ spadesuit 2 \ diamondsuit Q \ heartsuit Q \ clubsuit Q \ spadesuit Q $$ display $$   almost perfect (of course, if the opponent does not go under your kings or aces): you will be beaten off by the ladies, after which <del>  hang rival shoulder straps </del>  hand him a pair of twos. </p><br>  but many cards of the same (of course, non-transparent) suit, on the contrary, are not profitable - they will “interfere” with each other.  For example, arm <p><math> </math> $$ display $$ \ spadesuit 5 \ spadesuit J \ spadesuit A \ diamondsuit 6 \ diamondsuit 9 \ diamondsuit K $$ display $$   very unsuccessful - even if the opponent does not “knock out” your trump card with the first move and goes with the card of the peak suit, then all other cards thrown up will be of other suits, and you will have to give trumps to them.  In addition, it is very likely that the top five will remain unclaimed - all the trump cards you have are worth more than five, so under no circumstances (unless, of course, you initially went to the card under) you will not be able to cover it with any other card - the probability of taking a very is high.  On the other hand, we replace the jack with a ten of clubs, and the trump six with a triple: </p><p><math> </math> $$ display $$ \ spadesuit 5 \ clubsuit 10 \ spadesuit A \ diamondsuit 3 \ diamondsuit 9 \ diamondsuit K $$ display $$   Despite the fact that we replaced the cards with younger ones, such a hand is much better - firstly, you will not have to give away a trump card to the trekuit (and you can be more likely to use the ace). And secondly, if you beat then the card is your trump card, there is a possibility that someone will throw a peak at you (for there’s usually no point in holding such a card), and you will have to buy five. </p><br><p></p><br><p>  To implement these strategies, we modify our algorithm: Here we count the number of cards of each suit and value ... </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">/* бонусные коэффициенты в зависимости от количества карт одного достоинства - например, если нет ни оной карты какого-то достоинства или она только одна, бонусы не начисляются, а за все 4 карты коэффициент равен 1.25 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bonuses = doubleArrayOf(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0.75</span></span>, <span class="hljs-number"><span class="hljs-number">1.25</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> countsByRank = IntArray(<span class="hljs-number"><span class="hljs-number">13</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> countsBySuit = IntArray(<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> hand) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r = c.rank <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> s = c.suit res += ((relativeCardValue(r.value)) * RANK_MULTIPLIER).toInt() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s === trumpSuit) res += <span class="hljs-number"><span class="hljs-number">13</span></span> * RANK_MULTIPLIER countsByRank[r.value - <span class="hljs-number"><span class="hljs-number">1</span></span>]++ countsBySuit[s.value]++ }</code> </pre> <br><p>  ... here we add bonuses for them (calling <code>Math.max</code> needed in order not to charge negative bonuses for junior cards - because in this case it is also profitable) ... </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">13</span></span>) { res += (Math.max(relativeCardValue(i), <span class="hljs-number"><span class="hljs-number">1.0</span></span>) * bonuses[countsByRank[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]]).toInt() }</code> </pre> <br><p>  ... and here, on the contrary, we are fined for an unbalanced hand (the value of <code>UNBALANCED_HAND_PENALTY</code> empirically set to 200): </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// считаем среднее количество карт некозырных мастей... var avgSuit = 0.0 for (c in hand) { if (c.suit !== trumpSuit) avgSuit++ } avgSuit /= 3.0 for (s in Suit.values()) { if (s !== trumpSuit) { // и вычитаем штрафы в зависимости от отклонения от этого среднего по каждой масти val dev = Math.abs((countsBySuit[s.value] - avgSuit) / avgSuit) res -= (UNBALANCED_HAND_PENALTY * dev).toInt() } }</span></span></code> </pre> <br><p>  Finally, let us take into account such a banal thing as the number of cards in your hand.  In fact, it’s very good to have 12 good cards at the beginning of the game (especially since they can still throw no more than 6), but at the end of the game, when there’s only a 2-card opponent left behind you, it’s not like that. </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// считаем количество оставшихся в игре карт (в колоде и на руках у игроков) var cardsInPlay = cardsRemaining for (p in playerHands) cardsInPlay += p cardsInPlay -= hand.size // вычисляем, какая доля из них у игрока, и определяем величину штрафа (здесь MANY_CARDS_PENALTY = 600) val cardRatio = if (cardsInPlay != 0) (hand.size / cardsInPlay).toDouble() else 10.0 res += ((0.25 - cardRatio) * MANY_CARDS_PENALTY).toInt() return res</span></span></code> </pre> <br><p>  We summarize - in full, the evaluation function looks like this: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hand: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ArrayList</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Card</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, trumpSuit: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Suit</span></span></span></span><span class="hljs-function"><span class="hljs-params">, cardsRemaining: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, playerHands: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cardsRemaining == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; hand.size == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> OUT_OF_PLAY } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bonuses = doubleArrayOf(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0.75</span></span>, <span class="hljs-number"><span class="hljs-number">1.25</span></span>) <span class="hljs-comment"><span class="hljs-comment">// for cards of same rank var res = 0 val countsByRank = IntArray(13) val countsBySuit = IntArray(4) for (c in hand) { val r = c.rank val s = c.suit res += ((relativeCardValue(r.value)) * RANK_MULTIPLIER).toInt() if (s === trumpSuit) res += 13 * RANK_MULTIPLIER countsByRank[r.value - 1]++ countsBySuit[s.value]++ } for (i in 1..13) { res += (Math.max(relativeCardValue(i), 1.0) * bonuses[countsByRank[i - 1]]).toInt() } var avgSuit = 0.0 for (c in hand) { if (c.suit !== trumpSuit) avgSuit++ } avgSuit /= 3.0 for (s in Suit.values()) { if (s !== trumpSuit) { val dev = Math.abs((countsBySuit[s.value] - avgSuit) / avgSuit) res -= (UNBALANCED_HAND_PENALTY * dev).toInt() } } var cardsInPlay = cardsRemaining for (p in playerHands) cardsInPlay += p cardsInPlay -= hand.size val cardRatio = if (cardsInPlay != 0) (hand.size / cardsInPlay).toDouble() else 10.0 res += ((0.25 - cardRatio) * MANY_CARDS_PENALTY).toInt() return res }</span></span></code> </pre> <br><p>  So, we have the evaluation function ready.  In the next part, it is planned to describe a more interesting problem - making decisions based on such an assessment. </p><br><p>  Thank you all for your attention! </p><br><p>  PS This code is part of the application developed by the author in his free time.  It is available <a href="https://github.com/hyst329/OpenFool">on GitHub</a> (binary releases for Desktop and Android, the latest application is also available <a href="https://f-droid.org/en/packages/ru.hyst329.openfool/">on F-Droid</a> ). </p></li></ul></div>