<div class="post__text post__text-html js-mediator-article"><pre><code class="postgresql hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MATERIALIZED</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> very_very_big_table ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> w1 <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> w2 <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> w1.key = w2.<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> w2.key = <span class="hljs-number"><span class="hljs-number">123</span></span>;</code> </pre> <br><p>  Today, a commit has been dropped into the PostgreSQL repository, which allows you to control the processing behavior of the CTE subqueries, namely: you can now explicitly specify whether the subquery will materialize separately or run as part of a single large query. </p><br><p>  This will go into PostgreSQL 12, and this is a big deal.  Let's look at why </p><a name="habracut"></a><br><p>  Programmers love CTEs because it can significantly improve the readability of the code.  Well, indeed, some analytical queries can work with dozens of tables and various groupings and filters.  Write all this in one big request - guaranteed to get something unreadable.  Therefore, with the help of the <code>WITH</code> operator, we sequentially, in small subqueries (which specify a human-readable name), describe the operation logic, and then output the result.  Very comfortably. </p><br><p>  More precisely, <b>it would be</b> very convenient if it were not for one thing: the current PostgreSQL executes these subqueries separately from each other, materializes them (writes the result into a temporary table).  This can lead to a significant slowdown compared to one large unreadable monster.  Especially if CTE subqueries return millions of rows. </p><br><p>  However, there are situations when such a separate implementation works for the good: there is such an optimization trick, when it is better to perform a part of a complex query separately, but the postgres do not understand this themselves.  Then we bring this part to the CTE subquery. </p><br><p>  In general, situations are different, which is why a commit was made in Postgres 12, adding the keywords <code>MATERIALIZED</code> and <code>NOT MATERIALIZED</code> , which indicate whether the query should materialize or inline, respectively. </p><br><p>  Moreover, the default behavior has changed.  Now the CTE subquery will default to inline if its result is used once.  Otherwise, it will materialize as before. </p></div>