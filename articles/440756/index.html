<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Serverless CI / CD on AWS</title>
  <meta name="description" content="It would be cool if the deployment in the copy-peist format is in the past, but, alas, things are different. It happens that developers prefer this me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Serverless CI / CD on AWS</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/pr/ok/p2/prokp20fn2bwrkeqzq4ojxzx9gi.jpeg"><br><br>  It would be cool if the deployment in the copy-peist format is in the past, but, alas, things are different.  It happens that developers prefer this method of delivery.  Although now write an article about why this is not good, but you know everything without me.  With the tendency to serverless architecture, the CI / CD pipelines play an important role in the delivery of applications.  I also wrote about them in the article " <a href="https://medium.com/%40gavinlewis/3-top-tips-for-your-next-serverless-project-2ea87bc833e7">3 best tips for your next serverless project</a> ." </p><br><p>  I have been interested in the topic of CI and CD quite a while, and for the first time I ran into it a few years ago - thanks to TeamCity.  Currently TeamCity is still used for most of our CI / CD pipelines.  TeamCity works fine, I have nothing against it, but I always strive to improve my work.  For example, it would be good to collect pipelines in the form of code - this is one of the areas in which TeamCity is not so good. </p><br><p>  I studied the AWS integration and delivery tools some time ago, and although we use CodeDeploy for another project that works on EC2, I have not yet deployed a serverless project with them.  After reviewing the tools again, I noticed that: now there is a built-in integration function for deploying CloudFormation and Lambda, presumably based on SAM AWS;  we use a <a href="https://medium.com/%40gavinlewis/3-top-tips-for-your-next-serverless-project-2ea87bc833e7">serverless platform</a> - it generates CloudFormation templates, but it does not work out of the box with AWS tools. </p><a name="habracut"></a><br><h3 id="podgotovka">  Training </h3><br><p>  I use the following AWS services: EC2, Docker, ECR, S3, IAM, CodeBuild, CodePipeline, CloudWatch, CloudTrail.  To keep up, you need at least a basic level to understand what each of these services is doing. </p><br><p>  Basically, I write the server-side code in .NET, and this guide relies on this platform.  None of the ready-made CodeBuild images have both .NET and NodeJS runtimes simultaneously (NodeJS is needed for serverless platforms).  If your Lambda functions are written in NodeJS, setting up the deployment pipeline is much simpler, because this is the only runtime environment required for installation in the Docker image (if it's your case, skip most of the tutorial).  For a second, it was my first experience with containers, and I am glad to learn something new. </p><br><p>  I dare to assume that your code is in a certain repository, for example, git.  For guidance, we simply upload to S3 a file containing a package of code for deployment;  How you get it is up to you.  Having taken my work on the basis, you can always go further by connecting your pipeline to such repositories as github or CodeCommit. </p><br><h3 id="1-sozdayte-ekzemplyar-ec2-i-ustanovite-docker">  1. Create an EC2 instance and install Docker </h3><br><p>  Run a standard AWS Linux 2 EC2 instance ‚Äî this should be clear without explanation.  Log in and install Docker using the commands: </p><br><pre><code class="plaintext hljs">sudo yum update -y sudo amazon-linux-extras install docker sudo service docker start</code> </pre> <br><p>  You also need to add the user ec2 to the docker group in order to execute Docker commands without using sudo: </p><br><pre> <code class="plaintext hljs">sudo usermod -a -G docker ec2-user</code> </pre> <br><p>  When the command is completed, log out and log back into your EC2 instance so that the user ec2 gets new permissions.  Make sure the ec2 user runs Docker commands without sudo: </p><br><pre> <code class="plaintext hljs">docker info</code> </pre> <br><p> <a href=""><img src="https://habrastorage.org/webt/i-/aq/r_/i-aqr_g3enpgmdd4clpawaaykmu.png"></a> <br>  <em><code>docker info</code> output</em> </p><br><h3 id="2-sozdayte-obraz-docker-i-pomestite-v-ecr">  2. Create a Docker image and place it in ECR </h3><br><p>  Suppose the previous step was successful;  The next step is to create a Docker image that fits in the ECR.  AWS offers basic images for <a href="https://github.com/aws/aws-codebuild-docker-images">CodeBuild on github</a> , and this makes it easy to create your own image. </p><br><p>  I also posted the image on github - in case you don‚Äôt want to do the following to create your own: <a href="https://github.com/effectivedigital/serverless-deployment-image">https://github.com/effectivedigital/serverless-deployment-image</a> </p><br><p>  Copy the images and go to the .NET Core 2.1 directory: </p><br><pre> <code class="plaintext hljs">git clone https://github.com/aws/aws-codebuild-docker-images.git cd aws-codebuild-docker-images cd ubuntu/dot-net/core-2.1/</code> </pre> <br><p>  Open the Dockerfile in your preferred text editor: </p><br><pre> <code class="plaintext hljs">nano Dockerfile</code> </pre> <br><p>  Add commands to install NodeJS and serverless platforms at the end of other commands already available in the Dockerfile.  Most of these commands I received from the Docker NodeJS image in the same AWS repository: </p><br><pre> <code class="plaintext hljs"># Install Node Dependencies ENV NODE_VERSION="10.14.1" # gpg keys listed at https://github.com/nodejs/node#release-team RUN set -ex \ &amp;&amp; for key in \ 94AE36675C464D64BAFA68DD7434390BDBE9B9C5 \ B9AE9905FFD7803F25714661B63B535A4C206CA9 \ 77984A986EBC2AA786BC0F66B01FBB92821C587A \ 56730D5401028683275BD23C23EFEFE93C4CFFFE \ 71DCFD284A79C3B38668286BC97EC7A07EDE3FC1 \ FD3A5288F042B6850C66B31F09FE44734EB7990E \ 8FCCA13FEF1D0C2E91008E09770F7A9A5AE15600 \ C4F0DFFF4E8C1A8236409D08E73BC641CC11F4C8 \ DD8F2338BAE7501E3DD5AC78C273792F7D83545D \ 4ED778F539E3634C779C87C6D7062848A1AB005C \ A48C2BEE680E841632CD4E44F07496B3EB3C1762 \ ; do \ gpg - keyserver hkp://p80.pool.sks-keyservers.net:80 - recv-keys "$key" || \ gpg - keyserver hkp://ipv4.pool.sks-keyservers.net - recv-keys "$key" || \ gpg - keyserver hkp://pgp.mit.edu:80 - recv-keys "$key" ; \ done RUN set -ex \ &amp;&amp; wget "https://nodejs.org/download/release/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.gz" -O node-v$NODE_VER$ &amp;&amp; wget "https://nodejs.org/download/release/v$NODE_VERSION/SHASUMS256.txt.asc" -O SHASUMS256.txt.asc \ &amp;&amp; gpg - batch - decrypt - output SHASUMS256.txt SHASUMS256.txt.asc \ &amp;&amp; grep " node-v$NODE_VERSION-linux-x64.tar.gz\$" SHASUMS256.txt | sha256sum -c - \ &amp;&amp; tar -xzf "node-v$NODE_VERSION-linux-x64.tar.gz" -C /usr/local - strip-components=1 \ &amp;&amp; rm "node-v$NODE_VERSION-linux-x64.tar.gz" SHASUMS256.txt.asc SHASUMS256.txt \ &amp;&amp; ln -s /usr/local/bin/node /usr/local/bin/nodejs \ &amp;&amp; rm -fr /var/lib/apt/lists/* /tmp/* /var/tmp/* RUN npm set unsafe-perm true CMD [ "node" ] # Install Serverless Framework RUN set -ex \ &amp;&amp; npm install -g serverless</code> </pre> <br><p>  Now we collect and tag the image: </p><br><pre> <code class="plaintext hljs">docker build -t aws/codebuild/dot-net .</code> </pre> <br><p>  After completing the build, run the image - make sure that everything works and that the serverless platform is installed correctly: </p><br><pre> <code class="plaintext hljs">docker run -it --entrypoint sh aws/codebuild/dot-net -c bash sls -v</code> </pre> <br><p> <a href=""><img src="https://habrastorage.org/webt/ji/vh/da/jivhda2vzvu3vwc4uyltgyz0mza.png"></a> <br>  <em>Running <code>sls -v</code> inside a new container</em> </p><br><p>  Then create a repository in ECR using the AWS CLI.  After running the command, the new repository will be displayed in the AWS console: </p><br><pre> <code class="plaintext hljs">aws ecr create-repository --repository-name codebuild-dotnet-node</code> </pre> <br><p> <a href=""><img src="https://habrastorage.org/webt/qc/bq/-g/qcbq-gsw-afhdbp2q9meo1nsqrk.png"></a> <br>  <em>AWS CLI response to creating a repository in ECR</em> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/2q/sf/_v/2qsf_v-jbgorara_qbzwi2lavoc.png"></a> </p><br><p>  Now mark the <em>aws / codebuild / dot-net</em> image created earlier with the value of repositoryUri from the previous step: </p><br><pre> <code class="plaintext hljs">docker tag aws/codebuild/dot-net &lt;ACCOUNTID&gt;.dkr.ecr.ap-southeast-2.amazonaws.com/codebuild-dotnet-node</code> </pre> <br><p>  Run the get-login command to get the docker login authentication command line for the container registry: </p><br><pre> <code class="plaintext hljs">aws ecr get-login --no-include-email</code> </pre> <br><p> <a href=""><img src="https://habrastorage.org/webt/6l/w9/2d/6lw92dgbv2c7fvicbjvoz-afxwo.png"></a> </p><br><p>  Run the docker login command issued by the get-login command during the last step. </p><br><pre> <code class="plaintext hljs">docker login -u AWS -p eyJwYXlsb2FkIjoiNGZnd0dSaXM1L2svWWRLMmhJT1c0WWpOZEcxamJFeFJOK2VvT0Y5[...] https://&lt;ACCOUNTID&gt;.dkr.ecr.ap-southeast-2.amazonaws.com</code> </pre> <br><p>  If you are logged in successfully, place the docker image in the repository created in ECR.  This may take several minutes (depending on the size of the completed image). </p><br><pre> <code class="plaintext hljs">docker push &lt;ACCOUNTID&gt;.dkr.ecr.ap-southeast-2.amazonaws.com/codebuild-dotnet-node</code> </pre> <br><p> <a href=""><img src="https://habrastorage.org/webt/qc/bq/-g/qcbq-gsw-afhdbp2q9meo1nsqrk.png"></a> <br>  <em>Docker on EC2 creates our image</em> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/k-/me/2l/k-me2lgrhindh4_2p9tl24e0qau.png"></a> <br>  <em>Docker image in ECR</em> </p><br><p>  Then we can open access to the image from ECR to anyone.  The permission needs to be blocked in the working environment, but in this example we will open it.  Go to the permissions tab in the AWS console, select "Edit JSON Policy" and paste the following element into the policy: </p><br><pre> <code class="plaintext hljs">{ "Version": "2008-10-17", "Statement": [ { "Sid": "EnableAccountAccess", "Effect": "Allow", "Principal": "*", "Action": [ "ecr:BatchCheckLayerAvailability", "ecr:BatchGetImage", "ecr:DescribeImages", "ecr:DescribeRepositories", "ecr:GetAuthorizationToken", "ecr:GetDownloadUrlForLayer", "ecr:GetRepositoryPolicy", "ecr:ListImages" ] } ] }</code> </pre> <br><h3 id="3-sozdayte-payplayn">  3. Create Pipeline </h3><br><p>  It is time to assemble the pipeline.  In order to simplify the process, make it repeatedly deployable, and stick to the server-form architecture of the server, I assembled the pipeline using a serverless platform.  The same result can be achieved by assembling in CloudFormation. </p><br><p>  I will not copy the entire source from my serverless.yml file ‚Äî copy it from github: <a href="https://github.com/effectivedigital/serverless-deployment-pipeline">https://github.com/effectivedigital/serverless-deployment-pipeline</a> </p><br><p>  Review the serverless template to see exactly what it will do, but, in brief, it sets up the following elements: </p><br><ul><li>  3 S3 segments </li><li>  1 segment policy </li><li>  3 IAM roles </li><li>  1 CodeBuild project </li><li>  1 CodePipeline Pipeline </li><li>  1 CloudWatch Event </li><li>  1 track CloudTrail </li></ul><br><p>  Then update <em>DockerImageArn</em> for your image in ECR.  If you want to create deployment packages with a name other than <em>Deployment.zip</em> , then also update <em>DeploymentFilename</em> : </p><br><pre> <code class="plaintext hljs">DockerImageArn: &lt;ACCOUNTID&gt;.dkr.ecr.ap-southeast-2.amazonaws.com/codebuild-dotnet-node:latest DeploymentFilename: Deployment.zip</code> </pre> <br><p>  That's it, the pipeline is ready for deployment.  Run the serverless deployment command and wait until it is configured: </p><br><pre> <code class="plaintext hljs">sls deploy -v</code> </pre> <br><p> <a href=""><img src="https://habrastorage.org/webt/hi/wk/ys/hiwkysbgka2zessqrdqkb4nir1g.png"></a> <br>  <em>Created by serverless platform CloudFormation stack</em> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/hc/r6/yr/hcr6yrezormgpobpu2bdu-_tvj4.png"></a> <br>  <em>Created by serverless codepipeline platform</em> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/ef/ax/ad/efaxaddb_yspsbdxrl1azf5e1oo.png"></a> <br>  <em>Created by serverless platform project CodeBuild Project</em> </p><br><h3 id="4-dobavte-buildspecyml-v-svoe-prilozhenie">  4. Add buildSpec.yml to your application. </h3><br><p>  When CodePipeline detects a change in the deployment file in S3, it will tell CodeBuild to start and try to build and deploy the application.  However, CodeBuild should also know which commands should be executed to build and deploy the application, and buildSpec.yml contains instructions that CodeBuild will follow. </p><br><p>  I created a very simple "Hello world" application that includes an example buildSpec.yml file that you can use: <a href="https://github.com/effectivedigital/serverless-deployment-app">https://github.com/effectivedigital/serverless-deployment-app</a> <br>  Or create a file buildSpec.yml in existing applications and fill it out according to the instructions below: </p><br><pre> <code class="plaintext hljs">version: 0.2 phases: pre_build: commands: - chmod a+x * build: commands: - ./build.sh post_build: commands: - sls deploy -v -s $STAGE</code> </pre> <br><h3 id="5-proverka-payplayna">  5. Check Pipeline </h3><br><p>  Now everything is ready for the first launch of your pipeline.  Create a package called <em>Deployment.zip</em> , it should include all the files for your serverless application and the buildSpec.yml file. </p><br><p>  After a few moments, CloudTrail should register the PutObject event and activate the CloudWatch event rule, which then activates CodePipeline launch. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/zg/r4/ii/zgr4iikop3ujbabsgtsfbyjex4o.png"></a> <br>  <em>Deployment.zip booted in S3</em> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/ak/xd/iz/akxdizdzjomaespfhmnygedoqia.png"></a> <br>  <em>CodePipeline is running, the build has gone.</em> </p><br><p>  If we go to the details of the AWS CodeBuild step, we can see the build and deployment process: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/gv/sx/cb/gvsxcbcpmbcnj18k9rwbqbm_bhu.png"></a> <br>  <em>CodeBuild will get output from the build and deploy Docker image</em> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/l3/ec/xm/l3ecxm5cjedmhtpxne0nklzdzlm.png"></a> <br>  <em>Deployment was successful!</em> </p><br><p>  A new application deployed by our pipeline is also displayed in CloudFormation: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/r6/2s/xl/r62sxlivtmrg8vn3yze2xe0ez3y.png"></a> </p><br><p>  You can test the API endpoint created in our simple application (the URL is in the CodeBuild exit or in the API gateway) and make sure that the application works successfully: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/h4/s3/gh/h4s3ghrxxwlpxaf3ssdwhfx30sy.png"></a> <br>  <em>Postman to call API</em> </p><br><h3 id="kratkie-vyvody">  Brief conclusions </h3><br><p>  CodePipeline allows you to create a scalable, flexible and inexpensive CI / CD pipeline and helps to solve some of the problems associated with traditional pipelines created on servers. <br>  I would like to go ahead and add unit testing to the mix after deployment, but the topic deserves a separate article - and this is a reason to read us in the future! </p></div><p>Source: <a href="https://habr.com/ru/post/440756/">https://habr.com/ru/post/440756/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>