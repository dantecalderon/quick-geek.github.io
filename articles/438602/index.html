<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parse the protocol pager pocsag messages, p1</title>
  <meta name="description" content="Hi, Habr! 

 Once upon a time, when a mobile phone cost $ 2000 and a minute of a call cost 50 cents, there was such a popular thing as a paging connec...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Parse the protocol pager pocsag messages, p1</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr! <br><br>  Once upon a time, when a mobile phone cost $ 2000 and a minute of a call cost 50 cents, there was such a popular thing as a paging connection.  Then the communication became cheaper, and the pager first turned from a prestigious attribute of a business person into a non-prestigious courier or secretary attribute, and then this technology almost completely disappeared. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/js/zd/ld/jszdldd4jxhnimxk84qy9rnvfnk.png"></div><br>  For those who remember the joke "read the pager, thought a lot," and wants to figure out how it works, continued under the cut.  For those who want to understand even more detail, the <a href="https://habr.com/ru/post/438638/">second part</a> is available. <br><a name="habracut"></a><br><h2>  general information </h2><br>  For those who forgot or was born after the 2000s, briefly recall the basic ideas. <br><br>  From the user's point of view, paging has two big advantages, which are still relevant in some cases: <br><br>  - Communication is one-way, without any confirmations, so the paging network cannot be overloaded, its performance does not depend on the number of subscribers.  Messages are simply sequentially broadcast as is, and the pager receives them if the recipient's number matches the pager number. <br><br>  - The receiving device is very simple, so the pager can operate without recharging for up to a month from 2x ordinary AA batteries. <br><br>  There are two main standards for messaging - <a href="https://ru.wikipedia.org/wiki/POCSAG">POCSAG</a> (Post Office Code Standardization Advisory Group) and <a href="https://en.wikipedia.org/wiki/FLEX_(protocol)">FLEX</a> .  Standards are not new, POCSAG was approved in 1982, supported speeds of 512, 1200 and 2400 bps.  Frequency shift keying (FSK - frequency shift keying) with a frequency separation of 4.5 KHz is used for transmission.  A newer FLEX standard (proposed by Motorola in the 90s) supports speeds up to 6400 bps and can use not only FSK2, but also FSK4. <br><br>  The protocols are inherently simple enough, and 20 years ago decoders were written for them, capable of decrypting the signal from the sound card input (no message encryption is provided, so anyone can read them with such a program). <br><br>  Let's see how it works. <br><br><h2>  Reception of signals </h2><br>  For a start, we need a sample for decoding.  We take a laptop, rtl-sdr receiver, time machine, and receive the signal we need. <br><br><img src="https://habrastorage.org/webt/vj/ba/2g/vjba2gslgleejthwn_m8ccsvf00.jpeg"><br><br>  Since  frequency modulation, receive mode also set FM.  Using HDSDR, we record the signal in WAV format. <br><br>  Let's see what we did.  Load the wav file as an array using Python: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy.io <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> wavfile <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt fs, data = wavfile.read(<span class="hljs-string"><span class="hljs-string">"pocsag.wav"</span></span>) plt.plot(data) plt.show()</code> </pre> <br>  Result (bits are manually signed): <br><br><img src="https://habrastorage.org/webt/pm/ss/y7/pmssy79glsbnfsgxogjd93ylqre.jpeg"><br><br>  As you can see, everything is simple, and even "by eye" in Paint you can draw bits, where "0" and where "1".  But doing this for the entire file would be too long, the process should be automated. <br><br>  If we increase the graph, then we can see that the width of each ‚Äúbit‚Äù is 20 samples, which, at a sampling frequency of 24,000 samples / s wav-file, corresponds to 1200 bit / s.  We find in the signal the place of transition through zero - this will be the beginning of the bit sequence.  Display the markers to verify that the bits match. <br><br><pre> <code class="python hljs">speed = <span class="hljs-number"><span class="hljs-number">1200</span></span> fs = <span class="hljs-number"><span class="hljs-number">24000</span></span> cnt = int(fs/speed) start = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">2</span></span>*cnt): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[p] &lt; - <span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> data[p+<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">50</span></span>: start = p <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-comment"><span class="hljs-comment"># Bits frame bits = np.zeros(data.size) for p in range(0, data.size - cnt, cnt): bits[start + p] = 500 plt.plot(bits)</span></span></code> </pre><br>  As you can see, the coincidence is not perfect (the transmitter and receiver frequencies are still slightly different), but it is quite enough for decoding. <br><br><img src="https://habrastorage.org/webt/hc/s1/lf/hcs1lfxgchl-ngpkyeemhhsgrly.jpeg"><br><br>  For long signals, one would have to introduce a frequency adjustment algorithm, but in this case it is not required. <br><br>  And the last step is to translate the array from wav into a bit sequence.  Everything is also simple, we already know the length of one bit, if the data for this period is positive, then we add ‚Äú1‚Äù, otherwise ‚Äú0‚Äù (edit - as it turned out, the signal had to be reversed, so 0 and 1 are reversed). <br><br><pre> <code class="python hljs">bits_str = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, data.size - cnt, cnt): s = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(p, p+cnt): s += data[p] bits_str += <span class="hljs-string"><span class="hljs-string">"1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-string"><span class="hljs-string">"0"</span></span> print(<span class="hljs-string"><span class="hljs-string">"Bits"</span></span>) print(bits_str)</code> </pre><br>  Perhaps the code can be optimized by abandoning the loop, although in this case it is not critical. <br><br>  The result is a finished bit sequence (as a string) that saves our message. <br><br>  <i>1010101010101010101010101010101010101010101010101010101010101010101010101</i> <i><br></i>  <i>010101010101010101010101010101010101010101010100111110011010010000101001101</i> <i><br></i>  <i>100001111010100010011100000110010111011110101000100111000001100101110111101</i> <i><br></i>  <i>010001001110000011001011101111010100010011100000110010111011110101000100111</i> <i><br></i>  <i>000001100101110111101010001001110000011001011101111010100010011100000110010</i> <i><br></i>  <i>011011110101000100111000001100101110111101010001001110000011001011101111010</i> <i><br></i>  <i>100010011100000110010111011110101000100111000001100101110111101010001001110</i> <i><br></i>  <i>...</i> <i><br></i>  <i>111101111</i> <br><br><h2>  Decoding </h2><br>  The sequence of bits is already much more convenient than just a wav file, it is already possible to extract any data from it.  We divide the file into blocks of 4 bytes, and we get a more understandable sequence: <br><br>  <i>10101010101010101010101010101010</i> <i><br></i>  <i>10101010101010101010101010101010</i> <i><br></i>  <i>10101010101010101010101010101010</i> <i><br></i>  <i>10101010101010101010101010101010</i> <i><br></i>  <i><b>01111100110100100001010011011000</b></i> <i><br></i>  <i>01111010100010011100000110010111</i> <i><br></i>  <i>01111010100010011100000110010111</i> <i><br></i>  <i>01111010100010011100000110010111</i> <i><br></i>  <i>01111010100010011100000110010111</i> <i><br></i>  <i>00001000011011110100010001101000</i> <i><br></i>  <i>10000011010000010101010011010100</i> <i><br></i>  <i><b>01111100110100100001010111011000</b></i> <i><br></i>  <i>11110101010001000001000000111000</i> <i><br></i>  <i>01111010100010011100000110010111</i> <i><br></i>  <i>01111010100010011100000110010111</i> <i><br></i>  <i>01111010100010011100000110010111</i> <i><br></i>  <i>00100101101001011010010100101111</i> <br><br>  This is all that we can extract from the file, it remains to understand what these lines mean.  Open the documentation for the format, which is available <a href="https://www.raveon.com/pdfiles/AN142(POCSAG).pdf">as a PDF</a> . <br><br><img src="https://habrastorage.org/webt/3k/yt/dc/3kytdccgmehfmqstxxli1nt3fpa.png"><br><br>  Everything is more or less clear.  The message header consists of a long block ‚Äú10101010101‚Äù which is needed for the pager to go out of ‚Äúsleep mode‚Äù.  The message itself consists of Batch-1 ... Batch-N blocks, each of which begins with a unique FSC sequence (bold in the text).  Further, as can be seen from the manual, if the line starts with "0", then this is the recipient's address.  The address is sewn in the pager itself, and if it doesn‚Äôt match, the pager will simply ignore the message.  If the line starts with "1", then this is actually the message.  We have two such lines. <br><br>  Now look at each block.  We see codes Idle - empty blocks 01111 ... 0111, not carrying useful information.  We delete them, information remains very little, all that remains is: <br><br>  <i>01111100110100100001010011011000 - Frame Sync</i> <i><br></i>  <i>00001000011011110100010001101000 - Address</i> <i><br></i>  <i>10000011010000010101010011010100 - Message</i> <i><br><br></i>  <i>01111100110100100001010111011000 - Frame Sync</i> <i><br></i>  <i>11110101010001000001000000111000 - Message</i> <i><br></i>  <i>00100101101001011010010100101111 - Address</i> <br><br>  It remains to understand what's inside. <br><br>  We search further in the manual, and find out that messages can be digital or text.  Digital messages are stored as 4-bit BCD codes, so 5 characters can fit in 5 characters (there are still bits to control, we will not consider them).  The message can also be text, in this case the 7-bit encoding is used, but for text our message is too small - the total number of message bits is not a multiple of 7. <br><br>  From the lines 10000011010000010101010011010100 and 11110101010001000001000000111000 we get the following 4-bit sequences: <br>  <i>1 0000 0110 1000 0010 10101 0011010100</i> - 0h 6h 8h 2h Ah <br>  <i>1 1110 1010 1000 1000 00100 0000111000</i> - Eh Ah 8h 8h 2h <br><br>  And finally, the last step - look in the documentation of the symbol matching table. <br><br><img src="https://habrastorage.org/webt/vb/sj/zl/vbsjzluxbhaeuy_zrefccmqhogw.jpeg"><br><br>  As you can see, a digital message can only contain the digits 0-9, the letter U ("ugrent"), a space and a pair of brackets.  We write a simple output function, so as not to count them manually: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># 16 lines in a batch, each block has a length 32 bits for cw in range(16): cws = block[32 * cw:32 * (cw + 1)] if cws[0] == "0": addr = cws[1:19] print(" Addr:" + addr) else: msg = cws[1:21] print(" Msg: " + msg) size = 4 s = "" for ind in range(0, len(msg), size): bcd_s = msg[ind:ind + size] value = int(bcd_s, 2) symbols = "0123456789*U -)(" s += symbols[value] print(" ", s) print()</span></span></code> </pre><br>  As a result, we receive the transmitted message "0682 *) * 882".  What it means is hard to say, but since the format supports digital messages, it probably means someone needs it. <br><br><h2>  findings </h2><br>  As you can see, the POCSAG format is very simple, and in fact, can be decoded even in a school notebook.  And although now it is more of historical interest, the analysis of such protocols is very useful from a cognitive point of view. <br><br>  The <a href="https://habr.com/ru/post/438638/">next part is</a> about decoding ASCII messages. </div><p>Source: <a href="https://habr.com/ru/post/438602/">https://habr.com/ru/post/438602/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>