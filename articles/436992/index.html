<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Samples and errors when choosing HTTP Reverse Proxy</title>
  <meta name="description" content="Hello! 

 Today we want to talk about how the hotel booking service Ostrovok.ru team solved the problem of the growth of microservice, whose task is t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Samples and errors when choosing HTTP Reverse Proxy</h1><div class="post__text post__text-html js-mediator-article">  Hello! <br><br>  Today we want to talk about how the hotel booking service <a href="https://ostrovok.ru/%3Futm_source%3Dhabr%26utm_medium%3Dpr%26utm_campaign%3Dbozhok_jan19">Ostrovok.ru</a> team solved the problem of the growth of microservice, whose task is to exchange information with our suppliers.  Undying DevOps Team Lead in Ostrovok.ru tells about his experience. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mb/qx/eh/mbqxehqjq4oabybefapvvbpqadg.png"></div><a name="habracut"></a><br>  At first, microservice was small and served the following functions: <br><br><ul><li>  accept a request from a local service; </li><li>  make a request to a partner; </li><li>  normalize the response; </li><li>  return the result to the questioning service. </li></ul><br>  However, as time went on, the service grew with the number of partners and requests for them. <br><br>  As the service grew, various kinds of problems began to emerge.  Different suppliers put forward their own rules of work: someone restricts the maximum number of connections, someone restricts customers to white lists. <br><cut></cut><br>  As a result, we had to solve the following tasks: <br><br><ul><li>  It is desirable to have several fixed external IP addresses so that you can provide them to partners for adding them to the white lists, </li><li>  have a single pool of connections to all suppliers so that when scaling our microservice the number of connections remains minimal, </li><li>  Terminate SSL and keep <code>keepalive</code> in one place, thereby reducing the workload for the partners themselves. </li></ul><br>  They did not think long and immediately wondered what to choose: Nginx or Haproxy. <br>  At first, the pendulum swung toward Nginx, since I solved most of the problems associated with HTTP / HTTPS with its help and was always pleased with the result. <br><br>  The scheme was simple: a request was made to our new Proxy Server on Nginx with a domain like <code>&lt;partner_tag&gt;.domain.local</code> , in Nginx there was a <code>map</code> , where <code>&lt;partner_tag&gt;</code> partner‚Äôs address.  From the <code>map</code> address was taken and <code>proxy_pass</code> was made to this address. <br><br>  Here is an example of a <code>map</code> that we parse the domain with and select the upstream from the list: <br><br><pre> <code class="nginx hljs"><span class="hljs-comment"><span class="hljs-comment">### –±–µ—Ä–µ–º –ø—Ä–µ—Ñ–∏–∫—Å –∏–∑ –∏–º–µ–Ω–∏ –¥–æ–º–µ–Ω–∞: &lt;tag&gt;.domain.local map $http_host $upstream_prefix { default 0; "~^([^\.]+)\." $1; } ### –≤—ã–±–∏—Ä–∞–µ–º –Ω—É–∂–Ω—ã–π –∞–¥—Ä–µ—Å –ø–æ –ø—Ä–µ—Ñ–∏–∫—Å—É map $upstream_prefix $upstream_address { include snippet.d/upstreams_map; default http://127.0.0.1:8080; } ### –≤—ã—Å—Ç–∞–≤–ª—è–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é upstream_host –∏—Å—Ö–æ–¥—è –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π upstream_address map $upstream_address $upstream_host { default 0; "~^https?://([^:]+)" $1; }</span></span></code> </pre><br>  And this is what <code>snippet.d/upstreams_map</code> looks like: <br><pre> <code class="nginx hljs">‚Äúone‚Äù ‚Äúhttp://one.domain.net‚Äù; ‚Äútwo‚Äù ‚Äúhttps://two.domain.org‚Äù;</code> </pre><br>  Here we have the <code>server{}</code> : <br><br><pre> <code class="nginx hljs"><span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> <span class="hljs-number"><span class="hljs-number">80</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> / { <span class="hljs-attribute"><span class="hljs-attribute">proxy_http_version</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> <span class="hljs-variable"><span class="hljs-variable">$upstream_address</span></span><span class="hljs-variable"><span class="hljs-variable">$request_uri</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-variable"><span class="hljs-variable">$upstream_host</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Forwarded-For <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Forwarded-Port <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Forwarded-Proto <span class="hljs-string"><span class="hljs-string">""</span></span>; } } <span class="hljs-comment"><span class="hljs-comment"># service for error handling and logging server { listen 127.0.0.1:8080; location / { return 400; } location /ngx_status/ { stub_status; } }</span></span></code> </pre><br>  Everything is cool, everything works.  You can end this article, if not for one nuance. <br><br>  When using proxy_pass straight to the right address, the request goes, as a rule, via HTTP / 1.0 without <code>keepalive</code> and closes immediately after the response is completed.  Even if we <code>proxy_http_version 1.1</code> , nothing will change without upstream ( <a href="&amp;xid=17259,15700021,15700043,15700186,15700191,15700248,15700253&amp;usg=ALkJrhhdY9D2lIcEpYl_UU09ffYUNVlqqw#proxy_">proxy_http_version</a> ). <br><br>  What to do?  The first thought is to get all the suppliers in upstream, where the server will be the supplier‚Äôs address we need, and in the <code>map</code> to keep the <code>"tag" "upstream_name"</code> . <br><br>  Add another <code>map</code> for parsing the schema: <br><br><pre> <code class="nginx hljs"><span class="hljs-comment"><span class="hljs-comment">### –±–µ—Ä–µ–º –ø—Ä–µ—Ñ–∏–∫—Å –∏–∑ –∏–º–µ–Ω–∏ –¥–æ–º–µ–Ω–∞: &lt;tag&gt;.domain.local map $http_host $upstream_prefix { default 0; "~^([^\.]+)\." $1; } ### –≤—ã–±–∏—Ä–∞–µ–º –Ω—É–∂–Ω—ã–π –∞–¥—Ä–µ—Å –ø–æ –ø—Ä–µ—Ñ–∏–∫—Å—É map $upstream_prefix $upstream_address { include snippet.d/upstreams_map; default http://127.0.0.1:8080; } ### –≤—ã—Å—Ç–∞–≤–ª—è–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é upstream_host –∏—Å—Ö–æ–¥—è –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π upstream_address map $upstream_address $upstream_host { default 0; "~^https?://([^:]+)" $1; } ### –¥–æ–±–∞–≤–ª—è–µ–º –ø–∞—Ä—Å–∏–Ω–≥ —Å—Ö–µ–º—ã, —á—Ç–æ–±—ã –∫ –∫–æ–º—É –Ω–∞–¥–æ —Ö–æ–¥–∏—Ç—å –ø–æ https, –∞ –∫ –∫–æ–º—É –Ω–∞–¥–æ, –Ω–æ –Ω–µ –æ—á–µ–Ω—å - –ø–æ http map $upstream_address $upstream_scheme { default "http://"; "~(https?://)" $1; }</span></span></code> </pre><br>  And create <code>upstreams</code> with tag names: <br><pre> <code class="nginx hljs"> <span class="hljs-attribute"><span class="hljs-attribute">upstream</span></span> one { <span class="hljs-attribute"><span class="hljs-attribute">keepalive</span></span> <span class="hljs-number"><span class="hljs-number">64</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">server</span></span> one.domain.com; } <span class="hljs-attribute"><span class="hljs-attribute">upstream</span></span> two { <span class="hljs-attribute"><span class="hljs-attribute">keepalive</span></span> <span class="hljs-number"><span class="hljs-number">64</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">server</span></span> two.domain.net; }</code> </pre><br>  The server itself is slightly modified to take into account the scheme and use the name of the upstream instead of the address: <br><br><pre> <code class="nginx hljs"><span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> <span class="hljs-number"><span class="hljs-number">80</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> / { <span class="hljs-attribute"><span class="hljs-attribute">proxy_http_version</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> <span class="hljs-variable"><span class="hljs-variable">$upstream_scheme</span></span><span class="hljs-variable"><span class="hljs-variable">$upstream_prefix</span></span><span class="hljs-variable"><span class="hljs-variable">$request_uri</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-variable"><span class="hljs-variable">$upstream_host</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Forwarded-For <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Forwarded-Port <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Forwarded-Proto <span class="hljs-string"><span class="hljs-string">""</span></span>; } } <span class="hljs-comment"><span class="hljs-comment"># service for error handling and logging server { listen 127.0.0.1:8080; location / { return 400; } location /ngx_status/ { stub_status; } }</span></span></code> </pre><br>  Fine.  The solution works, we add to every upstream <code>keepalive</code> directive, we set <code>proxy_http_version 1.1</code> , - now we have a pool of connections, and everything works as it should. <br><br>  At this time, you can just finish the article and go to drink tea.  Or not? <br><br>  After all, while we are drinking tea, someone from the suppliers may change the IP address or a group of addresses (hi, Amazon) under the same domain, thus one of the suppliers may fall off in the midst of our tea party. <br><br>  Well, what to do?  Nginx has an interesting nuance: during reload it can otrezolvit servers inside <code>upstream</code> to new addresses and let traffic to them.  In general, also a solution.  Throw in <code>cron reload nginx</code> every 5 minutes and continue to drink tea. <br><br>  But still it seemed to me a so-so decision, so I began looking askance at Haproxy. <br><br>  Haproxy has the ability to specify <code>dns resolvers</code> and configure <code>dns cache</code> .  Thus, Haproxy will update the <code>dns cache</code> if the entries in it have expired, and replace the addresses for upstream in the event that they have changed. <br><br>  Fine!  Now it remains the case for the settings. <br><br>  Here is a quick configuration example for Haproxy: <br><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">frontend</span></span> http bind *:<span class="hljs-number"><span class="hljs-number">80</span></span> http-request del-header X-Forwarded-For http-request del-header X-Forwarded-Port http-request del-header X-Forwarded-Proto capture request header Host len <span class="hljs-number"><span class="hljs-number">32</span></span> capture request header Referer len <span class="hljs-number"><span class="hljs-number">128</span></span> capture request header User-Agent len <span class="hljs-number"><span class="hljs-number">128</span></span> acl host_present hdr(host) -m len gt <span class="hljs-number"><span class="hljs-number">0</span></span> use_backend %[req.hdr(host),lower,field(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">'.'</span></span>)] if host_present default_backend default resolvers dns hold valid <span class="hljs-number"><span class="hljs-number">1s</span></span> timeout retry <span class="hljs-number"><span class="hljs-number">100ms</span></span> nameserver dns1 <span class="hljs-number"><span class="hljs-number">1.1.1.1:53</span></span> backend one http-request set-header Host one.domain.com server one--one.domain.com one.domain.com:<span class="hljs-number"><span class="hljs-number">80</span></span> resolvers dns check backend two http-request set-header Host two.domain.net server two--two.domain.net two.domain.net:<span class="hljs-number"><span class="hljs-number">443</span></span> resolvers dns check ssl verify <span class="hljs-literal"><span class="hljs-literal">none</span></span> check-sni two.domain.net sni str(two.domain.net)</code> </pre><br>  It seems that this time everything works as it should.  That's just what I do not like Haproxy, so it is the complexity of the description of configurations.  You need to set up quite a lot of text to add one working upstream.  But laziness is the engine of progress: if you don‚Äôt want to write the same thing, write a generator. <br><br>  I already had a map from Nginx with the format <code>"tag" "upstream"</code> , so I decided to take it as a basis, parse and generate a haproxy backend based on these values. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#! /usr/bin/env bash haproxy_backend_map_file=./root/etc/haproxy/snippet.d/name_domain_map haproxy_backends_file=./root/etc/haproxy/99_backends.cfg nginx_map_file=./nginx_map while getopts 'n:b:m:' OPT;do case ${OPT} in n) nginx_map_file=${OPTARG} ;; b) haproxy_backends_file=${OPTARG} ;; m) haproxy_backend_map_file=${OPTARG} ;; *) echo 'Usage: ${0} -n [nginx_map_file] -b [haproxy_backends_file] -m [haproxy_backend_map_file]' exit esac done function write_backend(){ local tag=$1 local domain=$2 local port=$3 local server_options="resolvers dns check" [ -n "${4}" ] &amp;&amp; local ssl_options="ssl verify none check-sni ${domain} sni str(${domain})" [ -n "${4}" ] &amp;&amp; server_options+=" ${ssl_options}" cat &gt;&gt; ${haproxy_backends_file} &lt;&lt;EOF backend ${tag} http-request set-header Host ${domain} server ${tag}--${domain} ${domain}:${port} ${server_options} EOF } :&gt; ${haproxy_backends_file} :&gt; ${haproxy_backend_map_file} while read tag addr;do tag=${tag//\"/} [ -z "${tag:0}" ] &amp;&amp; continue [ "${tag:0:1}" == "#" ] &amp;&amp; continue IFS=":" read scheme domain port &lt;&lt;&lt;${addr//;} unset IFS domain=${domain//\/} case ${scheme} in http) port=${port:-80} write_backend ${tag} ${domain} ${port} ;; https) port=${port:-443} write_backend ${tag} ${domain} ${port} 1 esac done &lt; &lt;(sort -V ${nginx_map_file})</span></span></code> </pre><br>  Now all we need is to add a new host to nginx_map, start the generator and get a ready haproxy config. <br><br>  For today, perhaps, everything.  This article is rather an introductory one and was devoted to the problem of choosing a solution and its integration into the current environment. <br><br>  In the next article I will tell you more about what pitfalls we encountered when using Haproxy, what metrics it turned out to be useful to monitor and what exactly should be optimized in the system in order to get the maximum performance from the servers. <br><br>  Thank you all for your attention, see you soon! </div><p>Source: <a href="https://habr.com/ru/post/436992/">https://habr.com/ru/post/436992/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>