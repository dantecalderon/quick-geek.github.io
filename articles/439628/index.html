<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parallel data update in ASP.NET Web API</title>
  <meta name="description" content="I want to tell you how we organized the background data update during the request to the REST service. 

 The task is as follows: the system stores us...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Parallel data update in ASP.NET Web API</h1><div class="post__text post__text-html js-mediator-article">  I want to tell you how we organized the background data update during the request to the REST service. <br><br>  The task is as follows: the system stores user data.  The service works in isolation and does not have direct access to the databases with this data.  To work, the service must have in its internal database the names and surnames of users.  They can be obtained from the current user's Identity at the time of the request.  It is required to add or update names during each request.  It is advisable to do this in a separate thread so that this work does not affect the execution time of the main query. <br><a name="habracut"></a><br><h2>  Task clarification </h2><br>  In the database of the service we store the names and surnames of users.  Clients need them for information about who created or modified the resource. <br><br>  This data is not systemically significant: if suddenly the necessary records are missing in the database, nothing terrible will happen.  Therefore, we do not want to register our background work in ASP using QueueBackgroundWorkItem to make it difficult to overload the application domain. <br>  It is advisable to solve the problem as easy as possible. <br><br>  For those who want to learn more about background tasks in ASP.NET, I advise you to read a <a href="https://haacked.com/archive/2011/10/16/the-dangers-of-implementing-recurring-background-tasks-in-asp-net.aspx/">good article</a> about it. <br><br><h2>  Decision </h2><br>  We have a DbRefresher class that adds or changes user data in the RefreshAsync method. <br><br>  Our controllers use the attribute Authorize.  Add our successor to this class and override the OnAuthorization method: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnAuthorization</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpActionContext actionContext</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnAuthorization(actionContext); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsAuthorized(actionContext)) DbRefresher.RefreshAsync(actionContext.RequestContext.Principal) .ContinueWith(t =&gt; { LogFactory.For&lt;AuthorizeAndRefreshUserAttribute&gt;() .ErrorException(<span class="hljs-string"><span class="hljs-string">"Error occured"</span></span>, t.Exception); }, TaskContinuationOptions.OnlyOnFaulted); }</code> </pre> <br>  DbRefresher.RefreshAsync is an asynchronous method that returns a Task object that will continue its execution in another thread.  Exit the OnAuthorize method immediately without waiting for the task to complete.  In the event of a crash, an error message will be added to the log. <br><br>  That's all: it remains only to replace the Authorize attribute in controllers with the name of our new attribute.  The new attribute returns control immediately after checking the rights of the current user, after which the controller begins its work.  The database will be updated in parallel with the preparation of a response by the controller. <br><br><h2>  Testing </h2><br>  A test that starts several simultaneous requests to the service will help identify possible problems: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">TestMethod</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConcurrentTest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> threadCount = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tasks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Task[threadCount]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; threadCount; i++) { <span class="hljs-comment"><span class="hljs-comment">// DoOperations contains several CRUD operations on resources tasks[i] = Task.Factory.StartNew(DoOperations); } Task.WaitAll(tasks); }</span></span></code> </pre> <br><h2>  Problems </h2><br>  If any controller action methods are required for the database to knowingly contain the current user data, this approach is not suitable.  We'll have to use an explicit DbRefresher.RefreshAsync call in the body of the method. <br><br>  There may be problems when adding a new user to the database with multiple simultaneous requests.  If an attempt is made to add a user to a table with an already existing key, you should catch the primary key violation exception and stop working.  Then only one thread will do all the work of updating user data. <br><br><h2>  Conclusion </h2><br>  This approach has been successfully working in one of our services in Confit for more than a year. <br>  It seems to me simple and elegant.  It would be interesting to know the opinion of the community. </div><p>Source: <a href="https://habr.com/ru/post/439628/">https://habr.com/ru/post/439628/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>