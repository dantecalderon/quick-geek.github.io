<div class="post__text post__text-html js-mediator-article"><p>  Good afternoon, community Habra! </p><br><p>  That time has come for students of technical universities.  So it's time for home projects and conquering new peaks of microelectronic technology.  Today we will discuss my research with NRF51822-based circuit boards, which is a bit outdated Bluetooth module from Nordic Semiconductor.  This company is famous for its low-current radio modules and the NRF51822 chip is no exception. <a name="habracut"></a>  But we will not be distracted from the topic.  Let's talk about iron. </p><br><h1 id="sozdanie-otladochnogo-stenda">  Creating a debugging stand </h1><br><p>  Back in October, <strong>yj-14015-nrf51822</strong> boards were ordered for experiments with Bluetoth.  It was a bad idea to buy boards without wiring to pin connectors for standard wires for electronics lovers. </p><br><div class="spoiler">  <b class="spoiler_title">yj-14015-nrf51822</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/y3/ng/mv/y3ngmvstxvcodfs_8v77tznew4c.jpeg" alt="yj-14015-nrf51822"></p></div></div><br><p>  The distance between contacts less than 1 mm created great difficulties for me, a person with an extremely modest soldering experience.  Outputs on the board were not designed for soldering to wires and they were easy to tear off.  This fate befell the only power output VDD.  But with the help of a neighbor's efforts, it was possible to solder the wire to the output of a capacitor on the board.  Together, the outputs GND, SWDIO, SWCLK and some other GPIO outputs were soldered.  The result was something that resembles its own view of Frankenstein: </p><br><div class="spoiler">  <b class="spoiler_title">Soldered board</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/iq/vi/3c/iqvi3c2ya0c0rtg1glk2eetijnm.jpeg" alt="Soldered board"></p></div></div><br><p>  We will debug and flash our device using <a href="https://www.aliexpress.com/item/ST-LINK-Stlink-ST-Link-V2-Mini-STM8-STM32-Simulator-Download-Programmer-Programming-with-Cover/32921831799.html">ST-Link V2.</a> The connection scheme is extremely simple and logical: </p><br><table><thead><tr><th>  ST-Link V2 </th><th>  nrf51822 </th></tr></thead><tbody><tr><td>  3.3V </td><td>  Vdd </td></tr><tr><td>  GND </td><td>  GND </td></tr><tr><td>  SWDIO </td><td>  SWDIO </td></tr><tr><td>  SWDCLK </td><td>  SCLK </td></tr></tbody></table><br><p>  Unlike Frankenstein, a single current discharge was not enough to revive this module.  First of all, I tried to read nrf51822 memory using the <a href="https://www.st.com/en/development-tools/stsw-link004.html">STM32 ST-LINK utility</a> .  With some reservations, it worked with STM32 boards, but not with nrf.  On this, my work with the board temporarily stopped.  A little later I found <a href="https://www.diytronic.ru/2017/12/05/testing-nrf51822-ble-module/">article 1</a> and <a href="https://www.diytronic.ru/2018/01/08/nrf51822-trying-to-make-bluetooth-working/">article 2</a> about working with nrf51822.  It contained links to the SDK and a detailed description of how to organize the nrf memory.  The author of the articles used the more expensive JLink debugger unlike us.  Cheap solution is very important if you are a poor student :). </p><br><h1 id="izuchenie-sdk">  Learning SDK </h1><br><p>  If you want to use bluetooth functionality, <del>  which is pretty logical for a bluetooth chip, </del>  You will need to put the so-called "softdevice" in the beginning of the programmable nrf5 memory.  It comes in the form of firmware and contains bluetooth functionality.  The rest of the memory is recorded your firmware.  From it, you can call softdevice procedures to configure bluetooth. </p><br><p>  There are several different softdevices.  For nrf51, you can use s110 (for server applications) and s130 (for server and client applications).  To understand the compatibility of SDK and softdevice versions, there <a href="https://www.nordicsemi.com/DocLib/Content/Comp_Matrix/nRF51/latest/COMP/nrf51/nRF51422_nRF51822_ic_rev_sdk_sd_comp_matrix">is a compatibility matrix</a> .  It shows that the SDK up to version 12.3.0 is suitable for our motherboard.  But we will focus on the <a href="https://developer.nordicsemi.com/nRF5_SDK/nRF51_SDK_v10.x.x/doc/10.0.0/">SDK 10.0.0</a> .  It supports s110 and s130. </p><br><h1 id="nastroyka-openocd">  OpenOCD Setup </h1><br><p>  In the examples from the SDK and in the articles, the nrfjprog utility is used for firmware via JLink, and we need to flash through ST-Link V2.  Instead, we will use the cool <a href="http://openocd.org/">OpenOCD</a> program, <a href="">download for Windows</a> .  It allows you to flash and debug <del>  shit </del>  a huge number of different boards and chips.  There is a <a href="https://acassis.wordpress.com/2016/02/25/using-openocd-to-program-a-homebrew-nrf51822-board/">configuration</a> for the nrf51 chip.  To force OpenOCD to flash our board, you need to execute the format command below (after adding the OpenOCD / bin folder to the Path).  Read more about OpenOCD commands in the <a href="http://openocd.org/doc/html/General-Commands.html">documentation</a> . </p><br><pre><code class="plaintext hljs">openocd -f interface/stlink.cfg -f target/nrf51.cfg -c init -c "reset halt" ^ -c "nrf51 mass_erase 0" -c "flash write_image &lt;PATH_TO_HEX&gt; &lt;OFFSET&gt;" ^ -c reset -c exit</code> </pre> <br><p>  The devil, as always, is in the details: </p><br><ul><li>  "reset halt" sends a reset chip command and stops the device.  In this state, the firmware can be erased / recorded. </li><li>  "nrf51 mass_erase 0" allows writing to the bootloader section and erases the entire programmable memory of the chip (helps to avoid firmware loading errors in some cases) </li><li>  instead of &lt;PATH_TO_HEX&gt; you need to substitute the path to the hex file </li><li>  &lt;OFFSET&gt; sets the offset address of the firmware entry.  The parameter is useful if you want to flash your firmware separately from the softdevice.  If you want to write the firmware from the beginning of the memory (from the address 0x0), you can discard this parameter </li><li>  reset resets the microcircuit in order for it to work with the new firmware </li></ul><br><p>  The SDK includes hex softdevice files.  To pour s130 onto the board, you can use the following sequence of commands: </p><br><pre> <code class="plaintext hljs">set file=&lt;nRF5_SDK&gt;/components/softdevice/s130/hex/s130_nrf51_1.0.0_softdevice.hex openocd -f interface/stlink.cfg -f target/nrf51.cfg -c init -c "reset halt" ^ -c "nrf51 mass_erase 0" -c "flash write_image %file%" -c reset -c exit</code> </pre> <br><p>  Then you can upload our firmware.  It is important to remove the "nrf51 mass_erase 0" while the softdevice is not erased.  And also do not forget about the offset.  For s130, the offset is 0x1c000, and for s110 - 0x18000.  These values ​​can be found in the specifications for <a href="http://infocenter.nordicsemi.com/pdf/S130_SDS_v1.0.pdf">s130</a> and <a href="http://infocenter.nordicsemi.com/pdf/S110_SDS_v2.0.pdf">s110</a> . </p><br><pre> <code class="plaintext hljs">set file=&lt;PATH_TO_HEX&gt; openocd -f interface/stlink.cfg -f target/nrf51.cfg -c init -c "reset halt" ^ -c "flash write_image %file% 0x1c000" -c reset -c exit</code> </pre> <br><p>  Now in the programmable memory nrf51822 should lie firmware softdevice and ours.  For the tests, I used an example from the &lt;nRF5_SDK&gt; / examples / ble_peripheral / ble_app_beacon folder and an Android application called "nRF Connect".  After executing the commands, I began to see a device called nRF.  This is what we wanted. </p><br><h1 id="nastroyka-proekta-clion">  Setting up a CLion project </h1><br><p>  The nrf51 SDK contains examples based on makefiles.  To work with CLion, it is necessary to describe the project build using CMake files.  Googling showed that <a href="https://github.com/Polidea/cmake-nRF5x">CMake project for nrf51 is</a> already on the github.  It is written for use with SDK 12.XX. Because of this, some paths to the files for our SDK 10.0.0 were not spelled out correctly.  In addition, the project also uses the nrfjprog utility.  Therefore I had to tinker with setting up the project and rewrite the target for the firmware using OpenOCD.  The result of my work can be found on the <a href="https://github.com/zzuummaa/nrf5_sdk_cmake">githaba</a> .  The readme describes the project setup and debugging instructions in CLion. </p><br><h1 id="ps">  PS </h1><br><p>  Many of the technical details associated with the features of nrf51822 have escaped my narration.  I hope I will ever fill in the gaps by adding an article or writing a new one. </p></div>