<div class="post__text post__text-html js-mediator-article">  Hi, Habr! <br><br>  In the <a href="https://habr.com/ru/post/438602/">first part</a> , the POCSAG paging protocol was considered.  Were considered digital messages, we now turn to the more "full" messages in ASCII format.  Moreover, it is more interesting to decode them, because  the output will be readable text. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hu/ew/hr/huewhrcwg9oow3xpzglh8skuhqi.jpeg"></div><br>  For those who are interested in how it works, continued under the cut. <br><a name="habracut"></a><br><h2>  Receive signal </h2><br>  First, the signal must be accepted, for which we will use the same rtl-sdr receiver and HDSDR program.  We already know from the first part that paging messages can be numeric (the content is only numbers 0-9, the letter U is “ugrent”, a space and a pair of brackets) and alphanumeric, the content is full ASCII characters.  Naturally, we do not know in advance the type of message (it’s still not possible to decode them “by ear”), so when recording, we simply choose a longer message. <br><br><img src="https://habrastorage.org/webt/lu/ue/sk/luuesk79iv_yalka_pchncpwzoi.jpeg"><br><br>  The program for converting a wav file into a bitstream has already been considered, so we will immediately show the result - the paging message looks like this: <br><br><img src="https://habrastorage.org/webt/qb/wt/ud/qbwtud3zptfcwxw3xs0pam7pkr4.jpeg"><br><br>  Some features are immediately visible to the naked eye - for example, it can be seen that the starting sequence 01010101010101 is repeated twice.  Those.  This message is not only longer, but in fact consists of two “glued together” together, but the standard does not prohibit it. <br><br><h2>  Decoding </h2><br>  To begin, we recall a brief summary of the <a href="https://habr.com/ru/post/438602/">previous part</a> .  The paging message starts with a long header 0101010101, followed by a sequence of “packets”, shown in the picture as Batch1..N: <br><br><img src="https://habrastorage.org/webt/3k/yt/dc/3kytdccgmehfmqstxxli1nt3fpa.png" alt="image"><br><br>  Each packet starts with the Frame Sync Code start sequence (01111100 ...), followed by 32-bit blocks.  Each block can store either an address or a message body. <br><br>  The last time we looked at only digital messages, now we are interested in ASCII messages.  First of all, you need to learn to distinguish between them.  For this we need the field “Function Bits” - if these 2 bits are equal to 00, then the message is digital, if 11, then the text message. <br><br>  As can be seen from the figure, 20 bits are assigned to the message field, which is ideally placed in 5 4-bit BCD codes if the message is digital.  But if the message is text, then the text in 20 bits does not fit much, and even 20 is not divided into 7 or 8. We can assume that the first version of the protocol (and it was created already in 1982) supported only digital messages ( <s>yes and it is unlikely that the first pagers of those years on nixie-tubes could display more</s> ), and only then, in the next version, support for ASCII was added.  But since  it was no longer possible to break the format standard, they did it easier - the bitstream is simply merged as is (20 bits are extracted from each message and added to the end of the buffer), and then, at the end, all of this is decoded into characters. <br><br>  Consider one block of the received message (spaces added for clarity): <br><br><pre><code class="plaintext hljs">0 0001010011100010111111110010010 1 00010100000110110011 11100111001 1 01011010011001110100 01111011100 1 11010001110110100100 11011000100 1 11000001101000110100 10011110111 1 11100000010100011011 11101110000 1 00110010111011001101 10011011010 1 00011001011100010110 10011000010 1 10101100000010010101 10110000101 1 00010110111011001101 00000011011 1 10100101000000101000 11001010100 1 00111101010101101100 11011111010</code> </pre> <br>  In the first line, “0” in the first bit indicates that this is an address field, and “11” in bits 20-21 indicates that this message is symbolic.  Then simply take 20 bits from each line and add them together. <br><br>  We get this bit sequence: <br><br><pre> <code class="plaintext hljs">00010100000110110011010110100110011101001101000111011010010011000001101000 11010011100000010100011011001100101110110011010001100101110001011010101100 000010010101000101101110110011011010010100000010100000111101010101101</code> </pre> <br>  The POCSAG protocol uses 7-bit ASCII, so just divide the string into blocks of 7 bits: <br><br><pre> <code class="plaintext hljs">0001010 0000110 1100110 1011010 0110011 1010011 ...</code> </pre> <br>  We are trying to decode character codes (the ASCII table is easily googled on the Internet), and ... we get garbage at the output.  Once again, open the documentation and find the unobtrusive phrase "ASCII characters are placed from left to right (MSB to LSB).  The LSB is transmitting first. ”  Those.  the low-order bit is transmitted first, and then the high-order bit — to correctly decode ASCII codes, the 7-bit strings must be flipped. <br><br>  In order not to do this manually, we write the code in Python: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block)</span></span></span><span class="hljs-function">:</span></span> msgs = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> cw <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">16</span></span>): cws = block[<span class="hljs-number"><span class="hljs-number">32</span></span> * cw:<span class="hljs-number"><span class="hljs-number">32</span></span> * (cw + <span class="hljs-number"><span class="hljs-number">1</span></span>)] <span class="hljs-comment"><span class="hljs-comment"># Skip the idle word if cws.startswith("0111101010"): continue if cws[0] == "0": addr, type = cws[1:19], cws[19:21] print(" Addr:" + addr, type) else: msg = cws[1:21] print(" Msg: " + msg) msgs += msg # Split long string to 7 chars blocks bits = [msgs[i:i+7] for i in range(0, len(msgs), 7)] # Get the message msg = "" for b in bits: b1 = b[::-1] # Revert string value = int(b1, 2) msg += chr(value) print("Msg:", msg) print()</span></span></code> </pre><br>  As a result, we get the following sequence (bits, character codes, and the characters themselves): <br><br><pre> <code class="plaintext hljs">0101000 40 ( 0110000 48 0 0110011 51 3 0101101 45 - 1100110 102 f 1100101 101 e 1100010 98 b 0101101 45 - 0110010 50 2 0110000 48 0 0110001 49 1 0111001 57 9 0100000 32 0110001 49 1 0110011 51 3 0111010 58 : 0110011 51 3 0110001 49 1 0111010 58 : 0110100 52 4 0110101 53 5 0100000 32 0101010 42 * 0110100 52 4 0110111 55 7 0110110 54 6 0101001 41 ) 0100000 32 1000001 65 A 1010111 87 W 1011010 90 Z</code> </pre><br>  Combine the characters together and get the string: "(03-feb-2019 13:31:45 * 476) AWZ".  As promised at the beginning of the article, the text is quite readable. <br><br>  By the way, another interesting point is that as you can see, the protocol uses 7-bit ASCII.  Cyrillic characters do not fit into this range, so the question how the Russian language was paged was left open.  If anyone knows, write in the comments. <br><br><h2>  findings </h2><br>  Of course, the protocol was not completely disassembled, but the most interesting part was done, and then the routine, which is no longer so interesting, remains.  At a minimum, there is no decoding of recipient addresses (capcodes), and the support of the error correction code (BCH Check Bits) is not implemented - this would allow correcting up to 2 bits corrupted during transmission.  However, the goal is to make a full-fledged decoder and did not stand - such decoders are already there, and one more is hardly needed. <br><br>  Those who want to try decoding messages with rtl-sdr can do it themselves using the free <a href="https://www.discriminator.nl/pdw/index-en.html">PDW</a> program.  It does not require installation, after starting it is necessary to redirect the HDSDR output to the PDW input using the Virtual Audio Cable program and select the appropriate device in the PDW audio settings. <br><br>  The result of the program looks like this: <br><br><img src="https://habrastorage.org/webt/-7/g-/ka/-7g-kalvhmaqlv79qju-wmgpglg.jpeg"><br><br>  On this topic paging messages can be considered closed.  Those who wish to study the topic in more detail, can study the source codes of the <a href="https://github.com/EliasOenal/multimon-ng">multimon-ng</a> program, which can decode many protocols, including POCSAG and FLEX. </div>