<div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/bj/9x/wi/bj9xwicnsccegyu2fo2xvbvglr0.png"><br><br>  Can you predict how this Kotlin code will behave?  Will it compile, what will it output and why? <br><br>  No matter how good a programming language is, it can throw up such a thing that it remains only to scratch the back of the head.  Kotlin is not an exception - there are also “puzzle players” in it, when even a very short code fragment has unexpected behavior. <br><br>  Back in 2017, we published a <a href="https://habr.com/ru/company/jugru/blog/338924/">selection of</a> such puzzlers from <b>Anton Cake</b> <a href="https://habr.com/ru/users/antonkeks/" class="user_link">antonkeks</a> on Habré.  And later he spoke with us on Mobius with the second selection, and now we also translated it into a text view for Habr, hiding the correct answers under the spoilers. <br><br>  We also attach the video of the speech, if something is incomprehensible in the text, you can refer to it. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/t387acWEK3o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  The first half of the puzzler is aimed at those who are not very familiar with Kotlin;  the second half is for hardcore Kotlin developers.  We will run everything on Kotlin 1.3, even with progressive mode enabled.  The source code for the puzzler is <a href="https://github.com/angryziber/kotlin-puzzlers/">on GitHub</a> .  Whoever has new ideas, send pull requests. <br><br><h2>  Pazzler №1 </h2><br><pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { println(print(″Hello″) == print(″World″) == <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>) } hello()</code> </pre> <br>  Before us is a simple hello function, it runs a few print.  And we run this function itself.  A simple question for overclocking: what should it print? <br><br>  a) HelloWorld <br>  b) HelloWorldfalse <br>  c) HelloWorldtrue <br>  d) will not compile <br><br><div class="spoiler">  <b class="spoiler_title">Correct answer</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ce/uc/rg/ceucrgqimyvojaud8llfktt0l1s.png"><br><br>  The first option was correct.  The comparison is triggered after both print have already started, it cannot start earlier.  Why does such code compile at all?  Any function other than returning Nothing returns something.  Since in Kotlin everything is an expression, even return is also an expression.  The return type return is Nothing, it is cast to any type, so you can compare it like this.  And print returns Unit, so Unit can be compared with Nothing as many times as necessary, and everything works great. <br></div></div><br><h2>  Pazzler №2 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printInt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { println(n) } printInt(-<span class="hljs-number"><span class="hljs-number">2_147_483_648</span></span>.inc())</code> </pre><br>  A hint so that you do not guess: a scary number is a really minimal possible 32-bit signed integer. <br><br>  Here everything looks simple.  Kotlin has excellent extension functions like .inc () for incrementing.  We can call it on Int, and we can print the result.  What happens? <br><br>  a) -2147483647 <br>  b) -2147483649 <br>  c) 2147483647 <br>  d) None of the above <br><br><div class="spoiler">  <b class="spoiler_title">Run!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/se/sa/hy/sesahyqljf-z0kyeil35hpev4ho.png"><br><br>  As can be seen from the error message, there is a problem with Long.  But why Long? <br><br>  The extension-functions have priority, and the compiler first starts inc (), and only then the minus operator.  If inc () is removed, it will be int, and everything will work.  But inc (), starting first, turns 2_147_483_648 into Long, because this number without a minus is no longer valid Int.  It turns out Long, and only then minus is called.  All this cannot be transferred to the printInt () function, because it requires an Int. <br><br>  If we change the printInt call to regular print, which can accept Long, then the second option is correct. <br><br><img src="https://habrastorage.org/webt/qf/vf/q3/qfvfq3njfzcubm6ax7uvda6g8b4.png"><br><br>  We see that this is actually Long.  Beware of this: not all puzzle players can run into the real code, but this one is possible. <br></div></div><br><h2>  Pazzler №3 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x: UInt = <span class="hljs-number"><span class="hljs-number">0</span></span>u println(x--.toInt()) println(--x)</code> </pre><br>  In Kotlin 1.3 came new great features.  In addition to the final version of Korutin, we <br>  now finally we have unsigned numbers.  This is necessary, especially if you are writing some kind of network code. <br><br>  Now, even for literals there is a special letter u, we can define constants, we can decrement x, as in the example, and convert to Int.  I remind you that we have a sign with Int. <br><br>  What happens? <br><br>  a) -1 4294967294 <br>  b) 0 4294967294 <br>  c) 0 -2 <br>  d) will not compile <br><br>  4294967294 is the maximum 32-bit number that can be obtained. <br><br><div class="spoiler">  <b class="spoiler_title">Run!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/uj/up/ch/ujupchn07nkjmqfl8a9hnhbycha.png"><br><br>  The correct option is b. <br><br>  Here, as in the previous version: first, toInt () is called on x, and only then decrement is called.  The result of the decrement unsigned, and this is the maximum from unsignedInt. <br><br>  The most interesting thing is that if you write like this, the code will not compile: <br><br><pre> <code class="kotlin hljs">println(x--.toInt()) println(--x.toInt())</code> </pre><br>  And for me it is very strange that the first line is working, and the second is not, it is illogical. <br><br>  And in the pre-release version, the correct version would be C, so well done in JetBrains, that fixes bugs before the release of the final version. <br></div></div><br><h2>  Pazzler №4 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cells = arrayOf(arrayOf(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), arrayOf(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), arrayOf(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> neighbors = cells[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] print(neighbors)</code> </pre><br>  In this case, we ran into the real code.  We at Codeborne did Coding Dojo, together we implemented them on the Kotlin <a href="https://en.wikipedia.org/wiki/Conway%2527s_Game_of_Life">Game of Life</a> .  As you can see, Kotlin is not very convenient to work with multi-level arrays. <br><br>  In Game of Life, an important part of the algorithm is determining the number of neighbors for a cell.  All the ones around are neighbors, and it depends on this whether the cell will live on or die.  In this code, you can count edinichki and assume that it will. <br><br>  a) 6 <br>  b) 3 <br>  c) 2 <br>  d) will not compile <br><br><div class="spoiler">  <b class="spoiler_title">let's get a look</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/m2/8_/j0/m28_j0aa1kg9j7aixnsj2trzsrg.png"><br><br>  The correct answer is 3. <br><br>  The fact is that the plus from the first line is moved down, and Kotlin thinks that it is unaryPlus ().  As a result, only the first three cells are added.  If we want to write this code in several lines, we need to move plus to the top. <br><br>  This is another one of the “bad puzzlers”.  Remember, in Kotlin it is not necessary to transfer the operator to a new line, otherwise it may consider it unary. <br><br><img src="https://habrastorage.org/webt/f5/-9/ew/f5-9ewbhsw0ucybzsg-7xkeld1u.png"><br><br>  I have not seen situations where unaryPlus is needed in real code, except DSL.  This is a very strange topic. <br><br>  This is the price we pay for the lack of semicolons.  If they were, it would be clear when one expression ends and another begins.  And without them, the compiler must decide itself.  A line break for a compiler very often means that it makes sense to try to examine the lines separately. <br><br>  But there is one very cool JavaScript language, in which you can also not write a semicolon, and this code will still work correctly. <br></div></div><br><h2>  Pazzler №5 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>? = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> y: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = x?:<span class="hljs-number"><span class="hljs-number">0</span></span> + y println(sum)</code> </pre><br>  This puzzler was delivered by KotlinConf speaker Thomas Nild. <br><br>  Kotlin has a great nullable feature.  We have a nullable x, and we can convert it, if it turns out to be null, through an Elvis operator to some normal value. <br><br>  What will happen? <br><br>  a) 3 <br>  b) 5 <br>  c) 2 <br>  d) 0 <br><br><div class="spoiler">  <b class="spoiler_title">Run!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/1_/zg/-o/1_zg-ozj8sgftbrk2nswebclg30.png"><br><br>  The problem is again in the order or priority of the operators.  If we reformat it, the official format will do this: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = x ?: <span class="hljs-number"><span class="hljs-number">0</span></span>+y</code> </pre><br>  Already the format suggests that 0 + y starts first, and only then x?:.  Therefore, naturally, 2 remains, because X is equal to two, it is not null. <br></div></div><br><h2>  Pazzler №6 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Recipe</span></span></span><span class="hljs-class"> </span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hops: List&lt;Hops&gt; = emptyList() ) <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Hops</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> kind: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> atMinute: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> grams: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">beer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(build: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Recipe</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) = Recipe().apply(build) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Recipe.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hops</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(build: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Hops</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { hops += Hops().apply(build) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> recipe = beer { name = ″Simple IPA″ hops { name = ″Cascade″ grams = <span class="hljs-number"><span class="hljs-number">100</span></span> atMinute = <span class="hljs-number"><span class="hljs-number">15</span></span> } }</code> </pre><br>  When I was called here, I was promised a craft beer.  I'm going to look for him tonight, have not yet seen.  Kotlin has a great theme - builders.  In four lines of code, we write our DSL and then create it through the builders. <br><br>  First, we create IPA, add hops called Cascade, 100 grams in the 15th minute of cooking, and then print this recipe.  What have we got? <br><br>  a) Recipe (name = Simple IPA, hops = [Hops (name = Cascade, atMinute = 15, grams = 100)]) <br>  b) IllegalArgumentException <br>  c) will not compile <br>  d) None of the above <br><br><div class="spoiler">  <b class="spoiler_title">Run!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ji/ci/8p/jici8p8px4kd4hnogzpvcufsrqi.png"><br><br>  We got something similar to craft beer, but there’s no hop in it, it’s gone.  They wanted IPA, and got the "Baltic 7". <br><br>  Here is the naming clash.  The field in Hops is actually called kind, and in the line name = ″ Cascade ″ we use name, which is trapped with the name of the recipe. <br><br>  We can create our own BeerLang annotation and register it as part of the BeerLang DSL.  Now we are trying to run this code, and we should not compile it. <br><br><img src="https://habrastorage.org/webt/eq/i-/a3/eqi-a3r5hjxbpsy7z-rlzqlkqjg.png"><br><br>  Now we are told that, in principle, name cannot be used from this context.  DSLMarker is for this purpose necessary, that inside the builder the compiler did not allow us to use the external field, if we have the same inside, so that there is no naming clash.  The code is corrected like this, and we get our recipe. <br><br><img src="https://habrastorage.org/webt/rv/kn/8y/rvkn8ys1t9syngob9ikmtfbgij8.png"><br></div></div><br><h2>  Pazzler №7 </h2><br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (x) { x == <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; println(″$x TRUE″) x == <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; println(″$x FALSE″) } } f(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) f(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre><br>  This puzzler was one of JetBrains employees.  Kotlin has a feature when.  It is for all occasions, allows you to write cool code, often used together with sealed-classes for API design. <br><br>  In this case, we have a f () function that accepts a Boolean and prints something depending on true and false. <br><br>  What will happen? <br><br>  a) true TRUE;  false false <br>  b) true TRUE;  false true <br>  c) true FALSE;  false false <br>  d) None of the above <br><br><div class="spoiler">  <b class="spoiler_title">let's get a look</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/c6/g0/lo/c6g0loicys30gkbo0bf9cagvk20.png"><br><br>  Why is that?  First, we evaluate the expression x == true: for example, in the first case it will be true == true, which means true.  And then there is also a comparison with the sample that we passed to when. <br><br>  And when x is set to false, calculating x == true will give us false, but in the sample it will also be false - so the example will match the sample. <br><br>  There are two ways to fix this code. One is to remove x == in both cases: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (x) { <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; println(″$x TRUE″) <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; println(″$x FALSE″) } } f(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) f(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre><br>  The second option is to remove (x) after when.  When works with any conditions, and then will not compare with the sample. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { x == <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; println(″$x TRUE″) x == <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; println(″$x FALSE″) } } f(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) f(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre><br></div></div><br><h2>  Pazzler №8 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NullSafeLang</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> logo = name[<span class="hljs-number"><span class="hljs-number">0</span></span>].toUpperCase() } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Kotlin</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NullSafeLang</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name = ″Kotlin″ } print(Kotlin().logo)</code> </pre><br>  Kotlin was sold as a “null safe” language.  Imagine that we have an abstract class, it has some name, and also a property that returns the logo of this language: the first letter of the name, just in case made uppercase (all of a sudden, it was initially forgotten to be capitalized). <br><br>  Since the language is null safe, we will change the name and probably should get a correct logo, which is one letter.  What do we really get? <br><br>  a) K <br>  b) NullPointerException <br>  c) IllegalStateException <br>  d) will not compile <br><br><div class="spoiler">  <b class="spoiler_title">Run!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/bb/et/sm/bbetsm3lj5eh356zwho6z4bhzjs.png"><br><br>  We received a NullPointerException that should not be received.  The problem is that the superclass constructor is first called, the code tries to initialize the property logo and take the null char from the name, and at this point the name is null, so a NullPointerException occurs. <br><br>  The best way to fix this is to do this: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Kotlin</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NullSafeLang</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = ″Kotlin″ }</code> </pre><br>  If we run such code, we get "K".  Now the base class will call the base class constructor, it will actually call the getter name and get Kotlin. <br><br>  Property is a great feature in Kotlin, but you need to be very careful when you make override properties, because it is very easy to forget, to make a mistake, or to do something wrong. <br><br></div></div><br><h2>  Puzzler number 9 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = mutableListOf&lt;() -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>&gt;() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">3</span></span>) { i++ result += { print(″$i, $j; ″) } } result.forEach { it() }</code> </pre><br>  There are mutableList of some terrible things.  If it reminds you of Scala, then it is not in vain, because it really looks like.  There is a List lambda, we take two counters - I and j, increment and then do something with them.  What happens? <br><br>  a) 1 1;  2 2;  3 3 <br>  b) 1 3;  2 3;  3 3 <br>  c) 3 1;  3 2;  3 3 <br>  d) none of the above <br><br><div class="spoiler">  <b class="spoiler_title">Let's run</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/y8/ap/9j/y8ap9j-cfyyuanfscsg_irflczy.png"><br><br>  We get 3 1;  3 2;  3 3. This happens because i is a variable and it will retain its value until the end of the function.  And j is already passed by value. <br><br>  If instead of var i = 0, val i = 0, this would not work, but then we could not increment the variable. <br><br>  Here in Kotlin we use a closure, this feature is not in Java.  It is very cool, but it can bite us if we do not immediately use the value of i, but pass it to the lambda, which starts later and sees the last value of this variable.  And j is passed by value, because the variables in the loop condition are like val, they don’t change their value anymore. <br><br>  In JavaScript, the response would be “3 3;  3 3;  3 3 "because nothing is passed by value. <br><br></div></div><br><h2>  Pazzler number 10 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a:</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">, b: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = print(″$a, $b″) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> c = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> d = <span class="hljs-number"><span class="hljs-number">4</span></span> foo(c &lt; a, b &gt; d)</code> </pre><br>  We have a function foo (), takes two Boolean, prints them, everything seems simple.  And we have a bunch of numbers, left to see which figure is greater than the other, and decide which option is correct. <br><br>  a) true, true <br>  b) false, false <br>  c) null, null <br>  d) will not compile <br><br><div class="spoiler">  <b class="spoiler_title">Run</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/j6/m5/5c/j6m55cysqvltjnc9x67mxerzglq.png"><br><br>  Not compiled. <br><br>  The problem is that the compiler thinks it looks like generic parameters: with &lt;a, b&gt;.  Although it seems like “c” is not a class, it is not clear why it should have generic parameters. <br><br>  If the code were like this, it would work fine: <br><br><pre> <code class="kotlin hljs">foo(c &gt; a, b &gt; d)</code> </pre><br>  It seems to me that this is a bug in the compiler.  But when I come to Andrei Breslav with any such puzzler, he says “this is because the parser didn’t want it to be too slow”.  In general, he always finds an explanation why. <br><br>  Unfortunately, this is so.  He said that they will not fix it, because the parser is <br>  Kotlin still does not know about semantics.  First there is a parsing, and then it further transfers to another component of the compiler.  Unfortunately, this will probably remain so.  So do not write two such angle brackets and any code in the middle! <br></div></div><br><h2>  Puzzler number 11 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Container</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> items: List&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;) : List&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> items <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> (name, items) = Container(″Kotlin″, listOf(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)) println(″Hello $name, $items″)</code> </pre><br>  Delegate is a great feature in Kotlin.  By the way, Andrei Breslav says that this is the feature that he would like to remove from the language, he does not like it anymore.  Now, perhaps we will find out why!  And he also said that companion objects are ugly. <br><br>  But the data classes are beautiful.  We have a data class Container, it takes its name and items.  And at the same time in the Container we implement the type of items, this is a List, and we delegate all its methods to items. <br><br>  Then we use another cool feature - destructure.  We "destruct" the elements of the name and items from the Container and display them on the screen.  It seems that everything is simple and clear.  What happens? <br><br>  a) Hello Kotlin, [1, 2, 3] <br>  b) Hello Kotlin, 1 <br>  c) Hello 1, 2 <br>  d) Hello Kotlin, 2 <br><br><div class="spoiler">  <b class="spoiler_title">Run</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/fn/jt/bb/fnjtbbmz1sikuctkwsxxkmih7vc.png"><br><br>  The most incomprehensible option is d.  It turns out to be true.  As it turned out, elements simply disappear from the items collection, and not from the beginning or from the end, but remain only in the middle.  Why? <br><br>  The problem of destructuring is that due to the delegation all the collections in Kotlin also <br>  have their own destructuring option.  I can write val (I, j) = listOf (1, 2), and I get these 1 and 2 into variables, that is, the List has implemented functions component1 () and <br>  component2 (). <br><br>  The data class also has component1 () and component2 ().  But since the second component in this case is private, the one that is public from the List wins, so the second element is taken from the List, and here we get 2. The moral is very simple: don't do that, do not do that. <br></div></div><br><h2>  Puzzler number 12 </h2><br>  The following puzzle is very scary.  This is caused by a person who is somehow connected to Kotlin, so he knows what he is writing. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> Any?.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asGeneric</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? T <span class="hljs-number"><span class="hljs-number">42</span></span>.asGeneric&lt;<span class="hljs-built_in"><span class="hljs-built_in">Nothing</span></span>&gt;()!!!! <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-number"><span class="hljs-number">87</span></span> println(a)</code> </pre><br>  We have an extension function on nullable Any, that is, it can be applied to anything at all.  This is a very useful feature.  If it is not already in your project, you should add it, because it can cast everything on you, on everything, on anything.  Then we take 42 and cast it in Nothing. <br><br>  Well, if we want to be sure that we have done something important, you can instead !!!  write !!!!, the Kotlin compiler allows you to do this: if you lack two exclamation points, write at least twenty-six. <br><br>  Then we do if (true), and then I myself do not understand anything ... Let's immediately choose what happens. <br><br>  a) 87 <br>  b) Kotlin.Unit <br>  c) ClassCastException <br>  d) will not compile <br><br><div class="spoiler">  <b class="spoiler_title">We look</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/_t/g7/l-/_tg7l-vw0wze-y2vu_dix7cnvni.png"><br><br>  It is very difficult to give a logical explanation.  Most likely, the Unit turns out here due to the fact that there is nothing more to push.  This is an invalid code, but it works because we used Nothing.  We cast something to Nothing, and this is a special type that tells the compiler that an instance of this type should never appear.  The compiler knows that if the possibility of Nothing appears, which is impossible by definition, then you can not check further, this is an impossible situation. <br><br>  Most likely, this is a bug in the compiler, the JetBrains team even said that maybe this bug will someday be fixed, this is not a very priority.  The point is that we have deceived the compiler here because of this caste.  If you remove the line 42.asGeneric &lt;Nothing&gt; () !!!  and stop cheating, the code will stop compiling.  And if we leave, the compiler goes crazy, thinks this is an impossible expression, and stuffs everything into it. <br><br>  I understand that.  Maybe someone will explain it better. <br><br></div></div><br><h2>  Puzzler number 13 </h2><br>  We have a very interesting feature.  You can use dependency injection, and you can do without it, make singletones through object and run your program cool.  Why do you need Koin, Dagger or something?  Test, however, will be difficult. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: Any?) { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = javaClass.simpleName } <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> B : A(C) <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> C : A(B) println(Bx) println(Cx)</code> </pre><br>  We have a class A open for inheritance, it takes something inward, we create two objects, a singleton, B and C, both are inherited from A and pass each other there.  That is a great cycle is formed.  Then we print what B and C got. <br><br>  a) null;  null <br>  b) C;  null <br>  c) ExceptionInInitializerError <br>  d) will not compile <br><br><div class="spoiler">  <b class="spoiler_title">Run</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/lf/ic/tc/lfictczohzri2l2os2w5xpypbfw.png"><br><br>  The correct option is C;  null <br><br>  One would think that when the first object is initialized, there is no second one yet.  But when we print this out, C doesn’t have enough B. That’s, the order is reversed: for some reason, the compiler decided to initialize C first, and then it initialized B together with C. It looks illogical, it would be logical, on the contrary, null ;  B. <br><br>  But the compiler tried to do something, he did not succeed, he left there null and decided we did not throw anything.  This can also be. <br><br>  If Any?  in the type of parameter to remove?, it will not work. <br><br><img src="https://habrastorage.org/webt/re/mh/6n/remh6n7bggwrm2ig962qbh1uvlu.png"><br><br>  You can say bravo to the compiler for when null was resolved, he tried, but failed, and if?  No, he throws an exception to us that we cannot do a cycle. <br></div></div><br><h2>  Puzzler number 14 </h2><br>  In version 1.3 there were excellent new Korutin in Kotlin.  I thought for a long time how to come up with a puzzle about corutin so that someone could understand it.  I think for some people, any code with corortines is a puzzler. <br><br>  In 1.3, some of the function names changed, which were in 1.2 in the experimental API.  For example, buildSequence () is renamed to just sequence ().  That is, we can make excellent sequences with the yield function, infinite loops, and then we can try to get something out of this sequence. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> coroutines.yieldNoOne <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x = sequence { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) yield(n++) } println(x.take(<span class="hljs-number"><span class="hljs-number">3</span></span>))</code> </pre><br>  With the Korutins, it was said that all the cool primitives that exist in other languages, such as yield, can be done as library functions, because yield is a suspend function that can be interrupted. <br><br>  What will happen? <br><br>  a) [1, 2, 3] <br>  b) [0, 1, 2] <br>  c) Infinite loop <br>  d) None of the above <br><br><div class="spoiler">  <b class="spoiler_title">Run!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/dh/p2/s3/dhp2s3ugmoll1vijctjtmlxgmtm.png"><br><br>  The correct option is the last one. <br><br>  Sequence is a lazy thing, and when we cling to it, it is also lazy.  But if you add toList, then it would really be deduced [0, 1, 2]. <br><br>  The correct answer is not related to Corutin at all.  Korutiny really work, they are easy to use.  For the sequence and yield functions, it is not even necessary to connect a library with corortines, everything is already in the standard library. <br></div></div><br><h2>  Puzzler number 15 </h2><br>  This puzzler is also a developer from JetBrains.  There is such a hell of code: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> whatAmI = {-&gt;}.<span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> Function&lt;*&gt;.(){}() println(whatAmI)</code> </pre><br>  When I saw him for the first time, during KotlinConf, I could not sleep, trying to understand what it was.  Such a cryptic code can be written on Kotlin, so if someone thought that Scalaz is scary, then Kotlin is also possible. <br><br>  Let's guess: <br><br>  a) Kotlin.Unit <br>  b) Kotlin.Nothing <br>  c) will not compile <br>  d) None of the above <br><br><div class="spoiler">  <b class="spoiler_title">Let's run</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/fk/xy/o_/fkxyo_vljbjpo9gv1lak7ubr_1a.png"><br><br>  We got Unit, which came from no one knows where. <br><br>  Why?  First, we assign the variable lambda: {-&gt;} - this is a valid code, you can write an empty lambda.  It has no parameters, it returns nothing.  Accordingly, it returns Unit. <br><br>  We assign a lambda to a variable and immediately write an extension to this lambda, and then we launch it.  In fact, she will simply reserve Kotlin.Unit. <br><br>  Then on this lambda you can write an extension function: <br><br><pre> <code class="kotlin hljs">.<span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> Function&lt;*&gt;(){}</code> </pre><br>  She is declared on the Function &lt;*&gt; type, and what we have on top also suits her.  Actually, this is Function &lt;Unit&gt;, but I didn’t write to Unit so it would be more incomprehensible.  Know how an asterisk works in Kotlin?  This is not the same as a question in Java. Она выбирает тот тип, который лучше всего подходит. <br><br> В итоге запускаем эту функцию, и она возвращает Unit из {}, потому что она ничего не возвращает, это void-функция. Непонятно, зачем так писать, но можно. Анонимная функция-расширение, которую пишешь и сразу вызываешь — такое тоже бывает. <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This completes the puzzlemakers. In conclusion, I want to say that Kotlin is a cool language. If you are an iOS developer and saw it for the first time today, then what you see does not mean that you don’t need to write to Kotlin!</font></font><br><blockquote> Если вам понравился этот доклад с Mobius, обратите внимание: следующий <b>Mobius</b> состоится <b>22-23 мая в Петербурге</b> . Там без Kotlin тоже не обойдётся — <a href="https://mobiusconf.com/talks/4m2vganfahdoxedss0br9l/%3Futm_source%3Dhabr%26utm_medium%3D440974">доклад</a> «Coroutining Android Apps» поможет не наломать дров при переходе к корутинам. Будет и много другого для мобильных разработчиков (как Android, так и iOS), уже известные подробности о программе — на <a href="http://mobiusconf.com/%3Futm_source%3Dhabr%26utm_medium%3D440974">сайте</a> , и с <b>1 марта</b> стоимость билетов повысится. <br><br> Небольшой лайфхак: если не хотите покупать билет, у вас еще есть шанс попасть на конференцию в качестве спикера — до <b>6 марта</b> мы <a href="https://mobiusconf.com/cfp/%3Futm_source%3Dhabr%26utm_medium%3D440974">принимаем заявки</a> на доклады. <br></blockquote></div>