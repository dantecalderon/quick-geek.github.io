<div class="post__text post__text-html js-mediator-article"><p>  I decided to test the IntelliJ IDEA static Java code analyzer and with its help checked the project <a href="https://github.com/cdk/cdk">The Chemistry Development Kit</a> .  Here I will give some errors that I found.  I think that some of them are typical for Java-programs as a whole, therefore they may be interesting. </p><br><p>  The Chemistry Development Kit is an open source Java library for solving problems of chemoinformatics and bioinformatics.  When I was engaged in bioinformatics, we actively used it.  The project has been developed for more than 20 years, it has dozens of authors, and the quality of the code there is very uneven.  However, the project has unit tests, and pom.xml contains integration with the <a href="https://github.com/jacoco/jacoco">JaCoCo</a> coverage <a href="https://github.com/jacoco/jacoco">analyzer</a> .  In addition, there are set up plug-ins of as many as three static analyzers: <a href="https://github.com/findbugsproject/findbugs">FindBugs</a> , <a href="https://pmd.github.io/">PMD</a> , <a href="https://checkstyle.org/">Checkstyle</a> .  More interesting to check, what warnings remain. </p><a name="habracut"></a><br><p>  A static Java code analyzer built into <a href="https://www.jetbrains.com/idea/">IntelliJ IDEA</a> is not inferior to specialized static analysis tools, and in some ways surpasses them.  In addition, virtually all static analysis features are available in <a href="https://github.com/JetBrains/intellij-community">Community Edition</a> , the free and open source IDE.  In particular, the free version gives all the warnings described in this article. </p><br><p>  By default, static analysis is performed continuously in the code editing mode, so if you write code in IntelliJ IDEA, you will correct a lot of errors literally seconds after they were allowed, even before running the tests.  You can check the entire project or its part in batch mode using the <em>Analyze |</em>  <em>Inspect Code</em> or start a separate inspection using <em>Analyze |</em>  <em>Run Inspection by Name</em> .  In this case, some inspections become available, which, because of the complexity, do not work in edit mode.  However, there are few such inspections. </p><br><p>  Many IntelliJ IDEA inspections do not report a bug, but rather an inaccuracy in the code, or offer a more idiomatic, beautiful, or quick alternative.  This is useful when you are constantly working in the IDE.  However, in my case it is better to start with the messages that warn about real bugs.  Mostly interesting is <em>Java |</em>  <em>Probable Bugs</em> , although there are other categories that should be explored, for example, <em>Numeric Issues</em> . </p><br><p>  I will talk only about some interesting warnings. </p><br><h3 id="1-unarnyy-plyus">  1. Unary plus </h3><br><p> Unary pluses plucked as much as 66 in the project.  Write <code>+1</code> instead of just <code>1</code> sometimes you want for beauty.  However, in some cases, the unary plus comes out, if instead of <code>+=</code> <a href="">wrote</a> <code>=+</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> totalCharge1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (atoms1.hasNext()) { totalCharge1 = +((IAtom) atoms1.next()).getFormalCharge(); } Iterator&lt;IAtom&gt; atoms2 = products.atoms().iterator(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> totalCharge2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (atoms2.hasNext()) { totalCharge2 = +((IAtom) atoms2.next()).getFormalCharge(); }</code> </pre> <br><p>  The obvious misprint, which resulted in ignoring all iterations of the loop except the last.  It may seem strange that not “space equals plus space” is written, but “space equals space plus”.  However, the strangeness disappears if you <a href="">delve into history</a> .  Initially, "equal" and "plus" were really close, but in 2008 we went through an automatic formatter, and the code changed.  Here, by the way, the moral for static analyzers is that it is reasonable to issue warnings based on strange formatting, but if the code is automatically formatted, the warnings will disappear and the bugs will remain. </p><br><h3 id="2-celochislennoe-delenie-s-privedeniem-k-drobnomu">  2. Integer division with reduction to fractional </h3><br><p>  Pretty annoying mistake, but static analyzers find it well.  Here is <a href="">an example</a> : </p><br><pre> <code class="java hljs">angle = <span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">180</span></span> * Math.PI;</code> </pre> <br><p>  Unfortunately, the angle was not one degree at all, but zero.  <a href="">Similar error</a> : </p><br><pre> <code class="java hljs">Integer c1 = features1.get(key); Integer c2 = features2.get(key); c1 = c1 == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : c1; c2 = c2 == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : c2; sum += <span class="hljs-number"><span class="hljs-number">1.0</span></span> - Math.abs(c1 - c2) / (c1 + c2); <span class="hljs-comment"><span class="hljs-comment">// integer division in floating-point context</span></span></code> </pre> <br><p>  It seems that both the numbers <code>c1</code> and <code>c2</code> non-negative, which means that the modulus of the difference will never exceed the sum.  Therefore, the result will be 0 if both numbers are nonzero, or 1 if one of them is 0. </p><br><h3 id="3-vyzov-classgetclass">  3. Call Class.getClass () </h3><br><p>  Sometimes people call <code>getClass()</code> on an object of type <code>Class</code> .  The result is again an object of type <code>Class</code> with a constant value <code>Class.class</code> .  This is usually an error: do not call <code>getClass()</code> .  For example, <a href="">here</a> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T extends ICDKObject&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ofClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Class&lt;T&gt; intf, Object... objects)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!intf.isInterface()) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"expected interface, got "</span></span> + intf.getClass()); ...</code> </pre> <br><p>  If an exception happens, reporting it will be absolutely useless.  By the way, errors in the error handling procedure are often found by static analysis in old projects: as a rule, error handling procedures are tested the worst. </p><br><h3 id="4-vyzov-tostring-na-massive">  4. Calling toString () on an array </h3><br><p>  This is a classic of the genre: toString () for arrays is not redefined, and its result is rather useless.  Usually this can be found in <a href="">diagnostic messages</a> . </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] dim = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Dim:"</span></span> + dim + <span class="hljs-string"><span class="hljs-string">" SizeX:"</span></span> + grid.length + <span class="hljs-string"><span class="hljs-string">" SizeY:"</span></span> + grid[<span class="hljs-number"><span class="hljs-number">0</span></span>].length + <span class="hljs-string"><span class="hljs-string">" SizeZ:"</span></span>...</code> </pre> <br><p>  It’s difficult to notice the problem because here <code>dim.toString()</code> implicit, but string concatenation delegates to it.  Immediately proposed a fix - wrap in <code>Arrays.toString(dim)</code> . </p><br><h3 id="5-kollekciya-chitaetsya-no-ne-zapolnyaetsya">  5. The collection is read, but not filled. </h3><br><p>  This is also often found in the code base, which is not constantly checked by the static analyzer.  Here is a <a href="">simple example</a> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Set&lt;IBond&gt; bondsToHydrogens = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;IBond&gt;(); <span class="hljs-comment"><span class="hljs-comment">// ... 220 строк логики, но bondsToHydrogens нигде не заполняется! for (IBond bondToHydrogen : bondsToHydrogens) // в цикл не зайдём sgroup.removeBond(bondToHydrogen);</span></span></code> </pre> <br><p>  Obviously, filling just missed.  In static analyzers, there are simpler tests that talk about an unused variable, but here the variable is used, so they are silent.  We need a smarter inspection, which knows about the collection. </p><br><h3 id="6-naoborot-zapolnyaem-no-ne-chitaem">  6. On the contrary: fill, but do not read </h3><br><p>  Reverse cases are also possible.  Here is <a href="">an example with an array</a> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] tmp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[trueBits.length - <span class="hljs-number"><span class="hljs-number">1</span></span>]; System.arraycopy(trueBits, <span class="hljs-number"><span class="hljs-number">0</span></span>, tmp, <span class="hljs-number"><span class="hljs-number">0</span></span>, i); System.arraycopy(trueBits, i + <span class="hljs-number"><span class="hljs-number">1</span></span>, tmp, i, trueBits.length - i - <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><p>  Inspection knows that the third argument of the arraycopy method is used only to write the array, and after that the array is not used at all.  Judging by the logic of the code, the line <code>trueBits = tmp;</code>  . </p><br><h3 id="7-sravnenie-integer-po-">  7. Integer versus == </h3><br><p>  This is an insidious bug, because the small values ​​of Integer objects are cached, and everything can work well, until one day the number exceeds 127. This problem may not <a href="">be noticeable at all</a> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">0</span></span>; a &lt; cliqueSize; a++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-number"><span class="hljs-number">0</span></span>; b &lt; vecSize; b += <span class="hljs-number"><span class="hljs-number">3</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cliqueList.get(a) == compGraphNodes.get(b + <span class="hljs-number"><span class="hljs-number">2</span></span>)) { cliqueMapping.add(compGraphNodes.get(b)); cliqueMapping.add(compGraphNodes.get(b + <span class="hljs-number"><span class="hljs-number">1</span></span>)); } } }</code> </pre> <br><p>  Well, it would seem that some objects are compared in some lists, maybe everything is fine.  You must be careful to see that these lists are objects of type Integer. </p><br><h3 id="8-dublikat-v-map">  8. Duplicate in Map </h3><br><p>  In this inspection, the picture is worth a thousand words.  <a href="">See a mistake</a> ? <br><img src="https://habrastorage.org/webt/xc/ha/jh/xchajhzrjrstzxdo3uod6yatxue.png"></p><br><div class="spoiler">  <b class="spoiler_title">Is that better?</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/dr/pi/n0/drpin0xkjvcmgrkqygsldhcl5ws.png"></p></div></div><br><h3 id="9-ne-ispolzuetsya-rezultat-metoda">  9. The result of the method is not used. </h3><br><p>  The result of some methods is silly not to use, as IDEA <a href="">readily reports</a> : </p><br><pre> <code class="java hljs">currentChars.trim();</code> </pre> <br><p>  Probably meant <code>currentChars = currentChars.trim();</code>  .  Since strings in Java are immutable, if the result is not reassigned, nothing will happen.  There is also, <a href="">for example</a> , <code>str.substring(2)</code> . </p><br><p>  By the way, this is a rather complicated inspection.  In addition to a previously prepared list of methods, we sometimes try to automatically determine the methods whose result is worth using.  It requires an interprocedural analysis, both in the source text and in the bytecode of the libraries.  And all this is done on the fly in the process of editing the code! </p><br><h3 id="10-nedostizhimye-vetki-switch">  10. Unreachable switch branches </h3><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// if character is out of scope don't if (c &gt; 128) return 0; switch (c) { case '\u002d': // hyphen case '\u2012': // figure dash case '\u2013': // en-dash case '\u2014': // em-dash case '\u2212': // minus return '-'; // 002d default: return c; }</span></span></code> </pre> <br><p>  Since we have excluded characters with a code greater than 128, the <code>\u2012-\u2212</code> unreachable.  It seems not to be excluded. </p><br><h3 id="11-nedostizhimoe-uslovie">  11. Unreachable condition </h3><br><p>  An absolutely wonderful problem in the <a href="">chain of conditions</a> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oxNum == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hybrid.equals(<span class="hljs-string"><span class="hljs-string">"sp3"</span></span>)) { ... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hybrid.equals(<span class="hljs-string"><span class="hljs-string">"sp2"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">47</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oxNum == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; hybrid.equals(<span class="hljs-string"><span class="hljs-string">"sp3"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">47</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((oxNum == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; hybrid.equals(<span class="hljs-string"><span class="hljs-string">"sp3"</span></span>)) || (oxNum == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; hybrid.equals(<span class="hljs-string"><span class="hljs-string">"sp2"</span></span>)) || (oxNum == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; hybrid.equals(<span class="hljs-string"><span class="hljs-string">"sp"</span></span>))) <span class="hljs-comment"><span class="hljs-comment">// вот это вот недостижимо return 48; else if ((oxNum == 3 &amp;&amp; hybrid.equals("sp3")) || (oxNum &gt;= 2 &amp;&amp; hybrid.equals("sp2")) || (oxNum &gt;= 1 &amp;&amp; hybrid.equals("sp"))) return 49;</span></span></code> </pre> <br><p>  In complex conditional logic, this is not uncommon: we check a condition that cannot be true, because its fragment has already been checked above.  Here we have a separate branch, <code>oxNum == 0</code> , otherwise we check <code>oxNum == 0 &amp;&amp; hybrid.equals("sp")</code> , which, of course, cannot be. </p><br><h3 id="12-pishem-v-massiv-nulevoy-dliny">  12. We write to the array of zero length </h3><br><p>  Sometimes IntelliJ IDEA will notice if you are writing to an array <a href="">outside its size</a> : </p><br><pre> <code class="java hljs">Point3d points[] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point3d[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// завели массив на 0 элементов if (nwanted == 1) { points = new Point3d[1]; points[0] = new Point3d(aPoint); points[0].add(new Vector3d(length, 0.0, 0.0)); } else if (nwanted == 2) { // а тут пытаемся в него писать — исключение неминуемо points[0] = new Point3d(aPoint); points[0].add(new Vector3d(length, 0.0, 0.0)); points[1] = new Point3d(aPoint); points[1].add(new Vector3d(-length, 0.0, 0.0)); }</span></span></code> </pre> <br><h3 id="13-proverka-dliny-posle-obrascheniya-po-indeksu">  13. Length check after indexing </h3><br><p>  Another common problem with the order of actions and again <a href="">during error handling</a> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setParameters</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object[] params)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> CDKException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (params.length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CDKException(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(params[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Integer)) { <span class="hljs-comment"><span class="hljs-comment">// раз прочитали нулевой элемент throw new CDKException("The parameter must be of type Integer"); } if (params.length == 0) return; // то длина точно не нуль maxIterations = (Integer) params[0]; }</span></span></code> </pre> <br><p>  In the case of an empty array, the author of the code wanted to go out quietly, but because of the verification, he would come out, loudly banging an ArrayIndexOutOfBoundsException.  Obviously, the order of checks violated. </p><br><h3 id="14-proverka-na-null-posle-obrascheniya">  14. Check for null after a call. </h3><br><p>  And again, the order of actions is violated, <a href="">this time with null</a> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!line.startsWith(<span class="hljs-string"><span class="hljs-string">"frame:"</span></span>) &amp;&amp; input.ready() &amp;&amp; line != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { line = input.readLine(); logger.debug(lineNumber++ + <span class="hljs-string"><span class="hljs-string">": "</span></span>, line); }</code> </pre> <br><p>  IDEA writes that <code>line != null</code> always true.  It happens that verification is really redundant, but here the code looks as if null can really be. </p><br><h3 id="15-dizyunkciya-vmesto-konyunkcii">  15. Disjunction instead of conjunction </h3><br><p>  People often confuse logical operators AND and OR.  The CDK project is <a href="">no exception</a> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rStereo != <span class="hljs-number"><span class="hljs-number">4</span></span> || pStereo != <span class="hljs-number"><span class="hljs-number">4</span></span> || rStereo != <span class="hljs-number"><span class="hljs-number">3</span></span> || pStereo != <span class="hljs-number"><span class="hljs-number">3</span></span>) { ... }</code> </pre> <br><p>  Whatever <code>rStereo</code> and <code>pStereo</code> are equal to, it is clear that they cannot be equal to the four and the three at the same time, therefore this condition is always true. </p><br><h3 id="16-i-snova-dizyunkciya-vmesto-konyunkcii">  16. And again disjunction instead of conjunction </h3><br><p>  <a href="">A similar error</a> , but caught by another message: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getFirstMapping() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || !getFirstMapping().isEmpty()) { ... }</code> </pre> <br><p>  We can get to the right side only if <code>getFirstMapping()</code> returns <code>null</code> , but in this case we are guaranteed a NullPointerException, which is what IDEA warns about.  By the way, here we rely on the stability of the results of the <code>getFirstMapping()</code> method.  Sometimes we use heuristics, but here the stability is directly analyzed.  Since the class is final, the method cannot be redefined.  IDEA checks its body <code>return firstSolution.isEmpty() ? null : firstSolution</code>  <code>return firstSolution.isEmpty() ? null : firstSolution</code> and determines that stability is reduced to the stability of the <code>Map#isEmpty</code> method, which is preanantized as stable. </p><br><h3 id="17-ierarhiya-interfeysov-i-instanceof">  17. Hierarchy of interfaces and instanceof </h3><br><p>  When checking an object for belonging to any interface, do not forget that interfaces can inherit <a href="">each other</a> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (object <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> IAtomContainer) { root = convertor.cdkAtomContainerToCMLMolecule((IAtomContainer) object); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (object <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ICrystal) { root = convertor.cdkCrystalToCMLMolecule((ICrystal) object); } ...</code> </pre> <br><p>  The <code>ICrystal</code> interface <a href="">extends</a> the <code>IAtomContainer</code> interface, so the second branch is obviously unreachable: if a crystal comes here, it will fall into the first branch. </p><br><h3 id="18-obhod-pustogo-spiska">  18. Bypassing the empty list </h3><br><p>  Probably, the author of this code is <a href="">not very familiar</a> with the Java language: </p><br><pre> <code class="java hljs">List&lt;Integer&gt; posNumList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;(size); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; posNumList.size(); i++) { posNumList.add(i, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><p>  The size parameter in the <code>ArrayList</code> specifies the initial size of the internal array.  This is used to optimize to reduce the number of allocations, if you know in advance how many elements are added there.  At the same time, the actual elements in the list do not appear, and the <code>size()</code> method returns 0. Therefore, the next cycle of trying to initialize the elements of the list with zeros is completely useless. </p><br><h3 id="19-ne-zabyvaem-inicializirovat-polya">  19. Do not forget to initialize the fields </h3><br><p>  The analyzer checks constructors in a special way, taking into account field initializers.  Due to this, the <a href="">following error</a> was found: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IMatrix</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][] realmatrix; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][] imagmatrix; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rows; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> columns; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IMatrix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Matrix m)</span></span></span><span class="hljs-function"> </span></span>{ rows = m.rows; columns = m.columns; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, j; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; rows; i++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; columns; j++) { realmatrix[i][j] = m.matrix[i][j]; <span class="hljs-comment"><span class="hljs-comment">// NullPointerException гарантирован imagmatrix[i][j] = 0d; } } }</span></span></code> </pre> <br><p>  In spite of the fact that the fields are public, no one could penetrate and initialize them before the constructor.  Therefore, IDEA boldly warns that a call to an array element will cause a NullPointerException. </p><br><h3 id="20-po-dva-raza-ne-povtoryat">  20. Do not repeat twice </h3><br><p>  Repeated conditions also occur frequently.  Here is <a href="">an example</a> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (commonAtomCount &gt; vfMCSSize &amp;&amp; commonAtomCount &gt; vfMCSSize) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }</code> </pre> <br><p>  Such bugs are treacherous, because you never know, the second condition is simply superfluous, or the author wanted to check something else.  If this is not fixed right away, then it can be hard to figure it out.  This is another reason why static analysis should be used constantly. </p><br><p>  I reported some of these bugs to the <a href="https://github.com/cdk/cdk/issues">project's bug tracker</a> .  It is curious that when the authors of the project corrected a part, they themselves used the IntelliJ IDEA analyzer, found other problems about which I did not write, and also <a href="https://github.com/cdk/cdk/pull/532">began to correct them</a> .  I think this is a good sign: the authors realized the importance of static analysis. </p></div>