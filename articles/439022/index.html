<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>CNC in the hobby workshop (part 3)</title>
  <meta name="description" content="Initially, I planned to limit myself to two posts ( one , two ) about my CNC experiments. But, the topic turned out to be interesting to many, therefo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>CNC in the hobby workshop (part 3)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/ps/rt/b9/psrtb98htrntl_pcfsmcloxegei.png"><br><br>  Initially, I planned to limit myself to two posts ( <a href="https://habr.com/ru/post/437890/">one</a> , <a href="https://habr.com/ru/post/438018/">two</a> ) about my CNC experiments.  But, the topic turned out to be interesting to many, therefore, I will give it a little more.  In this post we will talk about writing home-made software for managing amateur CNC. <br><a name="habracut"></a><br><h2>  Foreword </h2><br>  I don‚Äôt know if I was able to motivate someone with the first posts, but some comments gave me good food for thought.  <a href="https://habr.com/ru/users/evilruff/">Special</a> thanks to <a href="https://habr.com/ru/users/evilruff/">@evilruff</a> for a photo of his <a href="https://habr.com/ru/post/437890/">laboratory</a> and for a video with a <a href="https://habr.com/ru/post/438018/">cool Korean</a> .  After watching the one and the other, my bardachek in the basement no longer seemed so cozy. <br><br>  Gathering his strength, on the weekend he brought something remotely resembling order and finally did 2 things that he was going to do half a year ago. <br><br>  First, he replaced a piece of plywood that served as a sacrificial table.  I used this plywood from the moment of purchase of the machine, screwing blanks to it with screws and constructing all sorts of insane structures of sticks and wedges.  All so that the item does not go into an unpredictable flight during milling. <br><br>  Can someone live hacking: a new table made of plastic decking (sold in Castorum): <br><br><img src="https://habrastorage.org/webt/yc/fv/mj/ycfvmjzxxjh35o9koqhm6fjzc-q.png"><br><br>  Bolted the boards directly to the aluminum table.  The bonus turned out convenient grooves for the workpiece clamps and quick installation of the filler table.  All about everything took a couple of hours and ~ 1100r. <br><br>  And second, finally, he wrote more or less usable software for managing non-standard CNC functions.  About this will be the main story. <br><br><h2>  Formulation of the problem </h2><br>  G-code for operations that are described in the <a href="https://habr.com/ru/post/438018/">second part is the</a> simplest.  However, the process of setting up cannot be called quick. <br><br><h3>  How did this happen </h3><br>  For example, it was necessary for the additive: knowing the width of the panel, calculate how many holes there should be, calculate the exact distance between them, create a file, write g-code, load it into Mach3.  All this takes, at best, 15 to 20 minutes. In this light, the advantages of a digital machine are considerably less than that of a hand-held tool, which can fill a whole bunch of holes during this time. <br><br><h3>  What I wanted to get </h3><br>  In the case of the same additive, I wanted to get a program where, in a very simple interface, I would enter the width and thickness of the panel and pressing the button would start the process of drilling the required number of filler holes at the same distance from each other. <br><br><h2>  Finding a solution </h2><br>  The first thing that came to mind was writing a standalone program that would directly interact with the parallel port.  A quick googling showed that the task of writing to lpt is completely solvable, but the devil is known to hide in the details.  Further study of the issue, I realized that you can get stuck here seriously and for a long time.  Moreover, such a solution would not be flexible: for another machine, for example with USB, it would not work. <br><br>  There was an option to deal with the SDK Mach3.  In the process of collecting information about the creation of mach-plug-ins, I came across an interesting solution.  It described how using OLE mechanisms you can pull Mach3 from a third-party application.  I am not an expert in Microsoft technologies, but after viewing the SDK Mach3 manual diagonally, if I got the basic idea correctly, no silver bullet exists, the plugins use the same public methods of Mach3 COM objects.  I did not intend to redraw the Mach3 interface, so the difference for the user between the plug-in and the standalon application was only that the plug-in was accessible from the Mach3 menu, and the application ‚Äî through an icon on the XP desktop. <br><br>  A separate application seemed to me preferable.  In this case, theoretically, I could immediately after starting the computer start my program, which would load Mach3 with a steam locomotive (instead of loading Mach3 first and then digging into its menu to launch the plugin). <br><br><h2>  We take up the sword </h2><br>  Last time I had to write a native desktop application for Windows a year, in 2006, and it was in Delphi.  Since then, web technologies with their Linux have completely absorbed me.  Therefore, now I didn‚Äôt have special preferences in which language to sculpt a windows program.  The simple example found was written in C #, and this language was chosen as a guinea pig. <br><br>  I will not post here the entire code of the resulting application (if you prefer, you can find it on github via the link at the bottom of the post).  I will explain the main things.  I did all the experiments on a virtual machine with WinXP SP3, VS 2003 and Mach3 Version R3.043.062.  For those who believe that it is better to see once the <a href="https://www.youtube.com/watch%3Fv%3D-IviSnDKsAY">link to the video in Youtube</a> that I understood.  Below is a transcript of the highlights. <br><br><h4>  Training </h4><br><ol><li>  In order for Visual Studio to properly pick up the Mach3 component, it is necessary that it be correctly registered in the registry.  To do this, download the file <a href="https://goo.gl/K2OAtk">Mach3Registry.reg</a> </li><li>  Run Mach3Registry.reg </li><li>  We launch VS, we create the project of the window application on C # </li><li>  In the Solution Explorer block, right-click on References, select Add Reference in the menu.  In the opened window, click Browse and look for Mach3.exe <br><br><img src="https://habrastorage.org/webt/bw/pv/tj/bwpvtjvkxx6gaivlgdkaly0z4_i.png"><br><br>  If everything is correct, a line should appear in the References list, who would have thought Mach4 ... </li><li>  5. Further we draw UI, we hang up processors, we implement algorithms ... </li></ol><br><h4>  Interaction with Mach3 </h4><br>  We connect the necessary libraries, we declare variables (Form1.cs) <br><br><pre><code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Runtime.InteropServices; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Mach4; <span class="hljs-comment"><span class="hljs-comment">// –ü–æ–¥–∫–ª—é—á–∞–µ–º –∫–æ–º–ø–æ–Ω–µ–Ω—Ç Mach namespace Cnc { public class Form1 : System.Windows.Forms.Form { private IMach4 _mach; private IMyScriptObject _mInst; ... // –ø–æ–ª—É—á–µ–Ω–∏–µ —Å—Å—ã–ª–∫–∏ –Ω–∞ –∑–∞–ø—É—â–µ–Ω–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä Mach3 private void GetMachInstance() { try { _mach = (IMach4) Marshal.GetActiveObject("Mach4.Document"); _mInst = (IMyScriptObject) _mach.GetScriptDispatch(); } catch { _mach = null; _mInst = null; } } ...</span></span></code> </pre> <br>  Using: <br><br><pre> <code class="cpp hljs">GetMachInstance(); <span class="hljs-comment"><span class="hljs-comment">// if(_mInst != null) { _mInst.DoOEMButton(1003); // –ù–∞–∂–∞—Ç–∏–µ –Ω–∞ –∫–Ω–æ–ø–∫—É Stop –≤ Mach3 _mInst.Code("G00 X100"); // –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ G-code _mInst.GetOEMDRO(800); // –ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã X }</span></span></code> </pre><br>  The codes of buttons and parameter values ‚Äã‚Äãcan be viewed on the wiki: <a href="http://www.machsupport.com/Mach3Wiki/index.php%3Ftitle%3DOEM_DROs">OEM_DROs</a> and <a href="http://www.machsupport.com/Mach3Wiki/index.php%3Ftitle%3DOEM_Buttons">OEM_Buttons</a> (their wiki podglyuchivaet, the values ‚Äã‚Äãof parameters in the table are not displayed, I looked at the tab ‚ÄúView source‚Äù). <br><br>  The first version of the program worked like this: according to the set parameters, g-code was generated which was frame-by-frame (i.e., line by line) executed by the <b>_mInst.Code</b> method.  And that was my mistake.  In the debugging environment on virtualke everything worked fine.  In Mach3 ran the correct numbers in the coordinates.  But when transferring to the machine computer, problems arose.  The carriage moved correctly, but the spindle did not turn on. <br><br>  It seems that the management of the router and the spindle in Mach works in different threads.  It turned out that the movement commands (G ...) were executed sequentially as they entered the _mInst.Code method in one thread, and the spindle control commands (M3, M5), regardless of the first, were executed in another thread.  As a result, the spindle was turned on (M3) and then turned off (M5), while the carriage movement went on as usual. <br><br>  I tried different options, connected delays, tried to drive the whole manager g-code into one line and send it in one piece in _mInst.Code.  As a result, I stopped at the ‚Äúhead on‚Äù solution: I simply pushed the generated code into a file, I open this file programmatically in Mach3, and in the same place programmatically press the ‚ÄúStart‚Äù button.  Fragment of working code: <br><br><pre> <code class="cpp hljs">_mInst.LoadFile(<span class="hljs-string"><span class="hljs-string">"C:\\tmp\\gcode.txt"</span></span>); System.Threading.Thread.Sleep(<span class="hljs-number"><span class="hljs-number">2000</span></span>); _mInst.DoOEMButton(<span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre><br>  A pause between downloading a file and pressing a button is necessary in order for Mach to have time to open the file.  Perhaps there is some more elegant way.  If anyone knows, write in the comments. <br><br>  An added bonus of this solution is that you can now observe the visualization of the processing process in the Mach interface. <br><br><h2>  What is the result? </h2><br>  Further, in a few words about the resulting application.  I will separately tell about UI for each operation. <br><br><h3>  Cutting </h3><br><img src="https://habrastorage.org/webt/xy/ny/jr/xynyjryvow1ftwsuwvss8xvyvie.png"><br><br>  It's all quite transparent.  The parameter S is needed to compensate for the size L if the workpiece is not fixed at the zero point in X (or Y in cutting along). <br><br><h3>  Additive </h3><br>  For additive, 2 snap configurations are possible.  The first with a grinder for drilling end holes.  And the second one with a conventional spindle for drilling in the plane of the shield (for some reason I called it ‚ÄúFrontal Additive‚Äù). <br><br><h4>  Additive face </h4><br><img src="https://habrastorage.org/webt/qq/mn/mi/qqmnmiv1ofy4bwpryj8n3obufcg.png"><br><br>  When the end additive is important to accurately set zero in the lower right corner of the workpiece (I have there is the angle of the side fence and the table).  It is not difficult to do this with a wood drill - there is a sharp tip that you need to get into this corner.  Fixing the workpiece on the table, I just put it in the drill. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/qvBl2Q2pg-k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Without changing the equipment in the same way, I make reciprocal holes by securing the workpiece vertically: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/8OzIyF37MWw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  The parameter X is needed in order to connect panels of different widths (for example, when the lower and upper panels of the cabinet are wider than the width of the side doors). <br><br><h4>  Frontal Additive </h4><br><img src="https://habrastorage.org/webt/ll/_k/kr/ll_kkr9enxnd-vrs_3yc5cskxsg.png"><br><br>  The tooling for the front is a normal spindle.  This type of additive is used when you need to drill holes in a horizontal surface, not only at the edges but also somewhere in the middle.  For example, if the cabinet has several compartments and there are internal besides the side walls.  If the length of the panel is greater than the length of the machine, the additive can be made in 2 sets with a turn of the part by 180 degrees.  In this case, the X parameter is also useful. <br><br><h3>  Turning </h3><br><img src="https://habrastorage.org/webt/e5/-j/e9/e5-je9dvs8fwye3vrv1rg5wsdam.png"><br><br>  For me, the main difficulty in preparing the g-code with the turning path was not to overdo it with the maximum depth of the disk.  The fact is that at the exit from Inkscape one line is obtained and the turning occurs in one pass.  Because of this, I had to make a separate code for the cylinder billet, and only after that the main pass started creating the form.  And there were some restrictions on this form.  In particular, it was necessary to ensure that the trajectory did not go too deep.  I tried not to go beyond 10 - 15mm from the level of the original cylinder. <br><br>  All the above problems were solved in the new program.  It works like this: load the ‚Äúraw‚Äù g-code obtained from Inkscape, set the size of the side of the bar of the workpiece and specify the maximum depth of processing in 1 pass (the harder the wood, the less this depth).  Based on the original g-code and parameters, the program will calculate the safe trajectory and send it to the CNC. <br><br><h2>  Future plans </h2><br>  The program has greatly simplified the routine, but it is still far from perfect.  First, it will be necessary to optimize the algorithm for drilling deep holes (the drill is clogged with chips and overheats, you need to make a swing back and forth).  Secondly, the idea to make a library of turning forms.  Those.  several typical forms (such as a cylinder, a cone, a rolling pin, etc.) with the ability to customize dimensions without the need to create trajectories in third-party programs. <br><br><h2>  Links </h2><br>  ‚Üí <a href="https://goo.gl/K2OAtk">Mach3Registry.reg</a> <br>  ‚Üí <a href="https://www.machsupport.com/downloads-updates/main-programs/">Mach3 SDK and other programs</a> <br>  ‚Üí <a href="https://github.com/Kolbaskin/CNC">The project repository on Github</a> (I apologize in advance to the sharpikov for architectural jambs - this is my first C # program). </div><p>Source: <a href="https://habr.com/ru/post/439022/">https://habr.com/ru/post/439022/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>