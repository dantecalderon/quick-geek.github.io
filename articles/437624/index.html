<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>OpenSceneGraph: Texture Basics</title>
  <meta name="description" content="Introduction 
 We have already considered an example where we painted a square in all the colors of the rainbow. Nevertheless, there is another techno...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>OpenSceneGraph: Texture Basics</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="image"><br><br><h1>  Introduction </h1><br>  We have already considered <a href="https://habr.com/ru/post/430212/">an example</a> where we painted a square in all the colors of the rainbow.  Nevertheless, there is another technology, namely the application to the three-dimensional geometry of the so-called <em>texture map,</em> or simply texture - a raster two-dimensional image.  In this case, the effect is not on the vertices of the geometry, but the data of all pixels obtained during rasterization of the scene change.  This technique can significantly increase the realism and detail of the final image. <br><br>  OSG supports several texture attributes and texturing modes.  But, before talking about textures, let's talk about how OSG deals with bitmap images.  To work with raster images, a special class is provided - osg :: Image, which stores within itself the image data intended, in the end, for texturing an object. <br><a name="habracut"></a><br><h1>  1. Representation of raster image data.  Class osg :: Image </h1><br>  The best way to load an image from disk is to use the osgDB :: readImageFile () call.  It is very similar to the osg :: readNodeFile () call that has already caused us to sink teeth.  If we have a bitmap named picture.bmp, then its download will look like this <br><br><pre><code class="cpp hljs">osg::ref_ptr&lt;osg::Image&gt; image = osgDB::readImageFile(<span class="hljs-string"><span class="hljs-string">"picture.bmp"</span></span>);</code> </pre> <br>  If the image is loaded correctly, then the pointer will be valid, otherwise the function will return NULL.  After downloading, we can get information about the image using the following public methods. <br><br><ol><li>  t (), s () and r () - return the width, height and depth of the image. <br></li><li>  data () - returns an unsigned char * pointer to raw image data.  Through this pointer, the developer can directly affect the image data.  You can get an idea of ‚Äã‚Äãthe format of image data using the getPixalFormat () and getDataType () methods.  The values ‚Äã‚Äãreturned by them are equivalent to the parameters of the format and type of OpenGL functions glTexImage * ().  For example, if a picture has the pixel format GL_RGB and the type is GL_UNSIGNED_BYTE, then three independent elements (unsigned bytes) are used to represent the RGB color component <br></li></ol><br><img src="https://habrastorage.org/webt/6g/mo/or/6gmoorwfvryg44pq7sdi0cb4l9s.png"><br><br>  You can create a new image object and allocate memory for it. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Image&gt; image = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Image; image-&gt;allocateImage(s, t, r, GL_RGB, GL_UNSIGNED_BYTE); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ptr = image-&gt;data(); <span class="hljs-comment"><span class="hljs-comment">// –î–∞–ª–µ–µ –≤—ã–ø–æ–ª–Ω—è–µ–º —Å –±—É—Ñ–µ—Ä–æ–º –¥–∞–Ω–Ω—ã—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –ª—é–±—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏</span></span></code> </pre><br>  Here s, t, r are the dimensions of the image;  GL_RGB specifies the pixel format, and GL_UNSIGNED_BYTE sets the data type to describe a single color component.  An internal data buffer of the required size is allocated in memory and is automatically destroyed if there are no references to this image. <br><br>  The OSG plug-in system supports downloading of almost all popular image formats: * .jpg, * .bmp, * .png, * .tif, and so on.  This list is easy to expand by writing your own plugin, but this is a topic for a separate conversation. <br><br><h1>  2. Basics of texturing </h1><br>  To apply a texture to a three-dimensional model, you must perform a number of steps: <br><br><ol><li>  Define the vertex texture coordinates for a geometric object (in the environment of three-dimensional designers, this is called UV-scanning). <br></li><li>  Create a texture attribute object for 1D, 2D, 3D or cubic texture. <br></li><li>  Set one or more images for the texture attribute. <br></li><li>  Attach the texture attribute and mode to the set of states applied to the object being drawn. <br></li></ol><br>  OSG defines an osg :: Texture class that encapsulates all sorts of textures.  Subclasses osg :: Texture1D, osg :: Texture2D, osg :: Texture3D and osg :: TextureCubeMap are inherited from it, which represent various texturing techniques adopted in OpenGL. <br><br>  The most commonly used method of the class osg :: Texture is setImage (), which defines the image used in the texture, for example <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Image&gt; image = osgDB::readImageFile(<span class="hljs-string"><span class="hljs-string">"picture.bmp"</span></span>); osg::ref_ptr&lt;osg::Texture2D&gt; texture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Texture2D; texture-&gt;setImage(image.get());</code> </pre><br>  or, you can pass an image object directly to a texture class constructor. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Image&gt; image = osgDB::readImageFile(<span class="hljs-string"><span class="hljs-string">"picture.bmp"</span></span>); osg::ref_ptr&lt;osg::Texture2D&gt; texture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Texture2D(image.get());</code> </pre><br>  The image can be retrieved from the texture object by calling the getImage () method. <br><br>  Another important point is to set texture coordinates for each vertex in the osg :: Geometry object.  The transfer of these coordinates occurs through the osg :: Vec2Array and osg :: Vec3Array array by calling the setTexCoordArray () method. <br><br>  After setting the texture coordinates, we need to set the texture slot number (unit), since OSG supports the imposition of several textures on the same geometry.  When using one texture, the number of the unit is always 0. For example, the following code illustrates setting the texture coordinates for unit 0 of the geometry. <br><br><pre> <code class="cpp hljs">osf::ref_ptr&lt;osg::Vec2Array&gt; texcoord = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec2Array; texcoord-&gt;push_back( osg::Vec2(...) ); ... geom-&gt;setTexCoordArray(<span class="hljs-number"><span class="hljs-number">0</span></span>, texcoord.get());</code> </pre><br>  After that, we can add a texture attribute to the state set, automatically including the appropriate texturing mode (in our example, GL_TEXTURE_2D) and apply the attribute to the geometry or node that contains the geometry <br><br><pre> <code class="cpp hljs">geom-&gt;getOrCreateStateSet()-&gt;setTextureAttributeAndModes(texture.get());</code> </pre><br>  Please note that OpenGL manages image data in the graphics card's graphic memory, but the osg :: Image object along with the same data is located in the system memory.  As a result, we will face the fact that we have two copies of the same data, taking up the memory of the process.  If this image is not shared by several texture attributes, you can remove it from the system memory immediately after OpenGL transfers it to the video adapter memory.  To enable this feature, the osg :: Texture class provides the appropriate method. <br><br><pre> <code class="cpp hljs">texture-&gt;setUnRefImageDataAfterApply( <span class="hljs-literal"><span class="hljs-literal">true</span></span> );</code> </pre> <br><h1>  3. Load and apply 2D texture </h1><br>  The most commonly used 2D texturing technique is to overlay a two-dimensional image (or images) on the edge of a three-dimensional surface.  Consider the simplest example of applying a single texture to a quadrilateral polygon. <br><br><div class="spoiler">  <b class="spoiler_title">Texture example</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Texture2D&gt; #include &lt;osg/Geometry&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back( osg::Vec3(-0.5f, 0.0f, -0.5f) ); vertices-&gt;push_back( osg::Vec3( 0.5f, 0.0f, -0.5f) ); vertices-&gt;push_back( osg::Vec3( 0.5f, 0.0f, 0.5f) ); vertices-&gt;push_back( osg::Vec3(-0.5f, 0.0f, 0.5f) ); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back( osg::Vec3(0.0f, -1.0f, 0.0f) ); osg::ref_ptr&lt;osg::Vec2Array&gt; texcoords = new osg::Vec2Array; texcoords-&gt;push_back( osg::Vec2(0.0f, 0.0f) ); texcoords-&gt;push_back( osg::Vec2(0.0f, 1.0f) ); texcoords-&gt;push_back( osg::Vec2(1.0f, 1.0f) ); texcoords-&gt;push_back( osg::Vec2(1.0f, 0.0f) ); osg::ref_ptr&lt;osg::Geometry&gt; quad = new osg::Geometry; quad-&gt;setVertexArray(vertices.get()); quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setTexCoordArray(0, texcoords.get()); quad-&gt;addPrimitiveSet( new osg::DrawArrays(GL_QUADS, 0, 4) ); osg::ref_ptr&lt;osg::Texture2D&gt; texture = new osg::Texture2D; osg::ref_ptr&lt;osg::Image&gt; image = osgDB::readImageFile("../data/Images/lz.rgb"); texture-&gt;setImage(image.get()); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(quad.get()); root-&gt;getOrCreateStateSet()-&gt;setTextureAttributeAndModes(0, texture.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Create an array of vertices and normals to the edge. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; vertices-&gt;push_back( osg::Vec3(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>) ); vertices-&gt;push_back( osg::Vec3( <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>) ); vertices-&gt;push_back( osg::Vec3( <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) ); vertices-&gt;push_back( osg::Vec3(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) ); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; normals-&gt;push_back( osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) );</code> </pre><br>  Create an array of texture coordinates <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec2Array&gt; texcoords = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec2Array; texcoords-&gt;push_back( osg::Vec2(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) ); texcoords-&gt;push_back( osg::Vec2(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); texcoords-&gt;push_back( osg::Vec2(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); texcoords-&gt;push_back( osg::Vec2(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) );</code> </pre><br>  The point is that each vertex of the three-dimensional model corresponds to a point on the two-dimensional texture, and the coordinates of the point on the texture are relative - they are normalized to the actual width and height of the image.  We want to stretch the entire loaded image onto the square, respectively, the corners of the square will correspond to the texture points (0, 0), (0, 1), (1, 1) and (1, 0).  The order of the vertices in the array of vertices must be the same as the order of the texture vertices. <br><br>  Next, create a square, assigning to the geometry an array of vertices and an array of normals <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Geometry&gt; quad = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geometry; quad-&gt;setVertexArray(vertices.get()); quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setTexCoordArray(<span class="hljs-number"><span class="hljs-number">0</span></span>, texcoords.get()); quad-&gt;addPrimitiveSet( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawArrays(GL_QUADS, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) );</code> </pre><br>  Create a texture object and load the image used for it. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Texture2D&gt; texture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Texture2D; osg::ref_ptr&lt;osg::Image&gt; image = osgDB::readImageFile(<span class="hljs-string"><span class="hljs-string">"../data/Images/lz.rgb"</span></span>); texture-&gt;setImage(image.get());</code> </pre><br>  Create the root node of the scene and put the geometry we created there. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Geode&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geode; root-&gt;addDrawable(quad.get());</code> </pre><br>  and finally apply the texture attribute to the node where the geometry is placed <br><br><pre> <code class="cpp hljs">root-&gt;getOrCreateStateSet()-&gt;setTextureAttributeAndModes(<span class="hljs-number"><span class="hljs-number">0</span></span>, texture.get());</code> </pre><br><img src="https://habrastorage.org/webt/wm/2a/fy/wm2afywfx6dnkhwaagvceqkycd8.png"><br><br>  The osg :: Texture2D class determines whether the dimensions of a texture image are multiples of a power of two (for example, 64x64 or 256x512) automatically scaling images that do not fit in size, in fact, using the OpenScL function gluScaleImage ().  There is a setResizeNonPowerOfTwoHint () method that determines whether or not to resize an image.  Some video cards require multiplicity of image size of a power of two, while the class osg :: Texture2D supports work with an arbitrary texture size. <br><br><h1>  Something about the texture mapping mode. </h1><br>  As we have already said, the texture coordinates are normalized from 0 to 1. The point (0, 0) corresponds to the upper left corner of the image, and the point (1, 1) corresponds to the lower right corner.  What happens if you set texture coordinates greater than one? <br><br>  By default, in OpenGL, as in OSG, the texture will be repeated in the direction of the axis, the value of the texture coordinate will exceed unity.  This technique is often used, for example, to create a model of a long brick wall, using a small texture, repeating its imposition many times in both width and height. <br><br>  This behavior can be controlled through the setWrap () method of the osg :: Texture class.  As the first parameter, the method takes the axis identifier to which the blending mode should be applied, transmitted as the second parameter, for example <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// –ü–æ–≤—Ç–æ—Ä—è—Ç—å —Ç–µ–∫—Å—Ç—É—Ä—É –ø–æ –æ—Å–∏ s texture-&gt;setWrap( osg::Texture::WRAP_S, osg::Texture::REPEAT ); // –ü–æ–≤—Ç–æ—Ä—è—Ç—å —Ç–µ–∫—Å—Ç—É—Ä—É –ø–æ –æ—Å–∏ r texture-&gt;setWrap( osg::Texture::WRAP_R, osg::Texture::REPEAT );</span></span></code> </pre><br>  This code clearly indicates to the engine to repeat the texture along the axes s and r, if the values ‚Äã‚Äãof texture coordinates exceed 1. Full list by the texture mapping mode: <br><br><ol><li>  REPEAT - repeat texture. <br></li><li>  MIRROR - repeat texture, reflecting mirror. <br></li><li>  CLAMP_TO_EDGE ‚Äî Coordinates outside the 0 to 1 bind to the corresponding texture edge. <br></li><li>  CLAMP_TO_BORDER - coordinates that go beyond the limits from 0 to 1 will give the user-set border color. <br></li></ol><br><h1>  4. Render to texture </h1><br>  The texture rendering technique allows the developer to create a texture based on some three-dimensional sub-stage or model and apply it to the surface on the main scene.  This technology is often called "baking" texture. <br><br>  For dynamic baking texture, you must perform three steps: <br><br><ol><li>  Create a texture object for rendering into it. <br></li><li>  Render the scene to texture. <br></li><li>  Use the resulting texture as intended. <br></li></ol><br>  We need to create an empty texture object.  OSG allows you to create an empty texture of a given size.  The setTextureSize () method allows you to set the width and height of the texture, as well as the depth as an additional parameter (for 3D textures). <br><br>  To render a texture to texture, attach it to a camera object by calling the attach () method, which takes a texture object as an argument.  In addition, this method takes an argument indicating which part of the frame buffer should be rendered to this texture.  For example, to transfer the color buffer to the texture, run the following code. <br><br><pre> <code class="cpp hljs">camera-&gt;attach( osg::Camera::COLOR_BUFFER, texture.get() );</code> </pre><br>  Other parts of the frame buffer available for rendering include the depth buffer DEPTH_BUFFER, the stencil buffer STENCIL_BUFFER, and additional color buffers from COLOR_BUFFER0 to COLOR_BUFFER15.  The presence of additional color buffers and their number is determined by the video card model. <br><br>  In addition, for the camera rendering the texture, the parameters of the projection and viewport matrix should be set, the size of which corresponds to the size of the texture.  The texture will be updated in the process of drawing each frame.  Please note that the main camera should not be used for rendering to the texture, since it provides the rendering of the main scene and you just get a black screen.  This requirement may not be fulfilled only when you perform off-screen rendering. <br><br><h1>  5. An example of the implementation of rendering to texture </h1><br>  To demonstrate the rendering technique into texture, we will implement such a task: create a square, drag a square texture onto it, and render a animated scene into the texture, of course, with our favorite.  The program that implements the example is quite voluminous.  However, I still give her the full source code. <br><br><div class="spoiler">  <b class="spoiler_title">Texrender example</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Camera&gt; #include &lt;osg/Texture2D&gt; #include &lt;osg/MatrixTransform&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgGA/TrackballManipulator&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osg::Geometry *createQuad(const osg::Vec3 &amp;pos, float w, float h) { osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back( pos + osg::Vec3( w / 2, 0.0f, -h / 2) ); vertices-&gt;push_back( pos + osg::Vec3( w / 2, 0.0f, h / 2) ); vertices-&gt;push_back( pos + osg::Vec3(-w / 2, 0.0f, h / 2) ); vertices-&gt;push_back( pos + osg::Vec3(-w / 2, 0.0f, -h / 2) ); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back(osg::Vec3(0.0f, -1.0f, 0.0f)); osg::ref_ptr&lt;osg::Vec2Array&gt; texcoords = new osg::Vec2Array; texcoords-&gt;push_back( osg::Vec2(1.0f, 1.0f) ); texcoords-&gt;push_back( osg::Vec2(1.0f, 0.0f) ); texcoords-&gt;push_back( osg::Vec2(0.0f, 0.0f) ); texcoords-&gt;push_back( osg::Vec2(0.0f, 1.0f) ); osg::ref_ptr&lt;osg::Geometry&gt; quad = new osg::Geometry; quad-&gt;setVertexArray(vertices.get()); quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setTexCoordArray(0, texcoords.get()); quad-&gt;addPrimitiveSet(new osg::DrawArrays(GL_QUADS, 0, 4)); return quad.release(); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Node&gt; sub_model = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::MatrixTransform&gt; transform1 = new osg::MatrixTransform; transform1-&gt;setMatrix(osg::Matrix::rotate(0.0, osg::Vec3(0.0f, 0.0f, 1.0f))); transform1-&gt;addChild(sub_model.get()); osg::ref_ptr&lt;osg::Geode&gt; model = new osg::Geode; model-&gt;addChild(createQuad(osg::Vec3(0.0f, 0.0f, 0.0f), 2.0f, 2.0f)); int tex_widht = 1024; int tex_height = 1024; osg::ref_ptr&lt;osg::Texture2D&gt; texture = new osg::Texture2D; texture-&gt;setTextureSize(tex_widht, tex_height); texture-&gt;setInternalFormat(GL_RGBA); texture-&gt;setFilter(osg::Texture2D::MIN_FILTER, osg::Texture2D::LINEAR); texture-&gt;setFilter(osg::Texture2D::MAG_FILTER, osg::Texture2D::LINEAR); model-&gt;getOrCreateStateSet()-&gt;setTextureAttributeAndModes(0, texture.get()); osg::ref_ptr&lt;osg::Camera&gt; camera = new osg::Camera; camera-&gt;setViewport(0, 0, tex_widht, tex_height); camera-&gt;setClearColor(osg::Vec4(1.0f, 1.0f, 1.0f, 1.0f)); camera-&gt;setClearMask(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); camera-&gt;setRenderOrder(osg::Camera::PRE_RENDER); camera-&gt;setRenderTargetImplementation(osg::Camera::FRAME_BUFFER_OBJECT); camera-&gt;attach(osg::Camera::COLOR_BUFFER, texture.get()); camera-&gt;setReferenceFrame(osg::Camera::ABSOLUTE_RF); camera-&gt;addChild(transform1.get()); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(model.get()); root-&gt;addChild(camera.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); viewer.setCameraManipulator(new osgGA::TrackballManipulator); viewer.setUpViewOnSingleScreen(0); camera-&gt;setProjectionMatrixAsPerspective(30.0, static_cast&lt;double&gt;(tex_widht) / static_cast&lt;double&gt;(tex_height), 0.1, 1000.0); float dist = 100.0f; float alpha = 10.0f * 3.14f / 180.0f; osg::Vec3 eye(0.0f, -dist * cosf(alpha), dist * sinf(alpha)); osg::Vec3 center(0.0f, 0.0f, 0.0f); osg::Vec3 up(0.0f, 0.0f, -1.0f); camera-&gt;setViewMatrixAsLookAt(eye, center, up); float phi = 0.0f; float delta = -0.01f; while (!viewer.done()) { transform1-&gt;setMatrix(osg::Matrix::rotate(static_cast&lt;double&gt;(phi), osg::Vec3(0.0f, 0.0f, 1.0f))); viewer.frame(); phi += delta; } return 0; }</span></span></span></span></code> </pre><br></div></div><br>  To create a square, we write a separate free function. <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">Geometry *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createQuad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osg::Vec3 &amp;pos, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> w, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> h)</span></span></span><span class="hljs-function"> </span></span>{ osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; vertices-&gt;push_back( pos + osg::Vec3( w / <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, -h / <span class="hljs-number"><span class="hljs-number">2</span></span>) ); vertices-&gt;push_back( pos + osg::Vec3( w / <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, h / <span class="hljs-number"><span class="hljs-number">2</span></span>) ); vertices-&gt;push_back( pos + osg::Vec3(-w / <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, h / <span class="hljs-number"><span class="hljs-number">2</span></span>) ); vertices-&gt;push_back( pos + osg::Vec3(-w / <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, -h / <span class="hljs-number"><span class="hljs-number">2</span></span>) ); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; normals-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>)); osg::ref_ptr&lt;osg::Vec2Array&gt; texcoords = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec2Array; texcoords-&gt;push_back( osg::Vec2(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); texcoords-&gt;push_back( osg::Vec2(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) ); texcoords-&gt;push_back( osg::Vec2(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) ); texcoords-&gt;push_back( osg::Vec2(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); osg::ref_ptr&lt;osg::Geometry&gt; quad = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geometry; quad-&gt;setVertexArray(vertices.get()); quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setTexCoordArray(<span class="hljs-number"><span class="hljs-number">0</span></span>, texcoords.get()); quad-&gt;addPrimitiveSet(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawArrays(GL_QUADS, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> quad.release(); }</code> </pre><br>  The function takes as input the position of the center of the square and its geometric dimensions.  Next, an array of vertices, an array of normals and texture coordinates is created, after which the created geometry is returned from the function. <br><br>  In the body of the main program we will load the model of Cessna <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; sub_model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg"</span></span>);</code> </pre><br>  In order to animate this model, create and initialize the transformation of rotation around the Z axis. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::MatrixTransform&gt; transform1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::MatrixTransform; transform1-&gt;setMatrix(osg::Matrix::rotate(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>))); transform1-&gt;addChild(sub_model.get());</code> </pre><br>  Now create a model for the main scene - the square on which we will render <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Geode&gt; model = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geode; model-&gt;addChild(createQuad(osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>), <span class="hljs-number"><span class="hljs-number">2.0f</span></span>, <span class="hljs-number"><span class="hljs-number">2.0f</span></span>));</code> </pre><br>  Create an empty texture for a 1024x1024 pixel square with an RGBA pixel format (32-bit three-component color with alpha channel) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tex_widht = <span class="hljs-number"><span class="hljs-number">1024</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tex_height = <span class="hljs-number"><span class="hljs-number">1024</span></span>; osg::ref_ptr&lt;osg::Texture2D&gt; texture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Texture2D; texture-&gt;setTextureSize(tex_widht, tex_height); texture-&gt;setInternalFormat(GL_RGBA); texture-&gt;setFilter(osg::Texture2D::MIN_FILTER, osg::Texture2D::LINEAR); texture-&gt;setFilter(osg::Texture2D::MAG_FILTER, osg::Texture2D::LINEAR);</code> </pre><br>  Apply this texture to the square model. <br><br><pre> <code class="cpp hljs">model-&gt;getOrCreateStateSet()-&gt;setTextureAttributeAndModes(<span class="hljs-number"><span class="hljs-number">0</span></span>, texture.get());</code> </pre><br>  Then create a camera that will bake the texture. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Camera&gt; camera = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Camera; camera-&gt;setViewport(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, tex_widht, tex_height); camera-&gt;setClearColor(osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); camera-&gt;setClearMask(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</code> </pre><br>  Viewport camera in size coincides with the size of the texture.  In addition, do not forget to set the background color when cleaning the screen and the cleaning mask, indicating to clear both the color buffer and the depth buffer.  Next, set up the camera to render into texture <br><br><pre> <code class="cpp hljs">camera-&gt;setRenderOrder(osg::Camera::PRE_RENDER); camera-&gt;setRenderTargetImplementation(osg::Camera::FRAME_BUFFER_OBJECT); camera-&gt;attach(osg::Camera::COLOR_BUFFER, texture.get());</code> </pre><br>  The rendering order PRE_RENDER indicates that this camera is rendered before rendering to the main scene.  We specify FBO as the target of the render and attach our texture to the camera.  Now we tune the camera to work in the absolute coordinate system, and as a scene we set our subtree, which we want to render into the texture: transformation of the rotation with the model of Cessna attached to it <br><br><pre> <code class="cpp hljs">camera-&gt;setReferenceFrame(osg::Camera::ABSOLUTE_RF); camera-&gt;addChild(transform1.get());</code> </pre><br>  Create a root group node, adding to it the main model (square) and camera processing texture <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Group&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Group; root-&gt;addChild(model.get()); root-&gt;addChild(camera.get());</code> </pre><br>  Create and customize viewer <br><br><pre> <code class="cpp hljs">osgViewer::Viewer viewer; viewer.setSceneData(root.get()); viewer.setCameraManipulator(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osgGA::TrackballManipulator); viewer.setUpViewOnSingleScreen(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  Configuring the projection matrix for the camera - a perspective projection through the parameters of the clipping pyramid <br><br><pre> <code class="cpp hljs">camera-&gt;setProjectionMatrixAsPerspective(<span class="hljs-number"><span class="hljs-number">30.0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(tex_widht) / <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(tex_height), <span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-number"><span class="hljs-number">1000.0</span></span>);</code> </pre><br>  Adjust the view matrix, which sets the position of the camera in space with respect to the origin of the sub-price from <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist = <span class="hljs-number"><span class="hljs-number">100.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> alpha = <span class="hljs-number"><span class="hljs-number">10.0f</span></span> * <span class="hljs-number"><span class="hljs-number">3.14f</span></span> / <span class="hljs-number"><span class="hljs-number">180.0f</span></span>; osg::<span class="hljs-function"><span class="hljs-function">Vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eye</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, -dist * cosf(alpha), dist * sinf(alpha))</span></span></span></span>; osg::<span class="hljs-function"><span class="hljs-function">Vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">center</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; osg::<span class="hljs-function"><span class="hljs-function">Vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">up</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-1.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; camera-&gt;setViewMatrixAsLookAt(eye, center, up);</code> </pre><br>  Finally, we animate and display the scene by changing the angle of the plane's rotation around the Z axis on each frame. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> phi = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> delta = <span class="hljs-number"><span class="hljs-number">-0.01f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!viewer.done()) { transform1-&gt;setMatrix(osg::Matrix::rotate(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(phi), osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>))); viewer.frame(); phi += delta; }</code> </pre><br>  As a result, we get a rather interesting picture. <br><br><img src="https://habrastorage.org/webt/se/g1/jr/seg1jrflbtmzfkb5cbtwys1hleg.gif"><br><br>  In this example, we implemented some scene animation, but remember that expanding the run () loop and changing the rendering parameters before or after rendering a frame is not a safe task from the point of view of organizing access to data from different streams.  Since OSG uses multi-threaded rendering, there are regular mechanisms for embedding your own actions in the rendering process, providing thread-safe access to data. <br><br><h1>  6. Saving the result of rendering to a file </h1><br>  OSG supports the ability to attach an osg :: Image object to the camera and save the contents of the frame buffer to the image data buffer.  After that, it is possible to save this data to disk using the osg :: writeImageFile () function <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Image&gt; image = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Image; image-&gt;allocateImage( width, height, <span class="hljs-number"><span class="hljs-number">1</span></span>, GL_RGBA, GL_UNSIGNED_BYTE ); camera-&gt;attach( osg::Camera::COLOR_BUFFER, image.get() ); ... osgDB::writeImageFile( *image, <span class="hljs-string"><span class="hljs-string">"saved_image.bmp"</span></span> );</code> </pre><br><h1>  Conclusion </h1><br>  Perhaps the material described in the article will seem trivial.  However, it outlines the very basics of working with textures in OpenSceneGraph, which are based on more complex techniques for working with this engine, which we will definitely talk about in the future. <br><br>  <i><a href="https://habr.com/ru/post/437688/">To be continued...</a></i> </div><p>Source: <a href="https://habr.com/ru/post/437624/">https://habr.com/ru/post/437624/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>