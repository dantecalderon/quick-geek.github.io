<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using DBREPLICATION when rolling out databases on Microsoft SQL Server</title>
  <meta name="description" content="For corporate accounting systems characterized by a gradual increase in the volume of databases due to the accumulation of historical information. Ove...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Using DBREPLICATION when rolling out databases on Microsoft SQL Server</h1><div class="post__text post__text-html js-mediator-article">  For corporate accounting systems characterized by a gradual increase in the volume of databases due to the accumulation of historical information.  Over time, the size of the database can reach such size that it provokes a number of problems with performance, service, available disk space and so on.  Today we will consider two approaches to solving this problem: increasing hardware resources and convolving historical data. <br><br><img src="https://habrastorage.org/webt/be/xv/ok/bexvokyatldfnkxeh_vtgjuz27m.jpeg"><a name="habracut"></a><br><br><h2>  Introduction </h2><br><p>  This article deals with the problem of convolution of very large databases on the MS SQL Server platform.  Describes the solution to this problem using the technology of replication DBREPLICATION from Softpoint. </p><br><h2>  Problematics </h2><br><p>  Each type of accounting systems may begin to show their own specific features.  For example, in systems on the 1C platform, there are problems with such regulatory operations as updating the configuration, updating the 1C platform.  As the database grows, the situation gradually worsens, and sooner or later it is necessary to take measures. </p><br><h2>  Approach # 1: hardware </h2><br><p>  The most obvious and technically transparent solution is to increase hardware resources.  This can be either the purchase of more efficient servers, disk storage, etc., or the rental of more powerful equipment in a third-party data center or cloud. </p><br><p>  If you go this way, then a good option is to host the database in the Microsoft Azure cloud.  Azure provides several options for the database deployment architecture: MS SQL on the Azure virtual machine, and three variants of the Azure SQL database in the cloud.  Therefore, it is possible to choose the most optimal placement option depending on the characteristics of a particular database and the conditions of its operation. </p><br><p>  Azure has a number of advantages compared with buying your own equipment.  One of the main ones is the enormous hardware power that Azure can provide.  As well as a flexible approach to the use of these capacities depending on the actual load.  For example, you can buy additional capacity for the period of the ‚Äúhigh season‚Äù of your business, or at the time of the close of the reporting period, in order to easily pass the peaks.  And the rest of the time, use a more budgetary configuration of resources.  Thus, on the one hand, you have access to the huge resource potential of Azure at the right moment (which, by the way, is growing all the time), but on the other hand, you can not overpay for excess capacity when you do not need it. </p><br><p>  However, despite its relative simplicity, increasing hardware resources is not a universal solution.  Firstly, the positive effect often turns out to be far out of proportion with financial investments (there are many investments - there is little effect).  Secondly, the effect is temporary, as the base continues to grow and requires more and more resources, more and more financial investments. </p><br><p>  In any case, this approach is quite right to life, and is widely used.  But we will not dwell on it anymore, since the main goal of the article is not the ‚Äúhardware‚Äù approach, but the ‚Äúsoftware‚Äù approach outlined below. </p><br><h2>  Approach # 2: base convolution </h2><br><p>  A more radical solution is the convolution of the base, that is, the removal from it of non-relevant historical data.  In a collapsed database, data remain only for a relatively short operational period, usually it is no more than 1-2 years.  Obviously, the degree of reduction in each case is different, and it is difficult to name any specific numbers.  And yet, let‚Äôs take as a guideline the rate of reducing the base by 50‚Äì70%, that is, about 2-3 times, about as much and most often turns out in practice, less, or vice versa more - it happens rarely. </p><br><p>  We will not dwell on the resulting gain.  Obviously, if the base is reduced by a factor of 2‚Äì3 or more, the performance effect will be very powerful and long-term, and additional investments in the hardware component can be avoided.  A convolution mechanism, once developed and run-in, can be reused in the future.  In general, this is a great effective solution that is guaranteed to give a result. </p><br><h2>  The complexity of the implementation of the convolutions </h2><br><p>  But with all its effectiveness, the convolution has one very big problem.  And the matter is not in the development of the convolution mechanism itself.  Yes, this development is also a difficult task, but it is somehow solved.  The thing is different.  When a database has a size of several hundred gigabytes or has stepped over a terabyte boundary, it turns out that it is physically quite problematic to perform a convolution operation.  Inevitably, a whole complex of interrelated difficulties arises, we consider them. </p><br><ul><li>  Resource-consuming convolution operations - the equipment is heavily loaded. <br><ul><li>  The convolution does not just physically remove a large amount of data, but also performs many related resource-intensive operations: various selections, checks, groupings, indexing, logging, data movement between tables, and so on.  This fact is especially important because the collapsible database, as a rule, is already heavily loaded without it, and it has no excess capacity. </li></ul></li><li>  Interference to users. <br><ul><li>  It is extremely difficult or even impossible to perform the convolution directly in the working database in parallel with the work of users due to the high additional load and locks created by the convolution process. </li></ul></li><li>  There is no technological window. <br><ul><li>  There is simply no technological window of sufficient duration when users are not working;  After all, the process of folding for bases of this size is usually tens of hours or several days. </li></ul></li><li>  High risks when rolling directly to the working base. <br><ul><li>  The approach, when the convolution algorithm is applied directly in the working base, is in itself highly risky for a number of reasons.  One of them is that the possibilities for final verification of the results of convolutions are very limited (there is no time). </li></ul></li><li>  Unacceptable duration of the iterative approach. <br><ul><li>  You can try to avoid a bottleneck - the technological window, and perform pruning directly in the productive base in iteratively small portions, selecting the size of each portion so that it fits into the existing technological windows.  But this path is also most often inapplicable, because, firstly, the pruning process stretches for an unacceptably long period (many weeks or months), secondly, the complexity of the folding mechanism, the total costs of ensuring an uninterrupted pruning process for such a long period , dramatically increase the risks of the project as a whole. </li></ul></li><li>  How to compress the voids in the data file !? <br><ul><li>  In the course of removing historical information from the database, its data file does not actually decrease (and often even increases a little), just huge voids arise inside it.  And we must somehow get rid of them so that the data file is reduced.  Otherwise, the gain is lost in terms of disk space.  One option is to perform a typical SHRINK.  And on such volumes it is a very long procedure (many hours, or even tens of hours). </li></ul></li></ul><br><p>  Thus, the convolution is a very nontrivial task.  It is not enough to develop a folding mechanism, it also needs to be applied.  Moreover, it is often the application becomes a bottleneck. </p><br><blockquote><p>  Note: Next, we leave behind the brackets the development of the convolution mechanism itself (in other words, the algorithm for deleting historical data), no matter what means it is created.  And we focus only on the application in combat of an already implemented mechanism. </p></blockquote><br><h2>  DBREPLICATION Solution </h2><br><p>  It would seem a dead end.  But there are still exits.  There is an effective technique that allows you to unravel the whole tangle of difficulties, remove risks and guaranteed to achieve the goal.  It involves the use of data exchange technology DBREPLICATION.  The solution is suitable for both the traditional infrastructure option and the cloud Microsoft Azure.  Briefly, the essence is as follows. </p><br><ul><li>  A clone of the base is created, one-way data exchange between the clone and the main base is configured via DBREPLICATION.  It is allowed for the main base and / or its clone to be placed (both or one of them) in the Microsoft Azure cloud. </li><li>  In the clone, users do not work, the convolution process starts there.  Since the process of folding does not bother anyone, it can last there round the clock without interruption for as long as it takes.  Thus, the binding to the duration of the technological window disappears! </li><li>  Users without interference work in the main database.  And DBREPLICATION technology automatically transfers all changes from the main database to the collapsible one at high speed.  Thus, the clone is up to date from the point of view of operational data. </li><li>  After the completion of the convolution, as a rule, detailed verification of the result is carried out with the involvement of technical specialists and the Customer‚Äôs business users.  And this process can take a long time (several hours or days).  In the considered methodology, there is practically no time limit; therefore, it is possible to allocate as much time for verification as is required. </li><li>  After the completion of the convolution and verification, all users switch to the trimmed clone, and from that moment it becomes the main base.  And the original uncircumcised database serves as an archive of historical data. <br><ul><li>  An additional advantage is the ability to switch replication in the opposite direction at the time of transition of users to the collapsed database.  This gives additional security, because if ‚Äúsomething goes wrong‚Äù, you can quickly switch users back to the uncircumcised database without losing the entered data. </li></ul></li><li>  If there is a need to keep the archived database up to date, you can switch the replication in the opposite direction, and transfer the changes already from the collapsed database to the archived one. </li></ul><br><p>  Fig.1.  Schematic diagram of database trimming using DBREPLICATION technology. </p><br><img src="https://habrastorage.org/webt/iq/sr/w6/iqsrw6aiiprzrf_k1wnlft-s3du.png"><br><br><p>  Fig.2.  Option with the deployment of collapsible database in the cloud MS Azure. </p><br><img src="https://habrastorage.org/webt/fk/23/j1/fk23j1d1yukqu596txi2dijocoq.png"><br><br><p>  Thus, the described convolution technique in the clone base will embroider all bottlenecks.  Eliminates dependency on technology window.  In the clone of the convolution does not bother anyone, and no one bothers her.  You can safely use the maximum clone resources, and also pay enough attention to the final verification. </p><br><p>  It remains to figure out which exchange technology can be used in this scheme?  Why DBReplication? </p><br><h2>  Why DBReplication? </h2><br><p>  In the described method, the key element is the exchange technology, which provides synchronization of the database being trimmed with the main one.  In principle, the exchange technology can be any if it satisfies the three mandatory key conditions: </p><br><ul><li>  Compatibility with the platform of the business application, the base of which is minimized. </li></ul><br><blockquote><p>  Example: If we turn off the base 1C, then not every exchange technology is compatible with the structure of the base 1C, in particular the classical MS Transaction Replication is not compatible, as it makes changes to the structure of the tables. </p></blockquote><br><ul><li>  Performance.  Exchange technology must be guaranteed to cope with the flow of changes that occurs in the working base during the convolution time. </li></ul><br><blockquote><p>  Explanation: in this article, we primarily mean highly loaded databases with a high intensity of data changes.  A convolution will last dozens of hours, maybe several days, perhaps there will not even be one iteration of the convolution.  During this time, users will make huge changes.  Many exchange technologies simply do not handle.  And you need not just to cope, it is desirable to cope with the stock. </p></blockquote><br><ul><li>  Principal applicability to the conditions of the problem. </li></ul><br><blockquote><p>  Explanation: it is possible that this item looks self-evident, but we will nevertheless single out it.  Namely: do not forget that our data in the source database and in the clone are not equal to each other!  This fact automatically sweeps aside a whole class of powerful and productive technologies based on synchronization of transaction logs - always on, log shipping, mirroring, etc. </p></blockquote><br><p>  In addition, the exchange technology should be effective in terms of other indicators: </p><br><ul><li>  Reliability and autonomy of operation.  Since we are talking about transferring huge amounts of data, and for quite a long time, the project team simply will not have the physical ability to manually deal with issues of exchange, collisions and failures, data quality checking, etc.  Therefore, the exchange technology should be as reliable as possible in terms of the quality of the transmitted data, as autonomous and automated as possible. </li><li>  Quality user interfaces for control and management. </li><li>  Easy deployment and configuration.  Exchange technology should not impose excessively high requirements on the qualifications of specialists for its configuration. </li></ul><br><p> Without these qualities, the exchange technology threatens to turn from a saving key element of the methodology into its ‚Äúweak link‚Äù, brings serious risks and threatens the entire project.  And then the original idea loses its meaning. </p><br><p>  However, the DBReplication technology certainly satisfies all the requirements and ensures the success of the convolution project. </p><br><p>  Note the main factors due to which DBReplication succeeds in this task: </p><br><ul><li>  Very high exchange rate.  Note some features that provide speed: <br><ul><li>  DBReplication is transactional replication, each change begins to be transmitted immediately after the transaction is committed; </li><li>  In the internal architecture of the transport subsystem, such solutions are applied as multi-threaded parallel queue processing, a pipeline approach, streaming compression, transaction batch processing, using Bulk Insert and others. </li></ul></li><li>  Transport is implemented on the basis of Windows services, equipped with many functions to ensure uninterrupted operation.  These include: automatic recovery of exchange after communication breaks, working on weak unstable communication channels, automatic handling of versionality conflicts (for two-way exchange), automatic adaptation in case of changes in the structure of business application tables, and others. </li><li>  The mechanism of guaranteed data delivery.  Strict adherence to transactional integrity and consistency in the transfer of changes. </li><li>  Does not change the structure of the business application tables.  Therefore, in particular, it can be successfully used for the convolution of 1C bases. </li><li>  An advanced user interface that allows you to centrally manage the ‚Äúone-window‚Äù exchange system, all service information is collected and displayed online. </li><li>  Easy deployment and configuration. </li><li>  Adapted for 1C platform.  The user does not work with tables, but with familiar 1C metadata objects. </li><li>  Any versions of MS SQL, starting from 2005, from Standard to Enterprise, both locally deployed and in MS Azure cloud;  from the point of view of Azure, it is possible to host both virtual machines and Azure SQL DB deployment options, including the managed Azure SQL database instance. </li><li>  DBReplication is a ready-made reliable solution that has been tested by many projects in a variety of conditions and tasks. </li><li>  If DBREPLICATION is used in one-way exchange mode, the exchange direction can be switched. </li></ul><br><p>  Additionally, we note another important feature: </p><br><ul><li>  DBREPLICATION can work in a two-way exchange mode, when you can enter / change data simultaneously in all databases participating in the exchange.  The number of bases that can be included in the exchange circuit is not limited. </li></ul><br><h2>  Practical application example </h2><br><p>  A large Russian company has an application accounting system based on 1C 8 + MS SQL Server.  The main operating base has long been stepped over 2 terabytes and continues to grow.  At the same time, the load is increasing more and more: both transactional and analytical.  In the end, a number of bases were formed to complete the convolution of the base.  It was decided to cut the historical data for the beginning of 2017.  The technique described here was chosen using DBReplication. </p><br><p>  By itself, the convolution algorithm was decided to be implemented mainly by means of TSQL with small inclusions of typical 1C tools.  The task was complicated by the fact that not all applied objects (tables) could be minimized by the target date, since the business features required that a number of the largest subsystems contained historical data in full to a depth of 5-7 years.  Therefore, from the point of view of the database size, the effect of convolution was not as large as we would like.  A preliminary analysis was carried out, showing that, taking into account the objective limitations, about 33% of the initial volume will be cut off.  But this was also assessed by the Customer as a good result, because the gain not only in the database volume as such, but also in the speed of individual tables, and the tables of the minimized subsystems decreased in volume by more than 33% - from 46% to 77% (in 2- 3 times). </p><br><p>  Enlargely we give some indicators and facts of the actual application of the bundle.  The duration of the immediate convolution of the data was about 12 hours.  Synchronization of accumulated changes via DBREPLICATION took about 1 hour.  One of the key points of the project was the final verification of the folded base, performed by the Customer‚Äôs specialists.  Especially worth noting its duration - this process took about 1 week.  Such a duration was due to the fact that the verification was very deep and comprehensive, with the involvement of specialists of different profiles, including the construction of a certain data model in an external system.  All this time, the folded base was automatically synchronized with the current combat database through DBREPLICATION.  Verification was successful.  And users have been switched to a collapsed base.  The old database was transferred to archive status, with read-only access.  There was no need for its subsequent synchronization, so replication was turned off. </p><br><b></b><p>  <u>Results of the project:</u> </p><br><ul><li>  The applied method has fully justified itself, thanks to it there was enough time to perform the convolution itself, as well as comprehensive verification of the data, which radically minimized the risks of missing any errors and switching to a collapsed database. </li><li>  Convolution completed successfully: <br><ul><li>  The total volume of operational database decreased by 33%.  It was not possible to achieve greater effect in terms of database size due to objective reasons, due to limitations on the convolution of some large subsystems. </li><li>  The volume of actively used tables of minimized subsystems decreased by 46-77% (2-3 times). </li></ul><br></li></ul><h2>  Conclusion </h2><br><p>  DBReplication is a ready-made reliable solution that has been on the market for many years, tested by many projects in a variety of conditions.  In this convolution technique, DBReplication completely takes over one of the key subtasks - database synchronization.  In the case of very large databases, very strict requirements are imposed on the exchange system, and DBReplication completely satisfies them.  Solves its task reliably and efficiently, thereby ensuring the success of the project as a whole. </p><br><h2>  For what other tasks can you use DBREPLICATION </h2><br><p>  The complex of features and competitive advantages allows you to use DBReplication for solving a variety of tasks.  In reference order will list them. </p><br><ul><li>  Database backup and resiliency. </li><li>  Load balancing: its redistribution between 2 or more synchronous instances of the database. </li><li>  Controlled transition to new software versions (MS SQL, 1C), the technique is similar to the convolution technique. </li><li>  Building a distributed information system with high-speed exchange based on DBReplication.  In particular, the replacement of the existing exchange technology company with a more productive and efficient one - DBREPLICATION. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/438902/">https://habr.com/ru/post/438902/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>