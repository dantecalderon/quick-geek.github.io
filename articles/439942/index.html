<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Docker'ization: what every .Net developer needs to know</title>
  <meta name="description" content="In the age of the victorious DevOps, developers simply need to know about Docker containers, why they are needed and how to work with them. This makes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Docker'ization: what every .Net developer needs to know</h1><div class="post__text post__text-html js-mediator-article">  In the age of the victorious DevOps, developers simply need to know about Docker containers, why they are needed and how to work with them.  This makes work a lot easier.  Moreover, even those who work with .Net Core in the Visual Studio 2017 development environment can feel the full force of containerization. Pavel Skiba, Head of Server Applications, told <a href="http://panda-meetup.ru/samara-c-net-meetup">Panda-Meetup C # .Net</a> on the tools available and setting up Docker for VS. <br><br><img src="https://habrastorage.org/webt/-u/oc/-i/-uoc-itpzk__qajoj6vuduyvqsc.jpeg"><br><a name="habracut"></a><br>  What should a developer know?  "Program" - you will answer and ... Guess.  But if earlier the list of necessary knowledge was over, now in the DevOps age it is just beginning.  When we write code, we definitely need to know the structure of the network: what interacts with what.  Support of several programming languages ‚Äã‚Äãis required at once, and different pieces of code in a project can be written on anything. <br><br><img src="https://habrastorage.org/webt/kv/v8/e0/kvv8e0hdfubjxrh-ph7y8bqaxho.jpeg"><br><br>  We need to know how to roll back the software if an error is found.  We have to manage the configurations for different media used in the company - at least a few dev-environments, test and combat environments.  Oh yeah, you also need to understand the scripts on different servers / operating systems, because not everything can be done with code, sometimes you have to write scripts. <br><br>  We need to know the security requirements, and they are getting tougher and eat off the developer a lot of time.  Do not forget about the support and development of related software: Git, Jenkins, and so on.  As a result, the developer may simply not have enough time for pure development. <br><br>  What to do?  There is a way out, and it lies in the Docker-containers and their management system.  Once you deploy this whole complex colossus, and you, like in the good old days, again you will write only code.  All the rest will be controlled by other people or the system itself. <br><br><h3>  Understanding Containers </h3><br>  What is a docker container?  This is a construction consisting of several layers.  The top layer is the binary layer of your application.  The second and third layers are now merged into .Net Core, the container is already going SDK-shny.  The next layer is depending on the operating system on which the container is deployed.  And the bottommost layer is the operating system itself. <br><br><img src="https://habrastorage.org/webt/la/9r/rr/la9rrrk6nijaktzurbzvs6-7vem.jpeg"><br><br>  At the bottom level is deployed Windows Nanoserver.  This is a mega-clipped squeeze from Windows Server, which can do nothing but maintain a deployed service program.  But her volume is 12 times smaller. <br><br>  If we compare the physical and virtual servers and containers, the benefits of the latter are obvious. <br><br><img src="https://habrastorage.org/webt/rv/jf/bf/rvjfbftq2pa8vxkypp0cufyailq.jpeg"><br><br>  When everything worked on physical servers, we faced a bunch of problems.  There was no isolation in the library codes, some applications could interfere with each other.  For example: one application worked on .Net 1.1, and another on .Net 2.0.  Most often this led to tragedy.  After some time virtual servers appeared, the problem of isolation was solved, there were no common libraries.  True, it has become very expensive in terms of resources and labor-intensive: it was necessary to keep track of how many virtual lovers are spinning on one virtual machine, on Hyper-V, and on a piece of hardware. <br><br>  Containers were designed to be an inexpensive and convenient solution, minimally dependent on the OS.  Let's see how they differ.  Virtual servers inside the system are located approximately like this. <br><br><img src="https://habrastorage.org/webt/7r/tx/hy/7rtxhyzwk89x504k4elpatklrue.jpeg"><br><br>  The bottom layer is the host server.  It can be both physical and virtual.  The next layer is any operating system with virtualization, above is a hypervisor.  From above there are virtual servers that can be divided into guest OS and applications.  That is, a guest OS is deployed for each virtual server on top of the OS, and this is a waste of resources. <br><br>  Let's see how the Linux containers are located in the system. <br><br><img src="https://habrastorage.org/webt/2i/fh/qm/2ifhqmfohluhldax3v5evaomvvo.jpeg"><br><br>  As you can see, the binaries with applications are immediately located above the host server and OS.  Guest OS is not needed, resources are released, guest OS licenses are not needed. <br><br>  Windows containers are slightly different from Linux. <br><br><img src="https://habrastorage.org/webt/br/p3/td/brp3tdb9vl_yau-iwsqj_c5yfmm.jpeg"><br><br>  The basic layers are the same: infrastructure, host OS (but now Windows).  But further containers can work directly with the OS or be deployed on top of the hypervisor.  In the first case, the isolation of processes and spaces is there, but they use the same core with other containers, which is not ice from the point of view of safety.  If you use containers through Hyper-V, then everything will be isolated. <br><br><h3>  We study Docker under VS </h3><br>  Let's get to the Docker itself.  Suppose you have Visual Studio and you are doing the first installation of the Docker client for Windows.  At the same time, Docker will deploy the Docker demon server, Rest interface for access to it and the client itself - the Docker command line.  It will allow us to manage everything related to containers: the network, images, containers, layers. <br><br><img src="https://habrastorage.org/webt/h3/ft/dz/h3ftdzxhy9d-y2cz43xjbllnfiq.jpeg"><br><br>  The slide shows the simplest commands: pull out the Docker container, run it, build, commit, send back. <br><br>  Docker is very organic with Visual Studio.  The screenshot shows the panel menu from Visual Studio 2017. Docker compose is integrated directly into Intellisense, Dockerfile is supported, and all artifacts work on the command line. <br><br><img src="https://habrastorage.org/webt/o6/lo/xq/o6loxq2u8gcuxqmeeqc9rf5d7jw.jpeg"><br><br>  Interestingly, we can use Docker to debug containers in real time.  And if your containers are connected to each other, they will immediately debug everything all at once, and you will not need to run several environments. <br><br>  How are containers assembled?  The main element here is the dockerfile file, which contains instructions for building the image.  Each project creates its own dockerfile.  It indicates: from where we take the base image, what arguments we pass, what is the name of the working directory with files, ports. <br><br><img src="https://habrastorage.org/webt/cw/y4/s4/cwy4s4ukujlmx_ewfcr9rhq6wk4.jpeg"><br><br>  This source argument has two parameters.  The second parameter is the way in which the result of the assembly will be placed in the project, the value is set by default.  In my opinion, this is not a very good option.  There is often a lot of garbage in this folder, it needs to be cleaned periodically, and we can rub the assembly when cleaning this folder.  So if you want, you can change it, it is set by the Docker_build_source system parameter, which can also be hammered by hand. <br><br>  The Entrypoint statement allows you to set up a container as an executable file.  This line is needed for .Net Core, so that after the container is successfully launched, it sends the message ‚ÄúYour application is running‚Äù to the command line. <br><br>  Now about the debugging of containers.  Here, everything looks like an ordinary .Net, you hardly notice the difference.  Most often, I run .Net Core as self-hosted under dotnet.exe.  It uses CLRDBG debugger, NuGet packet cache and source code. <br><br>  ASP.Net 4.5+ is hosted by IIS or IIS Express, it uses the Microsoft Visual Studio Debugger and the sources of the site root in IIS. <br><br><img src="https://habrastorage.org/webt/1h/xa/ad/1hxaadi82m4yntfg6nurythtlui.jpeg"><br><br>  There are two environments for debugging: Debug and Release.  The debugging image tag is marked as dev, and the latest release.  The Source argument for debugging is best set to obj / Docker / empty, so as not to be confused, and with the release of obj / Docker / publish.  Here you can use all the same binaries, views, wwwroot folder and all the dependencies that exist. <br><br><h3>  Learn Docker Compose </h3><br>  Let's move on to the most interesting part - the Docker-compose orchestration tool.  Consider an example: you have some kind of business service that affects 5-6 containers.  And you need to somehow fix how they should be assembled, in what order.  This is where Docker-compose comes in handy, which will provide all the build, launch and scaling of containers.  It is controlled simply, everything is going to one team. <br><br><img src="https://habrastorage.org/webt/d4/df/aq/d4dfaqe-8qt-k9wxxfs6y8gigke.jpeg"><br><br>  Docker-compose uses YAML files that store configuration, how exactly containers need to be assembled.  They describe what settings to use for the images themselves, assemblies, services, volumes, networks, environments.  The syntax is identical for publishing to clusters.  That is, such a file was written once, and if you later need to expand the business service into a cluster, you will not have to add anything else. <br><br>  Consider the structure of a YAML file.  Image is a Docker image.  The image is a container without an application layer; it is unchanged. <br><br><img src="https://habrastorage.org/webt/no/y1/s7/noy1s7xjmk8uzkx9qw-7dgtubuc.jpeg"><br><br>  Build indicates how to build, where to build and where to deploy. <br>  Depends_on - dependence on which services it depends on. <br>  Environment - here we set the environment. <br>  Ports - port mapping, on which port your container will be available. <br><br>  Consider an example.  We just have an API without a service, in fact there are 3 containers: there is SQL.data on Linux, there is an application itself, it depends on webapi, and webapi depends on SQL.data. <br><br><img src="https://habrastorage.org/webt/dl/_b/wz/dl_bwzfrtxf-dpiumh0d6mcmork.jpeg"><br><br>  It does not matter in which sequence the components are written in the file.  If everything is correctly described, Compose will automatically correctly build this information based on dependencies in the project.  This file is enough to collect all the containers at once, the output will be a ready release. <br><br>  There is a sort of "container containers", a special container docker-compose.ci.build.yml, which contains the entire composition.  From the command line of Visual Studio, you can run this special container, and it will be able to perform the entire build on the build server, for example, in Jenkins. <br><br><img src="https://habrastorage.org/webt/c-/n7/dt/c-n7dtz4rp_xdqlove2dxze5w7y.jpeg"><br><br>  Let's look inside the file.  The example contains the working directory and where it comes from.  He recovers the project from GIT, he himself makes the publication of this solution, the Release configuration and puts the result.  That's the whole team to build, nothing else needs to be written.  Enough once to register it, and then launch the publication with one button. <br><br>  What else you should pay attention.  Docker-compose for each environment collects images, for each configuration a separate file.  For each configuration, Visual Studio has a file with the settings you need for your environment. <br><br><img src="https://habrastorage.org/webt/hp/tl/mh/hptlmho5s80wvh-vqgpprnimnau.jpeg"><br><br>  Directly from VS, you can remotely start debugging of the entire composition. <br><br><h3>  Cluster Orchestrators </h3><br>  Finally, let's touch on a topic like cluster orchestrators.  We should not think about how containers further exist, what people or systems are managed.  To do this, there are 4 of the most popular container management systems: Google Kubernetes, Mesos DC / OS, Docker Swarm and Azure Service Fabric.  They allow you to manage clustering and composition of containers. <br><br><img src="https://habrastorage.org/webt/5h/xd/lq/5hxdlqbpiyr2e7lytjagsikndec.jpeg"><br><br>  These systems are able to cope with a huge layer of microservices, providing them with everything they need.  The developer will only need to adjust this layer once. <br><br>  The full performance on Panda Meetup is available below. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/GLMFaf39zxM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  For those who want to dive deeper into the topic, I advise you to study the following materials: <br><br>  Http: //dot.net <br>  Http: //docs.docker.com <br>  Http: //hub.docker.com/microsoft <br>  Http://docs.microsoft.com <br>  Http: //visualstudio.com <br><br>  And finally, an important advice from practice: the most difficult thing is to remember where everything lies. <br><br>  Documentation when working with docker containers will fall on your shoulders.  Without documentation, you will forget where in what container what is connected with what and what is working with.  The more services, the greater the total web of connections. </div><p>Source: <a href="https://habr.com/ru/post/439942/">https://habr.com/ru/post/439942/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>