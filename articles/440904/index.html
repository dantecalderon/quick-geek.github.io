<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Comparing Viper and MVVM architectures: How to apply one and the other</title>
  <meta name="description" content="Currently, VIPER and MVVM are the most popular architectural solutions used in the development of large applications that require participation in the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Comparing Viper and MVVM architectures: How to apply one and the other</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/db/bn/4z/dbbn4zxc39qxt6vtlimqyjql5ko.jpeg"><br><br>  Currently, VIPER and MVVM are the most popular architectural solutions used in the development of large applications that require participation in the development of large teams that are well-tested, long-lasting and constantly evolving.  In this article we will try to apply them on a small test project, which is a list of contacts of users with the ability to add a new contact.  This article has more practice than analysts, and it is intended primarily for those who are already in theory familiar with these architectures and now would like to understand how this works with specific examples.  However, a basic description of the architectures and their comparison is also present. <br><a name="habracut"></a><br><br>  This article is a translation of the article by Rafael Sacchi <a href="https://auth0.com/blog/compare-mvvm-and-viper-architectures/">"Comparing MVVM and Viper architectures: When to use one or the other</a> . <a href="https://auth0.com/blog/compare-mvvm-and-viper-architectures/">"</a>  Unfortunately, at some point in the creation of an article, ‚Äúpublication‚Äù was put up instead of ‚Äútranslation,‚Äù so you have to write here. <br><br>  A well-designed architecture is very important in order to provide long-term support for your project.  In this article, we will look at MVVM and VIPER architectures as an alternative to traditional MVC. <br><br>  MVC is a well-known concept for all those who have been developing software for quite some time.  This pattern divides the project into three parts: Model, representing entities;  View, which is an interface for user interaction;  and the Controller, responsible for ensuring the interaction between View and Model.  This is the architecture that Apple offers us to use in our applications. <br><br>  However, you probably know that projects come with fairly large and complex functionality: support for network requests, parsing, access to data models, data conversion for output, reaction to interface events, etc.  As a result, you get huge controllers that solve the above tasks and a bunch of code that cannot be reused.  In other words, MVC can be a nightmare for a developer with long-term project support.  But how to ensure high modularity and re-usability in iOS projects? <br><br>  We will look at two very well-known alternatives to the MVC architecture: MVVM and VIPER.  Both of them are quite famous in the iOS community and have proven that they can be an excellent alternative to MVC.  We will talk about their structure, write an example application and consider cases when it is better to use a particular architecture. <br><br>  <b>Example</b> <br><br>  We will write an application with a table of user contacts.  You can use the code from <a href="https://github.com/auth0-blog/mvvm_viper">this repository</a> .  The Starter folders contain the basic skeleton of the project, and the Final folders contain a complete application. <br><br>  The application will have two screens: on the first one there will be a list of contacts displayed as a table, the cell will contain the name and surname of the contact, as well as the basic picture instead of the user's image. <br><br><img src="https://habrastorage.org/webt/gn/kc/ww/gnkcwwblrc7b036fyvuz874zfpu.png"><br><br>  The second screen is a screen for adding a new contact, with input fields of the name and surname and the Done and Cancel buttons. <br><br><img src="https://habrastorage.org/webt/rx/b1/mv/rxb1mvegb0piorji2dovggxdj8q.png"><br><br>  <b>MVVM</b> <br><br>  How it works: <br><br>  MVVM stands for <b>Model-View-ViewModel</b> .  This approach differs from MVC in the logic of the distribution of responsibility between modules. <br><br><ul><li>  <b>Model</b> : This module is no different from that in MVC.  He is responsible for creating data models and may contain business logic.  You can also create helper classes, such as the manager class for managing objects in the Model and the network manager for handling network requests and parsing. </li><li>  <b>View</b> : And here everything starts to change.  The MVVM View module covers the interface (UIView subclasses, .xib and .storyboard files), display logic (animation, rendering) and user event handling (button presses, etc.) MVC is responsible for View and Controller.  This means that the interfaces (views) you will remain unchanged, while the ViewController will contain a small part of what was in it in MVC and, accordingly, greatly reduced. </li><li>  <b>ViewModel</b> : This is now the place where most of the code that you previously had in ViewController will be located.  The ViewModel layer requests data from the Model (it can be a request to a local database or a network request) and sends them back to View, in the format in which they will be used and displayed there.  But this is a bidirectional mechanism, the actions or data entered by the user go through the ViewModel and update the Model.  Since the ViewModel keeps track of everything that is displayed, it is useful to use the linking mechanism between the two layers. </li></ul><br><br>  Compared to MVC, you are moving from an architecture that looks like this: <br><br><img src="https://habrastorage.org/webt/lt/qm/pb/ltqmpblrgqxnj3kmmik_m41gw1s.png"><br><br>  To the following architecture: <br><br><img src="https://habrastorage.org/webt/zu/me/cj/zumecj56yf5vgzckbhjdarwx58i.png"><br><br>  In which the implementation of the View uses the classes and subclasses of UIView and UIViewController. <br><br>  Well, now to the point.  Let's write an example of our application using the MVVM architecture. <br><br>  <b>MVVM Contacts App</b> <br><br>  <b>MODEL</b> <br><br>  The following class is a <b>Contact</b> contact model: <br><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CoreData open class Contact: NSManagedObject { @NSManaged var firstName: String? @NSManaged var lastName: String? var fullName: String { get { var name = "" if let firstName = firstName { name += firstName } if let lastName = lastName { name += " \(lastName)" } return name } } }</code> </pre> <br><br>  The contact class has the fields <i>firstName</i> , <i>lastName</i> , and the calculated property <i>fullName</i> . <br><br>  <b>VIEW</b> <br><br>  VIEW includes: Main storyboard, with a view already placed on it;  ContactsViewController, which displays a list of contacts in a table;  and AddContactViewController with a couple of labels and input fields to add the name and surname of the new contact.  Let's start with <b>ContactsViewController</b> .  Its code will look like this: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit class ContactsViewController: UIViewController { @IBOutlet var tableView: UITableView! let contactViewModelController = ContactViewModelController() override func viewDidLoad() { super.viewDidLoad() tableView.tableFooterView = UIView() contactViewModelController.retrieveContacts({ [unowned self] in self.tableView.reloadData() }, failure: nil) } override func prepare(for segue: UIStoryboardSegue, sender: Any?) { let addContactNavigationController = segue.destination as? UINavigationController let addContactVC = addContactNavigationController?.viewControllers[0] as? AddContactViewController addContactVC?.contactsViewModelController = contactViewModelController addContactVC?.didAddContact = { [unowned self] (contactViewModel, index) in let indexPath = IndexPath(row: index, section: 0) self.tableView.beginUpdates() self.tableView.insertRows(at: [indexPath], with: .left) self.tableView.endUpdates() } } } extension ContactsViewController: UITableViewDataSource { func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { let cell = tableView.dequeueReusableCell(withIdentifier: "ContactCell") as? ContactsTableViewCell guard let contactsCell = cell else { return UITableViewCell() } contactsCell.cellModel = contactViewModelController.viewModel(at: (indexPath as NSIndexPath).row) return contactsCell } func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { return contactViewModelController.contactsCount } }</code> </pre> <br><br>  Even with a cursory glance it is clear that this class implements mostly interface tasks.  It also has navigation in the <i>prepareForSegue (: :)</i> method - and this is exactly the moment that will change in VIPER when you add the Router layer. <br><br>  Let's now take a closer look at the class extension that implements the UITableViewDataSource protocol.  The functions do not work directly with the contact model of the user Contact in the Model layer ‚Äî instead they receive data (represented by the ContactViewModel structure) in the form in which they will be displayed, already formatted using the ViewModelController. <br><br>  The same happens in the closure, which starts immediately after the contact is created.  His only task is to add a row to the table and update the interface. <br><br>  Now it is necessary to establish a connection between the subclass UITableViewCell and ViewModel.  So the cell of the cell of the <b>ContactsTableViewCell</b> table will look like: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit class ContactsTableViewCell: UITableViewCell { var cellModel: ContactViewModel? { didSet { bindViewModel() } } func bindViewModel() { textLabel?.text = cellModel?.fullName } }</code> </pre> <br><br>  And so the class <b>AddContactViewController</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit class AddContactViewController: UIViewController { @IBOutlet var firstNameTextField: UITextField! @IBOutlet var lastNameTextField: UITextField! var contactsViewModelController: ContactViewModelController? var didAddContact: ((ContactViewModel, Int) -&gt; Void)? override func viewDidLoad() { super.viewDidLoad() firstNameTextField.becomeFirstResponder() } @IBAction func didClickOnDoneButton(_ sender: UIBarButtonItem) { guard let firstName = firstNameTextField.text, let lastName = lastNameTextField.text else { return } if firstName.isEmpty || lastName.isEmpty { showEmptyNameAlert() return } dismiss(animated: true) { [unowned self] in self.contactsViewModelController?.createContact(firstName: firstName, lastName: lastName, success: self.didAddContact, failure: nil) } } @IBAction func didClickOnCancelButton(_ sender: UIBarButtonItem) { dismiss(animated: true, completion: nil) } fileprivate func showEmptyNameAlert() { showMessage(title: "Error", message: "A contact must have first and last names") } fileprivate func showMessage(title: String, message: String) { let alertView = UIAlertController(title: title, message: message, preferredStyle: .alert) alertView.addAction(UIAlertAction(title: "Ok", style: .destructive, handler: nil)) present(alertView, animated: true, completion: nil) } }</code> </pre> <br><br>  And once again, basically there is work with the UI.  Note that AddContactViewController delegates the contact creation functionality in the ViewModelController in the <i>didClickOnDoneButton (:)</i> function. <br><br>  <b>VIEW MODEL</b> <br><br>  It's time to talk about a completely new layer for us ViewModel.  To begin with, we will create the <b>ContactViewModel</b> contact <b>class</b> , which will provide the view we need to display, the &lt;and&gt; functions with parameters will also be defined, to sort the contacts: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactViewModel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fullName: <span class="hljs-type"><span class="hljs-type">String</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> &lt;(lhs: ContactViewModel, rhs: ContactViewModel) -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bool</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs.fullName.lowercased() &lt; rhs.fullName.lowercased() } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> &gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lhs: ContactViewModel, rhs: ContactViewModel)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs.fullName.lowercased() &gt; rhs.fullName.lowercased() }</code> </pre> <br><br>  The <b>ContactViewModelController</b> code will look like this: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactViewModelController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">fileprivate</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contactViewModelList: [<span class="hljs-type"><span class="hljs-type">ContactViewModel</span></span>] = [] <span class="hljs-keyword"><span class="hljs-keyword">fileprivate</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataManager = <span class="hljs-type"><span class="hljs-type">ContactLocalDataManager</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contactsCount: <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> contactViewModelList.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrieveContacts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> success: </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)?, failure: (() -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)?) { <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contacts = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> dataManager.retrieveContactList() contactViewModelList = contacts.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>() { <span class="hljs-type"><span class="hljs-type">ContactViewModel</span></span>(fullName: $<span class="hljs-number"><span class="hljs-number">0</span></span>.fullName) } success?() } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { failure?() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewModel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(at index: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">ContactViewModel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> contactViewModelList[index] } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createContact</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(firstName: String, lastName: String, success: </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-params">(ContactViewModel, Int)</span></span></span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)?, failure: (() -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)?) { <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contact = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> dataManager.createContact(firstName: firstName, lastName: lastName) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contactViewModel = <span class="hljs-type"><span class="hljs-type">ContactViewModel</span></span>(fullName: contact.fullName) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> insertionIndex = contactViewModelList.insertionIndex(of: contactViewModel) { $<span class="hljs-number"><span class="hljs-number">0</span></span> &lt; $<span class="hljs-number"><span class="hljs-number">1</span></span> } contactViewModelList.insert(contactViewModel, at: insertionIndex) success?(contactViewModel, insertionIndex) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { failure?() } } }</code> </pre><br><br>  <i><u>Note:</u></i> MVVM does not exactly define how to create a ViewModel.  When I want to create a more layered architecture, I prefer to create a ViewModelController that will interact with the Model layer and will be responsible for creating ViewModel objects. <br><br>  The main thing that is very easy to remember: the ViewModel layer should not be involved in working with the user interface.  In order to avoid this, it‚Äôs better to just <b>never</b> import UIKit into a file with ViewModel. <br><br>  The ContactViewModelController class queries contacts from local storage and tries not to affect the Model layer.  It returns data in a format that requires the view to be displayed, and notifies the view when a new contact is added and the data changes. <br><br>  In real life, this would be a network request, not a request to a local database, but in neither case should none be part of the ViewModel ‚Äî and work with the network and work with the local database should be provided with the help of their own managers ( managers). <br><br>  That's all about MVVM.  Perhaps this approach will seem to you more testable, supported and distributed than MVC.  Now let's talk about VIPER and see how it differs from MVVM. <br><br>  <b>VIPER</b> <br><br>  How it works: <br><br>  VIPER is the implementation of Clean Architecture for iOS projects.  Its structure consists of: View, Interactor, Presenter, Entity, and Router.  This is really a very distributed and modular architecture that allows you to share responsibility, is very well covered by unit tests and makes your code reusable. <br><br><ul><li>  <b>View</b> : Interface layer, which usually implies UIKit files (including UIViewController).  Understandably, in more distributed systems, the UIViewController subclasses must belong to View.  In VIPER, things are almost the same as in MVVM: View is responsible for displaying what Presenter gives and for transferring user-entered information or actions to Presenter. </li><li>  <b>Interactor</b> : Contains the business logic necessary for the operation of the application.  Interactor is responsible for receiving data from the Model (network or local requests) and its implementation is in no way associated with the user interface.  It is important to remember that network and local managers are not part of VIPER, but are treated as separate dependencies. </li><li>  <b>Presenter</b> : Responsible for formatting data for display in View.  In MVVM in our example, ViewModelController was responsible for this.  Presenter obtains data from Interactor, creates an instance of ViewModel (formatted class for correct display) and sends it to View.  He also responds to user input, requests additional data from the database, or vice versa, sends them to her. </li><li>  <b>Entity</b> : Take responsibility for the Model layer, which is used in other architectures.  Entity is simple data objects, without business logic, controlled by an intractor and various data managers. </li><li>  <b>Router</b> : All application navigation logic.  It may seem that this is not the most important layer, but if you need, for example, to reuse the same view on the iPhone and on the iPad application, the only thing you can change is how your view will appear on the screen.  This allows you not to touch any other layers except Router, who will be responsible for this in each case. </li></ul><br><br>  Compared to MVVM, VIPER has several key differences in the distribution of responsibility: <br><br>  - it has a Router, a separate layer responsible for navigation <br><br>  - Entities are simple data objects, thereby redistributing responsibility for accessing data from Model to Interactor <br><br>  - duties of ViewModelController are distributed between Interactor and Presenter <br><br>  And now let's repeat the same application, but on VIPER.  But for ease of understanding, we will only make a controller with contacts.  The code for the controller for adding a new contact can be found in the project by reference (VIPER Contacts Starter folder in <a href="https://github.com/auth0-blog/mvvm_viper">this repository</a> ). <br><br>  <i><u>Note</u></i> : If you decide to do your project on VIPER, then you should not try to create all the files manually - you can use one of the code generators, for example, such as <a href="https://github.com/pepibumur/viper-module-generator%3Futm_source%3Dswifting.io">VIPER Gen</a> or <a href="https://github.com/strongself/Generamba">Generamba (Rambler project)</a> . <br><br>  <b>VIPER Contacts App</b> <br><br>  <b>VIEW</b> <br><br>  VIEW is represented by elements from the Main.storyboard and ContactListView class.  VIEW is very passive;  Its only tasks are to pass interface events to the Presenter and update its state, upon notification from the Presenter.  This is what the <b>ContactListView</b> code looks like: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit class ContactListView: UIViewController { @IBOutlet var tableView: UITableView! var presenter: ContactListPresenterProtocol? var contactList: [ContactViewModel] = [] override func viewDidLoad() { super.viewDidLoad() presenter?.viewDidLoad() tableView.tableFooterView = UIView() } @IBAction func didClickOnAddButton(_ sender: UIBarButtonItem) { presenter?.addNewContact(from: self) } } extension ContactListView: ContactListViewProtocol { func reloadInterface(with contacts: [ContactViewModel]) { contactList = contacts tableView.reloadData() } func didInsertContact(_ contact: ContactViewModel) { let insertionIndex = contactList.insertionIndex(of: contact) { $0 &lt; $1 } contactList.insert(contact, at: insertionIndex) let indexPath = IndexPath(row: insertionIndex, section: 0) tableView.beginUpdates() tableView.insertRows(at: [indexPath], with: .right) tableView.endUpdates() } } extension ContactListView: UITableViewDataSource { func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { guard let cell = tableView.dequeueReusableCell(withIdentifier: "ContactCell") else { return UITableViewCell() } cell.textLabel?.text = contactList[(indexPath as NSIndexPath).row].fullName return cell } func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { return contactList.count } }</code> </pre> <br><br>  View sends to the Presenter the events <i>viewDidLoad</i> and <i>didClickOnAddButton</i> .  On the first event, the Presenter will request data from Interactor, and on the second, the Presenter will request Router to switch to the controller for adding a new contact. <br><br>  The protocol methods ContactListViewProtocol are called from Presenter, either when a contact list request is made, or when a new contact is added.  In this and in another case, the data in the View contain only the information that is necessary for display. <br><br>  Also in View there are methods that implement the UITableViewDataSource protocol, which fill the table with the received data. <br><br>  <b>INTERACTOR</b> <br><br>  Interactor is pretty simple in our example.  All he does is request data through a local database manager, and it doesn‚Äôt matter to him that this manager, CoreData, Realm, or some other solution is using it.  The code in the ContactListInteractor is as follows: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListInteractor</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListInteractorInputProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> presenter: <span class="hljs-type"><span class="hljs-type">ContactListInteractorOutputProtocol?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> localDatamanager: <span class="hljs-type"><span class="hljs-type">ContactListLocalDataManagerInputProtocol?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrieveContacts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contactList = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> localDatamanager?.retrieveContactList() { presenter?.didRetrieveContacts(contactList) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { presenter?.didRetrieveContacts([]) } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { presenter?.didRetrieveContacts([]) } } }</code> </pre> <br><br>  After Interactor receives the requested data, it notifies the Presenter.  Still, as an option, Interactor can pass an error to Presenter, which will then have to format the error into a form suitable for display in View. <br><br>  <i>Note</i> : As you can see, each layer in VIPER implements a protocol.  As a result, classes depend on abstractions, and not on a specific implementation, thus complying with the principle of dependency inversion (one of the SOLID principles). <br><br>  <b>PRESENTER</b> <br><br>  The most important element of architecture.  All communication between the View and the remaining layers (Interactor and Router) passes through the Presenter.  <b>ContactListPresenter</b> Code: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListPresenter</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListPresenterProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> view: <span class="hljs-type"><span class="hljs-type">ContactListViewProtocol?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interactor: <span class="hljs-type"><span class="hljs-type">ContactListInteractorInputProtocol?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wireFrame: <span class="hljs-type"><span class="hljs-type">ContactListWireFrameProtocol?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewDidLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { interactor?.retrieveContacts() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addNewContact</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(from view: ContactListViewProtocol)</span></span></span></span> { wireFrame?.presentAddContactScreen(from: view) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListPresenter</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListInteractorOutputProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didRetrieveContacts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> contacts: [Contact])</span></span></span></span> { view?.reloadInterface(with: contacts.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">ContactViewModel</span></span>(fullName: $<span class="hljs-number"><span class="hljs-number">0</span></span>.fullName) }) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListPresenter</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddModuleDelegate</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didAddContact</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> contact: Contact)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contactViewModel = <span class="hljs-type"><span class="hljs-type">ContactViewModel</span></span>(fullName: contact.fullName) view?.didInsertContact(contactViewModel) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didCancelAddContact</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {} }</code> </pre> <br><br>  After the View is loaded, it notifies Presenter, which in turn requests data through Interactor.  When a user clicks the add new contact button, View notifies the Presenter, which sends a request to open the add new contact screen to the Router. <br><br>  The Presenter also formats the data and returns it to the View after the contact list request is made.  It is also responsible for implementing the AddModuleDelegate protocol.  This means that the Presenter will receive a notification when a new contact is added, prepare the contact data for display and transmit to View. <br><br>  As you can see, the Presenter has every chance of becoming quite cumbersome.  If there is such a probability, the Presenter can be divided into two parts: The Presenter, which only receives data, formats it for display and sends to View;  and an event handler that will respond to user actions. <br><br>  <b>ENTITY</b> <br><br>  This layer is similar to the Model layer in MVVM.  In our application, it is represented by the Contact class and the definition functions for the &lt;and&gt; operators.  <b>Contact</b> content will look like this: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CoreData open class Contact: NSManagedObject { var fullName: String { get { var name = "" if let firstName = firstName { name += firstName } if let lastName = lastName { name += " " + lastName } return name } } } public struct ContactViewModel { var fullName = "" } public func &lt;(lhs: ContactViewModel, rhs: ContactViewModel) -&gt; Bool { return lhs.fullName.lowercased() &lt; rhs.fullName.lowercased() } public func &gt;(lhs: ContactViewModel, rhs: ContactViewModel) -&gt; Bool { return lhs.fullName.lowercased() &gt; rhs.fullName.lowercased() }</code> </pre> <br><br>  ContactViewModel contains fields that Presenter fills (formats) and which View displays.  The Contact class is a subclass of NSManagedObject that contains the same fields as in the CoreData model. <br><br>  <b>ROUTER</b> <br><br>  And finally, last but not least, a layer.  All responsibility for navigation lies with the Presenter and WireFrame.  Presenter receives an event from the user and knows when to make the transition, and WireFrame knows how and where to make this transition.  So that you are not confused, in this example the Router layer is represented by the class ContactListWireFrame and is referred to in the text as WireFrame.  <b>ContactListWireFrame</b> code: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit class ContactListWireFrame: ContactListWireFrameProtocol { class func createContactListModule() -&gt; UIViewController { let navController = mainStoryboard.instantiateViewController(withIdentifier: "ContactsNavigationController") if let view = navController.childViewControllers.first as? ContactListView { let presenter: ContactListPresenterProtocol &amp; ContactListInteractorOutputProtocol = ContactListPresenter() let interactor: ContactListInteractorInputProtocol = ContactListInteractor() let localDataManager: ContactListLocalDataManagerInputProtocol = ContactListLocalDataManager() let wireFrame: ContactListWireFrameProtocol = ContactListWireFrame() view.presenter = presenter presenter.view = view presenter.wireFrame = wireFrame presenter.interactor = interactor interactor.presenter = presenter interactor.localDatamanager = localDataManager return navController } return UIViewController() } static var mainStoryboard: UIStoryboard { return UIStoryboard(name: "Main", bundle: Bundle.main) } func presentAddContactScreen(from view: ContactListViewProtocol) { guard let delegate = view.presenter as? AddModuleDelegate else { return } let addContactsView = AddContactWireFrame.createAddContactModule(with: delegate) if let sourceView = view as? UIViewController { sourceView.present(addContactsView, animated: true, completion: nil) } } }</code> </pre> <br><br>  Since WireFrame is responsible for creating the module, it will be convenient to configure all dependencies here.  When you want to open another controller, the function that opens a new controller receives as an argument the object that will open it, and creates a new controller using its WireFrame.  Also, when creating a new controller, the necessary data is transferred to it, in this case only the delegate (the Presenter of the controller with contacts) to receive the created contact. <br><br>  The Router layer gives you a good opportunity to avoid using segues (transitions) in storyboards and organize all navigation code.  Since storyboards do not provide a compact solution for transferring data between controllers, our navigation implementation will not add extra code.  All we get is just the best advantage. <br><br><br>  <b>Results</b> : <br><br>  You can find both projects in <a href="https://github.com/auth0-blog/mvvm_viper">this repository</a> . <br><br>  As you can see, MVVM and VIPER, though different, are not unique.  MVVM tells us that besides View and Model there must be another ViewModel layer.  But nothing is said about how this layer should be created, nor about how the data is requested - the responsibility for this layer is not clearly defined.  There are many ways to implement it and you can use any of them. <br><br>  On the other hand, VIPER is a rather unique architecture.  It consists of many layers, each of which has a well-defined area of ‚Äã‚Äãresponsibility and is less than MVVM influenced by the developer. <br><br>  When it comes to the choice of architecture, the only right decision is usually not, but still I will try to give a couple of tips.  If you have a large and long-term project, with clear requirements and you want to have ample opportunities to reuse components, then VIPER will be the best solution.  A clearer delineation of responsibility makes it possible to better organize testing and improve reusability. </div><p>Source: <a href="https://habr.com/ru/post/440904/">https://habr.com/ru/post/440904/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>