<div class="post__text post__text-html js-mediator-article">  In this article we present the <i>page</i> , a very common memory management scheme, which we also apply in our OS.  The article explains why memory isolation is necessary, how <i>segmentation</i> works, what <i>virtual memory is</i> and how pages solve the problem of fragmentation.  We also explore the layout of multi-level page tables in the x86_64 architecture. <br><br>  This blog is posted on <a href="https://github.com/phil-opp/blog_os">github</a> .  If you have any questions or problems, open the corresponding request there. <br><a name="habracut"></a><br><h1>  Memory protection </h1><br>  One of the main tasks of the operating system is to isolate programs from each other.  For example, the browser should not interfere with the text editor.  There are different approaches depending on the hardware and the implementation of the OS. <br><br>  For example, some ARM Cortex-M processors (on embedded systems) have <a href="https://developer.arm.com/docs/ddi0337/e/memory-protection-unit/about-the-mpu"><i>a memory protection unit</i></a> (MPU) that defines a small number (for example, 8) of memory areas with different access permissions (for example, no access, read only, read records).  With each memory access, the MPU ensures that the address is in the area with the correct permissions, otherwise it throws an exception.  By changing areas and access permissions, the OS ensures that each process has access only to its memory in order to isolate processes from each other. <br><br>  On x86, two different approaches to memory protection are supported: <a href="https://en.wikipedia.org/wiki/X86_memory_segmentation">segmentation</a> and <a href="https://en.wikipedia.org/wiki/Virtual_memory">page organization</a> . <br><br><h1>  Segmentation </h1><br>  Segmentation was implemented in 1978, initially to increase the amount of addressable memory.  At that time, CPUs supported only 16-bit addresses, which limited the amount of addressable memory to 64 KB.  To increase this volume, we introduced additional segment registers, each of which contains an offset address.  The CPU automatically adds this offset at every memory access, thus addressing up to 1 MB of memory. <br><br>  The CPU automatically selects the segment register depending on the type of memory access: the <code>CS</code> code segment register is used for instructions, and the <code>SS</code> stack segment register (push / pop) is used for instructions.  Other instructions use the <code>DS</code> data segment register or the <code>ES</code> additional segment register.  Later, two additional segment registers <code>FS</code> and <code>GS</code> were added for free use. <br><br>  In the first version of segmentation, the registers directly contained offset and access control was not performed.  With the advent of <i><a href="https://en.wikipedia.org/wiki/X86_memory_segmentation">protected mode, the</a></i> mechanism has changed.  When the CPU is operating in this mode, segment descriptors store the index in a local or global descriptor table, which in addition to the offset address contains the segment size and access permissions.  By loading separate global / local descriptor tables for each process, the OS can isolate processes from each other. <br><br>  By changing the memory addresses before the actual access, the segmentation implemented a method that is now used almost everywhere: it is <i>virtual memory</i> . <br><br><h3>  Virtual memory </h3><br>  The idea of ​​virtual memory is to abstract the memory addresses from a physical device.  Instead of directly accessing the storage device, the conversion step is first performed.  In the case of segmentation, the offset address of the active segment is added at the translation stage.  Imagine a program that accesses a memory address <code>0x1234000</code> in a segment with an offset of <code>0x1111000</code> : in fact, it goes to address <code>0x2345000</code> . <br><br>  To distinguish between two types of addresses, addresses before conversion are called <i>virtual</i> , and addresses after conversion are called <i>physical</i> .  There is one important difference between them: the physical addresses are unique and always refer to the same unique memory location.  On the other hand, virtual addresses depend on the conversion function.  Two different virtual addresses may well refer to the same physical address.  In addition, identical virtual addresses can refer to different physical addresses after conversion. <br><br>  As an example of the useful use of this property we can cite the parallel launch of the same program twice: <br><br><img src="https://habrastorage.org/webt/qm/zz/nz/qmzznz4rei5d-xxygzcabu2latw.png"><br><br>  Here the same program is launched twice, but with different conversion functions.  In the first instance, the segment offset is 100, so its virtual addresses 0-150 are converted to physical addresses 100-250.  The second instance has an offset of 300, which converts virtual addresses 0-150 into physical addresses 300-450.  This allows both programs to execute the same code and use the same virtual addresses without interfering with each other. <br><br>  Another advantage is that now programs can be placed in arbitrary locations of physical memory.  Thus, the OS uses the entire amount of available memory without the need to recompile programs. <br><br><h3>  Fragmentation </h3><br>  The distinction between virtual and physical addresses is a real segmentation achievement.  But there is a problem.  Imagine that we want to run a third copy of the program that we saw above: <br><br><img src="https://habrastorage.org/webt/rr/np/1m/rrnp1m95lefyki9vwhnwe4uocom.png"><br><br>  Although there is more than enough space in the physical memory, the third copy does not fit anywhere.  The problem is that he needs a <i>continuous</i> piece of memory and we can not use separate free areas. <br><br>  One way to deal with fragmentation is to pause the execution of programs, move used parts of memory closer to each other, update the transformation, and then resume execution: <br><br><img src="https://habrastorage.org/webt/hd/rm/zo/hdrmzooae2xt4huangnbzebq3o0.png"><br><br>  Now for start of the third copy there is enough place. <br><br>  The disadvantage of such defragmentation is the need to copy large amounts of memory, which reduces performance.  This procedure has to be performed regularly until the memory becomes too fragmented.  Performance becomes unpredictable, programs stop at an arbitrary time and may stop responding. <br><br>  Fragmentation is one of the reasons why segmentation is not used in most systems.  In fact, it is no longer supported even in 64-bit mode on x86.  Instead of segmentation, pages that completely eliminate the problem of fragmentation are used. <br><br><h1>  Paging memory organization </h1><br>  The idea is to divide the space of virtual and physical memory into small blocks of fixed size.  Blocks of virtual memory are called pages, and blocks of physical address space are called frames.  Each page is individually mapped to a frame, which makes it possible to divide large areas of memory between non-adjacent physical frames. <br><br>  The advantage becomes obvious if we repeat the example with fragmented memory space, but this time using pages instead of segmentation: <br><br><img src="https://habrastorage.org/webt/29/rg/95/29rg95blzryjql4qjy_txkbx2uo.png"><br><br>  In this example, the page size is 50 bytes, that is, each of the memory areas is divided into three pages.  Each page is mapped to a separate frame, so a continuous area of ​​virtual memory can be mapped to isolated physical frames.  This allows you to run a third copy of the program without defragmentation. <br><br><h3>  Hidden fragmentation </h3><br>  Compared to segmentation, the paging organization uses many small fixed-size memory areas instead of several large variable-size areas.  Each frame has the same size, so that fragmentation due to too small frames is impossible. <br><br>  But this is only an <i>appearance</i> .  In fact, there is a hidden kind of fragmentation, the so-called <i>internal fragmentation</i> due to the fact that not every area of ​​memory is exactly a multiple of the page size.  Imagine in the above example a program of size 101: it will still need three pages of size 50, so it will take 49 bytes more than necessary.  For clarity, fragmentation due to segmentation is called <i>outer fragmentation</i> . <br><br>  Internal fragmentation is no good, but often it is a lesser evil than external fragmentation.  Extra memory is still consumed, but now there is no need to defragment, and the amount of fragmentation is predictable (on average, half a page per each memory area). <br><br><h3>  Page tables </h3><br>  We saw that each of the millions of possible pages is individually matched to a frame.  This address translation information needs to be stored somewhere.  Segmentation uses separate segment registers for each active memory area, which is impossible in the case of pages, because there are many more than registers.  Instead, it uses a structure called a <i>page table</i> . <br><br>  For the above example, the tables will look like this: <br><br><img src="https://habrastorage.org/webt/ij/g0/93/ijg093nmmxzlvn8fkj3n2fxvujg.png"><br><br>  As you can see, each copy of the program has its own page table.  A pointer to the current active table is stored in a special register CPU.  On <code>x86</code> it's called <code>CR3</code> .  Before launching each instance of the program, the operating system must load a pointer to the correct page table there. <br><br>  With each memory access, the CPU reads the table pointer from the register and searches for the corresponding frame in the table.  This is a fully hardware function that runs completely transparent to the running program.  To speed up the process, many processor architectures have a special cache that remembers the results of the latest transformations. <br><br>  Depending on the architecture, attributes such as access rights can be stored in the flags field of the page table.  In the example above, the <code>r/w</code> flag makes the page readable and writable. <br><br><h3>  Multi-level page tables </h3><br>  Simple page tables have a problem with large address spaces: memory is wasted.  For example, the program uses four virtual pages <code>0</code> , <code>1_000_000</code> , <code>1_000_050</code> and <code>1_000_100</code> (use <code>_</code> as the separator for the digits): <br><br><img src="https://habrastorage.org/webt/oh/hc/2d/ohhc2dbnzmw-3qfq1bjmjsksydg.png"><br><br>  Only four physical frames are required, but the page table has over a million entries.  We cannot skip empty records, because then the CPU in the conversion process will not be able to go directly to the correct record (for example, it is no longer guaranteed that the fourth page uses the fourth record). <br><br>  To reduce memory loss, you can use a <b>two-tier organization</b> .  The idea is that we use different tables for different areas.  An additional table, called the <i>second-level</i> page table, performs conversion between address areas and first-level page tables. <br><br>  This is best explained by example.  We define that each page table of level 1 is responsible for a <code>10_000</code> .  Then in the above example, the following tables will exist: <br><br><img src="https://habrastorage.org/webt/7w/3s/qk/7w3sqkqe6zbpna2z4kcnsxqokco.png"><br><br>  Page 0 falls into the first area <code>10_000</code> bytes, therefore it uses the first entry of the table of the second level pages.  This entry points to the first level T1 page table, which indicates that page 0 refers to frame 0. <br><br>  Pages <code>1_000_000</code> , <code>1_000_050</code> and <code>1_000_100</code> fall into the 100th byte area <code>10_000</code> , so they use the 100th entry of the level 2 page table. This entry points to another first-level table T2, which translates three pages into frames 100, 150 and 200. Notice that the page address in the first level tables does not contain the region offset, therefore, for example, the entry for page <code>1_000_050</code> is only <code>50</code> . <br><br>  We still have 100 empty entries in the second level table, but this is much less than the previous million.  The reason for the savings is that you do not need to create tables of the first level pages for <code>10_000</code> memory areas between <code>10_000</code> and <code>1_000_000</code> . <br><br>  The principle of two-level tables can be extended to three, four or more levels.  In general, such a system is called a <i>multi-level</i> or <i>hierarchical</i> table of pages. <br><br>  Knowing about page organization and multi-level tables, you can see how page organization is implemented in the x86_64 architecture (we assume that the processor is running in 64-bit mode). <br><br><h1>  Paging on x86_64 </h1><br>  The x86_64 architecture uses a four-level table with a 4 KB page size.  Regardless of the level, each page table has 512 elements.  Each record has a size of 8 bytes, so the size of the tables is 512 × 8 bytes = 4 KB. <br><br><img src="https://habrastorage.org/webt/tp/o9/x-/tpo9x-ibzvx7spvyvspck7_rtrq.png"><br><br>  As you can see, each table index contains 9 bits, which makes sense, because in the tables 2 ^ 9 = 512 records.  The lower 12 bits is the offset to the 4-kilobyte page (2 ^ 12 bytes = 4 KB).  Bits 48 to 64 are discarded, so x86_64 is not really a 64-bit system, but only supports 48-bit addresses.  There are plans to expand the size of the address to 57 bits through a <a href="https://en.wikipedia.org/wiki/Intel_5-level_paging">5-level page table</a> , but such a processor has not yet been created. <br><br>  Although bits 48 through 64 are discarded, they cannot be set to arbitrary values.  All bits in this range must be copies of bit 47 in order to maintain unique addresses and allow future expansion, for example, to a 5-level page table.  This is called <i>a sign extension</i> (sign-extension), because it is very similar to <a href="https://en.wikipedia.org/wiki/Two%27s_complement">a sign extension in an additional code</a> .  If the address is incorrectly expanded, the CPU throws an exception. <br><br><h3>  Conversion example </h3><br>  Consider an example of how address translation works: <br><br><img src="https://habrastorage.org/webt/zj/ox/fe/zjoxfeno1sahwas8h-ffyxechgm.png"><br><br>  The physical address of the current active page table level 4, which is the root page table of this level, is stored in register <code>CR3</code> .  Each page table entry then points to the physical frame of the next level table.  A level 1 table entry indicates a displayed frame.  Note that all the addresses in the page tables are physical, not virtual, since otherwise the CPU will need to convert these addresses (which can lead to endless recursion). <br><br>  The above hierarchy converts two pages (in blue).  From the indexes it can be concluded that the virtual addresses of these pages are <code>0x803fe7f000</code> and <code>0x803FE00000</code> .  Let's see what happens when the program tries to read the memory at <code>0x803FE7F5CE</code> .  First, we convert the address to binary and define the indexes of the page table and the offset for the address: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/600/d08/367/600d08367d49e110f1852796c23f9754.png"><br><br>  With the help of these indexes, we can now go through the hierarchy of the page tables and find the corresponding frame: <br><br><ul><li>  Read the address of the table of the fourth level of the register <code>CR3</code> . </li><li>  The fourth-level index is 1, so we are looking at the record with index 1 in this table.  She says that the level 3 table is stored at 16 KB. </li><li>  We load a third-level table from this address and look at the entry with the index 0, which indicates the second-level table at 24 KB. </li><li>  The second level index is 511, so we are looking for the last record on this page to find out the address of the first level table. </li><li>  By recording with index 127 in the first level table, we finally find out that the page corresponds to a frame of 12 KB or 0xc000 in hexadecimal format. </li><li>  The final step is to add an offset to the frame address to get the physical address: 0xc000 + 0x5ce = 0xc5ce. </li></ul><br><img src="https://habrastorage.org/webt/mo/iq/-g/moiq-grelw6eyagqsuygebpugkm.png"><br><br>  For a page in the first-level table, the <code>r</code> flag is specified, that is, read only is allowed.  At the hardware level, an exception will be thrown if we try to write there.  Higher-level table permissions spread to lower levels, so if we set the read-only flag on the third level, no subsequent lower-level page will be writable, even if the flags that allow writing are specified there. <br><br>  Although this example uses only one instance of each table, usually there are several instances of each level in each address space.  Maximum: <br><br><ul><li>  one table of the fourth level </li><li>  512 tables of the third level (since there are 512 records in the fourth level table), </li><li>  512 * 512 second-level tables (since there are 512 entries in each of the third-level tables), and </li><li>  512 * 512 * 512 tables of the first level (512 records for each table of the second level). </li></ul><br><h3>  Page Table Format </h3><br>  In the x86_64 architecture, page tables are essentially arrays of 512 entries.  In Rust syntax: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(align(4096))]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PageTable</span></span></span></span> { entries: [PageTableEntry; <span class="hljs-number"><span class="hljs-number">512</span></span>], }</code> </pre> <br>  As indicated in the <code>repr</code> attribute, the tables must be aligned with the page, i.e., at the 4 KB border.  This requirement ensures that the table always optimally fills the entire page, making the entries very compact. <br><br>  The size of each entry is 8 bytes (64 bits) and the following format: <br><br><table><thead><tr><th>  Bit (s) </th><th>  Title </th><th>  Value </th></tr></thead><tbody><tr><td>  0 </td><td>  present </td><td>  page in memory </td></tr><tr><td>  one </td><td>  writable </td><td>  recording allowed </td></tr><tr><td>  2 </td><td>  user accessible </td><td>  if the bit is not set, then only kernel access to the page </td></tr><tr><td>  3 </td><td>  write through caching </td><td>  write directly to memory </td></tr><tr><td>  four </td><td>  disable cache </td><td>  disable cache for this page </td></tr><tr><td>  five </td><td>  accessed </td><td>  The CPU sets this bit when the page is in use. </td></tr><tr><td>  6 </td><td>  dirty </td><td>  The CPU sets this bit when writing to the page. </td></tr><tr><td>  7 </td><td>  huge page / null </td><td>  zero bit in P1 and P4 creates 1 KB pages in P3, 2 MB pages in P2 </td></tr><tr><td>  eight </td><td>  global </td><td>  the page is not filled from the cache when switching the address space (the PGE register bit CR4 must be set) </td></tr><tr><td>  9-11 </td><td>  available </td><td>  OS can use them freely </td></tr><tr><td>  12-51 </td><td>  physical address </td><td>  the page-aligned 52-bit physical address of a frame or the following page table </td></tr><tr><td>  52-62 </td><td>  available </td><td>  OS can use them freely </td></tr><tr><td>  63 </td><td>  no execute </td><td>  disables code execution on this page (the NXE bit must be set in the EFER register) </td></tr></tbody></table><br>  We see that only bits 12-51 are used to store the physical address of the frame, while the rest work as flags or can be used freely by the operating system.  This is possible because we always point either to the address aligned to 4096 bytes, or to the aligned page of the tables, or to the beginning of the corresponding frame.  This means that bits 0-11 are always zero, so they can not be stored, they are simply reset at the hardware level before using the address.  The same applies to bits 52-63, since the x86_64 architecture only supports 52-bit physical addresses (and only 48-bit virtual addresses). <br><br>  In more detail we will consider available flags: <br><br><ul><li>  The <code>present</code> flag distinguishes the displayed pages from those that are not displayed.  It can be used to temporarily save pages to disk when main memory is full.  Upon subsequent access to the page, a special PageFault exception occurs, to which the OS responds by pumping up the page from the disk - the program continues. </li><li>  The <code>writable</code> and <code>no execute</code> flags determine whether the content of the page is writable or contains executable instructions, respectively. </li><li>  Flags <code>accessed</code> and <code>dirty</code> automatically installs the processor when reading or writing to the page.  The OS can use this information, for example, if it changes pages in places or when checking whether the content of the page has changed since the last download to disk. </li><li>  The <code>write through caching</code> and <code>disable cache</code> flags allow you to manage the cache for each page separately. </li><li>  The <code>user accessible</code> flag makes the page accessible to user space code, otherwise it is accessible only to the kernel.  This function can be used to speed up <a href="https://en.wikipedia.org/wiki/System_call">system calls</a> by keeping the address mapping for the kernel while the user program is running.  However, <a href="https://en.wikipedia.org/wiki/Spectre_(security_vulnerability)">Specter’s</a> vulnerability allows programs to read these pages from user space. </li><li> Флаг <code>global</code> сигнализирует оборудованию, что страница доступна во всех адресных пространствах и её нельзя удалять из кэша преобразования адресов (см. раздел о TLB ниже) на переключателях адресного пространства (address space switch). Обычно одновременно очищается флаг user <code>accessible</code> для трансляции кода ядра во все адресные пространства. </li><li> Флаг <code>huge page</code> позволяет создание страниц больших размеров, чтобы записи таблиц страниц уровня 2 или 3 непосредственно указывали на отображённый фрейм. Это увеличивает размер страницы в 512 раз: на втором уровне до 2 МБ = 512 × 4 КБ, а на третьем уровне до 1 ГБ = 512 × 2 МБ. Для больших страниц требуется меньше строк кэша преобразования адресов и меньше таблиц страниц. </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The x86_64 architecture defines the format </font></font><a href="https://docs.rs/x86_64/0.3.4/x86_64/structures/paging/struct.PageTable.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of the page tables</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and their </font></font><a href="https://docs.rs/x86_64/0.3.4/x86_64/structures/paging/struct.PageTableEntry.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entries</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , so we don’t have to create these structures ourselves.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Associative translation buffer (TLB) </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Because of the four levels, for each address translation, four memory accesses are required. For the sake of performance, x86_64 caches the last few translations in a so-called associative translation buffer (TLB). This allows you to skip the conversion if it is still in the cache. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unlike other processor caches, TLB is not completely transparent, does not update or remove conversions when the content of the page tables changes. This means that the kernel must update the TLB on its own whenever it changes the page table. To do this, there is a special CPU instruction called </font></font><a href="https://www.felixcloutier.com/x86/INVLPG.html"><code>invlpg</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(invalidate page), which removes the translation of the specified page from the TLB, so that at the next access it is loaded again from the page table. TLB is completely cleared by resetting the register.</font></font><code>CR3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">which imitates the address space switch. Through the </font></font><a href="https://docs.rs/x86_64/0.3.4/x86_64/instructions/tlb/index.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tlb module</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in Rust both options are available. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is important to remember to clean the TLB after each change of the page table, otherwise the CPU will continue to use the old translation, which will lead to unpredictable errors that are very difficult to debug.</font></font><br><br><h1>  Implementation </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We did not mention one thing: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">our core already supports paging</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The loader from the article </font></font><a href="https://os.phil-opp.com/minimal-rust-kernel/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“Minimal core on Rust”</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> has already established a four-level hierarchy that maps every page of our core with a physical frame, because page organization is mandatory in 64-bit mode on x86_64. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This means that in our kernel all memory addresses are virtual. Access to the VGA buffer at the address </font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">worked only because the bootloader ID </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">translated</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> this page into memory, that is, it associated the virtual page </font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with a physical frame </font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thanks to paging, the kernel is already relatively safe: every access beyond the permissible memory causes a page error, and does not allow writing to physical memory. </font><font style="vertical-align: inherit;">The loader even set the correct access permissions for each page: only the pages with the code will be executable, and only the pages with the data will be available for writing</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Page errors (PageFault) </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's try to call PageFault by accessing memory outside the kernel. </font><font style="vertical-align: inherit;">First, we create an error handler and register it with our IDT in order to see a specific exception instead of </font></font><a href="https://os.phil-opp.com/double-fault-exceptions/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> generic </font><a href="https://os.phil-opp.com/double-fault-exceptions/"><font style="vertical-align: inherit;">double error</font></a><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/interrupts.rs lazy_static! { static ref IDT: InterruptDescriptorTable = { let mut idt = InterruptDescriptorTable::new(); […] idt.page_fault.set_handler_fn(page_fault_handler); // new idt }; } use x86_64::structures::idt::PageFaultErrorCode; extern "x86-interrupt" fn page_fault_handler( stack_frame: &amp;mut ExceptionStackFrame, _error_code: PageFaultErrorCode, ) { use crate::hlt_loop; use x86_64::registers::control::Cr2; println!("EXCEPTION: PAGE FAULT"); println!("Accessed Address: {:?}", Cr2::read()); println!("{:#?}", stack_frame); hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the page fails, the CPU automatically sets the register </font></font><a href="https://en.wikipedia.org/wiki/Control_register"><code>CR2</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. It contains the virtual address of the page that caused the crash. To read and display this address, use the function </font></font><code><a href="https://docs.rs/x86_64/0.3.5/x86_64/registers/control/struct.Cr2.html">Cr2::read</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Typically, the type </font></font><code><a href="https://docs.rs/x86_64/0.3.4/x86_64/structures/idt/struct.PageFaultErrorCode.html">PageFaultErrorCode</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gives more information about the type of access to the memory that caused the error, but because of the </font></font><a href="https://github.com/rust-lang/rust/issues/57270"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LLVM bug, an</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> invalid error code is transmitted, so for the time being we ignore this information. Program execution cannot be continued until we eliminate the page error, therefore we insert at the end </font></font><code><a href="https://os.phil-opp.com/hardware-interrupts/">hlt_loop</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we get access to memory outside the kernel:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { use blog_os::interrupts::PICS; println!("Hello World{}", "!"); // set up the IDT first, otherwise we would enter a boot loop instead of // invoking our page fault handler blog_os::gdt::init(); blog_os::interrupts::init_idt(); unsafe { PICS.lock().initialize() }; x86_64::instructions::interrupts::enable(); // new let ptr = 0xdeadbeaf as *mut u32; unsafe { *ptr = 42; } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After launch, we see that the page error handler is being invoked: The </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/81e/aad/666/81eaad666e7980ce90867ffe3fcb0be3.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">register </font></font><code>CR2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">does contain the address </font></font><code>0xdeadbeaf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we wanted to access. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The current instruction pointer is </font></font><code>0x20430a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, so we know that this address points to a code page. </font><font style="vertical-align: inherit;">Code pages are displayed as read-only by the loader, so reading from this address is working, and writing will cause an error. </font><font style="vertical-align: inherit;">Try changing the pointer </font></font><code>0xdeadbeaf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to </font></font><code>0x20430a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// Note: The actual address might be different for you. Use the address that // your page fault handler reports. let ptr = 0x20430a as *mut u32; // read from a code page -&gt; works unsafe { let x = *ptr; } // write to a code page -&gt; page fault unsafe { *ptr = 42; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If we comment out the last line, we can make sure that the read is working, and the write causes a PageFault error. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Access to page tables </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now take a look at the page tables for the kernel: </font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { use x86_64::registers::control::Cr3; let (level_4_page_table, _) = Cr3::read(); println!("Level 4 page table at: {:?}", level_4_page_table.start_address()); […] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The function </font></font><code><a href="https://docs.rs/x86_64/0.3.4/x86_64/registers/control/struct.Cr3.html">Cr3::read</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of the </font></font><code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">returns from the register of </font></font><code>CR3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the currently active page table of the fourth level. Returns a pair </font></font><code><a href="https://docs.rs/x86_64/0.3.4/x86_64/structures/paging/struct.PhysFrame.html">PhysFrame</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code><a href="https://docs.rs/x86_64/0.3.4/x86_64/registers/control/struct.Cr3Flags.html">Cr3Flags</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. We are only interested in the first. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After the launch, we see the following result: </font></font><br><br> <code>Level 4 page table at: PhysAddr(0x1000)</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, the currently active fourth-level page table is stored in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">physical</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memory at the address </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, as indicated by the type </font></font><code>PhysAddr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Now the question is: how to access this table from the kernel? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With paging, direct access to physical memory is not possible, otherwise programs can easily bypass protection and gain access to the memory of other programs. Thus, the only way to access is through a virtual page that is translated into a physical frame at</font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This is a typical problem, because the kernel should regularly refer to page tables, for example, when allocating a stack for a new thread. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will describe the solutions to this problem in detail in the next article. For now, just say that the loader uses a method called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recursive page tables</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The last page of the virtual address space is </font></font><code>0xffff_ffff_ffff_f000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, use it to read some of the records in this table:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { let level_4_table_pointer = 0xffff_ffff_ffff_f000 as *const u64; for i in 0..10 { let entry = unsafe { *level_4_table_pointer.offset(i) }; println!("Entry {}: {:#x}", i, entry); } […] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have reduced the address of the last virtual page to a pointer to </font></font><code>u64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. As mentioned in the previous section, each page table entry is 8 bytes (64 bits) in size, so it </font></font><code>u64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">represents exactly one entry. With the help of the cycle </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we display the first 10 records of the table. Inside the loop, we use an unsafe block to read directly from the pointer and </font></font><a href="https://doc.rust-lang.org/std/primitive.pointer.html"><code>метод offset</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to calculate the pointer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After starting see the following results: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/725/8b0/9cb/7258b09cb744af09041bb3a2ee05fd54.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">According to the format described above, the value </font></font><code>0x2023</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recording means having flags 0 </font></font><code>present</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>writable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>accessed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and translation into a frame </font></font><code>0x2000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Record 1 is broadcast to the frame </font></font><code>0x6e2000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and it has the same flags, plus</font></font><code>dirty</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Records 2-9 are missing, so these virtual address ranges are not mapped to any physical addresses. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instead of working with unsafe pointers, you can use the type </font></font><a href="https://docs.rs/x86_64/0.3.4/x86_64/structures/paging/struct.PageTable.html"><code>PageTable</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from </font></font><code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { use x86_64::structures::paging::PageTable; let level_4_table_ptr = 0xffff_ffff_ffff_f000 as *const PageTable; let level_4_table = unsafe {&amp;*level_4_table_ptr}; for i in 0..10 { println!("Entry {}: {:?}", i, level_4_table[i]); } […] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we assign a pointer to the pointer </font></font><code>0xffff_ffff_ffff_f000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">first, and then convert it to the Rust link. The operation is still unsafe, since the compiler cannot know that access to this address is allowed. But after conversion, we have a safe type </font></font><code>&amp;PageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which gives access to individual records through safe, proven boundaries </font></font><a href="https://doc.rust-lang.org/core/ops/trait.Index.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of indexing operations</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">also provides some abstraction for individual records to instantly see the flags set: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/70a/d89/73d/70ad8973d35a531c7ad5943ef5144ef8.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next step - to follow the signs to write 0 or write 1 to the page table level 3. But now we have again the problem arises that </font></font><code>0x2000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and </font></font><code>0x6e5000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are physical addresses, so we do not we can get direct access to them. This problem will be solved in the next article.</font></font><br><br><h1>  Summary </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The article presents two methods of memory protection: segmentation and page organization. The first method uses variable-sized memory areas and suffers from external fragmentation, the second uses fixed-size pages and allows much more detailed control over access rights. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The page organization stores information about the pages broadcast in tables of one or several levels. The x86_64 architecture uses four-level tables with a page size of 4 KB. The equipment automatically bypasses the page tables and caches the conversion results in an associative translation buffer (TLB). When changing the page tables, it should be forcibly cleared.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We learned that our core already supports paging, and with unauthorized memory access, PageFault falls out. </font><font style="vertical-align: inherit;">We tried to access the current active page tables, but managed to access only the fourth-level table, since the page tables store the physical addresses, and we cannot access them directly from the kernel.</font></font><br><br><h1>  What's next? </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following article is based on the fundamentals that we have now learned. </font><font style="vertical-align: inherit;">To access the page tables from the kernel, an advanced technique called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recursive page tables</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is used to cross the table hierarchy and implement software translation of addresses. </font><font style="vertical-align: inherit;">The article also explains how to create new broadcasts in the page tables.</font></font></div>