<div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/f5d/0d7/06a/f5d0d706a7ba63af9b903584ea96e187.png" alt="SDL2"><br><br>  <i>From the translator:</i> <i><br><br></i>  <i>I continue the abandoned series of translations of tutorials from Twinklebear, originally available <a href="https://www.willusher.io/pages/sdl2/">here</a> , with the permission of the translator of the previous lessons of the <a href="https://habr.com/ru/users/invalidpointer/" class="user_link">InvalidPointer</a> series.</i>  <i>The first two lessons of the translation series in the list are for its authorship.</i>  <i>The translation is partly voluntary and may contain minor corrections or additions from the translator.</i> <br><a name="habracut"></a><br>  <b>List of lessons:</b> <br><br><ul><li>  <a href="https://habr.com/ru/post/198600/">Lesson 1. Hello World!</a> </li><li>  <a href="https://habr.com/ru/post/200730/">Lesson 2. Don't put everything in main</a> </li><li>  <b>Lesson 3. SDL extension libraries</b> </li><li>  <a href="https://habr.com/ru/post/437308/">Lesson 4. Event handling</a> </li><li>  Lessons 5-6 - To be continued </li></ul><br><h2>  SDL Extensions Libraries </h2><br>  Up to this point, we used only images in the BMP format, since this is the only type of images supported by the main library SDL 2, and this is not very convenient.  Fortunately, there are many extension libraries for SDL that add useful features, for example, SDL_image allows you to load many types of images, SDL_ttf adds support for text rendering using TTF fonts, SDL_net for low-level network support, and SDL_mixer for multi-channel audio. <br><br><h3>  Extension installation </h3><br>  In this tutorial, we will only use SDL_image, however, the installation process for the remaining extensions is no different, and, in general, almost coincides with that for installing SDL2 itself. <br><br><ul><li>  <b>Windows</b> (MinGW or Visual Studio): Place the extension files downloaded from <a href="http://www.libsdl.org/projects/SDL_image/">the extension's project page</a> in the SDL2 folder.  Also, you will need to copy SDL2_image, zlib and other .dll files (for example, libpng) to the folder with your executable file (or in C: \ Windows \ system32 - <i>approx. Lane</i> ) so that they load when the application starts. </li><li>  <b>Linux</b> : Install the extension using your full-time package manager, or build from source.  <i>If you have Linux - most likely you already know how to do this ©.</i> </li><li>  <b>Mac</b> : Download .dmg from the <a href="http://www.libsdl.org/projects/SDL_image/">official site</a> and follow the instructions in the Readme. </li></ul><br>  Also, in order to use the extension, you will need to update the list of used header files and link libraries, just as it did for SDL2 itself. <br><br>  Before you start working with the extension, the &lt;SDL2 / SDL_image.h&gt; file, or the file corresponding to the name of the desired extension, must be connected after the header file of the SDL itself to the .c and .cpp files that use it. <br><br><h3>  Initialize SDL_image (optional) </h3><br>  When an image of each type is first loaded, SDL_image automatically initializes the subsystem necessary for this type; however, this will cause a slight delay.  To avoid this, you can pre-initialize the necessary subsystems using the IMG_Init function.  IMG_Init returns a bit mask with a list of all subsystems that have been successfully initialized at the moment, so to check the success of the call, you need to check that the bits for all subsystems specified for initialization were set, for example, by applying the mask to the result of bitwise AND. Png.  It is important to carry out this operation after SDL_Init. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((IMG_Init(IMG_INIT_PNG) &amp; IMG_INIT_PNG) != IMG_INIT_PNG) { logSDLError(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>, <span class="hljs-string"><span class="hljs-string">"IMG_Init"</span></span>); SDL_Quit(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><br><h3>  Set the size </h3><br>  In this tutorial we will look at how to load images using SDL_image, how to scale textures when drawing and tile the background with tiles in a more rational way than in the previous lesson - a cycle based on the window and tile sizes. <br><br>  But first, let's set a constant for the size of the tiles, right below the constants for the window sizes. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SCREEN_WIDTH = <span class="hljs-number"><span class="hljs-number">640</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SCREEN_HEIGHT = <span class="hljs-number"><span class="hljs-number">480</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Будем использовать квадратные плитки const int TILE_SIZE = 40;</span></span></code> </pre><br><h3>  Image upload using SDL_image </h3><br>  SDL_image allows you to load several types of images, as well as immediately convert them to SDL_Texture with the IMG_LoadTexture function.  This function replaces almost the entire function code loadTexture from the previous lesson, now it is enough just to call IMG_LoadTexture, check for any errors during the load, and exit the function.  Since the function IMG_GetError defined in SDL_image is nothing more than a synonym for SDL_GetError, we can use any of them to display error messages. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Загружает изображение в текстуру для рендерера * @param file Путь к изображению * @param ren Рендерер, на который эту текстуру можно будет отрисовать * @return Возвращает текстуру, либо nullptr в случае ошибки. */</span></span> <span class="hljs-function"><span class="hljs-function">SDL_Texture* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;file, SDL_Renderer *ren)</span></span></span><span class="hljs-function"> </span></span>{ SDL_Texture *texture = IMG_LoadTexture(ren, file.c_str()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!texture) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; IMG_GetError(); <span class="hljs-comment"><span class="hljs-comment">// Можно заменить на SDL_GetError() } return texture; }</span></span></code> </pre><br><h3>  Specify the height and width for drawing </h3><br>  If, when rendering a texture to the renderer, specify the size of the rectangle that is different from the size of the texture itself, SDL2 will scale it accordingly.  However, if scaling is not required, then each time determining the original texture size can be inconvenient, so we implement two versions of the renderTexture function, one of which will render the texture with scaling, and the second without. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Отобразить SDL_Texture на SDL_Renderer на координатах x, y, с масштабированием * @param tex Текстура для отображения * @param ren Рендерер * @param x Координаты * @param y * @param w Фактический размер при отрисовке * @param h */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">renderTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SDL_Texture *tex, SDL_Renderer *ren, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> w, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> h)</span></span></span><span class="hljs-function"> </span></span>{ SDL_Rect dst; dst.x = x; dst.y = y; dst.w = w; dst.h = h; SDL_RenderCopy(ren, tex, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, &amp;dst); } <span class="hljs-comment"><span class="hljs-comment">/** * Отрисовать SDL_Texture на SDL_Renderer на координатах x, y, без масштабирования * @param tex Текстура * @param ren Рендерер * @param x Координаты * @param y */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">renderTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SDL_Texture *tex, SDL_Renderer *ren, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w, h; SDL_QueryTexture(tex, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, &amp;w, &amp;h); renderTexture(tex, ren, x, y, w, h); }</code> </pre><br><h3>  Texture loading </h3><br>  Since the main purpose of this lesson is to download PNG images, we will use the new set of images.  Also, we will demonstrate the preservation of PNG transparency when drawing a foreground image (with a transparent background) over a tiled background. <br><br>  We will use these pictures here: <br><br>  Tile to fill the background: <br><br><img src="https://habrastorage.org/webt/sc/nv/yr/scnvyry224o47rhupg2rzk8pywg.png"><br><br>  Foreground image (as written on it, with a transparent background, as well as again with emoticons that violate the rules of Habr): <br><br><img src="https://habrastorage.org/webt/-r/xn/hf/-rxnhffp2z9shdptiu134_zp74g.png"><br><br>  Upload images: <br><br><pre> <code class="cpp hljs">SDL_Texture *background = loadTexture(<span class="hljs-string"><span class="hljs-string">"background.png"</span></span>, renderer); SDL_Texture *image = loadTexture(<span class="hljs-string"><span class="hljs-string">"image.png"</span></span>, renderer); <span class="hljs-comment"><span class="hljs-comment">// Проверка if (!background || !image) { // В оригинале, эта часть использовала шаблонную функцию cleanup(), рассмотренную в PS к первому уроку, добавленному уже после написания перевода, и посему, не попавшему в перевод. SDL_DestroyTexture(background); SDL_DestroyTexture(image); SDL_DestroyRenderer(renderer); SDL_DestroyWindow(window); IMG_Quit(); SDL_Quit(); return 1; }</span></span></code> </pre><br><h3>  Tiling background </h3><br>  Since the tiles have become noticeably smaller, we will need to put more than four pieces to fill the entire window, and it will be rather difficult to specify the position for each one manually.  Fortunately, you can get the computer to determine these positions independently. <br><br>  We can find out how many tiles are needed in width by dividing the width of the window by the size of the tile, and likewise for height. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Определение количества плиток, необходимого для покрытия всего окна // От переводчика: я бы заменил на ceil(float(SCREEN_WIDTH) / TILE_SIZE), чтобы в том случае, кода размер окна не кратен размеру плитки, оставшаяся часть окна не оставалась пустой; однако, в данном примере размеры заданы константой и кратны, так что это не страшно. int xTiles = SCREEN_WIDTH / TILE_SIZE; int yTiles = SCREEN_HEIGHT / TILE_SIZE; // Отрисовка фона for (int i = 0; i &lt; xTiles * yTiles; ++i) { int x = i % xTiles; int y = i / xTiles; renderTexture(background, renderer, x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE); }</span></span></code> </pre><br><h3>  Foreground image rendering </h3><br>  As before, the foreground image is placed in the middle of the window. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iW, iH; SDL_QueryTexture(image, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, &amp;iW, &amp;iH); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = SCREEN_WIDTH / <span class="hljs-number"><span class="hljs-number">2</span></span> - iW / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = SCREEN_HEIGHT / <span class="hljs-number"><span class="hljs-number">2</span></span> - iH / <span class="hljs-number"><span class="hljs-number">2</span></span>; renderTexture(image, renderer, x, y);</code> </pre><br>  It remains only to display the result on the window and wait a couple of seconds, just as in the second lesson. <br><br><pre> <code class="cpp hljs">SDL_RenderPresent(renderer); SDL_Delay(<span class="hljs-number"><span class="hljs-number">2000</span></span>);</code> </pre><br><h3>  Cleaning </h3><br>  The release of resources is similar to that in lesson 2 (and has already been met above, when processing an image loading error), with the exception of the added IMG_Quit call. <br><br><pre> <code class="cpp hljs">SDL_DestroyTexture(background); SDL_DestroyTexture(image); SDL_DestroyRenderer(renderer); SDL_DestroyWindow(window); IMG_Quit(); SDL_Quit();</code> </pre><br>  After successful compilation and launch, if you did everything correctly, the window will look like this: <br><br><img src="https://habrastorage.org/webt/oa/sv/se/oasvseqewrkxuy-2_zjivhxsuy8.png"><br><br><h3>  The end of the third lesson </h3><br>  That came to an end the next lesson.  See you all in lesson 4: Event handling. </div>