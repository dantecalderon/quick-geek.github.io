<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Simple do-it-yourself logistics</title>
  <meta name="description" content="I want to share with you the experience of creating a logistics system in one commercial enterprise. 

 One fine day, in the near 2012, the head set t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Simple do-it-yourself logistics</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/8q/5x/us/8q5xusizpadue_6rabtgqyvxzlq.gif"><br><br>  I want to share with you the experience of creating a logistics system in one commercial enterprise. <br><br>  One fine day, in the near 2012, the head set the task: to think about the problem of optimizing the cost of transport logistics of the organization. <br>  The main activity of the enterprise is the wholesale sale and delivery of products, where transport costs occupy a significant share of costs. <br><br>  The management considered that the time had come to bring order to the expenditure of funds for fuel, and there were also suspicions that the drivers were additionally engaged in more ‚Äúleft‚Äù delivery between flights.  In small-medium enterprises, much is built on trust, as it is costly to keep individuals to control and is not always advisable.  When costs grow, and efficiency drops, then you just need to do something. <br><a name="habracut"></a><br>  To begin with, we tried to solve the problem with managerial methods: constant measurement of the fuel level, tachometer readings, delivery time measurement with personal cargo tracking.  The effect was about nothing but negativity, suspicion, and unnecessary movements (measuring it, too, for someone to work).  If during the single route it was still possible to define approximate frames, then during the flight from 25-35 trade objects everything changed very much, the spread was very large, both in time and in fuel. <br><br>  Objective: to send loaded vehicles to trade enterprises reducing mileage, and therefore costs.  If possible, avoid deviations from the route.  The goal is to reduce costs with minimal investment in finance and time to implement, so to speak yesterday.  During the discussions, agreed on several alternatives: <br><br><ol><li>  use one of the services for calculating routes and accounting for fuel; </li><li>  put on the fleet tracking / tracking modules; </li><li>  design something yourself; </li></ol><br>  We decided to try all three solutions and choose the best: <br><br>  1. We did not find a good ready-made solution at that time.  Either turnkey design, but expensive, or take it as it is and further by agreement.  We tried several online services.  In general, it is not bad, but basically the difficulty was to duplicate information from the accounting system, the number of actions to get the result (click here, go here, update the directory), everything is online (at that time it was critical).  But the biggest drawback is the difficulty in drawing up routes with multiple points and choosing the best route.  Usually, everything had to be selected manually, adjusting the values, which is a long and not always successful result. <br><br>  After a couple of months of work, they refused such a decision. <br><br>  2. As an experiment, GSM tracking modules were installed on a dozen vehicles. <br>  The result is more successful.  You always know where the car was.  But the cost is more expensive than the first option.  However, after identifying a couple of cases of deviations from the route (one driver of the Sabbath, the second visited the lady of the heart during working hours), the staff began to get rid of such devices.  Although they have not previously enthusiastically accepted this innovation.  Either the power terminal accidentally fell off, the device went out of order when the engine was repaired, the electronics in the sun ‚Äúoverheated‚Äù.  So for three years we lost 9 devices.  In general, the decision turned out to be positive, but from the drawbacks - it took a long time to look through the routes covered to identify suspicious activity, which is not very convenient.  A plus in the tracking system was an item about track export, which allowed to accumulate certain statistics on routes. <br><br>  Later we used another system from one of the major cellular operators for corporate communication and tracking the activity of sales agents, the result was similar: SIM cards broke, phones were lost, forgotten at home, the battery was exhausted, people would always find a way out. <br><br>  3. In parallel with the first two approaches, it was decided to <s>reinvent the wheel</s> , to realize the possibility to build routes in their own accounting system. <br><br>  For a start, we brought all the places of the visit and put their geo-coordinates in the database.  We received the coordinates according to the GPS tracker when visiting, as well as visually using <a href="https://www.openstreetmap.org/">OSM</a> maps, finding the right place with the mouse and copying the coordinates. <br><br>  At the second stage, it was necessary to obtain vector maps of the region in a convenient format. <br>  The choice fell on the same OSM, since the cards have an open format.  We didn‚Äôt master the parsit dump of the planet, so we initially unloaded the data into XML in pieces, through export from the OSM itself, and then connected the territories.  Later came across a <a href="http://gis-lab.info/">GIS-LAB</a> project.  These worthy people for many years laid out a <a href="http://gis-lab.info/projects/osm_dump/">daily dump of</a> territories, divided by region.  But everyone wants to eat, the project has recently stalled, and the guys have <a href="http://nextgis.com/">moved</a> , and are doing the same work for a reasonable price. <br><br>  Having received the map in XML format, we extracted the layer responsible for the roads according to the <a href="https://wiki.openstreetmap.org/wiki/RU:Highway_classification">specification</a> .  Since the volume of maps of several neighboring regions occupied a dozen gigabytes, the SAX parser was written in RUBY, it selected only the necessary tags and combined the neighboring regions in which the activity was carried out into a single structure. <br><br>  The project itself is written as an external DLL to the accounting system written in Pascal.  The fleet of devices on which the system was supposed to work was, to put it mildly, obsolete, so there was a limitation of 1 GB of RAM (Yes, there are still companies that use such equipment, it has been working for 10 years, it will work as long).  Initially, there was a desire to break the map into pieces and load it into RAM as needed (as on navigators), but this was extremely slow.  As a result, managed to build up to a reasonable fifty MB. <br><br>  In OSM, road maps are represented as vector sections of the roadway with additional attributes.  In our solution, we used <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BF%25D0%25B8%25D1%2581%25D0%25BE%25D0%25BA_%25D1%2581%25D0%25BC%25D0%25B5%25D0%25B6%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8">adjacency lists</a> .  Where the vertex is a point on the map, and the edges are the paths to the neighboring point.  For optimization, we assume that there can be a maximum of four paths from one vertex (intersection).  If there are more than 4 paths, then we need to split the edge into two additional ones, so we always have a fixed number of edges = 4 for each point of the map. This approach allows alignment of data in memory, although it is somewhat redundant. <br><br>  It is worth noting that the Earth is not a ball (unexpectedly), but a <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D0%25B5%25D0%25BE%25D0%25B8%25D0%25B4">geoid</a> , but for mapping purposes it is simplified to a spheroid or <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B8%25D0%25B3%25D1%2583%25D1%2580%25D0%25B0_%25D0%2597%25D0%25B5%25D0%25BC%25D0%25BB%25D0%25B8">ellipsoid</a> . <br><br>  For our purposes, I found a formula for calculating the distances between two points on the surface of an ellipsoid, which I could not understand the whole deep meaning, but this does not prevent us from using it. <br><br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre><code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">distance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StartLong:Single; StartLat:Single; EndLong:Single; EndLat:Single)</span></span></span><span class="hljs-function"> :</span></span> Single; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> D2R: Double = <span class="hljs-number"><span class="hljs-number">0.017453</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Degrees to Radians Conversion E2: Double = 0.006739496742337; // Square of eccentricity of ellipsoid var fPhimean: Double; // Mean latitude fdLambda: Double; // Longitude difference fAlpha: Double; // Bearing fRho: Double; // Meridional radius of curvature fNu: Double; // Transverse radius of curvature fR: Double; // Radius of spherical earth fz: Double; // Angular distance at centre of spheroid begin fdLambda := (StartLong - EndLong) * D2R; fPhimean := ((StartLat + EndLat) / 2.0) * D2R; fRho := (6378137.0 * (1 - E2)) / Power(1 - E2 * (Power(Sin(fPhimean),2)), 1.5); fNu := 6378137.0 / (Sqrt(1 - E2 * (Sin(fPhimean) * Sin(fPhimean)))); fz := Sqrt(Power(Sin((StartLat - EndLat) * D2R/2.0),2) + Cos(EndLat*D2R) * Cos(StartLat*D2R) * Power(Sin(fdLambda/2.0),2)); fz := 2 * ArcSin(fz); fAlpha := ArcSin(Cos(EndLat * D2R) * Sin(fdLambda) * 1 / Sin(fz)); fR := (fRho * fNu) / ((fRho * Power(Sin(fAlpha),2)) + (fNu * Power(Cos(fAlpha),2))); distance := fz * fR; // 1 –µ–¥–∏–Ω–∏—Ü–∞ 1 –º–µ—Ç—Ä end;</span></span></code> </pre> <br></div></div><br>  After creating the road base, a visual layer was needed to display the surrounding space.  Here the <a href="http://maperitive.net/">maperitive</a> project <a href="http://maperitive.net/">helped</a> , it allowed <a href="http://maperitive.net/">parsing</a> the OSM map of the regions into tiled areas in approximation layers, just like 10 ^ 100 or Yandex does.  There was an attempt to work with maps of giants online, drawing a vector map on top of the browser layer, but due to licensing restrictions, they decided to refuse.  As a result, a virtual disk was created and a dump of tiles for a couple of dozen gigabytes was uploaded there, but everything is at hand and does not slow down.  True, you have to refresh about once every six months, usually this coincides with the overload of maps. <br><br><img src="https://habrastorage.org/webt/08/yh/bv/08yhbvifuodykzr8nalo3tvjgbq.png"><br><br>  To combine a tile image and a vector map you need to know that tiles, Google, OpenStreetMap, Bing, Yahoo are represented in the <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F_%25D0%259C%25D0%25B5%25D1%2580%25D0%25BA%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580%25D0%25B0">Mercator projection</a> (more precisely, <a href="https://en.wikipedia.org/wiki/Web_Mercator_projection">WEB MERCATOR</a> , which is a projection on the sphere), where each deeper layer is twice as detailed as the previous one. <br><br><img src="https://habrastorage.org/webt/6z/un/ji/6zunjive2iit8lp9-blirxfcbde.png"><br><br>  Yandex.Maps use the ellipsoid Mercator projection. <br><br>  It does not matter if you can recalculate the geo-coordinates on the projection plane and back. <br><br>  We chose level 17 as the maximum.  Closer does not make sense due to the increased storage of the number of tiles (each level is 4 times more than the previous one), as well as their low information content. <br><br>  2 ^ 17 * 256 = 33554432 (256 is the size of the edge of the tile in pixels). <br><br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">Const</span></span> size =<span class="hljs-number"><span class="hljs-number">33554432</span></span>; <span class="hljs-comment"><span class="hljs-comment">// —Ä–∞–∑–º–µ—Ä –∫–∞—Ä—Ç—ã –Ω–∞ —É—Ä–æ–≤–Ω–µ –¥–µ—Ç–∞–ª–∏–∑–∞—Ü–∏–∏ 17 –≤ –ø–∏–∫—Å–µ–ª—è—Ö; center=16777216; // –∑–∞–¥–∞—ë—Ç x –∏ y –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Ü–µ–Ω—Ç—Ä–∞ –∫–∞—Ä—Ç—ã –≤ –ø–∏–∫—Å–µ–ª—è—Ö; EXCT=0.081819790992; // –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ –∑–µ–º–ª–∏ –æ—Ç —Å—Ñ–µ—Ä—ã –∫ —ç–ª–ª–∏–ø—Å—É map_type=true; // —Ç–∏–ø –ø—Ä–æ–µ–∫—Ü–∏–∏: –∏—Å—Ç–∏–Ω–∞ ‚Äì —Å—Ñ–µ—Ä–æ–∏–¥ –∏–Ω–∞—á–µ —ç–ª–ª–∏–ø—Å–æ–∏–¥ //============================================================= // –ü–µ—Ä–µ—Å—á—ë—Ç –¥–æ–ª–≥–æ—Ç—ã –Ω–∞ –ø–ª–æ—Å–∫–æ—Å—Ç—å function TO_X(X:Single):Integer; begin TO_X := floor(center+size*(x/360)); // –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ X —Ç–æ—á–∫–∏ –Ω–∞—Ö–æ–¥—è—â–µ–π—Å—è –Ω–∞ –¥–æ–ª–≥–æ—Ç–µ Lon; end; //============================================================= // –ü–µ—Ä–µ—Å—á—ë—Ç —à–∏—Ä–æ—Ç—ã –Ω–∞ –ø–ª–æ—Å–∫–æ—Å—Ç—å function TO_Y(Y:Single):Integer; var ls:single; begin ls:=sin(Y*Pi/180); // C–∏–Ω—É—Å —à–∏—Ä–æ—Ç—ã; if map_type then TO_Y := floor(center-atanh(ls)*(size/(2*Pi))) // –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ Y —Ç–æ—á–∫–∏ –Ω–∞—Ö–æ–¥—è—â–µ–π—Å—è –Ω–∞ –¥–æ–ª–≥–æ—Ç–µ Lat –¥–ª—è —Å—Ñ–µ—Ä—ã else TO_Y := floor(center-(atanh(ls) - EXCT * atanh(EXCT * ls))*(size/(2*Pi))); // –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ Y —Ç–æ—á–∫–∏ –Ω–∞—Ö–æ–¥—è—â–µ–π—Å—è –Ω–∞ –¥–æ–ª–≥–æ—Ç–µ Lat –¥–ª—è —ç–ª–ª–∏–ø—Å–æ–∏–¥–∞; end; //============================================================= // –û–±—Ä–∞—Ç–Ω—ã–π –ø–µ—Ä–µ—Å—á—ë—Ç –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –ø–∏–∫—Å–µ–ª—è –≤ –¥–æ–ª–≥–æ—Ç—É function TO_LON(X:Single):Single; begin TO_LON := (X - center) * 360 / size; end; //============================================================= // –û–±—Ä–∞—Ç–Ω—ã–π –ø–µ—Ä–µ—Å—á—ë—Ç –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –ø–∏–∫—Å–µ–ª—è –≤ —à–∏—Ä–æ—Ç—É function TO_LAT(Y:Single):Single; var g:Double; begin if map_type then // –î–ª—è —Å—Ñ–µ—Ä—ã TO_LAT:= (180 / Pi)* (2 * ArcTan(exp((center - y) * 2 * Pi / size)) - Pi / 2) else begin // –î–ª—è —ç–ª–ª–∏–ø—Å–æ–∏–¥–∞ g := (PI/2) - 2 * ArcTan(1 / Exp((20037508.342789 - (y*64) / 53.5865938) / 6378137)); TO_LAT:= 180 / Pi * (g + 0.00335655146887969 * Sin(2 * g) + 0.00000657187271079536 * Sin(4 * g) + 0.00000001764564338702 * Sin(6 * g) + 0.00000000005328478445 * Sin(8 * g)); end; end; //=============================================================</span></span></code> </pre><br></div></div><br>  Now that we have the basic tools, we can proceed directly to the task of creating the optimal route.  We connect trade objects with the nearest edge in the graph of roads, and then we start the search for the shortest path.  For this, we use a variant of the <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2594%25D0%25B5%25D0%25B9%25D0%25BA%25D1%2581%25D1%2582%25D1%2580%25D1%258B">Dijkstra algorithm</a> for its rarefied variation, successively for each entry point.  At the output, we obtain <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B0%25D1%2582%25D1%2580%25D0%25B8%25D1%2586%25D0%25B0_%25D1%2581%25D0%25BC%25D0%25B5%25D0%25B6%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8">the adjacency matrix</a> , the size (N + 1) * (N + 1) with infinity on the main diagonal (ring prohibition), where N is the number of visiting points without taking into account the exit point. <br><br>  The resulting matrix stores the minimum distance on the roads between all shopping facilities, which is the classic <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25B4%25D0%25B0%25D1%2587%25D0%25B0_%25D0%25BA%25D0%25BE%25D0%25BC%25D0%25BC%25D0%25B8%25D0%25B2%25D0%25BE%25D1%258F%25D0%25B6%25D1%2591%25D1%2580%25D0%25B0">task of a traveling salesman</a> .  Since the algorithmic complexity of such a task exceeds the limit, we used <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_%25D0%25B2%25D0%25B5%25D1%2582%25D0%25B2%25D0%25B5%25D0%25B9_%25D0%25B8_%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BD%25D0%25B8%25D1%2586">the branch and bound method</a> for solving.  For n &lt;15, exhaustive search, otherwise a rough estimate of depth was included.  The option is certainly not perfect, but quite working. <br><br>  As a result, we received a route close to the optimal distance with an estimate in km.  If necessary, the operator can manually change the route in favor of the priority of individual points. <br><br>  The solution works in the organization for about 7 years, quite successfully, although not without flaws, both in accuracy and in convenience.  The results are quite consistent with the data of GPS-tracking cars.  In my estimation, the introduction of logistics allowed saving 10-12% of the allocated funds for fuel.  The program was designed, launched and accompanied by just one person - your humble servant. <br><br>  My conservative leadership is not eager to "shine", so for the attention I offer a fictional example of the route. <br><br><img src="https://habrastorage.org/webt/q6/sf/1k/q6sf1kvowcm20qekajgg5higcpo.gif"><br><br>  Without visualization, the calculation goes many times faster, and within one settlement, almost instantly. <br><br>  After so many years, sometimes itching to climb into the code and rewrite it with a new experience on a new, more modern platform, but so far there is no economic feasibility. <br><br>  That's all that I wanted to tell you, I hope it was interesting. <br>  I apologize if I was somewhere not accurate. </div><p>Source: <a href="https://habr.com/ru/post/437280/">https://habr.com/ru/post/437280/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>