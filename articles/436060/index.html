<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Architectural solutions for mobile games. Part 3: View on jet propulsion</title>
  <meta name="description" content="In previous articles, we described how a convenient and well-designed model should be arranged, which command system that performs the functions of co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Architectural solutions for mobile games. Part 3: View on jet propulsion</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/ix/84/lz/ix84lzlun0rnpohgx14wu7mzbp4.jpeg"><br><br>  In previous articles, we described how a convenient and well-designed model should be arranged, which command system that performs the functions of controllers would suit her, it was time to talk about the third letter of our alternative MVC abbreviation. <br><br>  In fact, there is a ready-made very sophisticated library UniRX that implements reactivity and inversion of control for unity.  But we'll talk about it at the end of the article, because this powerful, huge and RX-compliant tool for our case is quite redundant.  It is perfectly possible to do everything that we need without pulling up the RX, and if you own it, it will not be difficult for you to do the same with it. <br><br>  <a href="https://habr.com/post/434582/">Architectural solutions for mobile games.</a>  <a href="https://habr.com/post/434582/">Part 1: Model</a> <br>  <a href="https://habr.com/post/435704/">Architectural solutions for mobile games.</a>  <a href="https://habr.com/post/435704/">Part 2: Command and their queues</a> <br><a name="habracut"></a><br>  When a person is just starting to write the first game, it seems logical to him the existence of a function that will draw him the whole form, or some part of it, and pull it every time something important has changed.  Time passes, the interface grows in size, fomochek and parts of the form becomes a hundred, then two hundred, and when the state of the wallet changes, a quarter of them have to be redrawn.  And then the manager comes, and says that ‚Äúlike in that game,‚Äù you need to make a little red dot on the button if there is a section inside the button, in which there is a subsection, in which the button, and now you have enough resources to do something that is important.  And all sailed ... <br><br>  The departure from the concept of drawing takes place in several stages.  First solved the problem of single fields.  You have, for example, a field in a model, and a text field in which all its contents should be displayed.  Ok, we get an object that subscribes to updates of this field, and with each update adds the results into a text field.  In the code, something like this: <br><br><pre><code class="cpp hljs">var observable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ChildControl(FCPlayerModel.ASSIGNED, Player); observable.onChange(i =&gt; Assigned.text = i.ToString())</code> </pre> <br>  Now we do not need to follow the redrawing, it is enough to create this construction, and then everything that happens in the model will fall into the interface.  Well, but cumbersome, it contains a lot of obviously unnecessary gestures that a programmer will have to write 100,500 times with his hands and sometimes make mistakes.  Wrap these ads in the expansion function, which will hide the extra small letters under the hood. <br><br><pre> <code class="cpp hljs">Player.Get(c, FCPlayerModel.ASSIGNED).Action(c, i =&gt; Assigned.text = i.ToString());</code> </pre> <br>  Much better, but that's not all.  Shifting the model field to a text field is so frequent and typical that we will create a separate wrapper function for it.  Now it turns out quite briefly and well, I think. <br><br><pre> <code class="cpp hljs">Player.Get(c, FCPlayerModel.ASSIGNED).SetText(c, Assigned);</code> </pre> <br>  Here I showed the main idea that I will use to guide the creation of the interface for the rest of my life: ‚ÄúIf you had to do something for the programmer at least twice, wrap it in a special convenient and short function.‚Äù <br><br><h2>  Garbage collection </h2><br>  A side effect of reactive interface construction is the creation of heaps of objects that are signed for something and therefore will not leave memory without a special kick.  For myself, back in ancient times, I came up with a method that is not so beautiful, but simple and affordable.  When creating any form, a list of all controllers is created that are created in connection with this form, for brevity, it is simply called ‚Äúc‚Äù.  All special wrapper functions accept this list as the first required parameter and when DisconnectModel is used, it uses code in the common ancestor to go through the list of all controls and all of them mercilessly displace.  No beauty and grace, but cheap, reliable and relatively practical.  It is possible to have a little more security if instead of a list of controls, you need an IView input and give it to all these places.  Essentially the same thing, forgetting to fill in the same way will not work, but it is harder to hack.  I'm afraid to forget, but I'm not very afraid that someone will deliberately break the system, because with such clever people you need to fight with a belt and other non-software methods, so I limit myself to just c. <br><br>  An alternative approach can be learned from UniRX.  Each wrapper creates a new object that has a link to the previous one that it listens to.  And at the end, the AddTo (component) method is called, which assigns the entire chain of controls to some deleted object.  In our example, this code will look like this: <br><br><pre> <code class="cpp hljs">Player.Get(FCPlayerModel.ASSIGNED).SetText(Assigned).AddTo(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);</code> </pre> <br>  If this last owner of the chain decides to be destroyed, he will give the command ‚Äúkill yourself about dispose if all of you other than me no longer listen to you‚Äù to all the controls assigned to it.  And the whole chain is obediently cleaned up.  So of course, it is much more concise, but from my point of view there is one important shortcoming.  AddTo can be accidentally forgotten and no one will ever know about this until it is too late. <br><br>  In fact, you can use the dirty Unity hack and do without any additional code in the View: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T AddTo&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> T disposable, Component component) where T : IDisposable { var composite = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompositeDisposable(disposable); Observable .EveryUpdate() .Where(_ =&gt; component == null) .Subscribe(_ =&gt; composite.Dispose()) .AddTo(composite); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> disposable; }</code> </pre> <br>  As you know, the link to the Component or the GameObject in Unity is null.  But you have to understand that this one here hakokostyl creates an Update listener for each chain of controls being destroyed, and this is not a little polite. <br><br><h2>  Model independent interface </h2><br>  Our ideal, which we, however, easily achieve, is the situation when we can download the full GameState at any moment, both the model checked by the server and the data model for the UI, and the application will be in exactly the same state, up to the state of all the buttons.  Two reasons interfere with this.  The first is that some variable programmers like to store inside the form controller, or even in the viewer itself, motivating it with the fact that their life cycle is exactly the same as that of the form itself.  The second is that even if all the data for the form is in its model, the team itself to create and fill out the form passes in the form of an explicit function call, also with some additional parameters, for example, on which field from the list you need to focus. <br><br>  With this you can not fight, if you do not really want the convenience of debugging.  But we are not, we want to debug the interface as conveniently as the main operations with the model.  To do this, the next focus.  In the UI part of the model, a variable is set, for example .main, and within the command you place the model of the form you want to see into it.  The state of this variable is monitored by a special controller, if, depending on its type, a model appears in this variable, it instantiates the desired form, places it where it is needed, and sends a call to it ConnectModel (model).  If the variable is freed from the model, the controller will remove the form from the canvas and subdispose it.  Thus, no action is taken to bypass the model, and everything that you did with the interface is perfectly visible on the ExportChanges model.  And then we are guided by the principle of ‚Äúeverything that is done double wrap‚Äù and use exactly the same controller at all levels of the interface.  If there is a place in the form for another form, then a UI model is created for it, and a variable is created in the model of the parent form.  Exactly the same with lists. <br><br>  A side effect of this approach is that two files are added to any form, one with the data model for this form, and the other, usually a single item containing references to the UI elements, which, having received the model in its ConnectModel function, will create all the reactive controllers for all model fields and all UI elements.  Well, it is even more compact to manage, so that it is also convenient to work with this, probably it is impossible.  If you can - write in the comments. <br><br><h2>  List controls </h2><br>  A typical situation is when the model has a list of some elements.  Since I want everything to be done very handy, and preferably in one line, I also wanted to do something for lists that would be convenient to process them.  Just one line is possible, but it turns out to be uncomfortably long.  It was empirically found out that almost all the variety of cases is covered by only two types of controls.  The first monitors the state of any collection, and calls three lambda functions, the first is called when an element is added to the collection, the second when the element leaves the collection, and finally the third is called when the elements of the collection change their order.  The second most frequent type of control keeps track of the list, and is the source of a sub-list of it - pages with a specific number.  That is, for example, it keeps track of a List 102 elements long, and it itself gives a List of 10 elements, from the 20th to the 29th.  And the events are generated exactly the same as if he himself was a list. <br><br>  Of course, following the principle of "create a wrapper for everything that was done twice," a huge number of convenient wrappers appeared, for example, one that only accepts Factory for the input, building a correspondence between the types of models and their View, and a link to the Canvas in which It is necessary to add elements.  And many other similar, only about a dozen wrappers for typical cases. <br><br><h2>  More complex controls </h2><br>  Sometimes there are situations that express through the model redundantly, as they are obvious.  Here controls that perform some operation on value can come to the aid, as well as controls that monitor other controls.  For example, a typical situation: an action has a price, and a button is active only if there is more money on the account than its price. <br><br><pre> <code class="cpp hljs">item.Get(c, FCUnitItem.COST).Join(c, Player.Get(c, MONEY)).Func(c, (cost, money) =&gt; cost &lt;= money).SetActive(c, BuyButton);</code> </pre> <br>  In fact, the situation is so typical that, in accordance with my principle, there is a ready-made wrapper for it, but here I showed its contents. <br><br>  They took an item to buy, created an object that is subscribed to one of its fields, and has a value of type long.  Another control was added to it, which has a type too long, the method returned a control that has a couple of values, and the Changed generating event when any of them changes, then Func creates an object for any change in the input computing function, and the Changed generating event if the total value counted function has changed. <br><br>  The compiler itself successfully builds the required type of control based on the types of input data and the type of the resulting expression.  In rare cases where the type returned by the lambda function is not obvious, the compiler will ask you to specify it explicitly.  Finally, the last call listens to the Bulenovsky control, depending on which it turns the button on or off. <br><br>  In fact, the real wrapper in the project accepts two buttons on the input, one for the case when there is money and another when there is not enough money, and also the second button puts the command to open the modal window ‚ÄúPurchase additional currency‚Äù.  And all this is in one simple line. <br><br>  It is easy to see that using Join and Func you can build arbitrarily complex structures.  I had a function in the code, generating a complex control, calculating for what amount a player can buy troops, given the number of players on his side, and the rule is that everyone can exceed the budget by 10% if they all together do not exceed the total budget.  And this is an example of how not to do it, because how simple and easy it is to debug what is happening in models for as many times as difficult to catch the error in the reactive controls.  You will even spend the time taking a lot of time to understand what led to it. <br><br>  Therefore, the general principle of using complex controls is as follows: When prototyping a form, you can use constructions on reactive controls, especially if you are not sure that they will become more complicated in the future, but as soon as you suspect that it breaks, you won‚Äôt understand what happened, You should immediately transfer these manipulations to the model, and the calculations that were previously done in controls should be placed in extension methods in static classes of rules. <br><br>  This is significantly different from the ‚ÄúDo it right all right‚Äù principle, so beloved by perfectionists, because we live in the game-dev world, and when you start to burn a mold you absolutely cannot be sure what it will do in three days.  As one of my colleagues said: ‚ÄúIf I received five kopecks every time game designers change their mind, I would be a very rich person.‚Äù  In fact, this is not bad, but even the opposite is good.  The game should be developed by trial and error, because if you are not making a stupid clone, then you finally can not imagine what the players really need. <br><br><h2>  Single data source for multiple views </h2><br>  On so many archetypical case that you need to talk about it separately.  It happens that the same model of an element as part of an interface model is drawn in different Views depending on where and in what context this occurs.  And we use the principle - ‚Äúone type, one view‚Äù.  For example, you have a weapon purchase card containing the same uncomplicated information, but in different modes of the store it should be represented by different prefabs.  The solution consists of two parts for two different situations. <br><br>  The first is when this View is placed inside two different Views, for example, a store in the form of a short list and a store with large pictures.  In this case, two separate, differently configured factories that build type-prefab conformance come to the rescue.  In the ConnectModel method of one View, you use one, and in the other, another.  It is a completely different case if you need to slightly show cards with absolutely identical information in one place.  Sometimes in this case, an additional field appears to the element model, indicating the festive headlight of this particular element, and sometimes just an element appears in the element model that does not have any fields, and is needed only to be drawn by another prefab.  In principle, nothing contradicts. <br><br>  It would seem an obvious solution, but I saw enough of someone else's code for strange dances with a tambourine around this situation, and found it necessary to write about it. <br><br><h2>  Special case: controls with a hell of dependencies </h2><br>  There is one very special case about which I want to talk separately.  These are controls that monitor a very large number of elements.  For example, a control that monitors the list of models and sums up the contents of some field lying inside each of the elements.  If there is a large overturning in the list, for example, filling it with the data, such a control risks catching as many change events as in the list of elements plus one.  Recounting the aggregate function as many times as possible is of course a bad idea.  Especially for such cases, we do the control, which we subscribe to the onTransactionFinished event, which sticks out from GameState, and as we remember, there is a link to GameState in any model.  And with any change in the input data, this control will simply put a label on it, that the source data has changed, and be recalculated only when it receives a message about the end of the transaction, or when it detects that the transaction is already completed when it received a message from the input event stream .  It is clear that such a control may not be protected from unnecessary messages if there are two such controls in the thread processing chain.  The first one accumulates a cloud of changes, waits until the end of the transaction, launches the flow of changes further, and there is another one that has already caught a lot of changes, received an event about the end of the transaction (it was unlucky to be earlier in the list of functions subscribed to the event), counted everything, and then bang and another change event, and recount everything a second time.  So maybe, but rarely, and more importantly, if your controls do such monstrous calculations more than once in one flow of calculations, then you are doing something wrong, and you need to transfer all these hellish manipulations into the model and the rules, where , in fact, the place. <br><br><h2>  UniRX Ready Library </h2><br>  And it would be possible to limit everything to what was said above, and calmly start writing your masterpiece, all the more so compared to the model and control teams it‚Äôs very simple and they‚Äôve written everything in less than a week if the idea that you invent a bicycle hadn‚Äôt been committed to it and everything is already thought out and written before me is distributed free to anyone. <br><br>  Having uniRX uncovered, we find a beautiful and standards-compliant design that can create streams from everything in general, deftly merzhit them, filter them from the main thread to the non-main thread, or return control back to the main thread, having a bunch of ready-made tools to send to different places and so Further.  We do not have there exactly two things: Simplicity and Debugging Convenience.  Have you ever tried to debug some multi-storey construction on Linq by steps in the debugger?  So here is still much worse.  At the same time, we completely lack something for which all this sophisticated machinery was created.  For the sake of simplicity in debugging and reproducing states, we completely lack a variety of sources of signals, everything happens in the main stream, because flirting with multithreading in the metagame is completely redundant, all the asynchronous processing of commands is hidden inside the command sending engine and the asynchronous itself occupies very much not a lot of space, much more attention is paid to all sorts of checks, self-checks, and logging and playback. <br><br>  In general, if you already know how to do UniRX, then especially for you I will do for IObservable models, and you will be able to use the trump features of your favorite library, but otherwise I suggest not trying to build tanks from high-speed cars and cars from tanks only on that basis that both the one and the other have wheels. <br><br>  At the end of the article I have to you, dear readers, the traditional questions that are very important for me, my ideas about the beautiful, and for the prospects for the development of my scientific and technical creativity. </div><p>Source: <a href="https://habr.com/ru/post/436060/">https://habr.com/ru/post/436060/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>