<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Microservices. Versioning in continuous integration and CI / CD deployment systems using TFS as an example</title>
  <meta name="description" content="Problematics 
 For large and technically complex projects, on which many distributed teams usually work at the same time, there is a well-known proble...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Microservices. Versioning in continuous integration and CI / CD deployment systems using TFS as an example</h1><div class="post__text post__text-html js-mediator-article"><h4>  Problematics </h4><br>  For large and technically complex projects, on which many distributed teams usually work at the same time, there is a well-known problem of software versioning, which different companies solve in different ways. <a name="habracut"></a><br><br>  Currently, a number of our clients and partners deliver the latest releases (CI / CD) to Production manually by installing the latest / current versions of their software, having previously tested it with the rest of the environment.  For example, by delivering assemblies of iOS, Android, etc., if we are talking about client software, or through updating docker-images in the docker environment, if we are talking about backend.  For large and important projects, where the decision to release a new version in Production is every time taken by the Project Manager, such a decision is justified and not too expensive, especially if releases are not frequent.  However, for a test development environment (Dev / Stage environment), the use of ‚Äúhand-held‚Äù tools leads to a project‚Äôs confusion, possible disruption to the Customer‚Äôs display, and so on.  The reasons for this may be many, including the inconsistency of versions of different containers on the middleware software or the absence of a detailed release history. <br><br>  We had to make sure of this personally and experience many difficulties on a large project, in which 6-8 new software versions were released every day on the backend and 2-3 software versions on the frontend in the CI system, where testing engineers objectively could not cope with the load and there was a constant misunderstanding of what version of software on the frontend / backend is considered stable at the current moment. <br><br><h4>  Our experience </h4><br>  Our company uses various CI / CD systems in its work, the choice of which is often determined by the requirements of the Customer.  For example, our specialists often encounter such systems as CI / CD as Jenkins, TeamCity, Travis CI, Circle CI, Gitlab CI, Atlassian Bamboo, where sometimes we work entirely on the infrastructure of the Customer.  Accordingly, with this approach, the issue with the decision of versioning rests entirely with the customer. <br><br>  When developing solutions for clients, when we have the opportunity to do it on our own infrastructure, we use TFS version 2018 as the basis for the Continuous Integration / Continuous Delivery system. This allows us to solve the main task of forming a complete software development cycle, namely: <br><br><ul><li>  Task setting (Issues, Bugs, Tasks) based on the software development approach used in the current project; </li><li>  Storing project source code; </li><li>  Deploying the infrastructure of build-agents for assemblies for different OS (Windows, Linux, MacOS); </li><li>  Build projects in "manual" mode and CI; </li><li>  Expand projects in "manual" mode and CD; </li><li>  Testing projects; </li><li>  Data generation in terms of time spent by employees on the project and a number of additional functions that we implemented using TFS Extensions of our own design and through adding statics to WIT (in this form, TFS replaced our company Redmine and simplified the collection of statistics, reports, etc. in the context of projects ). </li></ul><br>  In this case, it would be logical to assign the solution of the versioning problem to TFS, modifying the TFS functionality for our tasks and the Customer‚Äôs wishes.  As a result, the task of building a versioning system for microservice architecture projects was solved by means of TFS by customizing various build scenarios and streamlining test / release environments. <br><br><h4>  Solution: use TFS and third-party tools </h4><br>  So, we need a versioning system for microservice architecture projects for organizing test environments and releases. <br><br>  As the initial data we have: <br><br><ul><li>  Orchestration - we use docker swarm mainly in order to reduce the use of other third-party tools.  At the same time, there are converters for converting configs - for example, the <a href="http://kompose.io/">Kompose</a> utility, which will allow the use of Kubernetes if necessary. </li><li>  Build agents - VMs based on Linux servers. </li><li>  Source repository - TFS based Git. </li><li>  Image storage - docker registry on VM. </li></ul><br><h4>  To the question of the name of builds </h4><br><ul><li>  It will be logical to use the existing norms of the name, for example, such as the <a href="https://semver.org/">Semantic Versioning Specification</a> . </li><li>  We follow this name when manually starting the build process of the release version, since otherwise it will not be possible to automatically achieve the correct name (unless manually entered in the code, which, again, does not apply to CI ideology). </li><li>  In the CI mode for ‚Äúdebugging‚Äù software versions, we use the following names on different projects: <br><br><ol><li>  Embedded TFS internal numbers; </li><li>  Numbering based on the current date and build number on that day; </li><li>  The commit number for which the build was launched. </li></ol></li></ul><br>  A specific solution, for example, can be viewed on the basis of an example of a <a href="https://github.com/nahsh/calculator">Calculator</a> service made in Javascript and several publicly available projects. <br><br><h4>  Algorithm of the decision </h4><br>  <b>1.</b> In TFS2018, we create a project called SibEDGE Semver and import the repository into the local repository. <br><br><img src="https://habrastorage.org/webt/3n/9l/xi/3n9lxiufbqej7sscqofb3el3q58.jpeg" alt="image"><br>  <i>Figure 1 - SibEDGE Semver project in the repository on TFS 2018</i> <br><br>  <b>2.</b> Create a Dockerfile file describing the node.js assembly for our needs ( <a href="https://www.dropbox.com/s/l8xq8vti8652wub/Dockerfile-Semver%3Fdl%3D0">link</a> ). <br><br><pre><code class="plaintext hljs">FROM node:7 WORKDIR /usr/src/app COPY package.json app.js LICENSE /usr/src/app/ COPY lib /usr/src/app/lib/ LABEL license MIT COPY tests tests ENV NODE_ENV dev RUN npm config set strict-ssl false RUN npm update &amp;&amp; \ npm install -g mocha CMD ["mocha", "tests/test.js", "--reporter", "spec"]</code> </pre> <br><h4>  Script 1 - Dockerfile to build the build </h4><br>  <b>3.</b> On the test bench (with the docker installed), where we plan to deploy our environment, we create a swarm cluster.  In our case it will consist of one server. <br><br><pre> <code class="plaintext hljs">$ docker swarm init</code> </pre> <br>  <b>4.</b> Create a yml-file with a description of microservices for our needs ( <a href="">link</a> ). <br>  Notice that <code>vm-docker-registry.development.com:5000</code> - <code>vm-docker-registry.development.com:5000</code> - <code>vm-docker-registry.development.com:5000</code> is the internal repository for this project, which we prepared in advance.  In order for the test bench to use this repository, it is necessary to register an ssl-certificate in the /etc/docker/certs.d/&lt; folder of the repository name&gt; /ca.crt <br><br><pre> <code class="plaintext hljs">version: '3.6' services: #--- # Portainer for manage Docker #--- portainer: image: portainer/portainer:1.15.3 command: --templates http://templates/templates.json -d /data -H unix:///var/run/docker.sock networks: - semver-network ports: - 9000:9000 volumes: - /var/run/docker.sock:/var/run/docker.sock #--- #----Service Calculator Test# #--- semver-calc: image: vm-docker-registry.development.com:5000/calculator:latest networks: - semver-network #--- #----Pminder - Nginx# #--- nginx: image: nginx:1.9.6 depends_on: - mysql ports: - "8888:80" - "6443:443" networks: - semver-network # #----------------------------- # START NoSQL - Redis. #--- redis: image: redis:4.0 networks: - semver-network ports: - "8379:6379" # # END NoSQL - Redis. #--- #----Pminder - DB# #--- mysql: image: mysql:5.7 ports: - "3306:3306" environment: MYSQL_ROOT_PASSWORD: 'ODdsX0xcN5A9a6q' MYSQL_DATABASE: 'semver' MYSQL_USER: 'user' MYSQL_PASSWORD: 'uXcgTQS8XUm1RzR' networks: - semver-network #--- #----PhpMyAdmin # #--- phpmyadmin: image: phpmyadmin/phpmyadmin depends_on: - mysql environment: PMA_HOST: 'mysql' PMA_USER: 'user' PMA_PASSWORD: 'uXcgTQS8XUm1RzR' ports: - "8500:80" - "8600:9000" networks: - semver-network #--- networks: semver-network:</code> </pre><br><h4>  Script 2 - the contents of the semver.yml file, which is the docker-compose project file. </h4><br>  <b>5.</b> Create a build description in TFS2018 (Build Definition). <br><br>  <b>6.</b> The first action of our script is to build the image of the docker container: <br><br><img src="https://habrastorage.org/webt/ot/u2/hc/otu2hcqbokm6jsqq2xvrgdyo7ma.jpeg" alt="image"><br>  <i>Figure 2 - Building the image for our build in TFS 2018</i> <br><br>  <b>7.</b> Send the image of the docker container created on the build machine to the internal repository for this project: <br><br><img src="https://habrastorage.org/webt/c5/z0/-i/c5z0-irkolgl5vtvd_ljjmp4hte.jpeg" alt="image"><br>  <i>Figure 3 - Saving docker-image for our build in the TFS 2018 repository</i> <br><br>  <b>8.</b> For the whole environment on the test bench in the description of microservices we change the image name to the new one: <br><br><img src="https://habrastorage.org/webt/va/vs/-z/vavs-zlakgyiujowaaclrddgzd4.jpeg" alt="image"><br>  <i>Figure 4 - Replacing the image name in the build script for our build in TFS 2018</i> <br><br>  <b>9.</b> On the test bench, copy the created image of the docker container from the internal repository and update the service in docker swarm: <br><br><img src="https://habrastorage.org/webt/rc/gl/vq/rcglvqmsxim1iedm2ieq25_i_pq.jpeg" alt="image"><br>  <i>Figure 5 - Deploying the docker-container with the build script of our build from the image in TFS 2018</i> <br><br>  As a result, at the output in the TFS repository, we have a yml file with release versions of docker images, which in turn has the release name of the entire project. <br><br>  <b>10. We</b> go to the test bench and check the work of the services and make sure that the Calculator service is updated and uses the new version of the assembly. <br><br><pre> <code class="plaintext hljs">$ docker service ls</code> </pre> <br><br><img src="https://habrastorage.org/webt/mj/tq/kh/mjtqkhpjmndkwu-gnac7rc_jteo.jpeg" alt="image"><br>  <i>Figure 6 - Updating the Calculator service and checking its current version on our test bench</i> <br><br>  Thus, in our docker registry image storage we have a set of images of different versions of microservices (in this particular case, the version of only one microservice changes).  By running a separate deployment process (through a script that changes the yml-description file), at any time you can get the right environment for testing on the test bench and transfer this configuration to the QA department.  After testing (regression, load, etc.) we get information that microservice of such version works stably on a test bench with release versions of other microservice of such versions, and the final decision is already made on whether or not it is possible to update release stand to the new version. <br><br><h4>  Summary - what they got at the exit </h4><br>  Thanks to the implementation of versioning in projects with micro-architecture architecture, the following result was achieved: <br><br><ul><li>  the amount of chaos in versions has decreased; </li><li>  increased rate of deployment of new environments in projects; </li><li>  the quality of assemblies has improved and the level of errors in them has decreased; </li><li>  increased development transparency for Project Managers and Customer; </li><li>  improved interaction between departments; </li><li>  There are new directions in the work of DevOps. </li></ul><br>  <b>PS</b> Thanks to my colleague Cyril B. for help in writing this article. </div><p>Source: <a href="https://habr.com/ru/post/437992/">https://habr.com/ru/post/437992/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>