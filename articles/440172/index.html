<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>CQRS: divide and conquer principle in the service of a programmer</title>
  <meta name="description" content="Puff architecture is a salvation in the world of corporate development. With its help, you can unload iron, parallelize processes and clean up the cod...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>CQRS: divide and conquer principle in the service of a programmer</h1><div class="post__text post__text-html js-mediator-article">  Puff architecture is a salvation in the world of corporate development.  With its help, you can unload iron, parallelize processes and clean up the code.  We tried to use the CQRS pattern in the development of a corporate project.  Everything has become more logical and ... more difficult.  Recently, I talked about what I had to face, on the <a href="http://panda-meetup.ru/samara-c-net-meetup">Panda-Meetup C # .Net</a> mitap, and now I am sharing with you. <br><br><img src="https://habrastorage.org/webt/dx/rt/hg/dxrthgzb-ad0b1hfie06jz_3x-m.jpeg"><br><a name="habracut"></a><br>  Have you ever noticed what your corporate application looks like?  Why can't it be the same as Apple and Google?  Yes, because we have a constant lack of time.  Requirements change frequently, the term of their changes is usually "yesterday."  And what is most unpleasant, the business does not like mistakes very much. <br><br><img src="https://habrastorage.org/webt/nw/cm/6a/nwcm6aby-nd9z5rchxienijheqk.png"><br><br>  In order to somehow live with this, the developers began to divide their applications into parts.  It all started simply - with the data.  Many people know the scheme when the data is separate, the client is separate, and the logic is stored in the same place where the data is. <br><br><img src="https://habrastorage.org/webt/5d/yg/xa/5dygxacluuk_6axv8ttxi0moahi.png"><br><br>  Good scheme.  The largest DBMS has quite workable procedural SQL extensions.  About Oracle, the proverb goes, "Where there is Oracle, there is logic."  It is difficult to argue about the convenience and speed of this configuration. <br><br>  But we have a corporate application, and there is a problem: the logic is difficult to scale.  And it is unreasonable to load the capacity of a DBMS, which already has enough problems with extracting and updating data, also with trivial business tasks. <br><br>  Well, business logic programming tools built into the DBMS, to be honest, are rather weak for creating normal corporate applications.  Supporting business logic in T-SQL / PL-SQL is a pain.  It‚Äôs not for nothing that OOP languages ‚Äã‚Äãhave spread so widely among corporate applications: C #, Java, you don‚Äôt have to go far for an example. <br><br><img src="https://habrastorage.org/webt/0l/bf/7o/0lbf7oxhdqiob8np3x2oagupxv4.png"><br><br>  It would seem a logical decision: select the business logic.  She will live on her server, the base on her own, the client separately. <br><br>  What can be improved in this three-tier architecture?  In the layer of business logic architecture is involved, I would like to avoid this.  Business logic does not want to know anything about data storage either.  UI is also a separate world, in which there are entities that are not characteristic of business logic. <br><br>  Will increase the layers.  This solution looks almost perfect, it has some kind of inner beauty. <br><br><img src="https://habrastorage.org/webt/zw/lv/he/zwlvhelbpekiq63iyifzvuldvna.png"><br><br>  We have a DAL (Data Access Layer) - the data are separated from the logic, usually this is a CRUD repository using ORM, plus stored procedures for complex queries.  This option allows you to develop and quickly enough, and have an acceptable speed. <br><br>  Business logic can go as part of services or be a separate layer.  The interaction between the layers can be carried out through transport objects (DTO). <br><br>  The request from the UI goes to the service from us, it communicates with the business logic, climbs into the DAL to access the data.  This approach is called N-tier, and it has clear advantages. <br><br>  Each layer has its own obvious goals and objectives, which we, as programmers, like so much.  Each concrete layer is engaged only in its own business.  Services can be scaled horizontally.  The approach is understandable even to a novice developer, a person quickly understands how the system works.  It is very easy to trace all interactions as the request goes from beginning to end. <br><br>  Another consistency: all project subsystems work with one data, you do not need to worry that we have recorded data in one place, and the user does not see it in another part. <br><br><h3>  Layer Cake 1. N-Tier </h3><br>  Below is an example of a typical application fragment built on these principles.  We have a monetary requirement, here I considered the Anemic-model.  And there is a classic repository, work with which goes through ORM. <br><br><img src="https://habrastorage.org/webt/uj/bw/wa/ujbwwazglo6mvhy9x5dzt0qei4g.png"><br><br>  This is a typical service, they are also called managers.  He works with the repository, receives requests and responds to clients.  In this service, we see some confusion: we have a processing process, a process for working with UI and a process for some internal control units, they are weakly interconnected. <br><br>  Here is the typical method of this service.  For example, registration of a monetary claim. <br><br><img src="https://habrastorage.org/webt/g5/ux/lv/g5uxlv_eu-2xmky8lwlyk4-agvc.png"><br><br>  We receive data, perform some business checks.  Then there is an update, and after it - some post-actions, for example, sending a notification or writing to the user log. <br><br>  In this approach, despite all its beauty, there are problems.  Very often in corporate applications the load is not symmetrical: there are an order or two more reads than write operations.  With the scaling of the database itself there is already a problem.  Of course, this is done, and even by means of a DBMS on a database scale, it is called partitioning.  But it is difficult.  If this is done with the wrong qualification or done earlier than necessary, partitioning will fail. <br><br>  For example, in one of our systems, the data volume reached 25 TB, problems appeared.  We tried to scale ourselves, invited cool guys from a famous company.  They looked and said: we will need 14 hours of complete idle base.  We thought and said: guys, it will not work, business will not accept it. <br><br>  In addition to the base volume, the number of methods in services and repositories is growing.  For example, in the service for the monetary requirements of more than a hundred methods.  It is difficult to maintain, there are constant conflicts with merge request, it is harder to carry out code review.  And if we consider that the processes are different, different groups of developers are working on them, then the task of tracking down all the changes associated with a problem becomes a real headache. <br><br><h3>  Layer Cake 2. CQRS </h3><br>  So what to do?  There is a solution that was invented back in ancient Rome: to divide and conquer. <br><br><img src="https://habrastorage.org/webt/1s/wf/un/1swfunmbkv6_g1gevmg-be1qsoo.png"><br><br>  As they say, everything new is well forgotten old.  Back in 1988, Bertrand Meyer formulated the principle of imperative CQS programming - Command-query separation - for working with objects.  All methods are clearly divided into two types.  The first is Query ‚Äî queries that return a result without changing the state of the object.  That is, when you look at the client‚Äôs cash requirements, no one should write to the database that the client looked at this and that, there should be no side effects in the request. <br><br>  The second is Commands ‚Äî commands that change the state of an object without returning data.  That is, you ordered something to change, and in response do not expect a report for 10 thousand lines. <br><br><img src="https://habrastorage.org/webt/sz/tj/cn/sztjcny-m7hn7pnx4zn-37_dkly.png"><br><br>  Here the data model for reading is clearly separated from the model for writing.  Most business logic runs on write operations.  Reading can work on the materialized views or even on a different basis.  They can be divided and synchronized through events or some internal services.  There are many options. <br><br>  CQRS is not complicated.  We must clearly identify the commands that change the state of the system, but do not return anything.  Here the approach may be more balanced.  It is not particularly scary if the team returns the result of the execution: an error or, for example, an identifier of the created entity, then there is no crime in this.  It is important that the team does not work with the query, it should not look for data and return the business entity. <br><br>  Requests - everything is simple there.  Does not change the state so that there are no side effects.  This means that if we called the request twice in a row, and there were no other commands, the state of the object in both cases should remain identical.  This allows parallel queries.  Interestingly, a separate model for queries is not needed for work, since  there is no point in attracting business logic from the domain model for this. <br><br><h3>  Our CQRS project </h3><br>  Here is what we wanted to do in our project: <br><br><img src="https://habrastorage.org/webt/rc/jt/d_/rcjtd_xtvea4sppjzzpi1jumbzy.png"><br><br>  We have an existing application operating since 2006, it has a classic layered architecture.  Old fashioned, but still working.  No one wants to change it and does not even know what to replace it with.  The moment came when it was necessary to develop something new, from scratch practically.  In 2011-2012, Event Sourcing and CQRS were a very fashionable topic.  We thought it was cool that in this way we could keep the original state of the object and the events that led to it. <br><br>  That is, we are not updating the object.  There is an original state and a number - that applied to it.  In this case, there is a huge plus - we can restore the state of the object at any time in history.  In fact, the magazine is no longer needed.  As we store events, we understand exactly what happened.  That is, it‚Äôs not just that the client has updated the value in the ‚Äúaddress‚Äù cell; we‚Äôll have an event recorded, for example, a client‚Äôs move. <br><br>  It is clear that such a scheme is slow when receiving data, so we have a separate database with material representations to choose from.  Well, the synchronization of events: every time an event arrives at a state change, it is published.  In theory, everything seems to be fine, but ... I never met people who fully implemented it in production, at high loads with acceptable consistency for business. <br><br><img src="https://habrastorage.org/webt/a_/gb/l4/a_gbl4c68c45lor9e9it0tptgsw.png"><br><br>  The scheme can be developed further by separating the handlers and commands / requests.  Here, as an example, we have a team - a registered money requirement: there is a date, amount, customer, and other fields. <br><br>  We put a restriction on the cash request registration processor that it can only accept our team (where TCommand: ICommand).  We can write handlers, without changing old ones, simply by the method of adding complex requirements.  For example, first update the date, then write down the value, and here the client sent a notification - all this is written in different handlers for one command. <br><br>  How do we cause all this?  There is a dispatcher who knows where he has all these handlers stored. <br><br><img src="https://habrastorage.org/webt/x5/ru/oy/x5ruoyjo7opvudu_ee7o72oa1dy.png"><br><br>  The dispatcher is passed (for example, via the DI container) to the API.  And when the command comes, it only executes.  He knows where the container is, where the teams are, and executes them.  With requests - it is similar. <br><br>  What is the problem of such a scheme: all interactions become less obvious.  We build a hierarchy on the types that are registered in containers, and then respond to their commands / requests.  Requires very clearly design the architecture.  Any action by one method with one parameter is no longer limited.  You write a command, write a handler, register in a container.  The number of overheads increases.  In a large project, there are problems with basic navigation.  We decided to go in a more classic way. <br><br>  For asynchronous communication, a Rebus service bus was used. <br><br><img src="https://habrastorage.org/webt/yw/nj/qw/ywnjqwtw7grnr-vh790ed2vthqs.png"><br><br>  For simple tasks, it is more than enough. <br><br>  CQRS makes a slightly different approach to the code, focus on the process, because all actions are born within the framework of the process.  We have allocated a repository for requests, separately made the commands related to processing, and separately requests related to processing.  For reading, we did not use a separate repository, just in teams we work with ORM. <br><br><img src="https://habrastorage.org/webt/wh/6n/yt/wh6nytrv98oixsxcnwxxrtculis.png"><br><br>  Here, for example, is the method from which all unnecessary is thrown out.  In the cash claim registration team, we register the claim and publish the event to the bus that a cash claim is registered. <br><br><img src="https://habrastorage.org/webt/wh/6n/yt/wh6nytrv98oixsxcnwxxrtculis.png"><br><br>  Who is interested in this, he will respond to it.  For example, user authentication and logging work there. <br><br>  Here is an example request.  Everything became simple too: we read and give to the repository. <br><br><img src="https://habrastorage.org/webt/od/2g/wj/od2gwj9ud2gzo_61i9tcw6d0keu.png"><br><br>  I want to focus separately on Rebus.Saga.  This is a pattern that allows you to break a business transaction into atomic actions.  This allows you to block not all at once, but gradually and in turn. <br><br><img src="https://habrastorage.org/webt/d_/t9/t5/d_t9t5foqvuzu3gkpp8nmvqhmfa.jpeg"><br><br>  The first element performs actions and sends a message, the second subscriber reacts to it, fulfills, sends its message, to which the third part of the system responds.  If everything ended well, Saga generates its own message of the specified type, to which other subscribers will already respond. <br><br>  Let's see how in this case the money claim processing class looks like.  Everything is clear: there are teams, there are requests that relate to the registration process, well, the bus with logs. <br><br><img src="https://habrastorage.org/webt/bl/nm/7m/blnm7mchtolurp463y6_m_o6biq.png"><br><br>  In this case, there is one handler.  When an event occurs and the team arrives to register the money requirements, it responds to it.  Inside, everything is the same as before, but the peculiarity is that here there is a grouping by process. <br><br><img src="https://habrastorage.org/webt/ns/wi/iz/nswiizzxxzxajbkardg73qvtmq0.png"><br><br>  Because of this, it became a little easier, there were fewer changes in each file. <br><br><h3>  findings </h3><br>  What needs to be remembered, working with CQRS?  You need a better design approach, because rewriting the process is a bit more complicated.  There is a small overhead, a little more classes have become, but this is not critical at all.  The code has become less connected, however, this is not so much because of the CQRS, but because of the transition to the bus.  But it was CQRS that prompted us to use such event interaction.  The code began to be added more often than to change.  Classes have become more, but they are now more specialized. <br><br>  Do we all need to throw everything and massively move on CQRS?  No, you need to look at which work scenario is better suited for a specific project.  For example, if your subsystem works with reference books, CQRS is not needed, the classical layer approach gives a simpler and more convenient result. <br><br>  The full performance on Panda Meetup is available below. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/J9U0svFKX9A" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  If you want to dive deeper into the topic, it makes sense to explore these resources: <br><br>  <a href="https://docs.microsoft.com/en-us/azure/architecture/guide/architecture-styles/cqrs">CQRS architecture style - from Microsoft</a> <br><br>  <a href="https://blog.byndyu.ru/2014/07/command-and-query-responsibility.html">Alexandra Bindu's blog</a> <br><br>  <a href="https://jimmybogard.com/contoso-university-examples-with-cqrs-mediatr-automapper-and-more/">Contoso University Examples with CQRS, MediatR, AutoMapper and more - by Jimmy Bogard</a> <br><br>  <a href="https://martinfowler.com/bliki/CQRS.html">CQRS - by Martin Fowler</a> <br><br>  <a href="https://github.com/rebus-org">Rebus</a> </div><p>Source: <a href="https://habr.com/ru/post/440172/">https://habr.com/ru/post/440172/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>