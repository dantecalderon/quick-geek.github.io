<div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/pt/uh/r0/ptuhr0jo9giaq3dkb15uiqlfp30.png" alt="image"></div><br>  In this post, I will describe an algorithm for procedurally generating two-dimensional dungeon levels with a predetermined structure.  The first part will provide a general description, and the second - the implementation of the algorithm. <br><br><h2>  Introduction </h2><br>  The algorithm was written as part of the <a href="https://github.com/OndrejNepozitek/ProceduralLevelGenerator/blob/text/bachelor_thesis.pdf">work for a bachelor's degree</a> and is based on the article by <a href="http://chongyangma.com/publications/gl/index.html">Ma et al (2014)</a> .  The aim of the work was to accelerate the algorithm and supplement it with new functions.  I am quite pleased with the result, because we made the algorithm fast enough to use it during the execution of the game.  After completing the bachelor's work, we decided to turn it into <a href="https://github.com/OndrejNepozitek/ProceduralLevelGenerator/blob/text/extended_paper.pdf">an article</a> and send it to the Game-ON 2018 conference. <br><br><h2>  Algorithm </h2><br>  To create a game level, the algorithm receives as input a set of polygonal building blocks and a level connectivity graph (level topology).  The nodes of the graph denote rooms, and the edges define the connections between them.  The purpose of the algorithm is to assign each node of the graph the shape and location of the room so that no two room shapes intersect, and each pair of adjacent rooms can be connected with doors. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41f/ed9/68f/41fed968fc3150ffb6285e660ff2ec5c.png"></div><br>  (a) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/96a/68a/302/96a68a302c5af7bc046644a659f0cc81.png"></div><br>  (b) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc1/79e/c88/fc179ec88afc1fa1889937a2df25c029.png"></div><br>  (with) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d9f/898/224/d9f8982240071dcb3d9205207912a46f.png"></div><br>  (d) <br><br>  Figures (c) and (d) show diagrams generated from input graph (a) and building blocks (b). <br><br>  Using the connectivity graph, the game designer can easily control the course of the gameplay.  Do you need one common path to the boss room with several optional side paths?  Just start with a path graph and then set up a few nodes in which the player can choose: either go along the main path, or explore the side, with possible treasures and / or monsters waiting for him.  Need to cut a path?  Simply select the two nodes in the graph and add the short road connecting them.  The possibilities of this scheme are endless. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/619/044/41a/61904441a82fd281642664a0e784513d.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9fe/b4e/65e/9feb4e65e116328e42b3e9638911fae5.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/83c/fd9/d63/83cfd9d6388c784f88c818e7bc6c9513.png"></div><br>  <i>Examples of input graphs.</i>  <i>The main path is shown in red, the auxiliary path is shown in blue, the short path is orange.</i> <br><br>  The algorithm not only allows game designers to manage the high-level structure of the maps generated, but also provides the ability to control the appearance of individual rooms and the ways they connect to each other. <br><br><h3>  Different forms for different rooms </h3><br>  I mentioned the boss room at the end of the level.  We don't want the boss room to look like any other ordinary room, right?  The algorithm allows you to specify forms for each room.  For example, we can create a start level room and a boss room, which should have their own sets of room shapes, and one common set for all other rooms. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1f/988/e05/e1f988e05bf84eea4209c128ac0b9e60.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f97/b39/b15/f97b39b15661d51ad7cf3a30a4e9b80a.png"></div><br>  Two schemes generated from the input graph, in which with room number 8 is associated a special form of rooms. <br><br><h3>  Explicit door positions </h3><br>  Imagine that you have a quality boss meeting script, and that we need the player to enter the boss room from a certain tile.  Or we may have a room pattern in which some tiles are reserved for walls and other obstacles.  The algorithm allows designers to explicitly set possible door positions for individual room shapes. <br><br>  But sometimes the goal may be the opposite.  We can create room templates in such a way that the doors to them can be almost anywhere.  Because of this, we impose fewer restrictions on the algorithm, so it is often executed faster, and the generated schemes may seem less monotonous and more organic.  For such situations, it is possible to simply indicate the length of the doors and how far they should be from the corners.  The distance from the corners is a kind of compromise between manual placement of all doors and the presence of doors in any place. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/13d/cf8/05f/13dcf805f54ce10ad637ce1c6e298b28.png"></div><br>  (a) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7be/e9f/51e/7bee9f51e10cda43d07163e27f7ff1dd.png"></div><br>  (b) <br><br>  Figure (a) illustrates the different types of door placement — a square room has 8 clearly defined door positions, and a length and distance from corners are used in a rectangular room.  Figure (b) shows a simple generated diagram with the shapes of the rooms in figure (a). <br><br><h3>  Corridors between rooms </h3><br>  When we talk about dungeon levels, we often present rooms connected by narrow corridors.  I would like to assume that the connections in the input graph denote corridors, but they are not.  They simply ensure that all neighboring nodes are directly connected by doors.  If we want the rooms to be connected by corridors, then we need to insert a new node between all pairs of adjacent rooms and pretend that these are corridor rooms (with certain room shapes and given door positions). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b59/56a/2b3/b5956a2b30f27882272fa44fe540f0bb.png"></div><br>  (a) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbc/91d/b4e/fbc91db4e3beec215ad06cc7799cc56a.png"></div><br>  (b) <br><br>  Illustration of how we can change the input graph to add corridors between rooms.  Figure (a) shows the input graph before adding corridor rooms.  (B) shows the input graph created from (a) adding new rooms between all adjacent rooms of the original graph. <br><br>  Unfortunately, this way we greatly complicate the task of the algorithm, because often the number of nodes doubles.  Therefore, I implemented a version of the corridor-based algorithm, which reduces the decrease in performance when the corridor rooms are located.  At the moment, the algorithm supports or corridors between all rooms, or the complete absence of corridors, but in the future I plan to make it more flexible. <br><br><h2>  Examples </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b01/c4c/b17/b01c4cb173e0b315ce81c842a617e32c.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a2b/5a0/5aa/a2b5a05aa014d12b0fc70d23a540997d.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/305/5b7/de6/3055b7de654c62dc96c1e83ad510e199.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/80e/d9e/b26/80ed9eb26994f6b395e9fa2af34b6dce.png"></div><br>  <i>Several circuits generated from different sets of building blocks and with included corridors.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/738/8a4/a44/7388a4a4466fe32fc9b9975e71473936.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c1e/1ed/95b/c1e1ed95b4a9236c02fc11ed1bb33ed9.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/628/f19/025/628f19025acf78eed8aa199347804f9e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa7/7e5/03d/aa77e503dbb791e78189777bc875e2cd.png"></div><br>  <i>Several circuits generated from different sets of building blocks with corridors on and off.</i> <br><br>  In the second part of the post I will talk about the internal workings of the algorithm. <br><br>  I am also working on a Unity plugin for procedural dungeon generation, which will include this algorithm.  I do this because despite the possibility of using this algorithm directly in Unity (it is written in C #), the convenience of working with it is far from ideal.  It takes a lot of time to create room templates without a GUI, and a lot of code is needed to convert the output of the algorithm into the presentation used inside the game. <br><br>  Since I myself am not a game developer, my goal is to make the plugin good enough for other people to use.  If everything goes well, then I will try to publish updates when I have to tell about something interesting.  I already have quite a few ideas about the generator itself and about testing its capabilities. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d12/43f/2c0/d1243f2c05e18826eb3d97a30b6f743c.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ed/34f/05c/7ed34f05ca19aa127aae0938e26d63ec.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad4/d48/39f/ad4d4839f9ca1c333c2fbb3e0333989e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0e/805/121/c0e805121b2cda153980875d780d5f9b.png"></div><br>  <i>Unity plugin screenshots (project is under development)</i> <br><br><h2>  Part 2. Implementation of the algorithm </h2><br>  In this part I will talk about the main ideas laid down in the foundation of the algorithm described in the first part of the post.  Initially, I wanted to describe the basic concepts along with the main improvements required for the algorithm to be fast enough.  However, as it turned out, even basic concepts are more than enough for this post.  So I decided to reveal the performance improvements in a future article. <br><br><h2>  Motivation </h2><br>  Before proceeding with the implementation, I want to show the result of what we will do.  The video shown below shows 30 different schemes generated from one input graph and one set of building blocks.  The algorithm always stops for 500 ms after generating a circuit, and then tries to generate the next one. <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Your browser does not support HTML5 video. <source src="https://ondra.nepozitek.cz/blog/wp-content/uploads/2019/01/GeneratorWindow-12_01_2019-23_48_40.mp4" type="video/mp4"></video></div></div></div><br><h2>  How it works </h2><br>  The purpose of the algorithm is to assign the shape and position of the room to each node of the graph in such a way that no two rooms intersect and the adjacent rooms are connected by doors. <br><br>  One way to achieve this is to try all possible combinations of room shapes and their positions.  However, as you can guess, this will be very inefficient, and we probably will not be able to generate circuits, even based on very simple input graphs. <br><br>  Instead of searching through all possible combinations, the algorithm calculates how all individual rooms can be correctly connected (the so-called configuration spaces) and uses this information to direct the search.  Unfortunately, even with this information, it is still quite difficult to find the right scheme.  Therefore, for effective study of the search space, we use a probabilistic optimization technique (in this case, annealing imitation).  And to further accelerate the optimization, we divide the input task into smaller and easier to solve subtasks.  This is done by dividing the graph into smaller parts (called chains), followed by the creation of diagrams for each of them in order. <br><br><h2>  Configuration spaces </h2><br>  For a pair of polygons in which one is fixed in place, and the other can move freely, the configuration space is the set of free polygon positions at which two polygons do not intersect and can be connected by doors.  When working with polygons, each configuration space can be represented as a possible empty set of lines and calculated with the simplest geometric tools. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/134/823/45e/13482345ed98c982677a10e53ddaec2d.png"></div><br>  (a) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b8c/1eb/62c/b8c1eb62c2f6d8f166670781dfe35336.png"></div><br>  (b) <br><br>  Space configurations.  Figure (a) shows the configuration space (red lines) of a free rectangle relative to a fixed L-shaped polygon.  It determines all the locations of the center of the square at which the two blocks do not intersect and touch each other.  Figure (b) shows the intersection (yellow dots) of the configuration space of a moving square with respect to two fixed rectangles. <br><br>  The following algorithm is used to calculate the configuration space of one fixed and one free block.  We select the reference point on the movable block and consider all locations in <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>m</mi><mi>a</mi><mi>t</mi><mi>h</mi><mi>b</mi><mi>b</mi><msup><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>R</mi></mrow><mn>2</mn></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="10.843ex" height="2.539ex" viewBox="0 -987.6 4668.4 1093.4" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMATHI-6D" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMATHI-61" x="1128" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMATHI-74" x="1658" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMATHI-68" x="2019" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMATHI-62" x="2596" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMATHI-62" x="3025" y="0"></use><g transform="translate(3455,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMATHI-52" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMAIN-32" x="1074" y="581"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>m</mi><mi>a</mi><mi>t</mi><mi>h</mi><mi>b</mi><mi>b</mi><msup><mrow class="MJX-TeXAtom-ORD"><mi>R</mi></mrow><mn>2</mn></msup></math></span></span><script type="math/tex" id="MathJax-Element-1"> \ mathbb {R} ^ 2 </script>  , such that when the polygon is moved so that its reference point is located in this location, both the movable and the fixed block touch each other, but do not intersect.  The set of all such points forms the space of configurations of two blocks (figure (a) above).  To obtain the space of configurations of the movable block relative to two or more fixed blocks, the intersection of the individual spaces of the configurations is calculated (figure (b) above). <br><br>  The algorithm uses configuration spaces in two ways.  First, instead of trying random positions of individual rooms, we use configuration spaces to search for positions leading to as many adjacent doors as possible.  To do this, we need to obtain the maximum non-empty intersection of the configuration spaces of our neighbors.  Secondly, we use configuration spaces to check whether all pairs of adjacent rooms can be connected with doors.  This is done by checking whether the position of the room is within the configuration space of all its neighbors. <br><br>  Since the forms of rooms do not change during the execution of the game, we can precompute the configuration spaces of all pairs of room forms before the algorithm starts.  Due to this, the entire algorithm is significantly accelerated. <br><br><h2>  Incremental pattern </h2><br>  When solving a complex problem, one of the possible approaches is to divide it into smaller and simple subtasks, and to solve them already.  This is exactly what we will do with the task of locating individual rooms.  Instead of arranging all the rooms at a time, we divide the input graph into smaller subgraphs and try one by one to create diagrams from them.  The authors of the original algorithm call these subgraphs "chains" because of the very principle of these graphs, in which each node has no more than two neighbors, and therefore it is quite simple to create their scheme. <br><br>  The final output scheme is always one connected component, so there is no point in connecting the individual components into the diagrams, and then trying to combine them, because the merging process can be quite complicated.  Therefore, after placing the chain, the next chain to be connected will always be the one that is connected to the vertices already lined up in the scheme. <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-function">Layout </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateLayout</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">inputGraph</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> emptyLayout = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Layout(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stack = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stack&lt;Layout&gt;(); stack.Push(emptyLayout); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!stack.Empty()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> layout = stack.Pop(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nextChain = GetNextChain(layout, inputGraph); Layout[] partialLayouts = AddChain(layout, nextChain); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!partialLayouts.Empty()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsFullLayout(partialLayouts[<span class="hljs-number"><span class="hljs-number">0</span></span>])) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> partialLayouts[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { stack.Push(partialLayouts); } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  <i>Pseudocode that demonstrates an incremental approach to finding the right scheme.</i> <br><br>  The pseudo-code shown above demonstrates the implementation of the incremental scheme.  At each iteration of the algorithm (lines 6-18), we first take the last circuit from the stack (line 7) and calculate which chain to add next (line 8).  This can be done by simply storing the last chain number added to each partial circuit.  The next step is to add the following chain to the schema (line 9), generating several deployed diagrams, and save them.  If the expansion stage ends in failure, but no new partial schemes are added to the stack, and the algorithm must be continued with the last saved partial scheme.  We call this situation a return search, because the algorithm cannot expand the current partial scheme and must go back and continue with another saved scheme.  This is usually necessary when there is not enough space to connect additional circuits to the vertices that are already mapped.  Also, a return search is the reason that we are always trying to generate several advanced schemas (line 9).  Otherwise, we would have nothing to return to.  The process ends when we generate a complete circuit, or the stack is empty. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90e/909/ca4/90e909ca4640401cf869e4ad2e558d32.png"></div><br>  (a) Input Count <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ca/736/f69/8ca736f69ce1ba31910d12c49f0546a4.png"></div><br>  (b) Partial scheme <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0e/74f/284/d0e74f2846ea5cdd8351bd1a20561704.png"></div><br>  (c) Partial scheme <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c4/708/d35/2c4708d351e2b4a13a98cffa9a090a58.png"></div><br>  (d) Complete layout <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b3b/13b/796/b3b13b796d79dd8587d23d82cee6da52.png"></div><br>  (e) Complete scheme <br><br>  Incremental scheme.  Figures (b) and (c) show two partial diagrams after the layout of the first chain.  (D) shows the complete circuit after expansion (b) with the second circuit.  Figure (e) shows the complete circuit after expansion (c) with the second circuit. <br><br>  To divide the graph into parts, you need to find a flat embedding of the input graph, that is, a drawing on a plane in which the edges intersect only at the end points.  This embedding is then used to obtain all the faces of the graph.  The basic idea of ​​decomposition is that it is more difficult to create a circuit from cycles, because their nodes have more restrictions.  Therefore, we are trying to arrange the cycles at the beginning of the decomposition so that they are processed as early as possible and reduce the likelihood of the need to go back to the subsequent stages.  The first decomposition chain is formed by the smallest edge of the attachment, and the subsequent edges are then added in the search order in width (breadth-first search).  If there are other faces that can be selected, then the smallest one is used.  When no faces remain, the remaining non-cyclic components are added.  Figure 4 shows an example of a decomposition in a chain, which is obtained in accordance with these steps. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0f/c57/c57/e0fc57c571633c5f70b818c412e8d80c.png"></div><br>  (a) <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4bb/02c/950/4bb02c950ef9309be5df082e0c630ec3.png"></div><br>  (b) <br><br>  Decomposition on the chain.  Figure (b) shows an example of how figure (a) can be expanded on a chain.  Each color denotes a separate chain.  Numbers indicate the order in which the chains are created. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0c/ad3/554/f0cad3554aa63d7cc46e5d9dae334209.png"></div><br>  (c) Good partial layout <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d00/839/114/d0083911404026fa33a26f529d1db1a0.png"></div>  (d) Complete layout <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b27/f99/ed2/b27f99ed239d73e25a14e3f785ba5bd2.png"></div><br>  (a) Input Count <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85c/60c/13b/85c60c13b6479b643855f71f5138f738.png"></div><br>  (b) Bad partial graph <br><br>  Search with return.  Figure (b) shows an example of a bad partial scheme, because it does not have enough space to connect nodes 0 and 9. To generate a complete scheme (d), a return to another partial scheme (c) is necessary. <br><br><h2>  Annealing imitation </h2><br>  <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%25B8%25D0%25BC%25D0%25B8%25D1%2582%25D0%25B0%25D1%2586%25D0%25B8%25D0%25B8_%25D0%25BE%25D1%2582%25D0%25B6%25D0%25B8%25D0%25B3%25D0%25B0">The annealing simulation algorithm</a> is a probabilistic optimization technique, the purpose of which is to study the space of possible schemes.  She was chosen by the authors of the original article because she was useful in similar situations in the past.  When implementing the algorithm, I decided to use the same method, because I wanted to start with what has already proven its effectiveness in solving this problem.  However, I think that it can be replaced by another method and my library is written in such a way that the process of replacing a method is quite simple. <br><br>  The annealing simulation algorithm iteratively evaluates small changes in the current configuration, or pattern.  This means that we create a new configuration, randomly selecting one node and changing its position or shape.  If the new configuration improves the energy function, it is always accepted.  Otherwise, there is a small chance of making the configuration anyway.  The likelihood of making the worst decisions decreases over time.  The energy function is created in such a way that it imposes heavy penalties on intersecting nodes and non-interconnecting neighboring nodes. <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>E</mi><mo>=</mo><msup><mi>e</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mtext>&amp;#xA0;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>A</mi></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mtext>&amp;#xA0;</mtext><mi>o</mi><mi>m</mi><mi>e</mi><mi>g</mi><mi>a</mi></mrow></mrow></msup><msup><mi>e</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mtext>&amp;#xA0;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>D</mi></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mtext>&amp;#xA0;</mtext><mi>o</mi><mi>m</mi><mi>e</mi><mi>g</mi><mi>a</mi></mrow></mrow></msup><mo>&amp;#x2212;</mo><mn>1</mn></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="32.209ex" height="2.66ex" viewBox="0 -987.6 13867.5 1145.2" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMATHI-45" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMAIN-3D" x="1042" y="0"></use><g transform="translate(2098,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMATHI-65" x="0" y="0"></use><g transform="translate(466,412)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMATHI-66" x="353" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMATHI-72" x="904" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMATHI-61" x="1355" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMATHI-63" x="1885" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMATHI-41" x="2318" y="0"></use><g transform="translate(2170,0)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMATHI-6F" x="353" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMATHI-6D" x="839" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMATHI-65" x="1717" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMATHI-67" x="2184" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMATHI-61" x="2664" y="0"></use></g></g></g><g transform="translate(7093,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMATHI-65" x="0" y="0"></use><g transform="translate(466,412)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMATHI-66" x="353" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMATHI-72" x="904" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMATHI-61" x="1355" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMATHI-63" x="1885" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMATHI-44" x="2318" y="0"></use><g transform="translate(2225,0)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMATHI-6F" x="353" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMATHI-6D" x="839" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMATHI-65" x="1717" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMATHI-67" x="2184" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMATHI-61" x="2664" y="0"></use></g></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMAIN-2212" x="12366" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMAIN-31" x="13367" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>E</mi><mo>=</mo><msup><mi>e</mi><mrow class="MJX-TeXAtom-ORD"><mtext>&nbsp;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class="MJX-TeXAtom-ORD"><mi>A</mi></mrow><mrow class="MJX-TeXAtom-ORD"><mtext>&nbsp;</mtext><mi>o</mi><mi>m</mi><mi>e</mi><mi>g</mi><mi>a</mi></mrow></mrow></msup><msup><mi>e</mi><mrow class="MJX-TeXAtom-ORD"><mtext>&nbsp;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class="MJX-TeXAtom-ORD"><mi>D</mi></mrow><mrow class="MJX-TeXAtom-ORD"><mtext>&nbsp;</mtext><mi>o</mi><mi>m</mi><mi>e</mi><mi>g</mi><mi>a</mi></mrow></mrow></msup><mo>−</mo><mn>1</mn></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-2"> E = e ^ {\ frac {A} {\ omega}} e ^ {\ frac {D} {\ omega}} - 1 </script></p><br>  A is the total area of ​​intersection between all pairs of blocks in the circuit.  D is the sum of the squares of the distances between the centers of pairs of blocks that are neighbors in the input graph but are not related to each other.  Value <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>o</mi><mi>m</mi><mi>e</mi><mi>g</mi><mi>a</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.178ex" height="1.817ex" viewBox="0 -520.7 3090.5 782.1" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMATHI-6F" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMATHI-6D" x="735" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMATHI-65" x="1614" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMATHI-67" x="2080" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/436198/&amp;xid=25657,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhip5v0D7PR_-bneKlAv2KBq25qR7w#MJMATHI-61" x="2561" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>o</mi><mi>m</mi><mi>e</mi><mi>g</mi><mi>a</mi></math></span></span><script type="math/tex" id="MathJax-Element-3"> \ omega </script>  affects the likelihood that the simulated annealing will be allowed to go to the worst configuration;  This parameter is calculated from the average area of ​​the building blocks. <br><br>  After selecting a node to change, we change either its shape or position.  How do we choose a new position?  You can choose it randomly, but this will often degrade the energy function, and the algorithm will converge very slowly.  Can we choose a position that is likely to increase the energy function?  Do you understand what I am doing?  We use configuration spaces to select a position that satisfies the constraints of the largest number of adjacent rooms. <br><br>  Then, to change the shape, simply select one of the available room shapes.  While the algorithm is not trying to decide which form is most likely to lead us to the correct scheme.  Nevertheless, it would be interesting to try this opportunity and see if it accelerates the work of the algorithm. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">List&lt;Layout&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddChain</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">chain, layout</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentLayout = GetInitialLayout(layout, chain); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> generatedLayouts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Layout&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= n, i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-comment"><span class="hljs-comment">/* мы уже сгенерировали достаточное количество схем */</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt;= m, j++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newLayout = PerturbLayout(currentLayout, chain); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsValid(newLayout)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DifferentEnough(newLayout, generatedLayouts)) { generatedLayouts.Add(newLayout); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-comment"><span class="hljs-comment">/* newLayout лучше, чем currentLayout */</span></span>) { currentLayout = newLayout; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-comment"><span class="hljs-comment">/* вероятность, зависящая от того, насколько плоха энергия newLayout */</span></span>) { currentLayout = newLayout; } } <span class="hljs-comment"><span class="hljs-comment">/* уменьшаем вероятность принятия худших схем */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> generatedLayouts; }</code> </pre> <br>  This is the pseudo-code of the method responsible for creating the circuit of a separate circuit using simulated annealing. <br><br>  To speed up the whole process, we will try to find the initial configuration with low energy.  To do this, we will order the nodes in the current chain in search in width, starting with those that are adjacent to the nodes already included in the scheme.  Then the ordered nodes are placed one by one and the lowest energy position is selected from the configuration space for them.  Here we do not do any return back - this is a simple greedy process. <br><br><h2>  Bonus Video </h2><br>  The video shown below shows the schemas generated from the same input graph as in the first video.  However, this time an incremental approach is shown.  You may notice that the algorithm adds a chain of nodes one by one.  It also shows that sometimes there are two consecutive partial circuits with the same number of nodes.  This happens when the algorithm returns.  If the first attempts to add another circuit to the first partial circuit fail, then the algorithm tries another partial circuit. <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Your browser does not support HTML5 video. <source src="https://ondra.nepozitek.cz/blog/wp-content/uploads/2019/01/GeneratorWindow-13_01_2019-23_23_30.mp4" type="video/mp4"></video></div></div></div><br><h2>  Downloadable materials </h2><br>  Algorithm implementation on .NET can be found in <a href="https://github.com/OndrejNepozitek/ProceduralLevelGenerator">my github</a> .  The repository contains the .NET DLL and the WinForms GUI application, managed by the YAML configuration files. </div>