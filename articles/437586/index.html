<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Create a voice application on the example of Google Assistant</title>
  <meta name="description" content="Every fifth resident of the United States owns a smart column, and this is 47 million people. An assistant can create a reminder, to-do list, alarm cl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Create a voice application on the example of Google Assistant</h1><div class="post__text post__text-html js-mediator-article">  Every fifth resident of the United States owns a smart column, and this is <strong>47 million</strong> people.  An assistant can create a reminder, to-do list, alarm clock, timer, read the news, play music, podcast, order delivery, buy movie tickets and call a taxi.  All these are ‚Äúskills‚Äù or ‚Äúskills‚Äù helpers.  They are also called voice applications.  For Alexa and Google Assistant of such applications for 2018 <strong>70 000 are</strong> developed. <br><br>  In 2017, Starbucks launched a feature on ordering a coffee home for Amazon Alexa.  In addition to the increase in delivery orders, all possible media outlets wrote about it, creating a cool PR.  The example of Starbucks was followed by Uber, Domino's, MacDonald's, and even Tide washing powder had its own skill for Alexa. <br><br>  Like Starbucks, the voice application performs one or two functions: ordering coffee, setting an alarm or calling a courier.  To design something like this, it‚Äôs not necessary to be an intercontinental corporation.  The idea, design, testing, development and release are similar to similar stages in the world of mobile development, but with features for voice.  <strong>Pavel Guay</strong> told in detail about the process: from idea to publication, with examples of real games, with historical inserts and analysis of the world of voice development. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/sWLhSjg1LAw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><br>  <strong>About speaker</strong> : <strong>Pavel</strong> <a href="https://habr.com/ru/users/pavelgvay/" class="user_link">Guay</a> ( <a href="https://habr.com/ru/users/pavelgvay/" class="user_link">pavelgvay</a> ) - designs voice interfaces in the KODE mobile development studio.  The studio is developing mobile applications, for example, for Utair, Pobeda, RosEvroBank, BlueOrange Bank and Whiskas, but KODE has a division that deals with voice applications for Yandex.Alisa and Google Assistant.  Pavel has participated in several real-world projects, exchanges experience with developers and designers in this area, including from the USA, and speaks at thematic conferences.  In addition, Pavel is the founder of the <a href="https://tortu.io/">startup tortu.io</a> - a tool for the design of voice applications. <br><br><h2>  What is a conversational application <br></h2><br>  <strong>In a conversational application, the interaction channel with the user is built through a conversation</strong> : oral - with a smart column, or through a written one, for example, with Google Assistant.  In addition to the column, the device of interaction can be a screen, therefore conversational applications are also graphical. <br><br><blockquote>  It is correct to speak a <strong>conversational application</strong> , not a voice one, but this is already an established term, and I will also use it. <br></blockquote><br>  Voice applications have an important advantage over mobile: they do not need to be downloaded and installed.  It is enough to know the name, and the assistant will start everything himself. <br><br>  All because there is nothing to download - both speech recognition and business logic - the entire application lives in the cloud.  This is a huge advantage over mobile applications. <br><br><h2>  A bit of history <br></h2><br>  The history of voice assistants began with <strong>Interactive Voice Response</strong> - an interactive system of recorded voice responses.  Perhaps no one heard this term, but everyone came across when they called technical support and heard the robot: ‚ÄúPress 1 to get to the main menu.  Click 2 for more details ‚Äù- this is the <strong>IVR</strong> system.  In part, IVR can be called the first generation of voice applications.  Although they are already part of the story, they can teach us something. <br><br>  When interacting with the IVR system, most people try to contact the operator.  This is due to poor UX, when the interaction is based on hard commands, which is just inconvenient. <br><br>  This brings us to the basic rule of a good conversational application. <br><br><blockquote>  A good conversational application interacts with the user not through strict commands, but through lively, natural conversation, similar to communication between people. <br></blockquote><br>  A conversation with the application should be more like a call to a pizzeria to order, than to communicate with the chat bot teams.  To achieve the same flexibility as in a conversation between people will not work, but to speak with the application in a comfortable and natural language is completely. <br><br>  This is also the advantage of a voice over graphic applications: <strong>no need to learn to use</strong> .  My grandmother does not know how to enter sites or order pizza through the application, but she can call delivery through the column.  We must use this advantage and adapt to how people say, and not teach them to talk with our application. <br><br>  From IVR-systems we move on to the present - to virtual assistants. <br><br><h2>  Virtual Assistants <br></h2><br>  The voice world revolves around virtual assistants: <strong>Google Assistant</strong> , <strong>Amazon Alexa</strong> and <strong>Alice</strong> . <br><br>  Everything is arranged almost like in the mobile world, but instead of iOS and Android platforms, Alice is here, Google Assistant and Alexa, instead of graphical applications, voice, with their own names or names, and each assistant has their own internal store of voice applications.  Again, saying ‚Äúapplication‚Äù is wrong, because each platform has its own term: Alice has ‚Äúskills,‚Äù Alex has ‚Äúskills,‚Äù and Google has ‚Äúactions.‚Äù <br><br>  To start the skill, I ask the assistant: ‚ÄúAlex, tell Starbucks that I want coffee!‚Äù Alex will find the application of the coffee shop in his store and transfer the conversation to him.  The conversation goes not between Alex and the user, but <strong>between the user and the application</strong> .  Many people are confused and think that the assistant continues to speak with them, although the application has a different voice. <br><br>  This is how app stores look.  The interface resembles the App Store and Google Play. <br><img src="https://habrastorage.org/webt/it/jq/ga/itjqgarwr63ldgxnqrclk0kueeu.png"><br><br><h2>  Stages of development of conversational applications <br></h2><br>  For the user, the application has no graphic part - everything looks like a set of dialogue.  Outwardly, it may seem that the application is a simple thing, to create it is simple, but it is not.  Stages of development are the same as for mobile applications. <br><br><ul><li>  Design.  In the case of voices, not drawing the screens, but working out the dialogues. </li><li>  The development is divided into two parts: the development of a system for understanding speech and writing logic. </li><li>  Testing. </li><li>  Publication. </li></ul><br>  The first two stages are specific, as the applications are conversational, and the last two are standard. <br><br>  Let's go through each of the stages on the example of the game <strong>"Guess the price"</strong> , which is running under Google Assistant.  The mechanics are simple: the application shows the user a card with the goods, and he must guess the price. <br><br>  Let's start the dive from the first stage: we decided on an idea, conducted an analytics, realized that the user has a need and proceed to create a voice application. <br><br><h3>  Design <br></h3><br>  The main goal is to design the interaction between the user and the application.  In the mobile world, this stage is called design.  If the graphic application designer draws maps of the screens, buttons, shapes and selects colors, the VUI designer works out the dialogue between the user and the application: prescribes various branches of the dialogue, thinks about forks and side scenarios, chooses variants of phrases. <br><br>  Design is carried out in three stages. <br><br><ul><li>  Dialog examples. </li><li>  Drawing a flowchart. </li><li>  Making prompt lists. </li></ul><br><h4>  Dialog examples <br></h4><br>  The first thing to do is to understand how the application will work.  Understanding and vision will need to be broadcast on everyone else, especially if you are an outsourcing company, and you have to explain to the customer what he will receive in the end. <br><br>  A powerful tool to help - examples of dialogue: a <strong>conversation between the user and the application on roles</strong> , as in the play. <br><br>  An example of dialogue for our game. <br><br><img src="https://habrastorage.org/webt/b_/sg/w8/b_sgw8_kafllhyx-h-esqosdadw.png"><br><br>  The app greets, tells the user about the rules, offers to play, and, if the person agrees, shows a card with the goods so that the user guesses the price. <br><br>  The script helps to quickly understand how the application will work, what it can do, but, in addition, examples of dialogs help weed out the main mistake in the world of voice interfaces - <strong>working on the wrong scripts</strong> . <br><br><blockquote>  There is a simple rule: if you cannot imagine how you pronounce the script with another person, then you should not work on it. <br></blockquote><br>  Voice and graphics are significantly different, and not everything that works on graphical interfaces works well on voice.  Almost every mobile application has a registration, but I can not imagine how you can register by voice?  How to dictate a smart password column: "A capital letter, a small letter, es like a dollar ..." - and all this is out loud.  And if I'm not alone, but at work?  This is an example of an erroneous scenario.  If you start developing a script with an error, problems will arise with it: you will not understand how to execute it, users will not understand how to use it. <br><br>  Examples of dialogues will help to find such moments.  To find errors in the scenarios, record the dialogue, select a colleague, put them in front of you and play the roles: you are the user, the colleague is the application.  After role-playing the dialogue, it becomes clear whether the application sounds or not, and whether the user will be comfortable. <br><br>  Such a problem will appear constantly.  If you have an in-house development, there will be a temptation: ‚ÄúWe already have a website, let's just convert it to voice and everything will be fine!‚Äù Or the customer will come and say: ‚ÄúHere is the mobile application.  Do the same with your voice! ‚ÄùBut you can't do that.  You, as a specialist, should quickly find scenarios that should not be worked on, and explain to the customer why.  Dialog examples here will help. <br><br>  Absolutely any text editor you are used to will be suitable for writing dialogs.  The main thing - write down the text and read it by roles. <br><br><h4>  Block diagram <br></h4><br>  Dialogue examples are powerful, fast, and cheap, but they only describe linear developments, and <strong>conversations are always non-linear</strong> .  For example, in our game ‚ÄúGuess the price‚Äù, the user can answer the question correctly or incorrectly - this is the first fork in the set of those that will be encountered later. <br><br>  In order not to get confused in all branches of the dialogue of your application, make a flowchart - visualization of the dialogue.  It consists of only two elements: <br><br><ul><li>  Step dialogue on behalf of the user. </li><li>  Step dialogue on behalf of the application. <br></li></ul><br><img src="https://habrastorage.org/webt/es/rd/ed/esrdedt_jkjncnlx9mqnrrf2ab4.png"><br><br>  The block diagram is a map of our application, but with one unpleasant property - it grows heavily, becomes unreadable and visually incomprehensible.  Here, for example, a screenshot with a part of the flowchart from the scenario where the user guesses the price, with several forks. <br><br><img src="https://habrastorage.org/webt/1x/ic/ti/1xictirvsugplt7oo7_y5q74zay.png"><br><br>  A few forks is not the limit, there may be tens or hundreds.  We asked ourselves the questions: ‚ÄúWhat happens if a person answers correctly?  And if not?  What happens if the attempts end?  What if the goods run out?  And if he guesses the price exactly?  What if the Internet disappears at this step or at another? ‚ÄùAs a result, we created a huge unreadable scheme. <br><br>  In this we are not alone.  I spoke with a designer from the USA who was working on a serious project.  In the project there was an IVR, a bank, and a skill at the same time, and the whole thing inflated the flowchart to 600 sheets.  Nobody understood the scheme to the end, and when the designer saw it, she was simply terrified. <br><br>  I have advice on how to prevent this.  The scheme will always grow, but <strong>never try to build one big flowchart for the whole application</strong> - it will be cumbersome, and no one except you will understand it.  Go from the opposite and <strong>break the scheme into logical parts</strong> : separate scenario of price guessing, separate help script.  If necessary, break these scripts into sub-scenarios.  The result is not one big map with incomprehensible connections, but many small, readable, well-connected schemes in which it is convenient for everyone to navigate. <br><br>  For flowcharts fit any tool.  I used to use <strong><a href="https://realtimeboard.com/ru/">RealtimeBoard</a></strong> , but I also have <strong><a href="https://www.draw.io/">Draw.io</a></strong> and even <strong>XMind</strong> .  As a result, I developed my own, because it is simply more convenient.  In the picture it is just presented.  This tool supports, including, a breakdown into subscenarios. <br><br><h4>  prompt lists <br></h4><br>  The last artifact we will form at the design stage.  <strong>The prompt list</strong> is a list of all possible phrases that an application can say. <br><br>  There is one subtlety.  Conversation with the application should be flexible and similar to a conversation with a person.  This means not only the opportunity to go through different branches, which we did at the stage of the flowchart, but the sound of the conversation as a whole.  A person will never answer with the same phrase if you ask the same question.  The answer will always be rephrased and sound somehow different.  The application should do the same, so for each step of the dialogue on behalf of the application write not one answer, but at least five. <br><br><img src="https://habrastorage.org/webt/mi/8g/kb/mi8gkbvm6uxn4agzr009n1ykbgu.png"><br><br>  According to the prompt lists there is another important thing.  Communication should not only be lively and flexible, but also <strong>consistent</strong> in terms of speech style and the general feeling of the user's communication with your application.  For this, designers use an excellent technique - <strong>character creation</strong> .  When I call my friend, I do not see him, but subconsciously imagine the interlocutor.  The user when communicating with a smart column is the same.  This is called <strong><a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B0%25D1%2580%25D0%25B5%25D0%25B9%25D0%25B4%25D0%25BE%25D0%25BB%25D0%25B8%25D1%258F">pareidalia</a></strong> . <br><br>  At the prompt lists page, you create a character on whose behalf the application will speak.  With a character, your users will associate a brand and an app ‚Äî this can be a real person or a fictional one.  Work on his appearance, biography, character and humor, but if there is no time, just bring all your phrases in the prompt sheets to the same style.  If you started to contact the user on "You", then do not contact in other places on "You".  If you have an informal communication style, stick to it everywhere. <br><br>  Usually, Excel or Google spreadsheets are used to create the prompt sheets, but with them there are huge temporary losses for routine work.  The block diagram and the tablet with the phrases are in no way connected with each other, any changes have to be transferred manually, which translates into a permanent and long routine. <br><br>  I use not Excel, but my tool, because in it all the phrases are written directly in the flowchart, they are assigned to the step of the dialogue.  It eliminates the routine. <br><br><blockquote>  In design, we work through each scenario: we write an example of a dialogue, we find side branches, errors, we cover it with a flowchart, and then we work on the style of speech and phrases. <br></blockquote><br>  It seems that now everything is ready and you can give the task to the developers and get to the code, but there is one more important stage left - testing.  We need to make sure that as designers did everything correctly, that the application will work as we want, that all the phrases are in the same style, that we have covered all the side branches and processed all the errors. <br><br><h3>  Testing <br></h3><br>  Testing at this early stage is especially important for voice applications.  In the world of graphical user interfaces, the user is limited by what the designer has drawn: he will not go beyond the screen, will not find a button that does not exist, but will only click on what is ... <br><br>  In the world of voices, everything is not so: the user is free to say anything and you don‚Äôt know how he will start working with your application until you see it.  It is better to do this at an early design stage and prepare for the unexpected, before the expensive development begins. <br><br><img src="https://habrastorage.org/webt/x4/ht/d9/x4htd9abfvqf21rqbsnpbevfbz0.png"><br><br>  Applications are tested using the <strong>Wizard of Oz</strong> methodology.  It is used in graphic applications, but less often, but in a voice it is a must have.  This is a method when a user interacts with the system, assuming that it exists and works on its own, but you manage the whole process. <br><br>  Testing is done using interactive prototypes.  Usually the designer has to ask developers to create a prototype, but personally I use my tool, because everything is done in it with one click and you don‚Äôt have to wait for anyone.  We also need a user.  We call a person who is not involved in the development at all, does not know anything about the application and, ideally, is included in your Central Asia.  You invite a person, explain what kind of application it is, how to use it, plant it in a room, turn on an interactive prototype and the user starts talking to him.  The prototype does not recognize speech, and this is what you hear, what the person says, and choose the answer option with which the application responds to each phrase. <br><br>  If the user does not see the screen, then it seems to him that the application works by itself, but the process is controlled by you.  This is the testing of the Wizard of Oz.  With it, you will not only hear the sound of the application, but also see how people use it.  I guarantee that you will find many uncovered scripts. <br><br>  When I tested the game, I called my friend.  He began to guess the price and said that some kind of ointment was worth "pyatikhat."  I did not expect such a word, I thought that there would be options of 500 rubles, a thousand rubles, and not ‚Äúpyatikhat‚Äù or ‚Äúmower‚Äù.  This is a trifle that came to light on testing.  People use the application differently than you imagine, and testing reveals such trifles and non-working scenarios. <br><br><blockquote>  Test a lot and for a long time before developing until you are sure that the application is working and users interact with it as you expect. <br></blockquote><br>  This is where the design phase ends and we have examples of dialogues in our hands, a block diagram is a logical description of the operation of an application, and prompt-lists are what the application says.  We will give all this to the developers.  Before I tell you how developers create applications, I‚Äôll share design tips. <br><br><h3>  Tips <br></h3><br>  <strong>Use SSML markup language</strong> - as HTML, only for speech.  SSML allows you to pause, set the level of empathy, stress, prescribe what to spell and where to focus. <br><br><img src="https://habrastorage.org/webt/e3/yd/gn/e3ydgn-w1g6druouxlcqztgho7a.png"><br><br>  Marked speech sounds much better than the robot speech, and the better the application sounds, the more pleasant it is to use it.  Therefore, use SSML - it is not so complicated. <br><br>  <strong>Think about the moments in which users turn to your application for help.</strong>  This is especially important for voice.  A person can talk to a speaker alone in a room, or he can ride a bus and talk to a smartphone.  These are two fundamentally different behavior scenarios for a voice application.  We had a similar situation with the banking application.  In the application there was a script when the user receives information about the account, and this is private information.  I thought that if a person is talking at home, then everything is fine, but if he is traveling on a bus, and the application starts to voice the card balance out loud, it will be ugly. <br><br>  Thinking about these moments, you can determine that if the user is talking to a smartphone, even if by voice, then it is better not to read out private information, but to show it on the screen. <br><br><blockquote>  <strong>Use multimodal design.</strong> <br></blockquote><br>  This is a design for different surfaces and platforms.  Voice devices are very different in their texture.  In the mobile world, devices differ only in platform and screen size - form factor.  The voice is different.  For example, a speaker doesn't have a screen at all - just a voice.  The smartphone has a screen, and you can tap it with your finger.  The TV screen is huge, but it is useless to touch it.  Think about how your application will work on each of these surfaces. <br><br>  For example, a user made a purchase and we want to show a receipt.  Reading the check out loud is a bad idea, because there is a lot of information and no one will remember it, because voice information is perceived difficult and difficult. <br><br><img src="https://habrastorage.org/webt/ke/p4/gt/kep4gtllwrtpujw0tbxtga_mxnk.png"><br><br>  Using the principle of multimodal design, we understand that if there is a screen, then the check is better to show, instead of reading.  If there is no screen, then we are forced to speak out loud the main data of the check. <br><br>  This design is complete.  What I have told is the basics, the tip of the iceberg.  For self-study design, I gathered a lot of material on the design, at the end of the article will be links. <br><br><h3>  Development <br></h3><br>  We begin the conversation with a universal scheme of the application under any platform.  The scheme works with Alice, Amazon Alexa, and Google Assistant. <br><br><img src="https://habrastorage.org/webt/p3/gz/sr/p3gzsrjcnvz9qai2c6c3zdllttu.png"><br><br>  When a user asks to start our application, the assistant does this and transfers control of the conversation to the application.  The user says something and the application gets the raw text, which is processed by the speech recognition system. <br><br><ul><li>  The raw text system determines the intent of the user ‚Äî the <strong>intent</strong> , its parameters ‚Äî <strong>slots</strong> , and forms the answer: immediately, if no logic and additional information is required, and uses the <strong>webhook</strong> , if logic is necessary.  All business logic in voice applications lies in a webhook, from there requests are made to databases, API calls. </li><li>  The answer is formed and transmitted to the user by voice or shown on the screen. </li></ul><br><br>  For processing, we use <strong>Dialogflow</strong> , its structure is absolutely the same as that of other speech understanding systems, and we will consider the development using its example. <br><br>  We are moving to the first link - the human speech understanding system or Natural Language Understanding - NLU. <br><br><h4>  Dialogflow <br></h4><br><img src="https://habrastorage.org/webt/dy/mj/yh/dymjyh8t4bfm7te07joy290e7ye.png"><br><br>  We use Dialogflow, because it has rich features, good documentation, live support and it is easy and quick to master.  Dialogflow cross-platform tool: the main qualification is applications for Google Assistant, but for Yandex-Alice, Amazon Alexa and creating bots in Telegram it can also be used.  Separate plus - open API.  You can use the system to develop voice control for a website or an existing mobile application. <br><br>  The main components of Dialogflow. <br><br><ul><li>  <strong>Agent</strong> - your project, what's inside. </li><li>  <strong>Intents</strong> - the intentions of the user. </li><li>  <strong>Entities</strong> - data objects. </li><li>  <strong>Contexts</strong> - contexts, repositories for information. </li></ul><br>  Let's go through all the components, but let's start with the main thing - this is Intents. <br><br><h4>  Intents <br></h4><br>  This is a <strong>user intention</strong> , what the user wants to accomplish.  Intention expressed phrases.  For example, in the game, the user wants to know the rules of the game and says: ‚ÄúTell the rules of the game‚Äù, ‚ÄúTell me how to play?‚Äù, ‚ÄúHelp me - I'm confused‚Äù or something like that.  Accordingly, we create a separate Intent for the rules of the game, and at the input we write all these <strong>phrases that we expect</strong> from the user. <br><br>  I advise you to write 10 or more phrases.  In this case, speech recognition will work better, because Dialogflow uses a neural network that accepts these 10 input phrases and generates a bunch of other similar ones from them.  The more options, the better, but do not overdo it. <br><br>  Intent should have the answer to any user question.  In Dialogflow, an answer can be formed without applying logic, and if logic is needed, then we transmit the answer from the webhook.  The answers may be different, but the standard one is the text: it is sounded on the speakers, shown or spoken on smartphones. <br><br>  Depending on the platform, additional ‚Äúbuns‚Äù are available - graphic elements.  For example, for Google Assistant, these are buttons, flashcards, lists, carousels.  They are shown only if a person speaks with Google Assistant on a smartphone, TV, or other similar device. <br><br><h4>  Entities <br></h4><br>  Intent starts when the user says something.  At this moment information is transmitted - the <strong>parameters, which are called slots</strong> , and the data type of the parameters - <strong>Entities</strong> .  For example, for our game, these are examples of phrases that the user says when he guesses the price.  There are two parameters: amount and currency. <br><br><img src="https://habrastorage.org/webt/uc/vl/--/ucvl--ptbscwxqe7_bdnwkpr6oq.png"><br><br>  Parameters may be <strong>required</strong> and <strong>optional</strong> .  If the user answers "two thousand", then the phrase will be enough.  By default, we take rubles, so the currency is an optional parameter.  But without the sum, we cannot understand the answer, because the user can answer the question not specifically: <br><br>  - <em>How much is it?</em> <br>  - <em>A lot!</em> <br><br>  For such cases, Dialogflow has the concept of <strong>re-prompt</strong> - this is the phrase that will be uttered when the user does not name the required parameter.  For each parameter, the phrase is set separately.  For the sum, it could be something like: "Give the exact figure how much it costs ..." <br><br>  Each parameter must have a data type - Entities.  Dialogflow has many standard data types - cities, names, and it saves.  The system itself determines what is the name, what is the number, and what the city is, but you can also set your own custom types.  Dialogflow currency is a custom type.  We created it ourselves ^ described a technical system name, which we will use, and synonyms that correspond to this parameter.  For the currency is the ruble, dollar, euro.  When the user says: ‚ÄúEuro‚Äù, Dialogflow highlights that this is our ‚Äúcurrency‚Äù parameter. <br><br><h4>  Context <br></h4><br>  Think of this word literally: <strong>context</strong> is the context of what you are talking about with the user.  For example, you can ask the assistant: ‚ÄúWho wrote Mumu?‚Äù And he will answer that it is Turgenev.  After that you can ask when he was born.  I pay attention that we ask: "When <strong>he</strong> was born", without specifying who.  Google will understand, because it remembers - in the context of the conversation Turgenev. <br><br><img src="https://habrastorage.org/webt/xw/zc/bu/xwzcbuvbeyjcq50rhxxygbfplds.png"><br><br>  From a technical point of view, <strong>context</strong> is <strong>a repository of the ‚Äúkey-value‚Äù type</strong> into which information is stored.  Intent can either emit the context from itself, add something to it, or accept it as input and retrieve information from there.  The context has a lifetime.  It is determined by the number of steps of the dialogue from the last mention: for example, after 5 steps of the dialogue, forget what we said about Turgenev. <br><br>  The context has another important function - it can help us break the application into logical zones: into authorized and unauthorized ones, into a gaming session or not.  The breakdown is constructed in such a way that the Intent that accepts a context for input cannot be started without a context and requires a previous launch of another Intent.  So we can logically link and build our application. <br><br><img src="https://habrastorage.org/webt/tt/69/-t/tt69-tzedwqtefzh4fbitst9fbg.png"><br><br>  I mentioned webhook. Dialogflow has libraries for completely different languages, we used JS.  Google Assistant for webhook has a limitation - the answer from it should come no later than 5 seconds, otherwise an error will occur and the application will work in the fallback.  For Alice, the response time is 1.5 or 3 seconds. <br><br><blockquote>  We set up a speech understanding system, wrote a webhook and everything works for us, we launched QA, and now is the time for publication. <br></blockquote><br><h3>  Publication <br></h3><br><img src="https://habrastorage.org/webt/ff/lc/ln/fflclnncm9d9lzmvf5fskm-kok4.png"><br><br>  The publication is standard, almost like with mobile applications, but with a couple of nuances. <br><br>  Pay a separate, special and very close attention to the <strong>name of the application</strong> .  The user will say it out loud every time you start.  Therefore, the name should be easy to pronounce and easy to recognize by an assistant, because sometimes there are problems with this. <br><br>  The name has two rules: <br><br><ul><li>  <strong>You can not use common phrases</strong> .  In Yandex.Alisa, you can not use verbs.  For example, you will not be able to take the name "Taxi Order" because it is a common phrase that many people want to use. </li><li>  If you want to use the name of your company, then be prepared for the fact that you <strong>will be asked to confirm the rights to use the brand</strong> . </li></ul><br>  In Google Assistant, the <strong>standard phrase</strong> that launches any application is ‚ÄúOK, Google, talk to ...‚Äù.  You can use this feature, for example, say: ‚ÄúOK, Google, talk to Uber‚Äù - and he will launch the application on the main screen, at the starting point.  But you can make the user say, ‚ÄúOK, Google, tell Uber to pick me up from here and take me there!‚Äù We shorten one iteration, and the user gets into the desired action. <br><br>  The script is determined by the phrases that launch the application.  They are installed when publishing, but often work incorrectly - in Russian for sure.  For example, in our game, the phrase ‚ÄúLet's <strong>sy</strong> wey‚Äù worked, and ‚ÄúLet <strong>'s</strong> play‚Äù did not work.  I do not know what the fundamental difference between "play" and "play" for Google Assistant.  He recognized both phrases correctly, but the application did not work, although we had no problems with the English language. <br><br>  The rest of the publication runs smoothly, without any questions.  Support for Google Assistant is very lively, responds quickly, and the documentation is good. <br><br>  I also want to mention different types of releases. <br><br><ul><li>  <strong>Alpha</strong> - for 20 people and without passing review. </li><li>  <strong>Beta</strong> - for 200 people. </li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Production release</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - when the application gets to the store. </font><font style="vertical-align: inherit;">If we publish in Production, then we must pass a review. </font><font style="vertical-align: inherit;">People from Google manually check how the application works, and send feedback. </font><font style="vertical-align: inherit;">If all is well, the application is published. </font><font style="vertical-align: inherit;">If not, then you receive a letter with edits that does not work in your application and what to fix.</font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It would seem that this is all, but we are talking about the voice, so there is another important point here - this is the analyst. </font></font><br><br><h3>  Analytics <br></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Especially important for voice. </font><font style="vertical-align: inherit;">If for mobile applications, the analyst shows jambs, bugs and system errors, but in the world of voice, the analyst reveals missed opportunities to us - how people wanted to use our application, but could not. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is a mandatory step. </font><font style="vertical-align: inherit;">That is why Dialogflow has standard application analysis tools with the following modes:</font></font><br><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">History</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - impersonal history of conversations with your application.</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Learning</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is an interesting mode that shows all the phrases that the application has recognized, but has not been able to process.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">They are shown in a list and look like in the picture. </font><font style="vertical-align: inherit;">The user guessed the price of a motor and said: "4 pieces." </font><font style="vertical-align: inherit;">I remembered about the "mowers" for testing, but I forgot about the "things" - so I‚Äôll have to fix it. </font></font><br><br><img src="https://habrastorage.org/webt/hu/uh/n4/huuhn4xyfy3h8at5ivkvsuneggg.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analytics helps to find flaws, so be sure to look in the logs and check what happens to your application and what users do with it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That's all about voice applications. </font><font style="vertical-align: inherit;">I hope that you have at least a minimal understanding of how they are developed. </font><font style="vertical-align: inherit;">The report was general, but all additional materials about the development, design and business part are collected on the links.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Useful links and contacts </font></font><br></h2><br> <a href="https://t.me/conversational_interfaces_ru"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Telegram-chat of voice interface developers </font></font></a> <br> <a href="https://t.me/yadialogschat"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Telegram-chat Yandex. </font></font></a> <br> <a href="http://www.alexaslack.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dialogues Slack-chat developers Amazon Alexa </font></font></a> <br> <a href="http://googleslack.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Slack-chat developers Google Assistant </font></font></a> <br> <a href="https://designguidelines.withgoogle.com/conversation/conversation-design/welcome.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Guidelines Google Assistant </font></font></a> <br> <a href="https://developer.amazon.com/alexa-skills-kit/design"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Guideline Amazon Alexa </font></font></a> <br> <a href="https://www.amazon.com/Designing-Voice-User-Interfaces-Conversational-ebook/dp/B01NALL1Q0"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Designing VUI book by Cathy Pearl </font></font></a> <br> <a href="https://voicebot.ai/voice-ux-best-practices-ebook/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Book VUX best practices, Voicebot My own </font></font></a> <br> <a href="https://medium.com/appkode/vux-best-practices-voicebot-ebook-f67df69ebbc0"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">book higher on Medium </font></font></a> <br> <a href="https://developers.google.com/actions/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentation Google Assistant </font></font></a> <br> <a href="https://developer.amazon.com/documentation/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentation Amazon Alexa </font></font></a> <br> <a href="https://tech.yandex.ru/dialogs/alice/doc/about-docpage/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentation Yandex.Alise </font></font></a> <br> <a href="https://voicebot.ai/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">News, analytics </font></font></a> <br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contacts of speaker Pavel Guaya: </font></font></strong><font style="vertical-align: inherit;"></font><a href="https://twitter.com/PavelGvay"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Twitter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://ru.linkedin.com/in/pavel-gvay-230142167"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linkedin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> profiles </font><font style="vertical-align: inherit;">, and a blog on </font></font><a href="https://medium.com/%40pavelgvay"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Medium</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><blockquote> <a href="http://appsconf.ru/moscow/2019">AppsConf</a> 2019 –ø—Ä–æ–π–¥–µ—Ç –≤ —Ü–µ–Ω—Ç—Ä–µ –ú–æ—Å–∫–≤—ã, –≤ –ò–Ω—Ñ–æ–ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ 22 –∏ 23 –∞–ø—Ä–µ–ª—è. –û–±–µ—â–∞–µ–º –µ—â–µ –±–æ–ª—å—à–µ –ø–æ–ª–µ–∑–Ω–æ—Å—Ç–µ–π –ø–æ –º–æ–±–∏–ª—å–Ω–æ–π —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ, —á–µ–º –≤ –ø—Ä–æ—à–ª–æ–º –≥–æ–¥—É, –ø–æ—ç—Ç–æ–º—É –±—Ä–æ–Ω–∏—Ä—É–π—Ç–µ –±–∏–ª–µ—Ç –∏–ª–∏ <a href="https://conf.ontico.ru/users/login.html%3Furl%3D/lectures/propose%253Fconference%253Dac2019">–æ—Å—Ç–∞–≤–ª—è–π—Ç–µ –∑–∞—è–≤–∫—É –Ω–∞ –¥–æ–∫–ª–∞–¥</a> . <br><br> –ß—Ç–æ–±—ã –±—ã—Ç—å –≤ –∫—É—Ä—Å–µ –Ω–æ–≤–æ—Å—Ç–µ–π –∏ –∞–Ω–æ–Ω—Å–æ–≤ –¥–æ–∫–ª–∞–¥–æ–≤ ‚Äî –ø–æ–¥–ø–∏—Å—ã–≤–∞–π—Ç–µ—Å—å <a href="https://onticolist.us8.list-manage.com/subscribe%3Fu%3D719c4e65585ea6013f361815e%26amp%3Bid%3Dc91360a9e7">–Ω–∞ –Ω–∞—à—É —Ä–∞—Å—Å—ã–ª–∫—É</a> –∏ <a href="https://www.youtube.com/c/MobileChannelRussia">YouTube-–∫–∞–Ω–∞–ª –ø–æ –º–æ–±–∏–ª—å–Ω–æ–π —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ</a> . <br><br> –¢–æ–ª—å–∫–æ AppsConf, —Ç–æ–ª—å–∫–æ —Ö–∞—Ä–¥–∫–æ—Ä! <br></blockquote></div><p>Source: <a href="https://habr.com/ru/post/437586/">https://habr.com/ru/post/437586/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>