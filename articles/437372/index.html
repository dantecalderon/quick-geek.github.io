<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Three simple steps to reduce Docker images</title>
  <meta name="description" content="When it comes to creating Docker containers, it's best to always strive to minimize the size of the images. Images that use the same layers and weigh ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Three simple steps to reduce Docker images</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/339/ed2/afb/339ed2afb54b94a155f95e6a279ede9d.png" alt="image"><br><p>  When it comes to creating Docker containers, it's best to always strive to minimize the size of the images.  Images that use the same layers and weigh less are transferred and deposited more quickly. </p><br><p> But how to control the size when each execution of the <code>RUN</code> operator creates a new layer?  Plus, we still need intermediate artifacts before creating the image itself ... </p><a name="habracut"></a><br><p>  Perhaps you know that most Docker-files have their own, rather strange, features, for example: </p><br><pre> <code class="plaintext hljs">FROM ubuntu RUN apt-get update &amp;&amp; apt-get install vim</code> </pre> <br><p>  Well, why is it <code>&amp;&amp;</code> ?  Isn't it easier to run two <code>RUN</code> statements, like here? </p><br><pre> <code class="plaintext hljs">FROM ubuntu RUN apt-get update RUN apt-get install vim</code> </pre> <br><p>  Starting in Docker version 1.10, the <code>COPY</code> , <code>ADD</code> and <code>RUN</code> operators add a new layer to the image.  In the previous example, two layers were created instead of one. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/cfb/fd8/e34/cfbfd8e34d1dd89685121383128c05aa.gif" alt="image"></p><br><h3 id="sloi-kak-git-kommity">  Layers like git commits. </h3><br><p>  Docker layers preserve the differences between the previous and the current version of the image.  And as Git-commits, they are convenient if you share them with other repositories or images.  In fact, when requesting an image from the registry, only missing layers are loaded, which simplifies the separation of images between containers. </p><br><p>  But at the same time, each layer takes place, and the more of them, the heavier the final image.  Git repositories are similar in this respect: the size of the repository grows with the number of layers, because it must keep all changes between commits.  It used to be good practice to combine several <code>RUN</code> operators in one line, as in the first example.  But now, alas, no. </p><br><h2 id="1-obedinyaem-neskolkih-sloev-v-odin-s-pomoschyu-poetapnoy-sborki-docker-obrazov">  1. Merge several layers into one using phased build of Docker images </h2><br><p>  When the Git repository grows, you can simply reduce the entire change history to one commit and forget about it.  It turned out that something similar can be implemented in Docker - through a phased assembly. </p><br><p>  Let's create a Node.js container. </p><br><p>  Let's start with <code>index.js</code> : </p><br><pre> <code class="plaintext hljs">const express = require('express') const app = express() app.get('/', (req, res) =&gt; res.send('Hello World!')) app.listen(3000, () =&gt; { console.log(`Example app listening on port 3000!`) })</code> </pre> <br><p>  and <code>package.json</code> : </p><br><pre> <code class="plaintext hljs">{ "name": "hello-world", "version": "1.0.0", "main": "index.js", "dependencies": { "express": "^4.16.2" }, "scripts": { "start": "node index.js" } }</code> </pre> <br><p>  Package the application with the following <code>Dockerfile</code> : </p><br><pre> <code class="plaintext hljs">FROM node:8 EXPOSE 3000 WORKDIR /app COPY package.json index.js ./ RUN npm install CMD ["npm", "start"]</code> </pre> <br><p>  Create an image: </p><br><pre> <code class="plaintext hljs">$ docker build -t node-vanilla .</code> </pre> <br><p>  Check that everything works: </p><br><pre> <code class="plaintext hljs">$ docker run -p 3000:3000 -ti --rm --init node-vanilla</code> </pre> <br><p>  <em>Now you can follow the link: <a href="http://localhost:3000/">http: // localhost: 3000</a> and see ‚ÄúHello World!‚Äù There.</em> </p><br><p>  In the <code>Dockerfile</code> , we now have the operators <code>COPY</code> and <code>RUN</code> , so we fix an increase of at least two layers compared to the original way: </p><br><pre> <code class="plaintext hljs">$ docker history node-vanilla IMAGE CREATED BY SIZE 075d229d3f48 /bin/sh -c #(nop) CMD ["npm" "start"] 0B bc8c3cc813ae /bin/sh -c npm install 2.91MB bac31afb6f42 /bin/sh -c #(nop) COPY multi:3071ddd474429e1‚Ä¶ 364B 500a9fbef90e /bin/sh -c #(nop) WORKDIR /app 0B 78b28027dfbf /bin/sh -c #(nop) EXPOSE 3000 0B b87c2ad8344d /bin/sh -c #(nop) CMD ["node"] 0B &lt;missing&gt; /bin/sh -c set -ex &amp;&amp; for key in 6A010‚Ä¶ 4.17MB &lt;missing&gt; /bin/sh -c #(nop) ENV YARN_VERSION=1.3.2 0B &lt;missing&gt; /bin/sh -c ARCH= &amp;&amp; dpkgArch="$(dpkg --print‚Ä¶ 56.9MB &lt;missing&gt; /bin/sh -c #(nop) ENV NODE_VERSION=8.9.4 0B &lt;missing&gt; /bin/sh -c set -ex &amp;&amp; for key in 94AE3‚Ä¶ 129kB &lt;missing&gt; /bin/sh -c groupadd --gid 1000 node &amp;&amp; use‚Ä¶ 335kB &lt;missing&gt; /bin/sh -c set -ex; apt-get update; apt-ge‚Ä¶ 324MB &lt;missing&gt; /bin/sh -c apt-get update &amp;&amp; apt-get install‚Ä¶ 123MB &lt;missing&gt; /bin/sh -c set -ex; if ! command -v gpg &gt; /‚Ä¶ 0B &lt;missing&gt; /bin/sh -c apt-get update &amp;&amp; apt-get install‚Ä¶ 44.6MB &lt;missing&gt; /bin/sh -c #(nop) CMD ["bash"] 0B &lt;missing&gt; /bin/sh -c #(nop) ADD file:1dd78a123212328bd‚Ä¶ 123MB</code> </pre> <br><p>  As you can see, the final image has grown by five new layers: one for each operator in our <code>Dockerfile</code> .  Let's try a phased Docker build now.  We use the same two-part <code>Dockerfile</code> : </p><br><pre> <code class="plaintext hljs">FROM node:8 as build WORKDIR /app COPY package.json index.js ./ RUN npm install FROM node:8 COPY --from=build /app / EXPOSE 3000 CMD ["index.js"]</code> </pre> <br><p>  The first part of the <code>Dockerfile</code> creates three layers.  Then the layers are combined and copied to the second and final stages.  Two more layers are added on top of the image.  As a result, we have three layers. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/72c/6a6/61e/72c6a661ef969eabd58a91b4b71b0329.gif" alt="image"></p><br><p>  Let's try.  First create the container: </p><br><pre> <code class="plaintext hljs">$ docker build -t node-multi-stage .</code> </pre> <br><p>  Checking history: </p><br><pre> <code class="plaintext hljs">$ docker history node-multi-stage IMAGE CREATED BY SIZE 331b81a245b1 /bin/sh -c #(nop) CMD ["index.js"] 0B bdfc932314af /bin/sh -c #(nop) EXPOSE 3000 0B f8992f6c62a6 /bin/sh -c #(nop) COPY dir:e2b57dff89be62f77‚Ä¶ 1.62MB b87c2ad8344d /bin/sh -c #(nop) CMD ["node"] 0B &lt;missing&gt; /bin/sh -c set -ex &amp;&amp; for key in 6A010‚Ä¶ 4.17MB &lt;missing&gt; /bin/sh -c #(nop) ENV YARN_VERSION=1.3.2 0B &lt;missing&gt; /bin/sh -c ARCH= &amp;&amp; dpkgArch="$(dpkg --print‚Ä¶ 56.9MB &lt;missing&gt; /bin/sh -c #(nop) ENV NODE_VERSION=8.9.4 0B &lt;missing&gt; /bin/sh -c set -ex &amp;&amp; for key in 94AE3‚Ä¶ 129kB &lt;missing&gt; /bin/sh -c groupadd --gid 1000 node &amp;&amp; use‚Ä¶ 335kB &lt;missing&gt; /bin/sh -c set -ex; apt-get update; apt-ge‚Ä¶ 324MB &lt;missing&gt; /bin/sh -c apt-get update &amp;&amp; apt-get install‚Ä¶ 123MB &lt;missing&gt; /bin/sh -c set -ex; if ! command -v gpg &gt; /‚Ä¶ 0B &lt;missing&gt; /bin/sh -c apt-get update &amp;&amp; apt-get install‚Ä¶ 44.6MB &lt;missing&gt; /bin/sh -c #(nop) CMD ["bash"] 0B &lt;missing&gt; /bin/sh -c #(nop) ADD file:1dd78a123212328bd‚Ä¶ 123MB</code> </pre> <br><p>  See if the file size has changed: </p><br><pre> <code class="plaintext hljs">$ docker images | grep node- node-multi-stage 331b81a245b1 678MB node-vanilla 075d229d3f48 679MB</code> </pre> <br><p>  Yes, it has become smaller, but not significantly yet. </p><br><h2 id="2-snosim-vse-lishnee-iz-konteynera-s-pomoschyu-distroless">  2. We demolish all the excess from the container using distroless </h2><br><p>  The current image provides us with Node.js, <code>yarn</code> , <code>npm</code> , <code>bash</code> and many other useful binaries.  Also, it is based on Ubuntu.  Thus, deploying it, we get a full-fledged operating system with many useful binaries and utilities. </p><br><p>  However, we do not need them to run the container.  The only dependency needed is Node.js. </p><br><p>  Docker-containers should provide work of one process and contain the minimum necessary set of tools for its start.  The whole operating system is not required for this. </p><br><p>  Thus, we can take out everything from it except Node.js. </p><br><p>  <strong>But how?</strong> </p><br><p>  Google has already come to a similar decision - <a href="https://github.com/GoogleContainerTools/distroless">GoogleCloudPlatform / distroless</a> . </p><br><p>  The description for the repository reads as follows: </p><br><p>  <em>Distroless images contain only the application and the dependencies for its work.</em>  <em>There are no package managers, shells and other programs that are usually found in the standard Linux distribution.</em> </p><br><p>  <strong>This is what you need!</strong> </p><br><p>  Launch <code>Dockerfile</code> to get a new image: </p><br><pre> <code class="plaintext hljs">FROM node:8 as build WORKDIR /app COPY package.json index.js ./ RUN npm install FROM gcr.io/distroless/nodejs COPY --from=build /app / EXPOSE 3000 CMD ["index.js"]</code> </pre> <br><p>  We collect the image as usual: </p><br><pre> <code class="plaintext hljs">$ docker build -t node-distroless .</code> </pre> <br><p>  The application should earn normally.  To check, run the container: </p><br><pre> <code class="plaintext hljs">$ docker run -p 3000:3000 -ti --rm --init node-distroless</code> </pre> <br><p>  And we go to <a href="http://localhost:3000/">http: // localhost: 3000</a> .  Has the image become easier without extra binaries? </p><br><pre> <code class="plaintext hljs">$ docker images | grep node-distroless node-distroless 7b4db3b7f1e5 76.7MB</code> </pre> <br><p>  <strong>And how!</strong>  <strong>Now it weighs only 76.7 MB, as much as 600 MB less!</strong> </p><br><p>  Everything is cool, but there is one important point.  When the container is running and you need to check it, you can connect using: </p><br><pre> <code class="plaintext hljs">$ docker exec -ti &lt;insert_docker_id&gt; bash</code> </pre> <br><p>  Connecting to a running container and running <code>bash</code> very similar to creating an SSH session. </p><br><p>  But since distroless is a stripped-down version of the original operating system, there are neither additional binaries, nor, actually, a shell! </p><br><p>  How to connect to a running container if there is no shell? </p><br><p>  The most interesting thing is that. </p><br><p>  This is not very good, since only binaries can be executed in a container.  And the only one that can be run is Node.js: </p><br><pre> <code class="plaintext hljs">$ docker exec -ti &lt;insert_docker_id&gt; node</code> </pre> <br><p>  In fact, there is a plus in this, because if suddenly an attacker can gain access to the container, he will do much less damage than if he had access to the shell.  In other words, fewer binaries ‚Äî less weight and better security.  But, truth, at the price of more complex debugging. </p><br><p>  Here it would be necessary to make a reservation that you should not connect and debug containers on the prod-environment.  It is better to rely on properly configured logging and monitoring systems. </p><br><p>  But what if we still need debugging, and at the same time we want the docker image to have the smallest size? </p><br><h2 id="3-umenshaem-bazovye-obrazy-s-pomoschyu-alpine">  3. Reduce Base Images with Alpine </h2><br><p>  You can replace the distroless Alpine-image. </p><br><p>  <a href="https://alpinelinux.org/">Alpine Linux</a> is a security-oriented, lightweight distribution based on <a href="https://www.musl-libc.org/">musl libc</a> and <a href="https://www.busybox.net/">busybox</a> .  But let's not believe the word, but rather check. </p><br><p>  Launch <code>Dockerfile</code> using <code>node:8-alpine</code> : </p><br><pre> <code class="plaintext hljs">FROM node:8 as build WORKDIR /app COPY package.json index.js ./ RUN npm install FROM node:8-alpine COPY --from=build /app / EXPOSE 3000 CMD ["npm", "start"]</code> </pre> <br><p>  Create an image: </p><br><pre> <code class="plaintext hljs">$ docker build -t node-alpine .</code> </pre> <br><p>  Check the size: </p><br><pre> <code class="plaintext hljs">$ docker images | grep node-alpine node-alpine aa1f85f8e724 69.7MB</code> </pre> <br><p>  <strong>At the output we have 69.7MB - it is even less than a distroless-image.</strong> </p><br><p>  Check whether it is possible to connect to a running container (in the case of the distrolles image, we could not do this). </p><br><p>  We start the container: </p><br><pre> <code class="plaintext hljs">$ docker run -p 3000:3000 -ti --rm --init node-alpine Example app listening on port 3000!</code> </pre> <br><p>  And connect: </p><br><pre> <code class="plaintext hljs">$ docker exec -ti 9d8e97e307d7 bash OCI runtime exec failed: exec failed: container_linux.go:296: starting container process caused "exec: \"bash\": executable file not found in $PATH": unknown</code> </pre> <br><p>  Unsuccessful.  But maybe the container has <code>sh</code> 'ell ...: </p><br><pre> <code class="plaintext hljs">$ docker exec -ti 9d8e97e307d7 sh / #</code> </pre> <br><p>  Fine!  We managed to connect to the container, and at the same time its image is also smaller.  But here it was not without nuances. </p><br><p>  Alpine images are based on muslc - an alternative standard library for C. While most Linux distributions, such as Ubuntu, Debian and CentOS, are based on glibc.  It is believed that both of these libraries provide the same interface for working with the kernel. </p><br><p>  However, they have different goals: glibc is the most common and fast, muslc takes up less space and is written with an emphasis on security.  When an application is compiled, as a rule, it is compiled under a particular C library. If you need to use it with another library, you will have to recompile. </p><br><p>  In other words, assembling containers on Alpine images can lead to unexpected developments, since the standard C library used in it is different.  The difference will be noticeable when working with precompiled binaries, such as Node.js extensions for C ++. </p><br><p>  For example, the PhantomJS package does not work on Alpine. </p><br><h2 id="tak-kakoy-zhe-bazovyy-obraz-vybrat">  So which base image to choose? </h2><br><p>  Alpine, distroless or vanilla image - to solve, of course, better according to the situation. </p><br><p>  <strong>If we are dealing with a prod and security is important, perhaps the most appropriate would be distroless.</strong> </p><br><p>  Each binary added to a Docker image adds a certain risk to the stability of the entire application.  This risk can be reduced by having only one binary installed in the container. </p><br><p>  For example, if an attacker could find a vulnerability in an application running on the basis of a distroless image, he will not be able to launch a shell in the container, because it is not there! </p><br><p>  <strong>If for some reason the size of the docker image is extremely important to you, you should definitely look at the images based on Alpine.</strong> </p><br><p>  They are really small, but true, at the cost of compatibility.  Alpine uses a slightly different standard C - muslc library, so sometimes problems will pop up.  Examples can be found on the links: <a href="https://github.com/grpc/grpc/issues/8528">https://github.com/grpc/grpc/issues/8528</a> and <a href="https://github.com/grpc/grpc/issues/6126">https://github.com/grpc/grpc/issues/6126</a> . </p><br><p>  <strong>Vanilla images are ideal for testing and development.</strong> </p><br><p>  Yes, they are big, but they are as close as possible to a full-fledged machine with installed Ubuntu.  In addition, all binaries are available in the OS. </p><br><p>  <strong>Let's summarize the size of the received Docker images:</strong> </p><br><p>  <code>node:8</code> 681MB <br>  <code>node:8</code> with step build 678MB <br>  <code>gcr.io/distroless/nodejs</code> 76.7MB <br>  <code>node:8-alpine</code> 69.7MB </p><br><h3 id="naputstvie-ot-perevodchika">  Parting words from the translator </h3><br><p>  Read other articles on our blog: </p><br><p>  <a href="https://habr.com/ru/company/nixys/blog/426543/">Stateful backups in Kubernetes</a> </p><br><p>  <a href="https://habr.com/ru/company/nixys/blog/424717/">Backup a large number of heterogeneous web-projects</a> </p><br><p>  <a href="https://habr.com/ru/company/nixys/blog/347526/">Telegram-bot for Redmine.</a>  <a href="https://habr.com/ru/company/nixys/blog/347526/">How to simplify the life of yourself and people</a> </p></div><p>Source: <a href="https://habr.com/ru/post/437372/">https://habr.com/ru/post/437372/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>