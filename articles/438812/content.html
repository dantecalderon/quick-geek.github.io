<div class="post__text post__text-html js-mediator-article"><p>  Headhunter is a grocery company, the quality of the code is very important to us.  The better it is, the faster we can release new business features and more often please users. </p><br><p>  For each pull request, you must pass a review, even if only one line is changed.  It is necessary to have at least one person review at the same time open, anyone can participate, and this is welcome.  A review is needed to improve the quality of the code and spread knowledge among various teams. </p><br><p><img src="https://habrastorage.org/webt/ny/vq/jh/nyvqjhvmefsdb3n3evqppvsk8gu.png"></p><a name="habracut"></a><br><p>  Previously, there were constant debates on how to write correctly.  It took a lot of time and effort.  To solve these problems Style Guide was written.  He helped a lot, as there was a source of truth, which you can always refer to.  Also Style Guide helps newcomers to enter the project, immediately explaining what and how to write, as well as what to expect in the review. </p><br><p>  Nevertheless, there was a big problem with the Style Guide - people often forgot about it, it was necessary to constantly re-read it and link it to the pull request to prove that it was right.  As a result, the review sometimes slipped into biased disputes, it turned out something like this: </p><br><p><img src="https://habrastorage.org/webt/vo/bd/-y/vobd-yd73in6mfjyf5ybodjbtze.png"></p><br><p>  You understand how much it demotivates the developer, and how much time is spent on useless disputes in the review.  As a result, people did not want to go through the review and revision of other developers. </p><br><p> To make the head of the author of the code and the reviewer less busy with the questions of how to place commas correctly and in what order to write the rules for the <code>border</code> we decided to implement automation, at that time it was <a href="https://www.npmjs.com/package/jshint">jshint</a> , it became much better.  After <a href="https://www.npmjs.com/package/eslint">switching</a> to <a href="https://www.npmjs.com/package/eslint">eslint</a> due to several advantages: </p><br><ul><li>  He is more flexible </li><li>  Under it there are all sorts of plugins </li><li>  Different companies have good ready configs. </li></ul><br><p>  For a long time, we inherited from the <code>airbnb</code> , but we were not satisfied with everything in it, we had to redefine some rules.  It was not very convenient, as a result we wrote our config based on airbnb-shnogo.  We also added prekomit hooks, at that time we used <a href="https://www.npmjs.com/package/husky">husky</a> .  If the developer wrote something wrong, he immediately recognized it when he tried to commit his changes to github. </p><br><p>  But to our regret, eslint did not cover all aspects of code formatting, a <a href="https://www.npmjs.com/package/prettier">prettier was</a> added to solve this problem. </p><br><p>  The benefit of eslint and prettier work well together, you just need to put <a href="https://www.npmjs.com/package/eslint-plugin-prettier">eslint-plugin-prettier</a> and <a href="https://www.npmjs.com/package/eslint-config-prettier">eslint-config-prettier</a> and then fix the <code>.eslintrc</code> like this: </p><br><pre> <code class="plaintext hljs">... "plugins": ["prettier"], "extends": ["@hh.ru/eslint-config", "prettier"], "rules": { "prettier/prettier": ["error"], ...</code> </pre> <br><p>  Before releasing all this to the prod, it was necessary to go through the whole code base and fix it to conform to the new rules, it turned out to be not difficult at all: <code>yarn eslint --fix &lt;path_to_js&gt;</code> </p><br><p>  After that, most of the controversy about how to write and format the code was gone, since everything is covered by automation.  Total now we have: </p><br><ul><li>  All js and jsx are checked and autofixed with eslint and prettier. </li><li>  For less, <a href="https://www.npmjs.com/package/stylelint">stylelint is</a> used. </li><li>  For python flake8. </li></ul><br><p>  Modified files are checked on the developer’s machine at a commit, with <a href="https://www.npmjs.com/package/lint-staged">lint-staged</a> , here’s our <code>.lintstagedrc</code> : </p><br><pre> <code class="plaintext hljs">{ "*.{js,jsx}": ["eslint --fix", "git add"], "*.less": "stylelint", "*.py": "flake8", "package.json": "bash -c 'yarn check-versions &amp;&amp; yarn install --frozen-lockfile'", }</code> </pre> <br><p>  The code that has already passed the linting and tests gets into the githab, the reviewer no longer needs to think about it and pay attention to the little things.  You can fully focus on how well the code is written, whether there will be any performance problems, think about the architecture. </p><br><p>  After the review, the docker container is assembled, during the assembly all autotests and linters are run.  Now the whole build process takes about 7.5 minutes, despite the fact that we now have about 1000 js and 650 less files.  All this is necessary, since you can skip locally on the machine using <code>--no-verify</code> , and comments in the githabe do not block the task.  To deceive the assembly does not work. </p><br><p>  After passing the auto tests begins manual testing.  If the tester does not find any bugs, the task goes to the prod. </p><br><p>  If an error occurs at any of the stages, the task is returned for revision. </p><br><p>  As a result, it became: </p><br><ul><li>  Easier and faster to write code </li><li>  Easier to make a review </li><li>  In the master always quality code </li><li>  Less controversy, more happiness </li></ul><br><p>  We monitor the quality of the code during the execution of business tasks, but the product is constantly evolving, additional conditions appear in the code, the complexity increases.  New technologies are also emerging, old ones are dying due to all this technical tax.  As part of the tax we deal with: </p><br><ul><li>  Custom page optimization </li><li>  Infrastructure changes </li><li>  Improving the code base </li></ul><br><p>  All product teams have to spend 70% of their time on developing business tasks, and 30% on tax — this gives each developer the opportunity to tackle infrastructure tasks, maintain the code base in excellent condition, and spread knowledge about the project infrastructure to all teams.  As a tax, it is not necessary to do the tasks of your team; you can write code to any part of the project.  Anyone can offer a tax, if it seems useful, then it will be added to the backlog.  In addition, there are architectural teams that are engaged in technological features all the time.  All this allows you to keep the code base up to date. </p></div>