<div class="post__text post__text-html js-mediator-article">  The term <b>“indefinite behavior”</b> in C and C ++ refers to a situation in which literally “there isn’t anything”.  Historically, cases where former compilers for C (and architectures on it) behaved inconsistently were attributed to indefinite behavior, and the standard development committee, in its infinite wisdom, decided not to decide anything about this (i.e. not to give preference to one of the competing implementations).  Uncertain behavior was also called possible situations in which the standard, usually so exhaustive, did not prescribe any particular behavior.  This term has a third meaning, which in our time is becoming more and more relevant: indefinite behavior is a possibility for optimization.  And C and C ++ developers <i>love</i> optimization;  they strongly demand that compilers make every effort to speed up the work of the code. <br><br>  <i>This article was first <a href="https://cryptoservices.github.io/fde/2018/11/30/undefined-behavior.html"><i>published</i></a> on the Cryptography Services website.</i>  <i>The translation is published with the permission of the author Thomas Pornin.</i> <br><a name="habracut"></a><br>  Here is a classic example: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *dst)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; i ++) { dst[i] = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)src[i]; } }</code> </pre> <br>  Compile this GCC code on a 64-bit x86 platform for Linux (I am working on the latest version of Ubuntu 18.04, version of GCC - 7.3.0).  We enable full optimization, and then we look at the assembler listing, for which we use the <i>"-W -Wall -O9 -S</i> " keys (the " <i>-O9</i> " argument sets the maximum level of GCC optimization, which is equivalent to " <i>-O3</i> " in practice, although in some forks GCC defined and higher levels).  We get the following result: <br><br><pre> <code class="cpp hljs"> .file <span class="hljs-string"><span class="hljs-string">"zap.c"</span></span> .text .p2align <span class="hljs-number"><span class="hljs-number">4</span></span>,,<span class="hljs-number"><span class="hljs-number">15</span></span> .globl foo .type foo, @function foo: .LFB0: .<span class="hljs-function"><span class="hljs-function">cfi_startproc </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">movupd</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rdi)</span></span></span><span class="hljs-function">, %xmm0 movupd 16</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rdi)</span></span></span><span class="hljs-function">, %xmm1 cvttpd2dq %xmm0, %xmm0 cvttpd2dq %xmm1, %xmm1 punpcklqdq %xmm1, %xmm0 movups %xmm0, </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rsi)</span></span></span><span class="hljs-function"> ret .cfi_endproc .LFE0: .size foo, .-foo .ident "GCC: </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ubuntu </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7.3</span></span></span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">.0</span></span></span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-27u</span></span></span></span><span class="hljs-function"><span class="hljs-params">buntu1~</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">18.04</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> 7.3.0" .section .note.GNU-</span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">stack</span></span></span><span class="hljs-function">,"",@progbits</span></span></code> </pre> <br>  Each of the first two instructions, <i>movupd,</i> moves two <i>double</i> values ​​to the 128-bit SSE2 register ( <i>double</i> has a size of 64 bits, so the SSE2 register can store two <i>double</i> values).  In other words, four initial values ​​are read first, and only then they are <i>cast</i> to an <i>int</i> ( <i>cvttpd2dq</i> operations).  The <i>punpcklqdq</i> operation moves the four received 32-bit integer values ​​into one SSE2 register <i>(% xmm0</i> ), the contents of which is then written to RAM ( <i>movups</i> ).  And now the main thing: our C-program formally requires that the memory access take place in the following order: <br><br><ul><li>  Read the first <i>double</i> value from <i>src [0]</i> . </li><li>  Write the first <i>int</i> value to <i>dst [0]</i> . </li><li>  Read the second <i>double</i> value from <i>src [1]</i> . </li><li>  Write the second <i>int</i> value in <i>dst [1]</i> . </li><li>  Read the third <i>double</i> value from <i>src [2]</i> . </li><li>  Write the third value of type <i>int</i> in <i>dst [2]</i> . </li><li>  Read the fourth value of type <i>double</i> from <i>src [3]</i> . </li><li>  Write the fourth value of type <i>int</i> to <i>dst [3]</i> . </li></ul><br>  However, all these requirements make sense only in the context of an abstract machine, which is defined by the standard C;  The order of actions on a real machine may differ.  The compiler is free to rearrange or change operations, provided that their result does not contradict the semantics of the abstract machine (the so-called <i>as-if</i> rule - “as if”).  In our example, the order of action is just different: <br><br><ul><li>  Read the first <i>double</i> value from <i>src [0]</i> . </li><li>  Read the second <i>double</i> value from <i>src [1]</i> . </li><li>  Read the third <i>double</i> value from <i>src [2]</i> . </li><li>  Read the fourth value of type <i>double</i> from <i>src [3]</i> . </li><li>  Write the first <i>int</i> value to <i>dst [0]</i> . </li><li>  Write the second <i>int</i> value in <i>dst [1]</i> . </li><li>  Write the third value of type <i>int</i> in <i>dst [2]</i> . </li><li>  Write the fourth value of type <i>int</i> to <i>dst [3]</i> . </li></ul><br>  This is the C language: the entire contents of the memory are ultimately bytes (that is, slots with <i>unsigned char</i> values, and in practice, groups of eight bits), and any arbitrary pointer operations are allowed.  In particular, the <i>src</i> and <i>dst</i> pointers when called can be used to refer to overlapping portions of memory (this situation is referred to as “aliasing”).  Thus, the reading and writing order can be important if the bytes are written and then read again.  In order for the actual behavior of the program to conform to the abstract, defined by the C standard, the compiler would have to alternate read and write operations, providing a full cycle of memory accesses at each iteration.  The resulting code would be larger and would work much slower.  For C-developers, this would be grief. <br><br>  Here, fortunately, <i>indefinite behavior</i> comes to the rescue.  Standard C states that access to “cannot” values ​​is done through pointers, the type of which does not correspond to the current types of these values.  Simply put, if the value is written to <i>dst [0]</i> , where the <i>dst</i> pointer is of the <i>int</i> type, then the corresponding bytes cannot be read via <i>src [1]</i> , where <i>src</i> is a <i>double</i> pointer, since in this case we would try to access value, which now has type <i>int</i> , using an incompatible type pointer.  In this case, an undefined behavior would occur.  This is stated in paragraph 7 of section 6.5 of ISO 9899: 1999 (“C99”) (in the new edition 9899: 2018, or “C17”, the wording has not changed).  This requirement is called the strict aliasing rule.  As a result, the C compiler is allowed to act on the assumption that memory access operations that lead to undefined behavior due to a violation of the strict aliasing rule do not occur.  Thus, the compiler can rearrange read and write operations in any order, since they do not have to access overlapping sections of memory.  This is the code optimization. <br><br>  The meaning of indefinite behavior, if briefly, is this: the compiler can assume that there will be no indefinite behavior and generate code based on this assumption.  In the case of a strict aliasing rule - provided that aliasing takes place, - undefined behavior allows for important optimizations that would otherwise be difficult to implement.  Generally speaking, each instruction in the code generation procedures used by the compiler has dependencies that limit the algorithm for scheduling operations: the instruction cannot be executed before the instructions on which it depends, or after those instructions that depend on it.  In our example, undefined behavior eliminates dependencies between write operations in <i>dst []</i> and “subsequent” read operations from <i>src []</i> : such a dependency can exist only in cases where undefined behavior occurs when accessing memory.  Similarly, the concept of indefinite behavior allows the compiler to simply delete code that cannot be executed without entering the state of indefinite behavior. <br><br>  All this, of course, is good, but such behavior is sometimes perceived as treacherous betrayal by the compiler.  You can often hear the following phrase: "The compiler uses the concept of undefined behavior as a pretext to break my code."  Suppose someone writes a program that adds integers, and fears overflow - let us remember the <a href="https://en.bitcoin.it/wiki/Value_overflow_incident">case of Bitcoin</a> .  He can think like this: to represent integers, the processor uses additional code, which means that if overflow occurs, it will happen because the result will be truncated to the size of the type, i.e.  32 bits  This means that the result of the overflow can be predicted and checked with a test. <br><br>  Our conditional developer will write this: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; int add(int x, int y, int *z) { int r = x + y; if (x &gt; 0 &amp;&amp; y &gt; 0 &amp;&amp; r &lt; x) { return 0; } if (x &lt; 0 &amp;&amp; y &lt; 0 &amp;&amp; r &gt; x) { return 0; } *z = r; return 1; } int main(int argc, char *argv[]) { int x, y, z; if (argc != 3) { return EXIT_FAILURE; } x = atoi(argv[1]); y = atoi(argv[2]); if (add(x, y, &amp;z)) { printf("%d\n", z); } else { printf("overflow!\n"); } return 0; }</span></span></span></span></code> </pre><br>  Now let's try to compile this code using GCC: <br><br><pre> <code class="cpp hljs">$ gcc -W -Wall -O9 testadd.c $ ./a.out <span class="hljs-number"><span class="hljs-number">17</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="hljs-number"><span class="hljs-number">59</span></span> $ ./a.out <span class="hljs-number"><span class="hljs-number">2000000000</span></span> <span class="hljs-number"><span class="hljs-number">1500000000</span></span> overflow!</code> </pre><br>  Well, it seems to work.  Now let's try another compiler, for example, Clang (I have version 6.0.0): <br><br><pre> <code class="cpp hljs">$ clang -W -Wall -O3 testadd.c $ ./a.out <span class="hljs-number"><span class="hljs-number">17</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="hljs-number"><span class="hljs-number">59</span></span> $ ./a.out <span class="hljs-number"><span class="hljs-number">2000000000</span></span> <span class="hljs-number"><span class="hljs-number">1500000000</span></span> <span class="hljs-number"><span class="hljs-number">-794967296</span></span></code> </pre><br>  Shta <br><br>  It turns out that when an operation with signed integer types leads to a result that cannot be represented by a target type, we enter the territory of undefined behavior.  But the compiler may assume that it does not occur.  In particular, by optimizing the expression <i>x&gt; 0 &amp;&amp; y&gt; 0 &amp;&amp; r &lt;x</i> , the compiler concludes that since the values ​​of <i>x</i> and <i>y are</i> strictly positive, the third test cannot be true (the sum of two values ​​cannot be less than any of them) and you can skip this whole operation.  In other words, since overflow is an undefined behavior, it “cannot happen” from the compiler's point of view, and all instructions that depend on this state can be removed.  The mechanism for detecting undefined behavior simply disappeared. <br><br>  The standard never prescribed that “wrapping semantics” (which is actually used in processor operations) is used in calculations with signed types;  this happened rather because of tradition - even in those times when compilers were not smart enough to optimize the code, focusing on a range of values.  You can make Clang and GCC apply wrapping semantics to signed types via the special <i>-fwrapv</i> flag (in Microsoft Visual C, you can use <i>-d2UndefIntOverflow-</i> as described <a href="https://blogs.msdn.microsoft.com/vcblog/2016/05/04/new-code-optimizer/">here</a> ).  However, this approach is unreliable, the flag may disappear when transferring code to another project or to another architecture. <br><br>  Few people know that overflowing sign types implies undefined behavior.  This is stated in paragraph 5 of section 6.5 of the C99 and C17 standards: <br><br>  <i>If an exceptional state arises in the evaluation of an expression (that is, if the result is not mathematically defined or is outside the range of valid values ​​of this type), the behavior is not defined.</i> <br><br>  For unsigned types, however, modular semantics are guaranteed.  Paragraph 9 of section 6.2.5 states the following: <br><br>  <i>Overflow never occurs in calculations with unsigned operands, since a result that cannot be represented by a resultant unsigned integer type is truncated in absolute value, which is one more than the maximum value represented by the resultant type.</i> <br><br>  Another example of undefined behavior in operations with sign types is the division operation.  As everyone knows, the result of dividing by zero is not mathematically defined, therefore, according to the standard, this operation entails undefined behavior.  If in the <i>idiv</i> operation on the x86 processor, the divisor is zero, a processor exception occurs.  Like interrupt requests, processor exceptions are handled by the operating system.  On Unix-like systems, such as Linux, a processor exception, triggered by the <i>idiv</i> operation, is translated into a <i>SIGFPE</i> signal, which is sent to the process, and that is terminated by the default handler (don't be surprised that "FPE" is decoded as "floating-point exception" (the exception in floating point operations), while <i>idiv</i> works with integers).  But there is another situation that leads to undefined behavior.  Consider the following code: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char *argv[]) { int x, y; if (argc != 3) { return EXIT_FAILURE; } x = atoi(argv[1]); y = atoi(argv[2]); printf("%d\n", x / y); return 0; } Запустим его: $ gcc -W -Wall -O testdiv.c $ ./a.out 42 17 2 $ ./a.out -2147483648 -1 zsh: floating point exception (core dumped) ./a.out -2147483648 -1</span></span></span></span></code> </pre> <br>  And the truth is: on this machine (all the same x86 under Linux) the type <i>int</i> represents the range of values ​​from -2,147,483,648 to +2,147,483,647. If you divide -2,147,483,648 by -1, you should get +2,147,483,648 But this number is not in the range of values ​​of type <i>int</i> .  Therefore, the behavior is not defined.  Anything can happen.  In this case, the process is forcibly terminated.  On a different system, especially with a small processor, in which there is no division operation, the result may differ.  In such architectures, the division is performed programmatically - using the procedure usually provided by the compiler, and now it can do everything it likes with unspecified behavior, because that is exactly what it is about. <br><br>  I note that <i>SIGFPE</i> can be obtained under the same conditions and with the help of the modulo operator ( <i>%</i> ).  And in fact: it hides all the same <i>idiv</i> operation, which calculates both the particular and the remainder, so the same exception of the processor is triggered.  Interestingly, the C99 standard says that the expression <i>INT_MIN% -1</i> cannot lead to undefined behavior, since the result is mathematically defined (zero) and uniquely falls within the range of values ​​of the target type.  In version C17, the text of paragraph 6 of Section 6.5.5 has been changed, and now this case is also taken into account, which brings the standard closer to the real state of affairs on popular hardware platforms. <br><br>  There are many unobvious situations that also lead to undefined behavior.  Take a look at this code: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; unsigned short mul(unsigned short x, unsigned short y) { return x * y; } int main(int argc, char *argv[]) { int x, y; if (argc != 3) { return EXIT_FAILURE; } x = atoi(argv[1]); y = atoi(argv[2]); printf("%d\n", mul(x, y)); return 0; }</span></span></span></span></code> </pre> <br>  Do you think that the program, following the standard C, should print, if the function is passed to the multipliers of 45,000 and 50,000? <br><br><ul><li>  18,048 </li><li>  2,250,000,000 </li><li>  God save the queen! </li></ul><br>  The correct answer ... yes, all of the above!  You may have argued like this: once <i>unsigned short</i> is an unsigned type, it must support the wrapping semantics modulo 65,536, because on an x86 processor, this type of size is usually 16 bits (the standard allows for a larger size, but practice is still a 16-bit type).  Since the product is mathematically equal to 2,250,000,000, it will be truncated modulo 65,536, which gives the answer 18,048. However, thinking like this, we forget about the extension of integer types.  According to the C standard (section 6.3.1.1, paragraph 2), if the operands are of a type whose size is strictly less than the size of <i>int</i> , and values ​​of this type can be represented by the type of <i>int</i> without loss of bits (and we have just such a case: in my x86 Linux <i>int</i> size is 32 bits, and it can obviously store values ​​from 0 to 65,535), then both operands are cast to <i>int</i> type and the operation is already performed on the converted values.  Namely: the product is calculated as a value of type <i>int</i> and already only when returning from a function is returned back to an <i>unsigned short</i> (i.e. it is at this point that truncation takes place modulo 65,536).  The problem is that mathematically the result before the inverse transform is 2,250,000,000, and this value exceeds the range of <i>int</i> , which is a signed type.  As a result, we get an undefined behavior.  After that, anything can happen, including sudden attacks of English patriotism. <br><br>  However, in practice, with the usual compilers, you get the value of 18,048, because there is still no such optimization that could take advantage of the indefinite behavior in this particular program (one can imagine more artificial scenarios where it would really do trouble). <br><br>  Finally, another example, now in C ++: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;array&gt; int main(int argc, char *argv[]) { std::array&lt;char, 16&gt; tmp; int i; if (argc &lt; 2) { return EXIT_FAILURE; } memset(tmp.data(), 0, 16); if (strlen(argv[1]) &lt; 16) { strcpy(tmp.data(), argv[1]); } for (i = 0; i &lt; 17; i ++) { printf(" %02x", tmp[i]); } printf("\n"); }</span></span></span></span></code> </pre> <br>  This is not the typical “bad terrible <i>strcpy ()</i> !”.  After all, here the <i>strcpy ()</i> function is executed only if the size of the source string, including the terminal zero, is small enough.  Moreover, array elements are explicitly initialized to zero, so all bytes in the array have the specified value, regardless of whether a large or small string is passed to the function.  However, the loop at the end is incorrect: it reads one byte more than it should be. <br><br>  Run the code: <br><br><pre> <code class="cpp hljs">$ g++ -W -Wall -O9 testvec.c $ ./a.out foo <span class="hljs-number"><span class="hljs-number">66</span></span> <span class="hljs-number"><span class="hljs-number">6f</span></span> <span class="hljs-number"><span class="hljs-number">6f</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">58</span></span> ffffffca ff ffffac ffffffc0 <span class="hljs-number"><span class="hljs-number">55</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ffffff80 <span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">34</span></span> ffffff99 <span class="hljs-number"><span class="hljs-number">07</span></span> ffffffba ff ffffea ffffffd0 ffffffe5 <span class="hljs-number"><span class="hljs-number">44</span></span> ffffff83 fffffffd <span class="hljs-number"><span class="hljs-number">7f</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">58</span></span> ffffffca ffffffac ffffffc0 <span class="hljs-number"><span class="hljs-number">55</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ffffff97 <span class="hljs-number"><span class="hljs-number">7b</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-number"><span class="hljs-number">1b</span></span> ffffffa1 <span class="hljs-number"><span class="hljs-number">7f</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ffffffd8 ffffffe5 <span class="hljs-number"><span class="hljs-number">44</span></span> ffffff83 fffffffd <span class="hljs-number"><span class="hljs-number">7f</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ffffff80 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">60</span></span> <span class="hljs-number"><span class="hljs-number">56</span></span> (...) <span class="hljs-number"><span class="hljs-number">62</span></span> <span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>d <span class="hljs-number"><span class="hljs-number">30</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span> zsh: <span class="hljs-function"><span class="hljs-function">segmentation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fault</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(core dumped)</span></span></span><span class="hljs-function"> ./a.out foo Шта++?</span></span></code> </pre> <br>  You can naively object: well, it reads an extra byte outside the array;  but it's not so scary, because this byte is still on the stack, it is displayed in memory, so the only problem here is an extra seventeenth element with an unknown value.  The cycle will still print exactly 17 integers (in hexadecimal format) and end without any complaints. <br><br>  But the compiler has its own opinion on this.  He is well aware that the seventeenth reading provokes undefined behavior.  According to his logic, any subsequent instruction is suspended: there is no such requirement that, after an indefinite behavior, something must exist at all (formally, even previous instructions may be under attack, since indefinite behavior acts in the opposite direction).  In our case, the compiler will simply ignore the condition check in the loop, and it will spin forever, more precisely, until it starts reading outside the allocated stack memory, after which the <i>SIGSEGV</i> signal will work. <br><br>  It's funny, but if you run GCC with less aggressive settings for optimizations, it will give a warning: <br><br><pre> <code class="cpp hljs">$ g++ -W -Wall -O1 testvec.c testvec.c: In function <span class="hljs-string"><span class="hljs-string">'int main(int, char**)'</span></span>: testvec.c:<span class="hljs-number"><span class="hljs-number">20</span></span>:<span class="hljs-number"><span class="hljs-number">15</span></span>: warning: iteration <span class="hljs-number"><span class="hljs-number">16</span></span> invokes undefined behavior [-Waggressive-loop-optimizations] <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">" %02x"</span></span>, tmp[i]); ~~~~~~^~~~~~~~~~~~~~~~~ testvec.c:<span class="hljs-number"><span class="hljs-number">19</span></span>:<span class="hljs-number"><span class="hljs-number">19</span></span>: note: <span class="hljs-function"><span class="hljs-function">within </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">this</span></span></span><span class="hljs-function"> loop </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">; i &lt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">17</span></span></span></span><span class="hljs-function"><span class="hljs-params">; i ++)</span></span></span><span class="hljs-function"> </span></span>{ ~~^~~~</code> </pre> <br>  At the <i>-O9</i> level <i>,</i> this warning somehow disappears.  Perhaps the fact is that at high levels of optimization, the compiler imposes a more aggressive deployment of the loop.  It is possible (but inaccurate) that this is a GCC bug (in the sense of missing a warning; this is how GCC actions in any case do not contradict the standard, because it does not require issuing “diagnostics" in this situation). <br><br>  Conclusion: if you are writing code in C or C ++, be extremely careful and avoid situations that lead to undefined behavior, even when it seems that “nothing terrible”. <br><br>  Unsigned integer types are a good helper in arithmetic calculations, since they are guaranteed modular semantics (but you can still get problems related to the expansion of integer types).  Another option - unpopular for some reason - does not write at all in C and C ++.  For several reasons, this solution is not always suitable.  But if you can choose which language to write the program in, ie  when you start a new project on a platform with support for Go, Rust, Java or other languages, it may be more profitable not to use C as your “default language”.  The choice of tools, including a programming language, is always a compromise.  Pitfalls C, especially undefined behavior in operations with sign types, lead to additional costs with further code maintenance, which are often underestimated. </div>