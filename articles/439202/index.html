<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Detection of web attacks using autoencoder Seq2Seq</title>
  <meta name="description" content="Detection of attacks has been an important task in information security for decades. The first known examples of the implementation of IDS refer to th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Detection of web attacks using autoencoder Seq2Seq</h1><div class="post__text post__text-html js-mediator-article"> <a href="https://habr.com/ru/company/pt/blog/439202/"><img src="https://habrastorage.org/getpro/habr/post_images/5ad/baf/742/5adbaf742fa07b485b70886943da8036.png" alt="image"></a> <br><br>  Detection of attacks has been an important task in information security for decades.  The first known examples of the implementation of IDS refer to the early 1980s. <br><br>  A few decades later, a whole industry of attack detection tools was formed.  Currently there are various types of products, such as IDS, IPS, WAF, firewalls, most of which offer the detection of rule-based attacks.  The idea of ‚Äã‚Äãusing anomaly detection techniques to detect attacks based on production statistics does not seem as realistic as in the past.  Or is it? .. <a name="habracut"></a><br><br><h2>  Detection of anomalies in web applications </h2><br>  The first firewalls specifically designed to detect attacks on web applications began to appear on the market in the early 1990s.  Since then, both attack methods and defense mechanisms have changed significantly, and attackers can be one step ahead at any time. <br><br>  Currently, most WAFs attempt to detect attacks as follows: there are some mechanisms based on rules that are built into the reverse proxy server.  The most striking example is mod_security, a WAF module for the Apache web server, which was developed in 2002.  Identifying attacks with rules has a number of flaws;  for example, the rules cannot detect zero-day attacks, while the same attacks can be easily detected by an expert, and this is not surprising, since the human brain does not work at all like a set of regular expressions. <br><br>  From the point of view of WAF, attacks can be divided into those that we can detect by the sequence of requests, and those where only one HTTP request (response) is enough to solve.  Our research is focused on the detection of the latest type of attacks - SQL Injection, Cross Site Scripting, XML External Entities Injection, Path Traversal, OS Commanding, Object Injection, etc. <br><br>  But first, let's check ourselves. <br><br><h2>  What will the expert think when he sees the following requests? </h2><br>  Take a look at an example of an HTTP request to applications: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/112/aa6/d1d/112aa6d1d1cc3798f89a7b39fd0aad4c.png" alt="image"><br><br>  If you were given the task of detecting malicious requests to an application, you most likely would like to watch the normal behavior of users for some time.  By examining requests to multiple application endpoints, you can get a general overview of the structure and functions of non-dangerous requests. <br><br>  Now you get the following query for analysis: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/28b/be1/487/28bbe1487cb08fc21fee85bdc1f259b5.png" alt="image"><br><br>  Immediately striking that there is something wrong.  It will take some time to understand what is really there, and once you determine the part of the query that seems abnormal, you can start thinking about what kind of attack this is.  In essence, our goal is to make our ‚ÄúAI for detecting attacks‚Äù work in the same way ‚Äî to resemble human thinking. <br><br>  The unclear point is that some traffic, which at first glance looks malicious, may be normal for a particular website. <br><br>  For example, let's consider the following queries: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c3/11e/a25/7c311ea25d363c43c6559429f1bf8991.png" alt="image"><br><br>  Is this query abnormal? <br><br>  In fact, this request is a bug in Jira tracker and is typical for this service, which means that the request is expected and normal. <br><br>  Now consider the following example: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b03/57c/884/b0357c884e2b3c3dd19a8733da973a62.png" alt="image"><br><br>  At first glance, the request looks like a regular user registration on a website based on Joomla CMS.  However, the requested operation is user.register instead of regular registration.register.  The first option is outdated and contains a vulnerability that allows anyone to register as an administrator.  The exploit for this vulnerability is known as Joomla &lt;3.6.4 Account Creation / Privilege Escalation (CVE-2016-8869, CVE-2016-8870). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/45b/a08/994/45ba089942a993c3e4d32fd5f8f744a6.png" alt="image"><br><br><h2>  Where did we start </h2><br>  Of course, we first studied the existing solutions to the problem.  Various attempts to create algorithms for detecting attacks based on statistics or machine learning have been made for decades.  One of the most popular approaches is to solve the classification problem, when classes represent something like ‚Äúexpected queries‚Äù, ‚ÄúSQL injections‚Äù, XSS, CSRF, etc. This way you can achieve some good accuracy for a data set using the classifier However, this approach does not solve very important problems from our point of view: <br><br><ol><li>  <b>Class selection is limited and predefined</b> .  What if your model in the learning process is represented by three classes, say ‚Äúnormal queries‚Äù, SQLi and XSS, and during the operation of the system does it encounter a CSRF or zero-day attack? </li><li>  <b>The value of these classes</b> .  Suppose you need to protect ten clients, each of which runs completely different web applications.  For most of them, you have no idea what SQL injection actually looks like for their application.  This means that you have to somehow artificially create data sets for training.  This approach is not optimal, because ultimately you will learn from data that is different in its distribution from real data. </li><li>  <b>Interpretability of model results</b> .  Well, the model produced the result "SQL injection", and now what?  You and, more importantly, your client, who sees the warning first and usually is not an expert on web attacks, should guess which part of the query your model considers to be malicious. </li></ol><br>  Remembering all these problems, we still decided to try to train the model of the classifier. <br><br>  Since the HTTP protocol is a text protocol, it was obvious that we need to look at modern text classifiers.  One well-known example is sentiment analysis in the IMDB film review data set.  Some solutions use RNN to classify reviews.  We decided to try a similar model with RNN-architecture with some minor differences.  For example, in the RNN architecture in natural language, a vector representation of words is used, but it is unclear which words are found in unnatural language, such as HTTP.  Therefore, we decided to use the vector representation of symbols for our task. <br><br>  Finished views do not solve our problem, so we used simple symbol mappings to numeric codes with several internal markers, such as <code>GO</code> and <code>EOS</code> . <br><br>  After completing the development and testing of the model, all the previously predicted problems became apparent, but at least our team moved from useless assumptions to some result. <br><br><h2>  What's next? </h2><br>  Next, we decided to take some steps towards interpreting the model results.  At some point we came across the attentional mechanism Attention and began to implement it in our model.  And it gave promising results.  Now, our model has begun to display not only class labels, but also attention factors for each character that we have given to the model. <br><br>  Now we could visualize and show in the web interface the exact place where the ‚ÄúSQL injection‚Äù attack was detected.  It was a good result, but other problems from the list still remained unresolved. <br><br>  It was obvious that we should continue to move in the direction of extracting benefits from the mechanism of attention and move away from the task of classification.  After reading a lot of related research on sequence models (attentional mechanisms [2], [3], [4], vector representation, autoencoder architectures) and experiments with our data, we were able to create an anomaly detection model, which ultimately would work more or less in the way an expert does. <br><br><h2>  Autoencoders </h2><br>  At some point, it became clear that the Seq2Seq [5] architecture is best suited for our task. <br><br>  Model Seq2Seq [7] consists of two multi-layer LSTM - encoder and decoder.  The encoder maps the input sequence to a fixed-length vector.  The decoder decodes the target vector using the encoder output.  When learning, an autoencoder is a model in which target values ‚Äã‚Äãare set the same as input values. <br><br>  The idea is to teach the network to decode things that it has seen, or, in other words, to approximate the identity mapping.  If a trained autoencoder is given an abnormal pattern, it probably recreates it with a high degree of error, simply because he has never seen it. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b2b/d99/fb1/b2bd99fb15aff53c214892c8d8a36642.png" alt="image"><br><br><h2>  Decision </h2><br>  Our solution consists of several parts: model initialization, training, forecasting and testing.  Most of the code located in the repository, we hope, does not require explanations, so we will focus only on the important parts. <br><br>  The model is created as an instance of the Seq2Seq class, which has the following constructor arguments: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b5/183/1f3/0b51831f349befe5753636bda5da404c.png" alt="image"><br><br>  Next, autoencoder layers are initialized.  First coder: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ba/0e0/f7e/5ba0e0f7e354312048f8c3945436af16.png" alt="image"><br><br>  Then decoder: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fd4/c9c/d5e/fd4c9cd5ef2e4fca445e18dc9d25ff29.png" alt="image"><br><br>  Since the problem we solve is the detection of anomalies, the target values ‚Äã‚Äãand the input data are the same.  So our feed_dict looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6e6/7e3/04a/6e67e304a01caa06d4f366327a1d5ef3.png" alt="image"><br><br>  After each epoch, the best model is saved as a control point, which can then be loaded.  For testing purposes, a web application was created that we defended with a model to check whether real attacks were successful. <br><br>  Inspired by the attentional mechanism, we tried to apply it to the autoencoder model to mark the anomalous parts of this query, but noticed that the probabilities derived from the last layer work better. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/56d/748/22e/56d74822e5ee1a376db9d8c79b71769b.png" alt="image"><br><br>  At the testing stage in our delayed sample, we got very good results: precision and recall are close to 0.99.  And the ROC curve tends to 1. Looks amazing, doesn't it? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/be8/eb4/21f/be8eb421f44d245b553dd71846157aff.png" alt="image"><br><br><h2>  results </h2><br>  The proposed autoencoder model Seq2Seq was able to detect anomalies in HTTP requests with very high accuracy. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ad/baf/742/5adbaf742fa07b485b70886943da8036.png" alt="image"><br><br>  This model acts like a human being: examines only the "normal" user requests to the web application.  And when it detects anomalies in queries, it highlights the exact location of the query, which it considers abnormal. <br><br>  We tested this model on some attacks on a test application and the results were promising.  For example, the image above shows how our model found a SQL injection divided into two parameters in a web form.  Such SQL injections are called fragmented: pieces of attack payload are delivered in several HTTP parameters, which makes it difficult to detect for classic WAF based on rules, since they usually check each parameter separately. <br><br>  The model code and the training and test data are published as a Jupyter laptop so that everyone can reproduce our results and suggest improvements. <br><br><h2>  Finally </h2><br>  We believe that our task was rather non-trivial.  We would like with a minimum of effort spent (first of all - to avoid mistakes due to over-complication of the solution) to come up with a method of detecting attacks, which would learn how to solve what is good and what is bad by magic.  In the second place, I wanted to avoid problems with the human factor, when exactly the expert decides what is a sign of an attack and what is not.  Summing up, I would like to note that the auto-encoder with the Seq2Seq architecture for the task of searching for anomalies, in our opinion and for our problem, handled it perfectly. <br><br>  We also wanted to solve the problem of data interpretability.  Usually using complex neural network architectures make it very difficult.  In a series of transformations in the end, it is already difficult to say exactly what part of the data influenced the decision the most.  However, after rethinking the approach to interpreting the data by the model, it was enough for us to get the probabilities for each character from the last layer. <br><br>  It should be noted that this is not quite a production version.  We cannot disclose the details of the implementation of this approach in a real product, and we want to warn you that simply taking and integrating this solution into some product will not work. <br><br>  GitHub repository: <a href="http://goo.gl/aNwq9U">goo.gl/aNwq9U</a> <br><br>  <b>Authors</b> : Alexandra Murzina ( <a href="https://habr.com/ru/users/murzina_a/" class="user_link">murzina_a</a> ), Irina Stepanyuk ( <a href="https://github.com/idstep">GitHub</a> ), Fedor Sakharov ( <a href="https://github.com/montekki">GitHub</a> ), Arseny Reutov ( <a href="https://habr.com/ru/users/raz0r/" class="user_link">Raz0r</a> ) <br><br><h3>  References: </h3><br><ol><li>  <a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/">Understanding LSTM Networks</a> </li><li>  <a href="https://distill.pub/2016/augmented-rnns/">Attention and Augmented Recurrent Neural Networks</a> </li><li>  <a href="https://ai.googleblog.com/2017/08/transformer-novel-neural-network.html">Attention Is All You Need</a> </li><li>  <a href="http://nlp.seas.harvard.edu/2018/04/03/attention.html">Attention Is All You Need (annotated)</a> </li><li>  <a href="https://github.com/tensorflow/nmt">Neural Machine Translation (seq2seq) Tutorial</a> </li><li>  <a href="http://ufldl.stanford.edu/tutorial/unsupervised/Autoencoders/">Autoencoders</a> </li><li>  <a href="">Sequence to Sequence Learning with Neural Networks</a> </li><li>  <a href="http://blog.keras.io/building-autoencoders-in-keras.html">Building Autoencoders in Keras</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/439202/">https://habr.com/ru/post/439202/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>