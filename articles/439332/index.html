<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How PageRank works: implementation in the R language through linear algebra and power-method</title>
  <meta name="description" content="Hi, habrovchane! 

 My name is Aleksey. This time I broadcast from a workplace in ITAR-TASS. 

 In this small text I will introduce you to the method ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6974184241884155",
      enable_page_level_ads: true
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>How PageRank works: implementation in the R language through linear algebra and power-method</h1><div class="post__text post__text-html js-mediator-article">  Hi, habrovchane! <br><br>  My name is Aleksey.  This time I broadcast from a workplace in ITAR-TASS. <br><br>  In this small text I will introduce you to the method of calculating PageRank ¬© (I will call it PR later) using simple, understandable examples, in R. <a href="https://en.wikipedia.org/wiki/PageRank">The algorithm</a> is Google‚Äôs intellectual property, but because of its usefulness for data analysis tasks, many of them are used , which can be reduced to the search for large nodes on the graph and ranking them by significance. <br><br>  Mention of a large company in a post is not an advertisement. <br><a name="habracut"></a><br>  Since I am not a professional mathematician, I use this <a href="http://home.ie.cuhk.edu.hk/~wkshum/papers/pagerank.pdf">article</a> and this <a href="http://pi.math.cornell.edu/~mec/Winter2009/RalucaRemus/Lecture3/lecture3.html">tutorial</a> as a guide, and I recommend you. <br><br><h3>  Intuitive understanding of PR </h3><br>  Understanding how this works is not difficult.  There is a set of elements that are interconnected.  This is how they are related - this is a broad question: maybe through links (like Google‚Äôs), perhaps through references to each other (almost the same links), the probabilities of transitions between elements (the Markov process matrix) can be given a priori sense of communication.  I would like to assign to these elements a certain criterion of importance, which would carry information about the <b>probability</b> that a given element will be visited by some abstract particle traveling along the graph in the diffusion process. <br><br>  Um, that doesn't sound very clear.  It is easier to imagine a guy behind a <s>poppy with a</s> laptop who surfs pages from search results, smoking a hookah, follows links from one page to another and more and more often find himself on the same page (or pages). <br><br>  This is due to the fact that some of the pages that he visits contain such interesting information in the original source, that other pages have to reprint it with an indication of the link. <br><br>  This guy on Google was called Random surfer.  It is a particle in the process of diffusion: a discrete change of position on a graph over time.  And the probability with which he will visit the page with diffusion time tending to infinity is the PR. <br><br><h3>  Simple implementation of the calculation of PR </h3><br>  We agree - we work with 10 elements, in such a small, cozy graphchik. <br><br><pre><code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># clear environment rm(list = ls()); gc() ## load libs library(data.table) library(magrittr) library(markovchain) ## dummy data number_nodes &lt;- 10 node_names &lt;- letters[seq_len(number_nodes)] set.seed(1) nodes &lt;- sapply( seq_len(number_nodes), function(x) { paste( c( node_names[-x] , sample(node_names[-x], sample(1:5, 1), replace = T) ) , collapse = ' ' ) } ) names(nodes) &lt;- node_names print( paste(nodes, collapse = '; ') ) ## make long dt dt &lt;- data.table( citing_node = node_names , cited_node = nodes ) %&gt;% .[, .(cited_node = unlist(strsplit(cited_node, ' '))), by = citing_node] %&gt;% dcast( . , cited_node ~ citing_node , fun.aggregate = length ) dt apply(dt[,-1,with=F], 2, sum) ## affinity matrix A &lt;- as.matrix(dt[, 2:dim(dt)[2]]) A &lt;- sweep(A, 2, colSums(A), `/`) A[is.nan(A)] &lt;- 0 rowSums(A) colSums(A) mark &lt;- new("markovchain", transitionMatrix = t(A), states = node_names, name = "mark") plot(mark)</span></span></code> </pre> <br>  Each of the 10 elements (nodes) contains from 10 to 14 references to other nodes in random order, excluding itself.  At the moment, we just decide that these references are web links. <br><br>  It is clear that it may happen that some of the elements are mentioned more often than others.  Check it out. <br><blockquote>  By the way, I recommend using the data.table package for experiments.  In conjunction with the principles of tidyverse, everything turns out efficiently and quickly. </blockquote><img src="https://habrastorage.org/webt/jl/qc/jm/jlqcjm-czf_eyevyiz1uxlssav0.png"><br><br>  This is our link matrix (usually called adjacency matrix in English). <br><br>  The amount in each column is greater than zero, which means there is a connection from each element to any other element (this is important for further analysis). <br><blockquote>  &gt; apply (dt [, - 1, with = F], 2, sum) <br>  abcdefghij <br>  11 14 10 10 11 13 11 11 11 12 <br></blockquote><br>  We can create on the basis of this table the so-called Affinity matrix, or, in our opinion, the proximity matrix (and also called the transition matrix), which mathematicians call the stochastic matrix (column-stochastic matrix): <a href="https://en.wikipedia.org/wiki/Stochastic_matrix">main source</a> <br><br>  Assign it to a variable named A. <br><br><img src="https://habrastorage.org/webt/xv/x-/f0/xvx-f0z6eow64ngtc4tkofqolj8.png"><br><br>  The most important thing now is that the sum in all columns is one. <br><blockquote>  &gt; colSums (A) <br>  abcdefghij <br>  1 1 1 1 1 1 1 1 1 1 <br></blockquote><br>  Here it is - the transition matrix, it is Markov, it is similar.  Tsifir is the probability of transitions from an element in a column to an element in a line. <br><br>  This, of course, is not real "similarity."  These would be, for example, if you count the cosine of the angle between the presentation of documents.  But it is important that the transition matrix is ‚Äã‚Äãreduced to (pseudo-) probabilities, so that the sum for each column is equal to one. <br><br>  Let's look at the Markov transition graph (our A): <br><br><img src="https://habrastorage.org/webt/s9/yv/br/s9yvbr-kaqvsyfqs0wokofkojpk.png"><br><br>  Everything is approximately evenly confused).  This is because we have given equiprobable transitions. <br><br>  <b>And now is the time of magic!</b> <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">## calculate pagerank ei &lt;- eigen(A) as.numeric(ei$values[1]) pr &lt;- as.numeric(ei$vectors[,1] / sum(ei$vectors[,1])) sum(pr) names(pr) &lt;- node_names print(round(pr, 2))</span></span></code> </pre><br>  For a stochastic matrix A, the first eigenvalue must be equal to one, and the corresponding eigenvector is the PageRank vector. <br><blockquote>  &gt; print (round (pr, 2)) <br>  abcdefghij <br>  0.09 0.11 0.09 0.10 0.10 0.11 0.10 0.11 0.08 0.11 <br></blockquote><br>  This is the vector of PR values ‚Äã‚Äã- this is the normalized eigenvector of the transition matrix A, corresponding to the eigenvalue of this matrix, equal to one, the dominant eigenvector. <br><br>  Now you can rank the elements.  But due to the nature of the experiment, they have a very similar weight. <br><br><h3>  Problems and their solutions using the power-method </h3><br>  The transition matrix A may not satisfy the conditions of stochasticity. <br><br>  <b>Firstly, there may be elements that do not refer to anywhere, that is, with the lack of feedback (they themselves can be referenced).</b>  <b>For large real-life graphs, this is a very likely problem.</b>  <b>This means that one of the columns of the matrix will have only zeros.</b>  <b>In this case, the solution through eigenvectors will not work.</b> <br><br>  Google solved this problem by filling the column with a uniform probability distribution p = 1 / N.  Where N is the number of all elements. <br><br><pre> <code class="python hljs">dim<span class="hljs-number"><span class="hljs-number">.1</span></span> &lt;- dim(A)[<span class="hljs-number"><span class="hljs-number">1</span></span>] A &lt;- <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>.data.table(A) nul_cols &lt;- apply(A, <span class="hljs-number"><span class="hljs-number">2</span></span>, function(x) sum(x) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( sum(nul_cols) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) { A[ , (colnames(A)[nul_cols]) := lapply(.SD, function(x) <span class="hljs-number"><span class="hljs-number">1</span></span> / dim<span class="hljs-number"><span class="hljs-number">.1</span></span>) , .SDcols = colnames(A)[nul_cols] ] } A &lt;- <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>.matrix(A)</code> </pre><br>  <b>Secondly, in the graph there may be elements with feedback on each other, but not other elements of the graph.</b>  <b>This is also an insurmountable problem for linear algebra due to the violation of assumptions.</b> <br><br>  It is solved by introducing a constant called the Damping factor, which denotes the a priori probability of transition from any element to any other, even if there are no physically references.  In other words, diffusion is possible when it hits any state. <br><br><pre> <code class="python hljs">d = <span class="hljs-number"><span class="hljs-number">0.15</span></span> <span class="hljs-comment"><span class="hljs-comment">#damping factor (to ensure algorithm convergence) M &lt;- (1 - d) * A + d * (1 / dim.1 * matrix(1, nrow = dim.1, ncol = dim.1)) # google matrix</span></span></code> </pre><br>  If we apply these transformations to our matrix, then it can again be solved through eigenvectors! <br><br>  <b>Thirdly, the matrix can be trivial, not square, and this is critical!</b>  <b>I will not dwell on this moment, because I believe that you yourself will figure out how to fix it.</b> <br><br>  But there is a faster and more accurate method, which is also more economical in memory (which may be relevant for large graphs): Power method. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">## pagerank function (tested on example from tutorial) rm(pagerank_func) pagerank_func &lt;- function( A #transition matrix , eps = 0.00001 #sufficiently small error , d = 0.15 #damping factor (to ensure algorithm convergence) ) { dim.1 &lt;- dim(A)[1] A &lt;- as.data.table(A) nul_cols &lt;- apply(A, 2, function(x) sum(x) == 0) if( sum(nul_cols) &gt; 0 ) { A[ , (colnames(A)[nul_cols]) := lapply(.SD, function(x) 1 / dim.1) , .SDcols = colnames(A)[nul_cols] ] } A &lt;- as.matrix(A) M &lt;- (1 - d) * A + d * (1 / dim.1 * matrix(1, nrow = dim.1, ncol = dim.1)) # google matrix rank = as.numeric(rep(1 / dim.1, dim.1)) ## iterate until convergence while( sum( (rank - M %*% rank) ^ 2 ) &gt; eps ) { rank &lt;- M %*% rank } return(rank) } pr2 &lt;- pagerank_func(A) pr2=as.vector(pr2) names(pr2)=node_names</span></span></code> </pre><br>  Voila! <br><blockquote>  &gt; print (round (pr, 2)) <br>  abcdefghij <br>  0.09 0.11 0.09 0.10 0.10 0.11 0.10 0.11 0.08 0.11 <br>  &gt; print (round (pr2, 2)) <br>  abcdefghij <br>  0.09 0.11 0.09 0.10 0.10 0.11 0.10 0.11 0.08 0.11 <br></blockquote><br>  On this I will finish the tutorial.  Hope you find it useful. <br><br>  I forgot to say that to build a transition matrix (probabilities) you can use the similarity of texts, the number of mentions, the fact that there is a link, and other metrics that are reduced to pseudo-probabilities or are probabilities.  A rather interesting example is the ranking of sentences in the text on the matrix of similarity of the bags of the words tf-idf to highlight the sentence of the sum of all the text.  There may be other creative uses of PR. <br><br>  I recommend trying to play independently with the transition matrix and make sure that cool PR values ‚Äã‚Äãare obtained, which are also quite easily interpreted. <br><br>  If you see any inaccuracies or errors with me - please indicate in the comments or the message, and I will correct everything. <br><br>  All code is compiled here: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># clear environment rm(list = ls()); gc() ## load libs library(data.table) library(magrittr) library(markovchain) ## dummy data number_nodes &lt;- 10 node_names &lt;- letters[seq_len(number_nodes)] set.seed(1) nodes &lt;- sapply( seq_len(number_nodes), function(x) { paste( c( node_names[-x] , sample(node_names[-x], sample(1:5, 1), replace = T) ) , collapse = ' ' ) } ) names(nodes) &lt;- node_names print( paste(nodes, collapse = '; ') ) ## make long dt dt &lt;- data.table( citing_node = node_names , cited_node = nodes ) %&gt;% .[, .(cited_node = unlist(strsplit(cited_node, ' '))), by = citing_node] %&gt;% dcast( . , cited_node ~ citing_node , fun.aggregate = length ) dt apply(dt[,-1,with=F], 2, sum) ## affinity matrix A &lt;- as.matrix(dt[, 2:dim(dt)[2]]) A &lt;- sweep(A, 2, colSums(A), `/`) A[is.nan(A)] &lt;- 0 rowSums(A) colSums(A) mark &lt;- new("markovchain", transitionMatrix = t(A), states = node_names, name = "mark") plot(mark) ## calculate pagerank ei &lt;- eigen(A) as.numeric(ei$values[1]) pr &lt;- as.numeric(ei$vectors[,1] / sum(ei$vectors[,1])) sum(pr) names(pr) &lt;- node_names print(round(pr, 2)) ## pagerank function (tested on example from tutorial) rm(pagerank_func) pagerank_func &lt;- function( A #transition matrix , eps = 0.00001 #sufficiently small error , d = 0.15 #damping factor (to ensure algorithm convergence) ) { dim.1 &lt;- dim(A)[1] A &lt;- as.data.table(A) nul_cols &lt;- apply(A, 2, function(x) sum(x) == 0) if( sum(nul_cols) &gt; 0 ) { A[ , (colnames(A)[nul_cols]) := lapply(.SD, function(x) 1 / dim.1) , .SDcols = colnames(A)[nul_cols] ] } A &lt;- as.matrix(A) M &lt;- (1 - d) * A + d * (1 / dim.1 * matrix(1, nrow = dim.1, ncol = dim.1)) # google matrix rank = as.numeric(rep(1 / dim.1, dim.1)) ## iterate until convergence while( sum( (rank - M %*% rank) ^ 2 ) &gt; eps ) { rank &lt;- M %*% rank } return(rank) } pr2 &lt;- pagerank_func(A) pr2=as.vector(pr2) names(pr2)=node_names print(round(pr, 2)) print(round(pr2, 2))</span></span></code> </pre><br></div></div><br>  PS: this whole idea is also easily implemented in other languages, at least in Python I did everything without difficulty. </div><p>Source: <a href="https://habr.com/ru/post/439332/">https://habr.com/ru/post/439332/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container">Waiting for the list from <a href="../../index.html">here</a>...</nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52319614 = new Ya.Metrika({
                  id:52319614,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52319614" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>